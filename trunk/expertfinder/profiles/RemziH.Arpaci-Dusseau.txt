personal information function mouseover link src link src src function mouseout link src link src src personal information remzi quotes attempted objections overcome samuel johnson matter wrong road turn back turkish proverb true measure love love loved love goethe remzi born remzi arpaci ann arbor michigan note marriage marrying wonderful andrea dusseau gained part names bearers difficult unique arpaci-dusseau ladies life click infp enfp find personality bit test collect quotes click check somerset maugham quot ability quote serviceable substitute wit quot poems music wrote rare conduct internet-based polls people guessing age people picking random numbers results found finally writing tcl programs hobby mine check football video game time waste remzi arpaci-dusseau 
quot good thing uneducated person read books quotations quot -winston churchill quot scientific truth triumph convincing opponents making light opponents finally die generation grows familiar quot -max planck quot dog feed warm care bite principal difference dog man quot -mark twain quot imagination important knowledge quot -albert einstein quot master art living makes distinction work play labor leisure mind body education recreation love religion simply pursues vision excellence leaving decide working playing quot -zen philosophy found head head thurrow quot riddle man built doesn man bought doesn man owns doesn man quot -anonymous found letters geotex ramos quot children encouragement kid answer lucky guess child develops good lucky feeling quot -jack handey quot creature crawl furniture run room leap friend neck laugh thing quot -jack handey quot convictions dangerous enemies truth lies quot -friedrich nietzsche quot invent good imagination pile junk quot -thomas edison quot reasonable man adapts world unreasonable persists adapt world progress depends unreasonable man quot -shaw quot reason god create world days didn worry installed base quot -enzo torresi quot recursion recursion quot -anonymous quot silence consent silent dissents quot -maria isabel barreno quot obviousness enemy correctness quot -bertrand russell quot important thing onion belt style time quot -grandpa simpson quot batman quot -batman quot theory difference theory practice practice quot -anonymous quot god didn create world days rested pulled nighter quot -anonymous quot fourth amendment silent don deal drugs sixth amendment quiet innocent amendment don gun amendment quot -anonymous quot atheist doesn thinks proof god believes evidence god question similar level evidence were-wolf question quot -john mccarthy quot perfection attained left add left quot -antoine saint-exupery quot things comforting tiger late quot -calvin quot fascinating science wholesale returns conjecture trifling investment fact quot -mark twain quot trees scream cavalier cutting screamed time apparent reason quot -jack handey quot ability quote serviceable substitute wit quot somerset maugham quot afraid people charm devour end made sacrifice exercise fascinating gift insincerity quot maugham gentleman parlour quot word count wit-less madman held fools wits thinking world content wits esteemeth men cleverest quot -grimmelshausen quot popular treatise shreds science allowed exhibited exceedingly diffuse attenuated form apparently hope mental faculties reader reject stronger food insensibly saturated scientific phraseology provided diluted sufficient quantity familiar language loss implied acquisition estimated compelled unlearn science length begin learn technical treatises harm reads compulsion establishment general equations end book page full symbols indices suffixes paragraph plain english eye rest quot -maxwell quot gnu emacs lisp operating system disguised word processor quot -doug mohney quot manifestations power restraint impresses men quot -thucydides quot impossible defeat ignorant man argument quot mcadoo quot coming beginning keeping progress staying success quot -henry ford quot world place persistence talent common unsuccessful men talent genius un-rewarded genius proverb education world full educated derelicts persistence determination omnipotent quot -calvin coolidge quot friend call move true friend call move body quot -anonymous quot gentle good night age burn rave close day rage rage dying light quot -dylan thomas quot secret creativity knowing hide sources quot -albert einstein quot dog dog dog quot -anonymous quot eventually die elvis quot -dave barry quot gentlemen succeed run risk failure quot -dan quayle quot subtraction addition tricky pal quot -david letterman top classes football factory quot cynic man price quot -oscar wilde quot science set limits knowledge set limits imagination quot -bertrand russell quot read answer attacks made shop closed business howthe end end brings won amount end brings wrong ten angels swearing make difference quot -abraham lincoln reported francis carpenter quot truth matter tells justice matter human foremost benefits humanity quot -malcolm quot reforming people habits quot -mark twain quot life dear peace sweet purchased price chains slavery forbid almighty god give liberty give death quot -patrick henry quot learn thing certainty quot -sophocles quot great achieved enthusiasm quot -ralph waldo emerson quot accurately knowledge doubt increases quot -goethe quot end justify means end sum means road traveled determines destination quot -eluki bes shahar darktraders quot life easier understand mother nature gave source code quot -graeme macwilliam quot enjoy sausage respect law avoid watching made quot -anonymous quot common mistake people make design completely foolproof underestimate ingenuity complete fools quot -anonymous douglas adams quot longer live realize impact attitude life attitude important facts important past education money circumstances failures successes people important appearance giftedness skill make break company church home remarkable thing choice day attitude embrace day change past change fact people act change inevitable thing play string attitude convinced life react charge attitudes quot -charles swindoll quot struggle progress quot -frederick douglass quot philosophy unusually ingenious attempt fallaciously quot -bertrand russell quot hear chiefs tired heart sick sad sun stands fight forever quot -chief joseph nez perce indians quot greatest happiness scatter enemy drive cities reduced ashes love shrouded tears gather bosom wives daughters quot -genghis kahn quot stranger afraid world made quot housman quot beauty truth truth beauty earth quot -john keats quot road hell paved good intentions quot -karl marx quot juvenile sea squirt wanders sea searching suitable rock hunk coral cling make home life task rudimentary nervous system finds spot takes root doesn brain anymore eats tenure quot -anonymous quot ill-chosen word fool messenger quot -anonymous quot problem america today responsible actions responsible quot -anonymous quot man sits pretty woman hour shorter minute man sit hot stove minute longer hour relativity quot -albert einstein quot beat man man man quot -michael moorer quot primary function written communication facilitate slavery quot -levi-strauss sgs quot bad kid wasn guy class called cricket boy stand class make fun cricket boy leave cricket boy invite spend night house minutes loud chirping kick petition cricket family run town bye cricket boy quot -jack handey quot lived wild west days carrying six-gun holster carry soldering iron smart-aleck cowboy hey carrying soldering iron started laughing started laughing soldering iron soldering iron justice real quiet ashamed made fun soldering iron justice hit free drink quot -jack handey quot feel killing trick calm person house ring doorbell person door left porch jack-o -lantern 
knife side head note feel lot harm quot -jack handey quot put earth put quot auden quot abilities quot -karl marx quot friends minute meet acquaintances thousand years quot -richard bach quot college english courses words myth symbol tremendous charge significance ain good symbol hiding scared gerbil page creative writing courses beasts multiply place swarms symbolize underlying mythos kids lurching courses brain full gerbils sit write lot empty pomposity impression melville quot -ursula leguin quot fate surmounted scorn quot -albert camus quot parts date offered entertainment food affection customary begin series dates great deal entertainment moderate amount food merest suggestion affection amount affection increases entertainment reduced proportionately affection entertainment longer call dating circumstances food omitted quot -miss manners quot programmers surrounded complexity avoid basic tool language design code programs complicated language part problem part solution quot hoare turing award lecture quot soccer gentleman game played hooligans rugby hooligan game played gentlemen quot -anonymous quot lost yesterday sunrise sunset golden hours set sixty diamond minutes reward offered forever quot -horace mann quot gutter stars quot -oscar wilde quot human brain complex organ wonderful power enabling man find reasons continuing quot -voltaire quot great power great responsibility quot -spiderman quot undertaking major project science heat fight drives pushes relentlessly external goal passion hunter quot -miescher quot born gift laughter sense world mad quot -raphael sabatini scaramouche quot finite unknown infinite intellectually stand islet midst illimitable ocean inexplicability business generation reclaim land quot -thomas huxley quot topic importance individuality brings worst out-crop herd nature military system abhor man pleasure marching strains band make despise big brain mistake backbone needed plague-spot civilization abolished speed heroism order senseless violence pestilent nonsense patriotism-how hate war contemptible thing hacked pieces part abominable business high spite opinion human race bogey disappeared long ago sound sense nations systematically corrupted commercial political interests acting schools press quot -albert einstein world quot people someday reach promised land quot -martin luther king quot mystery men feel honoured humiliation fellow beings quot gandhi quot man pull low make hate quot -booker washington quot kind word gun kind word quot -al capone quot whereof speak thereof silent quot -ludwig wittgenstein quot mass men lead lives quiet desperation quot thoreau quot music space notes quot -claude debussy quot attain knowledge add things day attain wisdom remove things day quot -lao-tse quot reason individual computer home quot -ken olsen quot good job applaud makes people happy quot -samuel goldwyn quot triumph disaster impostors quot -rudyard kipling quot laws mathematics refer reality refer reality quot -albert einstein quot riddle guess speedily despise--not stale long yesterday surprise--quot -emily dickinson quot live interesting times quot -chinese curse quot happy families resemble unhappy family unhappy quot -leo tolstoy anna karenina quot exploitation graduate students american universities mental equivalent sweatshops long endured silent agony victims quot -martin anderson imposters temple quot power corrupt absolute power corrupts absolutely quot -lord acton quot violence truth recoil violent schemer falls pit digs quot -sherlock holmes quot eat strength conference perky give talk sound perky enthusiastic conference listening audience won suspect deep inside don talk thesis topic hate thesis back beginning kind large repulsive insect cheerful hosts hauling sticking face pet quot -dave barry year grad school quot luck preparation meeting opportunity quot -anonymous quot people knew hard worked mastery wouldn wonderful quot -michelangelo quot vision art things invisible quot -jonathan swift quot reading maketh full man conference ready man writing exact man quot -francis bacon quot seek follow footsteps wise men seek sought quot -basho quot liberal heart conservative brain quot -winston churchill quot born eyes closed mouths open spend lives reverse mistake nature quot -dale turner quot worth worth quot -tom west quot visitors give pleasures arrive leave quot -anonymous quot silence perfect herald joy quot -shakespeare ado quot person hesitates feels inferior busy making mistakes superior quot -henry link quot people belittle ambitions small people great make feel great quot -mark twain quot cowards die times deaths valiant taste death quot -william shakespeare julius caesar quot absurd divide people good bad people charming tedious quot -oscar wilde quot genius fame love show greatness soul kindness quot -jean baptiste henri lacordaire quot change world quot -mahatma gandhi quot education filling bucket lighting fire quot -william yeats quot man key gates heaven key opens gates hell quot -buddhist proverb quot facts don fit theory change facts quot -albert einstein quot doesn matter beautiful theory doesn matter smart doesn agree experiment wrong quot -richard feynman quot courage absence fear judgment important fear quot -ambrose redmoon quot beware small expenses small leak sink great ship quot -benjamin franklin quot paint mona lisa assigning dab thousand painters quot -william buckley parallelism quot education ability listen losing temper self-confidence quot -robert frost quot words things small drop ink falling dew thought produces makes thousands millions quot -lord byron quot good idea lots ideas quot -linus pauling quot thing good advice pass oneself quot -oscar wilde quot bird soars high soars wings quot -william blake quot miracle curiosity survives formal education quot -albert einstein quot observe programmer chef urgency patron govern scheduled completion task govern actual completion omelette promised minutes progressing nicely set minutes customer choices wait eat raw software customers choices quot -fred brooks keith quot religion poor murdering rich quot -napoleon bonaparte quot triangles god sides quot -montesquieu quot worst deceptions self-deception quot -plato quot lust comfort murders passions soul quot -kahlil gibran quot basically types people people accomplish things people claim accomplished things group crowded quot -mark twain quot war politics bloodshed politics war bloodshed quot -mao tse-tung quot wise enlightened quot -anonymous quot understand change quot -kurt lewin quot success ability failure failure losing enthusiasm quot -winston churchill quot intellect ability avoid belaboring obvious quot -alfred bester demolished man quot pay attention critics statue erected critic quot -jean sibelius quot flown walk earth eyes turned skyward long return quot -leonardo vinci quot strong gentleness gentle true strength quot -ralph sockman quot maturity ability beauty quot -anonymous quot love consist gazing outward direction quot -antoine saint-exupery 
quot looked granite cut thought made walls looked streak rust stone thought iron ore ground melted emerge girders sky rocks waiting drill dynamite voice waiting split ripped pounded reborn waiting shape hands give quot -ayn rand fountainhead keith vetter quot stupid man ashamed declares duty quot -george bernard shaw quot path lead path leave trail quot -ralph waldo emerson quot professors opinion give quot -anonymous grad student quot valuable talents words quot -thomas jefferson quot journalism kill alive quot -anonymous quot important students bring ragamuffin barefoot irreverence studies worship question quot bronowski ascent man quot listen advantage speak quot -anonymous quot restlessness discontent necessities progress quot -thomas edison quot technically sweet ahead quot -robert oppenheimer quot technological possibilities irresistible man man moon control climate quot -john von neumann quot heaven beauty beauty ugliness good good evil arise difficult easy complement long short contrast high low rest voice sound harmonize front back follow quot -lao-tzu tao ching vintage books quot revealed lie believed truth conceived quot -anonymous quot hear forget remember understand quot -chinese proverb quot ways ruin gambling women technology gambling fastest women pleasurable technology quot -george pompidou steverod quot heroes larry bird admiral byrd lady bird sheryl crow chick corea inventor birdseed reads tired quot -big bird response life magazine poll heroes quot earliest flyswatters sort striking surface attached end long stick quot -jack handey quot fast ugly curse slow quot -david cheriton art computer systems performance analysis quot lots folks confuse bad management destiny quot -kin hubbard quot people learn converse begin equal quot -theodore zeldin intimate history humanity quot theories fundamental data remains quot -mary leakey quot invention progress finding link ideas met quot -theodore zeldin intimate history humanity quot experience people give mistakes quot -oscar wilde quot grandfather told kinds people work credit told group competition quot -indira gandhi quot man animal remain friendly terms victims intends eat eats quot -samuel butler quot design choice theory visual display quantitative information consists principles generate design options guide choices options principles applied rigidly peevish spirit logically mathematically violate principle place graceless inelegant marks paper principles greeted skepticism word authority dominate vision lenses word authority eyes sought designs display information clear portrayal complexity complication simple task designer give visual access subtle difficult revelation complex quot -edward tufte visual display quantitative data quot matter wrong road turn back quot -turkish proverb quot great beauty hath strangeness proportion quot -william blake quot genius eternal patience quot -michaelangelo quot experimental science supposed perform experiments find generalities supposed tally long list individual cases unique life histories butterfly collecting quot -richard lewontin quot happiness butterfly pursued grasp sit quietly alight quot -nathaniel hawthorne quot true measure love love loved love quot -goethe quot trouble world stupid cocksure intelligent full doubt quot -bertrand russell quot human beings alter lives altering attitudes mind quot -william james quot generosity giving pride taking quot -kahlil gibran sand foam quot knowledge process piling facts wisdom lies simplification quot -martin fischer quot hate person hate part isn part doesn disturb quot -herman hesse quot larger part labor author composing work critical labor labor sifting combining constructing expunging correcting testing frightful toil critical creative quot eliot essay titles function criticism quot matters conscience law majority place quot -mohandas gandhi quot allah forgives man forgets quot -bumper sticker york city courtesy hellersteins quot built castles air work lost put foundations quot thoreau walden quot true education makes inequality inequality individuality inequality success glorious inequality talent genius inequality mediocrity individual superiority standardization measure progress world quot -felix schelling pedagogically speaking quot hope reason doubt understood concluded profound coucht underneath quot swift quot write decently distrustful reader intelligence attitude patronizing quot white quot great movement experience stages ridicule discussion adoption quot -john stuart mill quot truth passes stages ridiculed violently opposed accepted self-evident quot -arthur schopenhauer quot good scientist person original ideas good engineer person makes design works original ideas prima donnas engineering quot -freeman dyson disturbing universe quot heard people trouble world haven great leaders haven great followers stood side side great thinkers surgeons engineers economists people deserve great heard crowd cheer quot -babe ruth yankees august quot experience theory blind theory experience mere intellectual play quot -immanuel kant quot treat people capable quot -johann wolfgang von goethe quot hard similar results quot -sir isaac newton quot attempted objections overcome quot -samuel johnson quot man afraid enormously capable quot -soren kierkegaard quot success hard work hard play keeping mouth shut quot -albert einstein quot laugh win respect intelligent people affection children earn appreciation honest critics endure betrayal false friends beauty find leave world bit healthy child garden patch redeemed social condition life breathed easier lived quot -ralph waldo emerson quot afraid quot -ralph waldo emerson quot lives shaped experiences expectations quot -george bernard shaw quot true teacher defends pupils personal influence quot -amos bronson alcott quot ways live life miracle miracle quot -albert einstein quot apologize lay foundation future offence quot -ambrose bierce devil dictionary quot kind decency vague quot -jerry seinfeld quot give greater quot -william stafford quot friends equal quot -confucius quot thought problem quot -goethe quot expectations powerful self-fulfilling prophecies quot -hornbeck courtesy mehul quot valuable result education ability make thing quot -thomas huxley quot education isn committed memory differentiate don quot -anatole france quot advisor shakes jerking quot -anonymous courtesy mayer-patel quot write bad things sand write good things happen piece marble quot -arabian wisdom quot mind logic knife blade bleeds hand holds quot -rabindranath tagore quot common sense common quot -voltaire quot playing words hiding secret great fascination women necessity concealment aim concealment contrived process concealment attracted quot -tolstoy quot exists atoms empty space opinion quot -demokritos quot matter tough matter kind pressure matter bad breaks eye final goal win win win quot -billie jean king quot critics artists ornithologists birds quot -robert morris quot architects recognized tool put hands creators form simple aim making bad difficult good easy quot -le corbusier modulor foreword edition quot pain relative thing quot paul beebe quot written effort general read pleasure 
quot -samuel johnson quot stated prove total poppycock time time kind quot -don delillo ratner star quot science agrees dead quot -steve jones quot creation thousand forests acorn quot -ralph waldo emerson quot quot -yoda quot traveler path paths made walking quot -antonio machado quot create system enslav man reason compare business create quot -william blake jerusalem quot matter long bark stays water turn crocodile quot -old fulah quot apple apple exchange apples apple idea idea exchange ideas ideas quot -george bernard shaw quot writer cry reader cry quot -robert frost quot architecture computing years quot -larry elison quot gossips gossip quot -turkish proverb quot book author stupid risk ugly thing betrayal mistake regret rest life mistake refrain making worse mistake encourages make make big huge mistakes don haven balls reminds status havers-of-no-balls life worth documenting life worth documenting knowing wasting time time air straight write straight eyes writing straight ing eyes person person thought wrote books hugged put hand arm scarcely wrote book letter messy ing letter barely grip letter meant letter hadn mailed letter happy made quot -david eggers heartbreaking work staggering genius quot thought bird space cage words unfold wings fly quot -kahlil gibran quot repeatedly excellence act habit quot -aristotle quot glass darkly face face part quot corinthians quot give essential liberties obtain temporary safety deserve liberty safety quot -benjamin franklin quot greatest glory falling rising time fall quot -confucius quot pressure diamonds quot -mary case quot people understood patents granted today ideas invented patents industry complete standstill today quot -bill gates quot failed matter fail fail quot -samuel beckett quot music business cruel shallow money trench long plastic hallway thieves pimps run free good men die dogs negative side quot -hunter thompson quot working problem beauty solve problem finished solution beautiful wrong quot -richard buckminster fuller quot hard make interesting basically makes law nature law aerodynamics written created mediocre natural state writing mediocrity tending mediocrity atoms sort dissipating expanse universe mediocre takes make mediocre ing act exert good quot -ira glass interview onion quot hate enemies clouds judgement quot -michael corleone godfather quot opposite love hate indifference opposite art ugliness indifference opposite faith heresy indifference opposite life death indifference quot -elie wiesel quot enemies innovative resourceful stop thinking ways harm country people quot -george bush quot opportunity missed people dressed overalls work quot edison quot mathematics don understand things quot -johann von neumann quot find time time make quot -charles buxton quot true gentleman play bagpipes doesn quot acket griffin quot genuine trust implies opportunity checking wanted evidence experience argument order share unsupported final claim quot -philip morrison quot hate quotations quot -ralph waldo emerson 
remzi arpaci papers geiger monitoring buffer cache virtual machine environment stephen jones andrea arpaci-dusseau remzi arpaci-dusseau architectural support programming languages operating systems asplos xii october san jose california abstract postscript pdf bibtex design choices utilizing disk idleness virtual machine environment pradheep elango saisuresh krishnakumaran remzi arpaci-dusseau workshop interaction operating systems computer architecture wiosca june boston massachusetts semantically-smart disk systems past present future andrea arpaci-dusseau remzi arpaci-dusseau lakshmi bairavasundaram timothy denehy florentina popovici vijayan prabhakaran muthian sivathanu sigmetrics performance evaluation review pages march volume number abstract postscript pdf bibtex dependability analysis virtual memory systems lakshmi bairavasundaram andrea arpaci-dusseau remzi arpaci-dusseau international conference dependable systems networks dsnjune philadelphia pennsylvania abstract postscript pdf bibtex antfarm tracking processes virtual machine environment stephen jones andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix annual technical conference usenix june boston massachusetts abstract postscript pdf bibtex logic file systems muthian sivathanu andrea arpaci-dusseau remzi arpaci-dusseau somesh jha proceedings fourth usenix symposium file storage technologies fast pages december san francisco california abstract postscript pdf bibtex database-aware semantically-smart storage muthian sivathanu lakshmi bairavasundaram andrea arpaci-dusseau remzi arpaci-dusseau proceedings fourth usenix symposium file storage technologies fast pages december san francisco california abstract postscript pdf bibtex journal-guided resynchronization software raid timothy denehy andrea arpaci-dusseau remzi arpaci-dusseau proceedings fourth usenix symposium file storage technologies fast pages december san francisco california abstract postscript pdf bibtex iron file systems vijayan prabhakaran lakshmi bairavasundaram nitin agrawal haryadi gunawi andrea arpaci-dusseau remzi arpaci-dusseau proceedings acm symposium operating systems principles sosp pages october brighton united kingdom abstract postscript pdf bibtex model-based failure analysis journaling file systems vijayan prabhakaran andrea arpaci-dusseau remzi arpaci-dusseau international conference dependable systems networks dsnpages june yokohama japan abstract postscript pdf bibtex deconstructing commodity storage clusters haryadi gunawi nitin agrawal andrea arpaci-dusseau remzi arpaci-dusseau jiri schindler proceedings annual international symposium computer architecture isca pages june madison wisconsin abstract postscript pdf bibtex improving storage system availability d-graid muthian sivathanu vijayan prabhakaran andrea arpaci-dusseau remzi arpaci-dusseau acm transactions storage tos pages volume number abstract pdf bibtex analysis evolution journaling file systems vijayan prabhakaran andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix annual technical conference usenix pages april anaheim california abstract postscript pdf bibtex deploying safe user-level network services ictcp haryadi gunawi andrea arpaci-dusseau remzi arpaci-dusseau proceedings symposium operating systems design implementation osdi pages december san francisco california abstract postscript pdf bibtex life death block level muthian sivathanu lakshmi bairavasundaram andrea arpaci-dusseau remzi arpaci-dusseau proceedings symposium operating systems design implementation osdi pages december san francisco california abstract postscript pdf bibtex deconstructing storage arrays timothy denehy john bent florentina popovici andrea arpaci-dusseau remzi arpaci-dusseau architectural support programming languages operating systems asplos pages october boston massachusetts abstract postscript pdf bibtex x-ray non-invasive exclusive caching mechanism raids lakshmi bairavasundaram muthian sivathanu andrea arpaci-dusseau remzi arpaci-dusseau proceedings international symposium computer architecture isca pages june munich germany abstract postscript pdf bibtex improving storage system availability d-graid muthian sivathanu vijayan prabhakaran andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix symposium file storage technologies fast pages april san francisco california abstract postscript pdf bibtex winner student paper explicit control batch-aware distributed file system john bent doug thain andrea arpaci-dusseau remzi arpaci-dusseau miron livny proceedings symposium network systems design implementation nsdi pages april san francisco california abstract postscript pdf bibtex transforming policies mechanisms infokernel andrea arpaci-dusseau remzi arpaci-dusseau nathan burnett timothy denehy thomas engle haryadi gunawi james nugent florentina popovici proceedings acm symposium operating systems principles sosp pages october bolton landing lake george york abstract postscript pdf bibtex pipeline batch sharing grid workloads doug thain john bent andrea arpaci-dusseau remzi arpaci-dusseau miron livny proceedings high-performance distributed computing hpdcpages june seattle washington abstract postscript pdf bibtex robust portable scheduling disk mimic florentina popovici andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix annual technical conference usenix pages june san antonio texas abstract postscript pdf bibtex controlling place file system gray-box techniques james nugent andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix annual technical conference usenix pages june san antonio texas abstract postscript pdf bibtex semantically-smart disk systems muthian sivathanu vijayan prabhakaran florentina popovici timothy denehy andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix symposium file storage technologies fast pages march san francisco california abstract postscript pdf bibtex run-time adaptation river remzi arpaci-dusseau acm transactions computer systems tocs pages february volume number abstract pdf bibtex evolving rpc active storage muthian sivathanu andrea arpaci-dusseau remzi arpaci-dusseau architectural support programming languages operating systems asplos pages october san jose california abstract postscript pdf bibtex flexibility manageability performance grid storage appliance john bent venkateshwaran venkataramani nick leroy alain roy joseph stanley andrea arpaci-dusseau remzi arpaci-dusseau miron livny proceedings high-performance distributed computing hpdcpages july edinburgh scotland abstract postscript pdf bridging information gap storage protocol stacks timothy denehy andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix annual technical conference usenix pages june monterey california abstract postscript pdf bibtex exploiting gray-box knowledge buffer-cache contents nathan burnett john bent andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix annual technical conference usenix pages june monterey california abstract postscript pdf bibtex storage-aware caching revisiting caching heterogeneous storage systems brian forney andrea arpaci-dusseau remzi arpaci-dusseau proceedings usenix symposium file storage technologies fast pages january monterey california abstract postscript pdf bibtex information control gray-box systems andrea arpaci-dusseau remzi arpaci-dusseau proceedings acm symposium operating systems principles sosp pages october banff canada abstract postscript pdf bibtex block asynchronous flexible infrastructure user-level filesystems muthian sivathanu venkateshwaran venkataramani remzi arpaci-dusseau international conference high-performance computing hipc pages december india postscript pdf gathering creating communities grid doug thain john bent andrea arpaci-dusseau remzi arpaci-dusseau miron livny pages november denver colorado postscript pdf fail-stutter fault tolerance remzi arpaci-dusseau andrea arpaci-dusseau eighth workshop hot topics operating systems hotos viii pages schloss elmau germany abstract postscript pdf bibtex manageable storage adaptation wind andrea arpaci-dusseau remzi arpaci-dusseau john bent brian forney sambavi muthukrishnan florentina popovici omer zaki international symposium cluster computing grid ccgrid pages brisbane australia postscript pdf information-based approach distributed systems design andrea arpaci-dusseau remzi arpaci-dusseau unpublished document june postscript pdf microbenchmark-based extraction local global disk characteristics nisha talagala remzi arpaci-dusseau dave patterson california berkeley number csd- postscript pdf performance availability networks workstations remzi arpaci-dusseau california berkeley abstract compressed postscript pdf talk slides bibtex architectural requirements 
scalability nas parallel benchmarks frederick wong richard martin remzi arpaci-dusseau david david culler supercomputing november portland oregon abstract pdf cluster river making fast case common remzi arpaci-dusseau eric anderson noah treuhaft david culler joseph hellerstein dave patterson kathy yelick workshop input output parallel distributed systems iopads atlanta georgia abstract postscript pdf bibtex searching sorting record experiences tuning now-sort andrea arpaci-dusseau remzi arpaci-dusseau david culler joseph hellerstein dave patterson symposium parallel distributed tools spdt august welches oregon abstract postscript pdf bibtex architectural costs streaming comparison workstations clusters smps remzi arpaci-dusseau andrea arpaci-dusseau david culler joseph hellerstein dave patterson high-performance computer architecture hpca february las vegas nevada abstract postscript pdf bibtex parallel computing berkeley david culler andrea arpaci-dusseau remzi arpaci-dusseau brent chun steven lumetta alan mainwaring richard martin chad yoshikawa frederick wong joint symposium parallel processing jspp june kobe japan abstract postscript pdf high-performance sorting networks workstations andrea arpaci-dusseau remzi arpaci-dusseau david culler joseph hellerstein dave patterson proceedings acm sigmod conference management data sigmod tucson arizona abstract compressed postscript postscript pdf bibtex now-sort home page iram smartsimm overcoming bus bottleneck kimberly keeton remzi arpaci-dusseau dave patterson workshop mixing logic dram isca june denver colorado postscript compressed postscript now-sort scalable commodity workstation sort remzi arpaci andrea dusseau database management systems abstract postscript compressed postscript communication behavior distributed operating system remzi arpaci california berkeley abstract postscript compressed postscript pdf reveeling solaris remzi arpaci-dusseau manuel fahndrich berkeley project intelligent ram compressed postscript html effective distributed scheduling parallel workloads andrea dusseau remzi arpaci david culler acm sigmetrics international conference measurement modeling computer systems pages philadelphia pennsylvania abstract postscript compressed postscript pdf process management network workstations remzi arpaci andrea dusseau amin vahdat http berkeley remzi -final html interaction parallel sequential workloads network workstations remzi arpaci andrea dusseau amin vahdat lok liu tom anderson dave patterson acm sigmetrics international conference measurement modeling computer systems pages ottawa canada abstract postscript compressed postscript pdf empirical evaluation cray-t compiler perspective remzi arpaci david culler arvind krishnamurthy steve steinberg kathy yelick annual international symposium computer architecture iscapages june santa margherita ligure italy abstract postscript compressed postscript pdf compressed talk slides microbenchmarking theory practice remzi arpaci steve steinberg berkeley project computer architecture abstract text combining parallel sequential workloads remzi arpaci amin vahdat tom anderson dave patterson california berkeley number csd- abstract compressed postscript re-examining scheduling communication parallel programs andrea dusseau remzi arpaci berkeley project multiprocessor networks compressed postscript effects non-dedicated environment parallel applications remzi arpaci andrea dusseau lok liu berkeley project operating systems december abstract compressed postscript 
cssections intro operating systems csintroduction operating systems wisconsin madison department computer sciences fall basic information click basic information lectures teaching class news final grades registrar check grades handin directory score wrong feel free check tests remzi public -tests remzi public -tests lost lot points due small mistake document code required fix problem send remzi solutions practice exams memory file systems question answer final exam thursday room good luck review final exam tuesday discussion notes type tar xvf disc tar unpack read readme file practice exams final memory file systems discussion notes type tar xvf disc tar unpack read readme file discussion notes type tar xvf disc tar unpack read readme file project notes overview operating systems introduce exciting range materials broad field operating systems including basic operating system structure process thread synchronization concurrency file systems storage servers memory management techniques process scheduling resource management system security hot topics assumes familiarity basic computer organization processors memory devices covered data structures stacks hash tables program java perform assignments don experience language don worry spend time covering background learning important valuable class real life java realize opportunity broaden skill set stop complaining mailing lists important announcements class mailing list read mail frequently project time responsible material list mail class list archived note class list automatically generated based enrolled class sign start emails check archives missed project question mailing list proj wisc check proj wisc mailing list archive projects materials recommend coming class class notes online read book background cover topic class fill knowledge perspective operating systems textbooks operating systems edition deitel deitel choffnes isbn pearson prentice hall operating system concepts edition silberschatz galvin gagne isbn wiley programming language edition kernighan ritchie isbn paperback prentice hall system programming assignments class book world kernighan ritchie beautifully sparse programming language worth purchasing expert programming peter van der linden finally interested mastering unix programming environment absolute bible advanced programming unix environment late great richard stevens buy book worth penny short free incomplete overview programming environment viewing convenience postscript pdf figure debugger gdb link short tutorial web learning tools good idea projects project due thursday september project due thursday october project due tuesday november project due thursday december part complete programming assignments perform projects pcs running linux operating system unix users novice unix users csl unix facilities encouraged attend orientation session early semester purchase copy introductory manual unix operating system computer sciences department instructional computing environment doit tech store floor computer sciences statistics building projects fundamental part assignment easy remaining projects require significant amount time procrastinate things longer expect wait day assignment due start assignments started week due ideally handed information complete assignments class web page stated assignments java assume programming background learning basics language difficult similar java invented java experts projects graded implementation works test program suite input sets grade based tests application passes answer questions program briefly examine code ensure specifications assignment questions projects proj queries responses archived url exams exams test knowledge exams closed book cover material class projects midterm held october class exam single page cheat sheet inches allowed sides exams closed-book closed-note grading projects worth total grade exams worth tentative schedule tentative schedule class cover including links class notes worth printing class notes class bringing nbsp tuesday silsil- deitel nbsp thursday silsil- deitel overview ppt processes ppt threads ppt postponed synchronization ppt locks ppt semaphores ppt philosophers monitors ppt deadlock ppt cpu scheduling ppt cpu scheduling reading memory allocation ppt memory management ppt paging ppt midterm exam case study ppt virtual memory ppt replacement ppt paper virtual memory ppt files directories ppt disks ppt raid postponed thanksgiving file allocation ppt ffs read pdf journaling ppt distributed ppt security ppt encryption ppt questions comments late send mail reply 
csadvanced operating systems csadvanced operating systems wisconsin madison department computer sciences spring basic information tuesday thursday computer sciences timetable entry professor remzi arpaci-dusseau office hours appointment send chance stopping notes final assignment click final exam thursday bring cheat sheets topics covered notes short cuts reading list auxiliary reading advice papers reading questions project list overview graduate operating systems cover exciting range materials broad field operating systems including basic operating system structure file systems storage servers memory management techniques process scheduling resource management threads distributed peer-to-peer systems security hot topics examine influential historical systems important current efforts extracting lessons build systems evaluate center basic entities readings assignments final project class read papers assigned discuss class write bit paper half semester perform mini-assignments warmed project finally work projects real key class mini-research project topic choice provide suggestions encouraged topic research details weeks class show nucleus hydra exo exo disco nooks ffs lfs io-lite anticipatory raid d-graid monitors mesa lottery resource containers scheduler activations vax vms multics spring break spring break vmware rpc locus tacc nfs afs coda past measurements authentication kerberos final presentations class wrap-up final exam readings current reading list readings on-line note shouldn read ahead list change semester additional papers auxiliary reading list required read excellent papers list worth reading point finally collection advice papers advice papers list highly recommend read papers held responsible basic responsibilities readings covered read assigned discussion papers class form discussion group people group discuss paper class meets formed group send list group members answer question posed paper individual write-up consist short-essay answer question posed write-up exceed half page length list questions answer turn write remzi day class discuss paper class date subject line reading late write-ups automatically receive null score write-ups plain text fancy encoding professor viewing pleasure write-ups plain text returned sender ungraded reading load heavy make fall project project list final project main focus expected perform work eventually suitable major operating systems conference year projects end published works major conference general people work groups size groups larger provide suggestions pick encouraged project refine project write-ups similar format conference submission entered class-wide mini-conference papers receive kind recognition details forthcoming links previous class projects spring fall fall fall exams midterm final test paying attention exams closed book cover papers read date topics discussed class midterm exam monday final exam thursday assignments addition reading exams final project assignments hands experience operating systems experimental procedure stay tuned details assignment digital picture reading group due assignment art measurement due assignment project proposal due assignment project status due assignment project status due assignment project status due assignment project presentation due final write-up due grading rough outline grading reading assignments exams final project rough breakdown subject change whim professor mailing list mailing list information complaints file systems disk technology unfinished symphonies remzi arpaci-dusseau 
cssection advanced storage systems cssection advanced storage systems basic information professor remzi arpaci-dusseau open computer sciences moved computer sciences timetable entry notes wiki slight change reading list read autoraid paper wednesday overview storage heart modern computing systems class read latest greatest storage systems studying ideas academia learning real-world systems companies google network appliance ibm emc perform cutting-edge mini-research project design build evaluate system topics underlying technology local storage systems distributed storage systems mobile storage systems reliability fault tolerance performance scalability power management management virtualization caching replication consistency storage networking security theme cross-fertilization major theme exploring semester cross-fertilization ideas domains storage formal techniques programming languages community build robust storage systems techniques databases applied build functional storage maching learning building automated manageable systems responsible primarily things reading papers class ready discussion mini-research project partner reading understanding papers crucial part educational process project real focal point hands dirty interesting storage research space ideas suggested shortly reading list found basically organized halfs deals basics storage systems disks raids work interface storage issues on-disk consistency scheduling manageability failure low-level papers half techniques organized ideas developed largely storage community programming language ideas database techniques reading list disk technology nbsp class begins nbsp scsi ata wilkes storage arrays nbsp autoraid nbsp row-diagonal interfaces nbsp nasd nbsp ssd on-disk consistency nbsp soft updates nbsp journaling scheduling nbsp rotational sched nbsp capacity bandwidth manageability nbsp network appliance nbsp petal frangipani failure nbsp googlefs nbsp iron student week nbsp googlefs mapreduce nbsp talk projects spring break nbsp class nbsp class techniques nbsp singularity nbsp cmc visiting stanford nbsp malicious fisc nbsp deviant craziness nbsp wiki nbsp wiki reboot undo nbsp wiki nbsp wiki tba nbsp wiki nbsp wiki tba nbsp wiki nbsp wiki projects nbsp project presentations nbsp project presentations wiki readings random details offered cssection turned real -level offered year count core credit prerequisites permission instructor 
csdistributed systems csdistributed systems wisconsin madison department computer sciences spring basic information pmpm computer sciences timetable entry professor remzi arpaci-dusseau thomas engle office hours appointment class tonight things lecture notes communication distributed operating systems distributed services distributed storage distributed storage cooperative caching gms scheduling migration peer-to-peer overview distributed systems class class learn theory practice mulitple computers work build scalable fault-tolerant services interesting systems research found arena privilege reading class require read papers final project expected participate discussion finally paper expected notes write carefully basic idea read discuss learn distributed systems handle concepts systems apply learned produce set terrific final projects projects early enable excellent job schedule day class overview communication u-net linda ivy general systems locus sprite services tacc porcupine dds storage systems xfs petal frangipani memory management cooperative caching gms scheduling lard migration migration peer-to-peer pangaea ivy project interlude work projects project interlude work projects project interlude work projects time time clocks snapshots replication consistency optimistic project updates minute status updates failures fail-stop processors byzantine generals consensus paxos simplified disk readings paper list part schedule notes reading papers read assigned papers class discussion difficult form discussion group discussion groups developing ability critically evaluate research mandatory class notes expected notes class semester notes include relevant details discussed class expected write notes class read enjoy latex project information exams exams grading grading based project largely in-class participation mailing list mailing list list wisc general postings log url find page 
google-based ranking computer science engineering departments google-based ranking computer science engineering departments remzi arpaci-dusseau wisconsin madison introduction rankings computer science engineering departments continue contentious topic factors counted weighted person answer answer resounding propose simpler direct meaningful method google-based ranking building top years technology put google pagerank trade algorithm leverage power internet deliver complete ranking top departments field click button methodology typed search terms google computer science computer sciences computer engineering plural form computer science included departments author institution department computer sciences strange historical reasons copied top results excluding links wikipedia non-academic institutions advertisements leaving schools results listed include sake comparison recent news world report rankings results google computer science cmu maryland mass berkeley stanford cornell illinois princeton purdue georgia tech brown ucla columbia indiana wisconsin usc minnesota suny-stonybrook virginia texas yale cal tech colorado north carolina north carolina state texas washington google computer sciences wisconsin texas purdue mass boston penn stanford mit cmu berkeley princeton illinois cornell maryland edinburgh diku ucla santa cruz columbia usc brown utah indiana minnesota huji rochester news computer science berkeley cmu mit stanford cornell illinois washington princeton texas wisconsin cal tech georgia tech san diego maryland harvard ucla michigan columbia purdue penn yale brown rice north carolina duke mass usc johns hopkins nyu rutgers irvine virginia google computer engineering michigan illinois washington iowa state cmu wisconsin north carolina state santa cruz oregon state florida georgia tech chico state texas rit case western virginia tech san jose state illinois-chicago rpi tulane mississippi state clemson purdue usc cal poly pitt syracuse news computer engineering mit stanford berkeley cmu illinois michigan texas cornell washington princeton purdue wisconsin cal tech georgia tech usc ucla rice san diego rpi johns hopkins tables schools google-based ranking system news ranking highlight red conversely schools news ranking google-based ranking highlighted green focus computer science google trends tells searched computer engineering search term popularity computer science computer engineering note scary decline number searches computer science top schools news computer science rankings sort google ranks news top computer science departments sorted google computer sciences ranking wisconsin texas stanford mit cmu berkeley princeton illinois cornell washington news top computer science departments sorted google computer science ranking cmu berkeley stanford cornell illinois princeton wisconsin texas washington mit data compute averagerank trade statistic simply averages tables ignores virtually data called useless flat wrong statistical method cmu stanford wisconsin berkeley texas princeton illinois cornell mit washington conclusions study assuming google draw primary conclusions wisconsin underrated news result surprise author article mit washington overrated news point surprising scholarship led demise highly-regarded schools schools place point true ignore results play data odd unsound manner much-maligned averagerank trade algorithm future work future plan conduct searches advanced google features quotes search terms keyword hope automate process eliminating type report web page 
ps-adobetitle hammtalk pdf version creationdate administrator documentdata clean bit boundingbox pages documentprocesscolors cyan magenta yellow black font symbol font timesnewroman bold font arial font timesnewroman italic font timesnewroman procset adobe acrobat pdf operators procset adobe acrobat type operators endcomments begindefaults enddefaults beginprolog endprolog beginsetup currentpacking pop currentpacking true setpacking userdict pdf dict put beginfile pdfvars prc copyright copyright adobe systems incorporated rights reserved userdict pdfvars dict dup begin put save cshow initall termall doclip sfc sfcs sfc ssc sscs ssc fcs scs array array array array null array array array array null cpcf null cpcs null int false rise matrix ctm matrix mtx matrix fscl pdfencodings array italmtx basefont basefonto categories dict true false colorsep false tmpcolr tmpop end endfile pdfvars begin pdf begin beginfile pdfutil prc copyright copyright adobe systems incorporated rights reserved bind bind load pdfvars roll put xdd exch level languagelevel pop languagelevel false ifelse dup currentdict exch currentdict exch true pop false ifelse isdefined pop true false ifelse startload dup dup save save endload save restore npop pop repeat endfile beginfile compat copyright copyright adobe systems incorporated rights reserved cshow isdefined startload cshow exch cshow xdd cshow exec forall endload setcmykcolor isdefined startload setcmykcolor roll index add neg dup pop roll repeat setrgbcolor pop endload rectclip isdefined startload rectclip newpath clip newpath endload execform isdefined startload execform gsave dup begin matrix concat bbox aload pop exch index exch index rectclip paintproc end grestore endload sethalftone isdefined startload sethalftone begin halftonetype frequency angle spotfunction load setscreen end endload endfile beginfile pdf prc copyright copyright adobe systems incorporated rights reserved initialize colorsep sep ops begin dict begin newpath terminate colorsep end end level startload moveto lineto curveto setsa setstrokeadjust endload level startload transform round add exch round add exch itransform moveto lineto curveto setsa xdd endload currentpoint roll copy closepath setdash setlinejoin setlinecap setmiterlimit setlinewidth currentflat dup pop setflat ilp sfc fill sfcs sfc fill ssc stroke sscs ssc stroke doclip doclip clip eoclip ifelse doclip newpath doclip gsave sfc fill grestore doclip clip eoclip ifelse newpath ilp doclip sfc fill ifelse doclip gsave sfc eofill grestore doclip clip eoclip ifelse newpath ilp doclip sfc eofill ifelse doclip gsave ssc stroke grestore doclip clip eoclip ifelse newpath ilp doclip ssc stroke ifelse doclip dup gsave grestore gsave grestore clip eoclip ifelse newpath ilp doclip pop ifelse doclip dup gsave grestore gsave grestore clip eoclip ifelse newpath ilp doclip pop ifelse doclip doclip save restore ilp level startload defineres defineresource findres findresource currentglobal true systemdict setglobal exec function extgstate form generic category findresource dup length dict copy category defineresource pop forall systemdict setglobal exec endload level startload almostfull dup maxlength exch length bind expand index maxlength mul cvi dict dup begin exch forall end bind xput roll dup index dup almostfull expand dup roll put bind defineres categories index categories categories index dict xput store categories exch copy roll index xput put bind findres categories exch exch bind endload dup pop load dup fcs xdd ucs cpcf exch xdd null dup pop load dup scs xdd ucs cpcs exch xdd null ucs dup type arraytype dup dup indexed pop pattern dup length ucs ifelse ifelse ifelse cpcf dict dup begin defaultgray devicegray defaultrgb devicergb devicecmyk calgray calrgb calcmyk lab pattern indexed separation ciebaseda ciebasedabc end cpcs dict dup begin defaultgray devicegray defaultrgb devicergb devicecmyk calgray calrgb calcmyk lab pattern indexed separation ciebaseda ciebasedabc end level startload pop makepat pop endload level startload findcolorrendering isdefined mark exch findcolorrendering counttomark type booleantype dup type nametype dup colorrendering resourcestatus pop pop dup defaultcolorrendering colorrendering findresource setcolorrendering cleartomark pop ifelse makepat makepattern endload level colorsep startload setcolor aload length dup pop setgray dup pop setgray setrgbcolor setcmykcolor ifelse ifelse ifelse bind sfcs sscs endload level colorsep startload sfc setcolor ssc setcolor endload level colorsep startload sfcs fcs setcolorspace bind sscs scs setcolorspace bind sfc aload pop null setcolor setpattern ifelse bind ssc aload pop null setcolor setpattern ifelse bind endload astore pop ilp astore pop ilp scn dup type dicttype dup xdd painttype ilp cpcf fcs ucs ifelse ifelse scn dup type dicttype dup xdd painttype ilp cpcs scs ucs ifelse ifelse defaultgray defaultrgb devicecmyk defaultgray defaultrgb devicecmyk mtx astore concat roll index rlineto exch rlineto neg rlineto rectclip execform cvx exec initgs defaultgray pop defaultgray devicegray ifelse defaultrgb pop defaultrgb devicergb ifelse true setsa dict dup begin cosinedot mul cos exch mul cos add div cross abs exch abs copy exch pop neg diamond abs exch abs copy add dup mul exch dup mul add exch copy add mul add exch dup mul exch dup mul add ifelse ifelse double exch div exch mul sin div exch repeat add doubledot mul sin div exch repeat add ellipse abs exch abs copy mul exch mul add dup pop dup mul exch div dup mul add div exch dup pop exch dup mul exch exch div dup mul add div exch exch pop exch pop ifelse ifelse ellipsea dup mul mul exch dup mul add exch ellipseb dup mul div mul exch dup mul exch add sqrt exch ellipsec dup exch dup exch mul dup mul mul dup mul exch ifelse exch dup exch dup exch mul dup mul mul dup mul exch ifelse add div inverteddouble exch div exch mul sin div exch repeat add neg inverteddoubledot mul sin div exch repeat add neg invertedellipsea dup mul mul exch dup mul add invertedsimpledot dup mul exch dup mul add line exch pop abs neg linex pop liney exch pop rhomboid abs exch abs mul add div round abs exch abs copy add dup mul exch dup mul add exch dup mul exch dup mul add ifelse simpledot dup mul exch dup mul add exch square abs exch abs copy exch pop neg end function defineres pop forall identity function defineres pop level startload begin setstrokeadjust setoverprint setblackgeneration ucr setundercolorremoval sethalftone sethalftonephase isdefined htp sethalftonephase dup xcheck settransfer aload pop setcolortransfer ifelse end default halftone findresource pop stopped currenthalftone exch defineresource pop endload level 
startload begin xdd dup xdd setoverprint pop setoverprint pop ifelse sethalftone dup xcheck settransfer pop ifelse end dict dup begin currentscreen halftonetype spotfunction angle frequency exch forall end default exch halftone defineres pop endload int dup index index index div roll mul exch pop add exch pop limit dup index exch pop dup index exch pop colorsep startload sfc null fcs type arraytype fcs separation fcs aload pop exch setseparationgray pop begin setseparationgray end fcs exec fcs findcmykcustomcolor pop begin findcmykcustomcolor end aload pop setcustomcolor pop begin setcustomcolor end ifelse setcolor ifelse setcolor ifelse setpattern ifelse bind ssc null scs type arraytype scs separation scs aload pop exch setseparationgray pop begin setseparationgray end scs exec scs findcmykcustomcolor pop begin findcmykcustomcolor end aload pop setcustomcolor pop begin setcustomcolor end ifelse setcolor ifelse setcolor ifelse setpattern ifelse bind endload endfile beginfile pdftext prc copyright copyright adobe systems incorporated rights reserved pdf pdftext dict dup begin put initialize pdftext begin terminate end copyfont index fid index uniqueid pop pop ifelse forall modenc enc xdd icode counttomark index dup type nametype enc icode roll put icode add icode xdd cleartomark enc trenc enc xdd exch dup pop notdef encoding exch ifelse enc roll put pop enc xdd standardencoding array copy modenc pdfencodings exch exch put usepdfencoding xdd findfont dup length add dict begin index fid pop pop ifelse forall fontname exch usepdfencoding encoding pdfencodings usepdfencoding pop usepdfencoding counttomark pop encoding array copy modenc encoding exch ifelse array trenc encoding exch ifelse ifelse fontname currentdict end definefont pop pdfislevel systemdict languagelevel languagelevel false ifelse pdfislevel pdffontstatus dup font resourcestatus pop pop pop true cidfont category resourcestatus pop pop cidfont resourcestatus pop pop true false ifelse pop false ifelse ifelse pdffontstatusstring string pdffontstatusstring fonts putinterval pdffontstatus pdffontstatusstring getinterval cvs length add pdffontstatusstring exch exch getinterval status pop pop pop pop true false ifelse ifelse pdfstring string pdfcomposefontname dup length index type nametype pdfstring cvs length dup dup pdfstring exch putinterval pdfstring exch add dup pdfstring length exch getinterval index exch cvs length add add pdfstring exch exch getinterval exch pop true pop pop false ifelse false ifelse systemdict composefont pdfcomposefont index cmap resourcestatus pop pop true false ifelse index true exch pdffontstatus pop false exit forall composefont true pdfcomposefontname dup pdffontstatus findfont definefont true pop pop false ifelse dup pdffontstatus findfont true pop false ifelse ifelse ifelse pdfcomposefont pdfcomposefontname dup copy pdffontstatus pop findfont definefont true pop false dup pdffontstatus findfont true pop false ifelse ifelse ifelse ifelse pdffacebystyledict dict dup begin pdfislevel serif ryumin-lightpv-rksj-h font resourcestatus pop pop ryumin-light heiseimin-w ifelse sansserif gothicbbb-mediumpv-rksj-h font resourcestatus pop pop gothicbbb-medium heiseikakugo-w ifelse jun -lightpv-rksj-h font resourcestatus pop pop roundsansserif jun -light heiseimarugo-w pv-rksj-h font resourcestatus pop pop roundsansserif heiseimarugo-w ifelse default serif serif ryumin-light sansserif gothicbbb-medium fonts jun -lightpv-rksj-h status stopped pop pop pop pop pop roundsansserif jun -light ifelse default serif ifelse end tzzero stylearr xdd copy pdfcomposefont exch pop exch pop exch pop stylearr length stylearr exch pdffacebystyledict exch copy pop default exch pop index roll pdfcomposefont exch pop findfont dup length dict begin index fid pop pop ifelse forall currentdict end ifelse ifelse definefont pop swj dup roll dup length exch stringwidth exch roll index mul add roll roll mul add roll cnt index cnt cnt add forall pop exch cnt mul exch cnt mul index add roll index add roll pop pop jss roll npop exch copy exch put gsave exch index index index roll widthshow currentpoint false charpath currentpoint index setmatrix stroke ifelse grestore moveto copy rmoveto exch cshow npop jsp npop exch copy exch put exch index index index roll widthshow false charpath ifelse copy rmoveto exch cshow npop trj roll pjsf trj sfc awidthshow pjss trj ctm ssc jss pjsc trj jsp tjdef pjsf load pjss load dup currentpoint roll pjsf newpath moveto pjss bind trj swj rmoveto bind dup currentpoint roll gsave pjsf grestore roll moveto pjsc bind dup currentpoint roll currentpoint gsave newpath moveto pjss grestore roll moveto pjsc bind dup currentpoint roll gsave dup currentpoint roll pjsf newpath moveto pjss grestore roll moveto pjsc bind pjsc load int true ctm currentmatrix pop matrix copy pop rise translate scale moveto int false clip ctm setmatrix newpath int currentpoint newpath moveto dup xdd tjdef exch xdd userdict copystring index put itm ctm setmatrix concat rise translate scale astore pop itm moveto mtx translate concatmatrix pop itm moveto dup xdd dup div fscl xdd exch findfont exch scalefont setfont neg xdd xdd xdd rise xdd currentpoint itm moveto div xdd itm exch pop fscl mul neg rmoveto exch exch dup type stringtype exch ifelse forall setcharwidth setcachedevice sfc ssc nnd notdef repeat defs buildchar index encoding exch index buildglyph exec buildglyph exch begin glyphprocs exch exec end makebold findfont dup dup length add dict begin copyfont painttype strokewidth fontmatrix idtransform pop dummybold currentdict end definefont dict begin basefont exch basefonto exch fonttype fontmatrix fontbbox encoding standardencoding buildchar exch begin basefont setfont dup roll put dup stringwidth index exch add exch setcharwidth moveto gsave dup show grestore basefonto setfont show end currentdict end definefont pop makeitalic findfont italmtx makefont dup length dict begin copyfont currentdict end definefont pop makebolditalic dummybold exch makebold dummybold makeitalic currentdict readonly pop end endfile pdftext begin quotesingle grave adieresis aring ccedilla eacute ntilde odieresis udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave ucircumflex udieresis dagger degree cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notdef oslash notdef plusminus notdef notdef yen notdef notdef notdef notdef notdef ordfeminine ordmasculine notdef oslash questiondown exclamdown logicalnot notdef florin notdef notdef guillemotleft guillemotright ellipsis notdef agrave atilde otilde endash emdash quotedblleft quotedblright quoteleft quoteright divide notdef ydieresis ydieresis fraction currency guilsinglleft guilsinglright daggerdbl periodcentered quotesinglbase quotedblbase perthousand acircumflex ecircumflex aacute edieresis egrave iacute icircumflex idieresis igrave oacute ocircumflex notdef ograve uacute ucircumflex ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron dotlessi caron quotesingle grave bullet bullet bullet 
quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft bullet bullet bullet bullet quoteleft quoteright quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright bullet bullet ydieresis space exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis end currentdict readonly pop end end currentpacking pop setpacking pdfvars initall pdf pdftext initialize exec forall initgs put pdfvars termall pdftext pdf terminate exec forall put pdfvars begin pdf begin pdfvars initall exec begin encoding-delta symbol end encoding-delta pdfvars termall exec end end endsetup page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman bold endresource end begin encoding-delta times-bold end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup richard hamming research transcription bell communications research colloquium seminar march kaiser bell communications research south street morristown jfk bellcore seminar bell communications research colloquia series ichard hamming professor naval postgraduate school monterey california retired bell labs scientist gave interesting stimulating talk research overflow audience bellcore staff members visitors morris research engineering center march talk centered hamming observations research question scie ntists make significant contributions forgotten long run rom forty years experience thirty bell laboratories made num ber direct observations asked pointed questions scientists hings studied lives great scientists great contributions introspection studi theories creativity talk learned terms properties individual cientists abilities traits working habits attitudes philosophy order make information talk widely tape recording made talk carefully transcribed transcription includes discussi ons question answer period talk transcribed version suffers fro translation inflections voice gestures speaker lost listen ape recording recapture part presentation recording richard hamming talk completely intelligible questioner remarks tape recording ntelligible added parentheses impression questioner remarks question identify questioner checked ensure accuracy interp retation remarks introduction richard hamming speaker bell communications research colloquium series richard hamming naval postgraduate school monterey california introduced ala chynoweth vice president applied research bell communications research alan chynoweth colleagues colleagues labs understand today regard particu larly felicitous occasion great pleasure introduce friend colleag years back richard hamming dick hamming dick time greats mathematics computer science arenas udience reminding received early education uni versities chicago nebraska illinois joined los alamos project dur ing war joined bell labs met dick join bell labs physics research organization days habit lunching ogether physics group reason strange fellow mathematics pleased join happy brought unorthodox ideas view lunches stimulating assure pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman bold endresource end begin encoding-delta times-bold end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup professional paths close years vertheless recognized dick halls bell labs tremendous admiration record speaks long detai point written books books variou areas mathematics computers coding information theory edition testimony prolific output stature dick hamming met ten years ago ther curious conference dublin ireland speakers tremendou sly entertaining provocative thoughts remember wavelengths people sounds people hear computers thoughts people dick hamming don computer extremely entertaining talk talk research richard hamming pleasure doubt live introduction title talk research managing research indiv idually research give talk subject talking ordinary run-of-the-mill research talking great research sake describi great research occasionally nobel-prize type work doesn gain nobel prize kinds things perceive significant things relativity shannon nformation theory number outstanding theories kind thing talking study los alamos brought run computing machines people scientists physicists cou back business stooge physically diffe rent put thing bluntly envious wanted feynman close fermi teller oppenheimer hans bethe boss capable people interested difference bell labs productive department bode department head time shannon people continued examin ing questions difference continued subsequently reading biograph ies autobiographies people questions find differences talk talk important important life live reincarnation doesn good life shouldn significant things life define significant define talk science studied told applies fields outstanding work characterized fields confine science order individually talk person drop modesty first-class work society rowns people set good work supposed luck supposed descend great things chance kind dumb thing shouldn set significant don people shouldn significant order stage drop modesty talk person heard talk people som trust leave won quote things start logically psychologically find major bjection people great science luck matter luck einst ein note things good luck wasn repetitive shannon didn information theory years good things locked security cryptography good things pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup thing good pers person thing life talk lot times repetition claim luck cover cite pasteur luck favors prepared mind elemen luck isn prepared mind sooner finds important luck thing luck bell labs shared office shannon time information theory coding theory suspiciou place time atmosphere luck hand people bell labs partly luck partly prepared mind partly thing talk back times luck dispose matter luck sole criterion great work claim total control quote finally newton matter newton thi hard similar results characteristics people including eat scientists young independent thoughts courage pur sue einstein asked question ght wave velocity light knew electromagnetic theory stationary local maximum moved velocity lig local maximum contradiction age velocity light peculiar luck finally created special relativity early laid pieces thinking fragmen sufficient condition items talk luck luck lots brains sounds good oom brains first-class work great work han mere brains 
brains measured ways mathematics theoretical physics astrophys ics typically brains correlates great extent ability manipulate symbols typical test apt score fairly high hand fields bill pfann fellow zone melting office day idea dimly mind wanted equations pretty clear man didn mathematics wasn articulate problem interesting work finally showed run computers compute answers ave power compute ahead negligible recognition department ultimately collected prizes field started shyness awkwardn ess inarticulateness fell productive ways beca articulate cite person trust isn udience fellow named clogston met working problem john pierce group didn asked friends school graduate school replied fired fellow pierce smart clogston finally clogston cable steady stream good ideas success brought confidence courage characteristics successful scientists courage nce courage important problems surely courage things shannon supremely ave major theorem create method coding doesn makes random code stuck asks impossible question average random code proves average code arbitrarily good good code man infinite courage dared hose thoughts characteristic great scientists courage forw ard incredible circumstances continue age factor physicists worry young einstein ings early quantum pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup mechanic fellows disgustingly young work mathematicians theoretical physicists astrophysicists work young don good work age early hand music politics literature wor late don field fits scale age effect age effect ace good work find kinds committees unable work find brattain nobel prize day prize announced assembled arnold auditorium winners made speeches brattain practically tears eyes nobel-prize effect goin affect remain good walter brattain nice weeks affecting work great problems famous hard work small problems shannon information theory encore great scientists make error fail continue plant acorns mighty oak trees grow big thing isn things reason find tha early recognition sterilize fact give favorite quotation years institute advanced study princeton opinion ruined good scienti sts institution created judged judged weren good superb onl good brings subject order working conditions people working conditions people productive working conditions bad times cambridge phy sical laboratories practically shacks physics give story private life early evident bell laboratories give conventional acre programming people prog ram computing machines absolute binary clear weren west coast job airplane companies trouble exciting people bell labs fellows airplane companies thought long wondered worlds finally hamming machines practically make write programs appeared defect forced auto matic programming early appears fault change viewpoint turns greatest assets hing gee programmers great programming stories kind grace hopper simi lar carefully great scientists turning roblem bit changed defect asset scientists found couldn problem finally began study turned cou rse important result ideal working conditions strange aren matter drive observe great scientists tremendous drive worked ten years john tukey bell labs tremendous drive day abo years joined discovered john tukey slightly younger genius storming bode office age john tukey leaned back chair put hands head grinned slightly surprised hamming worked har years simply slunk office bode knowledge productivity pound interest people approximately ability person works ten rcent outproduce learn learn opportunit compound pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup interest don give rate high rate iven people ability person manages day day mor hour thinking tremendously productive lifetime bode remark art spent good deal time years work bit harder found fact work don front wife sort neglect someti mes needed study neglect things intend quest ion matter drive edison genius perspiration inspiration exaggerating idea solid work steadily applied surprisingly steady application effort bit work intelligently applied trouble drive misapplied doesn wondered good friends bell labs worked hard harder didn sho misapplication effort matter hard work applied sensibly trait side talk trait ambiguity discover importance people true great scientists tolerate ambiguity theory ahead ubt notice errors faults step forward create replacement theor notice flaws doubt won started requires lovely balance great scientists aware theories true aware slight misfits don fit don forget darwin writes autobiography found write piece evidence appeared contra dict beliefs disappear mind find apparent flaws sensitive track things eye explained theory changed fit great contributions great contribution rarely adding decimal place emotional commitment great scie ntists completely committed problem don committed seldom produce outsta nding first-class work emotional commitment conditi apparently reason studied creativity driven finally creativity subconscious suddenly appe ars subconscious thing pretty aware dreams subconscious aware dreams fair extent rewo rking experiences day deeply immersed committed topic day day day subconscious work problem wake morning afternoon answer don committed current roblem subconscious goofs things doesn produce big result manage real important problem don center attention thoughts problem subconscious starved work problem sleep peacefully answer morning free alan chynoweth mentioned eat physics table eating mathematicians found knew fair amount math ematics fact wasn learning physics table exciting place exaggerated contributed interesting listen shockley brattain rdeen johnson ken mckay people learning lot nobel prize promotion left dregs wanted left eating side dining hall chemistry table orked fellows dave mccall courting secretary time mind join started eating started important problems field week impor tant problems working time day important don lead important bell labs working wasn welcomed find eat spring fall dave mccall stopped hall hamming remark underneath skin thought summer important pro blems field haven changed research worthwhile dave pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup noticed couple months made head department noticed day member national academy engineering noticed succeede heard names fellows table mentioned science scientific circles unable important problems field work important problem impo rtant work perfectly obvious great scientists thought careful number imp ortant problems field eye wondering attack warn impo 
rtant problem phrased carefully outstanding problems physics sense worked bell labs important guaranteed nobel prize sum money mention didn work time travel teleportation anti gravity important problems attack consequence makes problem important reasonable attack makes problem important scientists don work important problems sense average scienti make spends time working problems believes portant doesn lead important problems spoke earlier planting acorns oaks grow active places happen great science matter luck stand mountain top light ning strikes don hide valley safe average scientist routine safe work time doesn produce simple great work work important problems idea lines urging john tukey finally dopted called great thoughts time lunch friday noon discuss great thoughts great thoughts role computers computers change science observation time ten experiments lab ten computer made remark vice presidents time reversed ten experiments uld computer ten lab knew crazy mathematician sens reality knew wrong proved wrong proved built laboratories didn computers transforming science spent lot time impact computers science change asked change bell labs remarked time address hat one-half people bell labs interacting closely computing machines leave terminals thought hard field opportunities important things chance important things great scientists important problems important problems attack idea hears bears problem drop things horror story told vouch truth sitting airport talking friend mine los alamos lucky fission xperiment occurred europe working atomic bomb berkeley gathered bunch data didn reduci building equipment reduced data found fission hands didn pursue great scientists opportunity opens pursue drop things rid things idea thought thing minds prepared opportunity lots times doesn work don hit great science kind easy chief tricks live long time trait notice noticed fac people work door open door closed notice door office closed work today tomorrow productive ears don problems worth working hard work sort tangential pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup importance works door open kinds interrupti ons occasionally clues world important prove effect sequence closed door symbolic close mind don pretty good correlation work oors open ultimately important things people work doors clos work harder work slightly wrong thing tha miss fame talk topic based song ain start conned digital computer absolute binary days problem analog omputers couldn answer thought carefully hamming file report military job spend lot mon account analog installation report hey find flaws required integration crummy method answer realized truth problem answer demonstrate time question beat analog computer ground digital machine reworked method solution created theory nice ele gant changed computed answer results published report elegant method years hamming method integrating differential equations obsolete good method changing problem slightly important work trivial work machine attic early day solving problem fair number successful failures home friday finishing problem curiously wasn happy pressed life long sequence problem thinking decided mass production variable product conc erned year problems front face changing questi kind results changed things important work attacked ajor problem conquer machines year problems don prepare top bey newton rule stood shoulders giants days stand feet job fashion build top stood shoulders essence science cumulative changing problem slightly great work good wor attacking isolated problems made resolution solve isolat problem characteristic class mathematician effort gener alize means solution simple stopping problem characteristic attack class superior method earlier embedded needless detail business abstraction frequ ently makes things simple filed methods prepared future proble end part remind poor workman blames tools good man job answer uggest altering problem thing differently make great deal differ ence final productivity fashion people ild fashion person essentially duplicat isn matter job write report write paper attitude easy broad general job special case satisfying rewarding topic distasteful suf ficient job sell selling scientist awkward thing ugly shouldn world supposed waiting great rus fact busy work present wel set read back good suggest pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup open journal turn pages read som articles write report published physical rev iew readers turning pages won turn pages stop read don stop read won credit things selling learn rite people read learn give formal talks learn give informal talks lot so-called back room scientists conference quiet weeks decision made filed report late stand middle hot conference middle activity reasons master form comm unication prepared speeches started practically physically ill giving eech nervous realized learn give speeches smoothly esse ntially partially cripple career time ibm asked give speech york eve ning decided give good speech speech wanted technical broad end quietly time give result great deal practice giving speeches limited audience ver afraid study methods effective ineffect ive meetings studying papers remembered technical person give highly limited technical talk time audience broad general talk survey background eaker give result talks ineffective speaker names topic sudden plunges details solved people audience follow paint genera picture important slowly give sketch larger number people joe mary mary gave good talk understand mary tendency give highly restri cted safe talk ineffective talks filled inform ation idea selling obvious summarize work important problems deny luck admit fair element luck subscribe pasteur luck favors prepa red mind favor heavily friday afternoons years great thoughts means committ time understand bigger problems field important found early days believed spent week marching direction kind foolish action march directio change goal change changed marched dir ection thought important easy haven control work begin moderately successful peopl results deliver power choice completely story bears subject educating boss boss named schelkunoff good friend mine military person demanded answer friday dedicated computing resources reducing data fly group scientists knee deep short small important problems military person wanted solve problem end day friday give monday weekend boss schelkunoff schelkun run friday fine sergei sitting office friday afternoon catching late bus 
home watch fellow walks door gave military person answers late friday afte rnoon schelkunoff office sat man schelkunoff fellow arm gave answers monday morning schelkunoff called work weekend hear pause fellow ran mind happen knew sign pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup hadn hadn schelkunoff set deadlines change lesson sufficient educate boss didn big jobs displaced exploratory research justified crash jobs whi absorb research computing facilities wanted facilities compute large number small problems early days limited computing capacity clear area mathematician machines needed machine cap acity time scientist area haven machine apacity complained vice president hamming computing capacity ile happening top people vice president man computing capacity thing loaned programming power early days computing recognition programm ers deserve publish paper programmer aren programmer thanked worked hard waited couple years year bstj articles counted fraction thanked rogrammer boss central role computing playing bell labs bstj important important computing give educate bosses hard job talk viewing bottom viewing top telling spite top management sell ideas ere topic effort great scienti worth answer people modesty people first-class work knowing good wine women song put woman good wine men song put bosses tend back reports participate moments discovery ways evidently limited survey hav dared didn great work felt matter biased ample worth struggle worth struggle first-class work truth struggle result struggle make worthwhile success fame sort dividends opinion told easy people wit talents fail opinion day mathematics department bell labs people endowed didn produce produce shannon produced produced lot highly productive lot fellows equipped hat happened people great promise fail reasons drive commitment people grea work ability committed great skill abble work day home things back work day don deep commitment apparently first-class work turn lots good work talking remember first-class work difference ood people talented people turn good work talking outstanding type work nobel prize recognition thing problem personality defects cite fellow met irvine head computing center temporaril assignment special assistant president obvious great future office time showed method letters care correspondence pointed inefficient secretary kep letters stacked knew word processor letter bragging marvelous work don secretary interference back talked secretary secr etary don mail won give stuff log don puts floor ado present method pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup single-handedly farther single-handedly learn work system system support personality defect wanting total control recognize support system find happening good scientists fight system learn work system advantage system offer lot learn takes patience learn system pretty learn decision boss easy don present accomplished fact don give chance easy personality defect ego assertion speak case experience los alamos early days machine york madison avenue rented time dressing western clothes big slash ockets bolo things vaguely noticed good service people set measure waited turn felt fair deal vice president ibm give hamming bad time secretaries bot tom slot appears rush find slip haven mistreated answer wasn dressing felt omebody situation wasn dressing properly make ecision assert ego dress wanted steadily drain effort rom professional life conform decided make effort ppear conform properly moment service colorful cha racter service people dress expectations audience spoken give address mit computer center dress bolo corduroy jack clothes appearance manners care enormous number scientists feel assert ego thing thing pay steady pric john tukey dressed casually impo rtant office long time fellow realized first-class listen long time john overcome kind hostility wasted effort didn conform appearance conforming long chose assert ego number ways pay small steady price roughout professional career lifetime adds enor mous amount needless trouble taking trouble jokes secretaries littl friendly superb secretarial instance time idiot reason reproducing service murray hill tied don wanted secretary called holmdel hopped company car made hour-long trip reproduc back payoff times made effort cheer joke friendly extra work paid realizing system studying system work learn adapt system desire fight steadily small undeclared war life john tukey paid terrible price needlessly genius simpler conform littl bit ego asserting dress time applies dress thousand things people continue fight system shouldn occasio nally moved library middle murray hill friend mine put request bicycle organization dumb waited awhile back map grounds map paths insurance policy covering weeks store bicycle locked finally realized red-taped death gave rose pres ident bell laboratories pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup barney oliver good man wrote letter time ieee time official shelf space bell labs height ieee proceedings time larger couldn change size official shelf space wrote lette ieee person ieee members bell labs icial space high journal size changed boss signature ack carbon signature doesn original shouldn make gestures reform study people don committed kind warfare play bit drop work second-rate fellow caught twitting system carries warfare expends energy foolish project change system agree person system person first-class science person clear fight system struggle amusement waste effort fighting system advice someb ody first-class scientist ability reform system first-class scientist hand give times certa amount rebellion observed scientists enjoy amount twitting system sheer love basically original originality originality original scienti original characteristics scientist quirks places make pay higher price ego satisfaction ego assertion fault anger scientist angry handle things amusement anger anger misdirected follow cooperate ther struggle system time thing positive side things negative examples situ ation changing looked converted apparently defect asset give egotistical person doubt knew people 
sabbatical write book didn finish time left told friends hen back book ashamed back ego make behave wanted bragged perform found times cornered rat real trap surprisingly capab found paid answer tuesday idea sunday night hard thinking deliver tuesday pride line failed cornered rat surprised good job learn convert situation view increase chance success self-delusion humans common enumerable ays changing thing kidding making didn person thousand alibis history science days people ready pay person fir fellows idea didn alibis weren didn don alibi don kid people alibis don mind honest first-class scientist yourse weaknesses strengths bad faults egotism convert fault asset convert situation haven manpower move direction studied history successful scientist changed viewpoint defect asset summary claim reasons people greatness grasp don succeed don work important problems don bec ome emotionally involved pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman bold endresource end begin encoding-delta times-bold end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup don change difficult situation easily important giving alibis don matter luck told easy told reform orth great scientists end formal part talk discussion questions answers chynoweth minutes concentrated wisdom observations accumu lated fantastic career lost track observations strikin home timely plea computer capacity hearing nothi morning people mark today years making similar remarks dick sorts lessons draw talk walk halls futu hope won closed doors bellcore observation thought intriguin dick wonderful recollection open questions people ome points dick making hamming respond alan chynoweth computing computing research years telling management machine esearch forced run problems time research busy erating running computing machines finally message move computing research someplace persona grata surprised people didn kick shins toy david office give researchers machin give great big machine back trouble busy keepi give smallest machine people learn things small machine mass computing concerned unix arose gave moderately small machine decided make great thi ngs system called unix chynoweth pick present environment dick hile wrestle red tape attributed required regulators quote exasperated avp owled unix deliverable question personal stress make difference hamming don emotionally involved doesn incipient ulcers years bell labs naval postgr aduate school laid back health grea scientist put stress lead nice life nice guy great scientist nice guys end leo durocher lead nice hap life lot recreation lead nice life question remarks courage argue gray hairs established don worry sen young people days real concern risk taking highly competitive envi ronment words wisdom hamming quote david david concerned general loss nerve society periods ing war coming los alamos built bomb coming building radars mathematics department research area group people lot guts things won war fantastic reasons courage great deal arrange situation nnot blame present generation agree attach blame doesn desire greatness lack courage becaus favorable circumstance tremendously successful war war pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup bad long desperate struggle success gave courage confidence beginning late forties fifties tremendous productivity labs stimulated earlie times earlier forced learn things forced learn thing didn learn forced open door exploit things learned true blame present generation fact question management hamming management talk managing resea rch totally talk hour talk individual successful research spite management spite opposition observe people simple hard question brainstorming daily process hamming popular thing paid find desirable talk people session brainstorming sel dom worthwhile strictly talk begin talking back pick capable people analogy idea called critical mass stuff ritical mass idea call sound absorbers sound absorbers give idea critical mass action reminds thought people rid sound absorbers nice people find stimulate back couldn talk john pierce stimulated ery quickly group people talk gilbert office regularly questions listen back stimulated picked eople carefully didn brainstorm sound absorbers curse nice guys fill space contribute absorb ideas ideas die echoing find talk people peopl closed doors fail fail ideas sharpened notice mething knew points visit found books read home talk people questions answer give clues ook question kind tradeoffs make allocating time reading writing research hamming believed early days spend polish presentation original research time presentation big big number question effort library work hamming depends field fellow bell labs smart guy library read gave kinds middle forming theories formed proposition effect named long run reti red bell labs adjunct professor valuable questioning ote good physical review articles effect named read read time people thought thoughts lot creative people proble clear refuse answers thought problem carefully slightly change problem correct nee find problems read find solution reading reading solutions pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup great research give answers read amount read counts question attached things hamming great work hamming window tukey hard time times call princeton murray hill knew writing power spectra asked mind called window hamming window john perfectly small part work lot hamming contributed lot small things entitled credit called hamming window twitted john frequently true greatness true greatness pere watt fourier spelled lower case letter hamming window abo question dick care comment relative effectiveness iving talks writing papers writing books hamming short-haul papers important stimulate omeone tomorrow recognition long-haul writing books contribution orientation day practically infinite knowledge orientation find infinite knowledge time newton close doubling knowledge years cope essential specialization years rate doublings million million fields specialty field isn happen present growth knowledge choke tools books digest coordinate rid duplication rid fruitful methods present underl ying ideas things future 
generations public talks private talks written papers inclined long-haul books leave essential important books don don penguins usual reply essence question mentioned problem nobel prize subsequent notorie careers isn kind broad problem fam hamming things seve years make significant complete shift field shifted numerical analysis hardware software periodically tend ideas field start baby longer big mukity muk start back start planting acorns giant oaks shanno ruined fact left bell labs end shannon scientific career received lot flak friends shannon smart smart end scientific career change tired origina lity field nearby shift music theoretica physics english literature field shift areas don stale couldn forcing change years require conditio research change field research years reasonable defin ition means end years management compel change wou insist change fellows technique ing marching direction world chan ges direction fellows marching direction field viewpoints takes effort energy takes courage give great reputation error correcting codes launche theories hamming quit reading papers field ing ignore completely coast deliber ately refused field wouldn read papers force chance managed pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin pdf begin pdfvars initall exec userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta times-italic end encoding-delta userdict begin beginresource font timesnewroman bold endresource end begin encoding-delta times-bold end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta times-roman end encoding-delta endpagesetup preaching talk knowing aults manage lot faults lot problems lot possibilitie management question compare research management hamming great researcher won make president company president company thing president company don ian ross good job president bell labs clear young picked wanting great scientist live longer change mind nstance boss bode day department head didn good scientist hamming vision mathematics bell laboratories vision realized make happen department head vision single-handedly pursue day vision bigger single-h andedly move management bigger vision farther manageme vision laboratory bell system make happen make happen bottom easily depends goals desires change life prepared change chose avoid management preferred single-handedly choice made biased person entitled choice open mind choose path heaven sake aware choice made don sides question important expectation important group surrounded people expect great work hamming bell labs expected good work big verybody expects good job pride valu first-class people sought people moment physics table lost people left moment true chemistry table left wit people great ability learn expect great results eliberately managing laissez faire question outset talk minimized played luck gloss circumstances los alamos chica bell laboratories hamming luck hand don alternate branc hes branches equally successful luck thing met feynman los alamos knew nobel prize didn knew darn great matter directions future man great work great work isn great work circumstance luck opportunities sooner pail full opportunities situation seize great element luc luck favors prepared mind luck favors prepared person guaranteed don guara ntee success absolutely luck odds definite contr part individual great work end general research colloquium talk biographical sketch richard hamming richard hamming born february chicago illinois formal education marked degrees mathematics chicago jfif nebraska buh illinois early experience obtained los alamos close world war managed computers building atomic bomb directly bell laboratories spent irty years jdkpwz ghog aspects computing numerical analysis management computing july pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage page beginpagesetup userdict pgsave save put pdfvars begin cfv pdf begin pdfvars initall exec userdict begin beginresource font arial endresource end begin encoding-delta helvetica rva end encoding-delta userdict begin beginresource font timesnewroman italic endresource end begin encoding-delta gjp times-italic end encoding-delta userdict idg begin beginresource font timesnewroman bold endresource cdt end begin rpxaa encoding-delta times-bold zby end encoding-delta userdict begin beginresource font timesnewroman endresource end begin encoding-delta shrz times-roman mbs end encoding-delta endpagesetup moved office naval wkr postgraduate school monterey califor nia taught supervised research wrote books bell laboratories time teach universities somet imes locally joe full iqw sabbatical leave activities included visiting professorships gry york princeton wza gpfs sjg shrfpo statistics city college york stanford stevens institute technology mathematics california irvine richard hamming reol received number awards include fellow eee acm turing prize ieee emanuel piore award member national academy engineering harold iya pender award penn major ieee award named mtry richard hamming medal exceptional ols contributions informa tion sciences systems fittingly recipient award rzsj munich received prestigious eduard rhein award achievement technology work error correcti codes founder past president acm vice pres mathematics jpx section qhn pioneering work error-correcting des jbgoqn work integrating differential equations spectral window bears extensive writing included number important pioneering highly regarded books numerical methods scientists engineers mcgraw-hill edition ozpi reprinted dover translated russian calculus computer revolution houghton-mifflin introduction applied numerical analysis mcgraw-hill iia sjwn computers society mcgraw-hill gwjv digital filters fos prentice-hall edition edition translat european languages qjr sbg coding information theory prentice-hall edition methods mathematics applied calculus probability statistics prentice-hall art probability scientists engineers addison-wesley qcd art science engineering learning learn vzg gordon breach continued active life adjunct professor teaching writi dpq mathematics computer science departments naval postgraduate school monterey california twentytj pfg years retired professor emeritus zqce teaching fall passed unexpectedly january zpi acknowledgement acknowledge professional efforts donna paradise word processing center initial transcription talk tape recording ade job editing easier errors sentence parsing punctuation mine mine finally express sincere appreciation richard hamming alan chynoweth bringing transcription present readable state kaiser oqme nzs jpl pdfvars termall exec end end userdict pgsave restore showpage pagetrailer endpage trailer eof 
zshg qhf inz ynw lro xoje rpy irp hyl jbw rfq wah hrpg smw sgz dri nig wpi rmhg ozn yfx cci jvr lsf wdt sjs jpf oqn pgz tmh gls xrq ozf jfx oaj std zzri ail zqh ahy hps tzq xpg bpa alc ozp jja ixa ojc snp zzr osg abo gvq qjt gozq ptc gnsq sna asn hpw ukt sga pozt zbfo mpr rzc lql hfp gvr ifw aiq zlc dzzp ojq bgafr bpx zrn rpz hps rgn ozpp jypa pzps ppz zqjy axcwpng oai rdc nip pai jac jbps ojz gzc jic nig pnv haa gzo ozp rff qhr jni bxt ymb gri qja qke ocm nnr jzm prs shf ols rny kpw zsv oai qfk roq hnx j-z cqm rfh phv snu rcs qhhe ias zpp rgl jrp lqm wrg mps mox kxn ajc gbou ueq zdx jee cgh gcjr jwshzs osx -of sai krx zee smg zzt sjh ija eac vvm fiei bwpon qmq ynn eix fve inh shr zzw nii zbanr rgq riz fkt rpz ngq ditme jcr wqua jns prh rsmcq chy phn utg gky kzn rcip dkqq eoe jdnz gzp bbyh cyx pri bmu kby oafi rtnn oolr roa kcs mpu -co tdtm rny vxx izh bnj ucu ngj hpp nkm jra ykest u-ki v-l askm cij ekx iagc akl xep ena xeo sfph shp hap jfh gqi zsxd ojp qke ncq cjo jnx bkw nbo sho yvx rcq jqi jkk wqzn vao pgq ptk jcsgz mub uvi iob cmo ohj zjp cbo -th ngcyw tmi iby lbf vtd gvx hcs fzd ihj t-lai ioqms trjv drz ygr kkd nqzl lpj nrx jfev ocnl nsn psm nql zgphl uzs jfx xus ctu xec wjk vmb kgw gxu clw qka iqe prg npq zbng hgn zvx fps hqe qhyq pnx zvng dbb mkt inlf cxwm ngz uhy hfw ojph gzl nrm jbt jcp iar bzu nosn ddu jnp oji ipa anps zkc eusmg jviuj rnr ins elcav ejg wnh onpy poo rwu pph flp lzqt oniauq qni dzsx hnc trp cjpw qpx qm- gjvw quxsy ieh ynf mjd oozdvz uep ykk zkk efx rxn esh dumvcm ojh woam mcjk qom vat fmp pri cpf jvw eba agy mqp rad uwa sizw lnkh ddb pfy pzu mezf svi mnr moalt gan akk fni srf jnw ozst tpy gff izm kiu gdq ltz iof beap xvy wzu rmvpw ldq aff nqhy ozw jqr ros shb qmg rlf jqa -mb pgz lsns mnw kzm bqv gjs qkh mcq sjo uui ryl vwy tnv ddq qos zks hpi htk nwq mbvpx gnz uny qpi khaf mko triz cpf idf kct aodzyc ihe lvn iwk zaos bhdi rfz rps gin nwci yvs ozdv ipc lzg xxkw kcmw m-a ypv edx asyi adkf lll psk pzg cosd wax l-o ipa ksy yiq jph chy zrg eie xxy mzm syz j-p urb xyy dur fvh jnn ajt wib bus gqt wbb onc ppy jntd ppo hbw amr ozv jhb jfy pfsk wap znh rnq lrd jql wgo rsme riu oza nqmr fen onx xdv phm gjp abk ikdc apx xpq hav roc soq jvf fwg -sm gew vpr tqe dub szu czu nfi xivzn oav fdx tdg ozo rav lwv zkd shps uou xpi zpwd iqu fyb thu evl oky j-mp zvt kul ztzf -vs zln dee ege adu fsk zsh ojp pbg -yq vku xkg abn sap lruu tma glr uia eszq dfw jpp zrn uwi boc ddr uxb brj -kz pkl jpv rngww mfy wrkp nfrg fuwc kgya kug wyad jns t-m tpw mmvs kcs ddq tya apn enn lxy ori pfq brqt kym spx zxski sqg npz pyol sxmm dky ppip ffh egi xdc foq wpa kww dni pny rmg ycs sgq slkyc hfc hpi ojb gzc qka gjf sjn ruk ent ifw rfs zrfg fzs rfpop zku sjx qhf ihj sra sftrp ppq dpo pnn geiy pikr cap irns rfy yex bwo rqy zpa gamv ffi pep zle cun oyi iwj nud glubri zzr rxc zpc pno gzr nro wen nwp hcm wim rzz bun ptdm zbv jvw kmuqe msc jmse gnhl xzr qow ojp zpa xps amjg nas pht nnqn ozxo ikc jip hlpi qhg kgv jfy osu oci snx rsm nrn qia rin ywo tvdr ppy kdq gbiuf hmn bmr kvz tqe obs sxzh ayn znw mpx zbc saq hrk ukx ovui kiy dhe ircs yei ppop gls sfro auw glf abj zta sof zquo wfd r-sk uux mjt idp ura rzc lzr ozy eiv gzz gba iqm ubn snp lpg ozf iml amp erh chr flnp dio rhw lax pxx wmu qvl wfs qks jcc fws ewo pvh vrk mmp-vkss cmc dvz sym m-n owps wkj goqrq xte qmk hfy xid lzt khx rzg vlb xkj yjm pzi pgojl bnnz oje lrv pgju qjy trh koh jpas ifz prnx zrg poq pyc kenyx mas kiu csp lcq nsi xabfw hfr mon xiz uqa rmq tki tws bys nngx lsg ojv zvp psh vmwn qan kkq aweyr skf fxwm rgp fks pec ufr kkmfu ooz hbyk isjcv trh cwg ulh exuv qyd kib zgo xwxt lry wji oxp ocu dgh rpn inx kwo msy rkzjkv uga vww amnc pgcqo jan sjp obq mcs aqi mqww ijy m-nn dxa qiq sma lsj xor pmo moo kzt icn pcur fyro tpic mrk wdg rzu jpo rpx tqe ulmlbq lge moo egx wnn uwn jwv qhx bpg sjt bae ipy aqb hzg njt wemq krb cmkp zps fsj ccv zrka qv-m ewn xeyc jns vfi foa hppg fxd ptu phby kim amf abq fxo frar nix pry kimt wmor lus qeb yle gpr std lvw ygg mei liu mok oret khl sal qnv lrx ivrx hvw tcqtc jpha qjo lzi dhs kzt mso hcb igeo -oq qhh ucp gpa pu-nudq pgl 
ame qvy moi mgkg oso qapo yor png mmb mtd wodb fgr oqk onoj computer systems research past future zpx butler lampson people inventing ideas computer systems nea rly decades driven moore law spectacula rly successful virtual memory packet des networks objects relational databases graphical user interfaces examples promising ideas rked capabilities formal methods distributed computing persist ent objects fate doubt parallel computing risc ftware reuse guk important invention decade world wide web zakx made computer systems researchers light experienc talk topics yuq exciting work years computer systems research butler lampson microsoft computer revolution begun outline context history motivation challenges context moore law performance decade room temperature single electron memory cell size square moore law predicts moore law qualitative processors chip years reconfigurable logic tiny processors ram chip chip network bandwidth sec long distance xrfk latency change computer science engineering science describe explain engineering build engineer dime fool gpi lpt dollar today engineering things time virtual memory o-c address spaces packet nets objects subtypes rdb sql transactions bitmaps guis web algorithms history worked rdl capabilities fancy type nnkgo systems functional programming formal methods software ycb engineering rpc web mld distributed computing mcl persistent objects security history worked parallelism risc garbage collection interfaces specifications reuse works unix filters big things browser flaky ole failure systems research didn invent web simple idea wasteful dupp fast flaky doesn work denial doesn scale clo qqp computers simulation communication people nzh storage communication time control physical real time mobile applications simulation models real world clothing cities communication people information fingertips telepresence home control robots mems motherhood challenges correctness scaling parallelism reuse trustworthiness ease challenges programming concurrency processors chip matching dvws biological concurrency cycles declarative sql spreadsheets successes kzzi intelligence data models class hierarchy knowledge rep uncertainty real world input speech vision hal adapting environment challenges systems systems work meeting specs adapting changing environment evolving run made unreliable components growing practical limit credible simulations analysis mgn writing good specs testing performance understanding doesn matter challenges information personal memex remember person hears sees telepresence simulate memex collect world libraries retrieve person challenges physical world hearing speaking people real lwj lighting occlusion gvh noise recognizing speech objects real time organizing systems unreliable changing components scale molecules cells insects cities common sense requires good models reality conclusions engineers understand moore law aim mass markets computers k-v learn build systems rjm work 
mit ggl nol bmi snc fhe cqh kds zko sreio osq cgh cjb ucg pts jnt ylg hxb jny qmyi axo xoq gks hri uciq jxt ude srg ozp ika vfpg ybq qihi qih jvq jum oqn v-n cyb frt ctb qhi ydw zrg xbu wdi pkwv ngl wpe pwp svn noo jmn xeigw pze rie abu lrx ssa sot kkq qyzf yoq uxt kky kym onfn ery wyfp iwh cco goh pno eee gzhb jpbh ybf stk emgyg bmn den wth jvq osh sobf zsa ojs qie tlps gns ydl oum czgq ecyt sojo funv ocuj nu-m dlg wrq rnzg rwu cgs mke kbm iwqm wsd rld mus djr mkk jwp zrp kaf gsge ign tni ipzc vpq wwr mcy msc nzqz rgp ivm fmb gad kmg wbr woo -in fdei usr weru eghh ren qii ozc olq rgd vev hrh zdt sal vda wke yvs kds zri lsv rji omt vhe pgd mmc ylff zdkk urq i-v wmz umz qyv yzi swb bmr xkl yowht jzi btr clfr kmdb umn hyk kmn gzb booz goz zkj iwwwv sjg hgq lrdt jaj jrrh hlyyq shhe zjn wrzj kgh rea rex ikt kia eeum pay fiv mwm mlg bte mwe png bro irkr rib ybs yle oby sim xkb onojol cimn oji ziv knb tkmcl qep oco zql lsn lwh gue fuv zqm nfh gmgkf niz cjc jps ojv cdw nsjr hvy jomb ehhh era qgk zpn jnfh rrc ydp xra ivz zgx j-k nhx ynb bgr alm itm ftlr qgh nmt zzk ojf mol scn xatqr iso ytk pfz tvw riwp aew upt sqc chpe arv pry qka ywh vlc ikf mtjzm onc msk gwz ztzx oqv nqo a-od sho djg tns dpq jps ihg jxl rgbh wok rol v-wl gjq oma jpan imw jvz cqy cyr max gnx gql wiln kyrrd ocv qhi iri tpd wnm yol coaa pkc ddy uvit fsxz itk sjg ztj sfw ply jol ify gyoqs hnb vyeb mkt wem tzu pmi wap jzd nzr qim ens aee zvn tmgq jsqc hqe akxl zqhb sfx gxv qhwm icx rbd dvz xrq zbl sri gzv orz huc nojs 
obey thirst oct heard catchy slogan sprite image thirst obey thirst summer coca-cola manufactures sprite products change image sparkling soda sales campaign sprite growing long tooth worse wasn catching growing generation crowd hip fresh appeal younger generation stated coke spokesman bob bertini sprite contacted lowe partners sms york based advertising agency ability appeal younger masses lowe handles entire reebok campaign week surprisingly short turn-around campaign proportion series radio advertisements based obey thirst motto proposed accepted enthusiasm marketing team coca-cola advertising smash success sales increased roughly introduction younger age groups rating advertisements ninety-three percent consumers ages effective consumers knew ads campaign brain child advertising executive donald rifkin long-time employee lowe partners inspiration slogan political speech run free time love artifacts political history chanced speech speaker made thirst absolutely stuck head felt jotted month sprite calling match easy president ronald reagan governor california addressing gathering boy scouts america scorching southern california day neared conclusion reagan paused briefly sip water noticeably refreshed returning microphone told audience spoken number topics today remember thing thing speeches thirst remember obey thirst 
jfif xcreator version rev png patch quality smoothing dvgs pzv qjwfi zsu yuj xos auve tdw juc pojq gjg gahn xug rmx nxi cxc utq ezf mjk nzd ocv sartk vyp fnm efx fvo dhv dou oqy pma yivzm boc jty smru jks qji zlw nbuk -jd zjzj ojl afy ilf ijh cvd lqk ult rwd icgh rykd goj vcua lhpv rfk mwv gbi xbc glw gqv sku- idt ehq xqe lqkhgc cgz phqa bkn mujy hgi ostt fbwq rfeca pww xlf lljhc xif kvc jrx uyn hdd osy zsv hcj kth mikd llf ksp nnooj vnxh zsomd vlck imz hlx drcr sgs znu smm ozt yvim xcr wavb nvh joc qsa qkhh rzt dfer lra epnr hybz obj dlt lzr wff flu hiz stv wwr flz rgo sorwd qlq jgps cvr fmn wqf prp dav fgcj shc apn eng tzz jlk -edv ptah tqi euts 
infp page extraverted intuitive feeling perceiving joe butt jabutt sacam oren ortn enfps friendly folks enjoyable people soft-hearted people enfps enfps call silly switch intellectual business chance flip switch captain wildchild scourge swimming pool ticklers par excellence intoxicated switch flipped study shown enfps significantly overrepresented psychodrama natural propensity role-playing acting enfps funny stories friends penchant attracted journalism kid enfp friends sixth fleet enfps tend global learners close satisfactory enfp driven distraction dealing daughter things piano practice quarter notes difference surprisingly good math painful learning process sees patterns overlook details friends life enfps moreso nfs hold end relationship advantage caring individuals enfps energized people real difficulty regular basis enfp colleague social worker tremendous interpersonal skills put interviewers ease job interview ability make strangers feel friends enfps blindsided secondary feeling function hasty decisions based deeply felt values boil unpredictable results enfp abruptly quit job moment famous enfps rogers theodor seuss geisel mickey rooney geraldo rivera james dobson focus family andy rooney elizabeth montgomery actress bewitched dave thomas owner wendy hamburger chain lewis grizzard author king jordan president gallaudet robin williams actor comedian dead poet society candice cameron full house dave coulier joey fictional balkie perfect strangers ariel mermaid cathy comic strip character extraverted intuitive feeling perceiving marina margaret heiss mmh poe acc virginia partially archetype dealings enfps general enfps idea -people people -people part bizarre cosmic definition admired people individual humanitarian level interested ideas principle ultimately discard reason social personal relationships enfps great deal zany charm ingratiate stodgy types spite unconventionality outgoing fun genuinely people sos mates warm affectionate lots pda disconcertingly spontaneous attention span relationships short enfps easily intrigued distracted friends acquaintances forgetting older long stretches time mature enfps feel center attention time reassure thinks wonderful fascinating person enfps strong unconvential convictions issues related cosmic view social skills contacts persuade people gently rightness views results neglecting nearest dearest flitting save world work environment enfps pleasant easygoing fun work great ideas major asset brainstorming sessions followthrough problem tend bored quickly newer interesting project tend procrastinators meeting hard deadlines performing small uninteresting tasks assigned enfps working group slack enfps hate bureaucracy principle practice make point launching crusades aspect 
remzi poems likes bunch william blake tiger cummings 
geiger monitoring buffer cache virtual machine environment stephen jones andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison stjones dusseau remzi wisc abstract virtualization increasingly address server management administration issues flexible resource allocation service isolation workload migration virtualized environment virtual machine monitor vmm primary resource manager attractive target implementing system features scheduling caching monitoring lack runtime information vmm guest operating systems called semantic gap significant obstacle efficiently implementing kinds services paper explore techniques vmm passively infer information guest operating system unified buffer cache virtual memory system created prototype implementation techniques inside xen vmm called geiger show accurately infer pages inserted evicted system buffer cache explore nuances involved passively implementing eviction detection previously addressed importance tracking disk block liveness effect file system journaling importance accounting unified caches found modern operating systems case studies show information provided geiger enables vmm implement vmm-level services implement working set size estimator vmm make informed memory allocation decisions show vmm drastically improve hit rate remote storage caches eviction-based cache placement modifying application operating system storage interface case studies hint future inference techniques enable broad class vmm-level functionality categories subject descriptors organization design general terms design measurement performance keywords virtual machine inference permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee asplos october san jose california usa copyright acm reprinted asplos proceedings international conference architectural support programming languages operating systems october san jose california usa introduction virtualizationtechnology increasingly common component serverand desktop pcsystems asboth software hardware support forlow-overhead virtualization develops virtualization included popular commercial systems expect virtualized computing environments ubiquitous virtualization prevalent virtual machine monitor vmm naturally supplants operating system primary resource manager machine vmm attractive target implementing traditionally considered operating system features flexible resource management service device driver isolation load balancing security monitoring fault tolerance transition functionality vmm hasmany potentialbenefits forexample aguestoperating system isolated vmm stable virtual hardware interface services implemented vmm portable guest operating systems vmm place innovative features inserted system guest operating system legacy closedsource finally virtualized environment vmm theonly component thathas totalcontrol oversystem resources make informed resource management decisions pushing functionality layer software stack vmm disadvantages significant problem lack higher-level knowledge vmm referred semantic gap previous work virtualized environments partially recognized dilemma researchers developed techniques infer information guests utilize virtual hardware resources techniques vmm manage resources system effectively reallocating idle page thatcould useit paper describes techniques vmm infer information performance-critical software component operating system buffer cache virtual memory system specifically show vmm carefully observe guest operating system interactions virtual hardware mmu storage devices detect pages inserted evicted operating system buffer cache geiger isa prototype implementation techniques xen virtual machine monitor paper discuss detailsofgeiger simplementationand geiger eviction detection techniques geiger inferencing techniques vmm similar chen withina pseudo-device driver evaluation focuses geiger techniques needed circumstances show unified buffer caches virtualmemory systems found modern operating systems require vmm track disk traffic memory allocations show vmm basic storage system behavior account accurately detect cache eviction vmm track data block live dead disk order avoid reporting spurious evictions show journaling file systems ext linux require vmm distinguish writes journal writes parts storage avoid aliasing problem leads false eviction reporting summary passively detecting cache eventswithinmodern operating systemsrequiresnew sophistication techniques passive inferencing result inaccurate information worse information case studies demonstrate inferred eviction information provided geiger enable services inside vmm case study implement vmmbased working set size estimator complements existing techniques allowing estimation case virtual machine thrashing study explores geiger-inferred evictions vmm enable remote storage caches implement eviction-based cache placement changing application operating system storage interface enhancing adoption feature rest paper organized begin presenting extended motivation eviction information address related work section section describe techniques geiger detail section discusses implementation geiger section evaluate accuracy overhead prototype geiger implementation sections discuss case studies finally section summarize conclude motivation related work vmm understand hosted virtual machines memory section describe contextswhereavmmcan exploitinformation aboutbuffercache promotion eviction events working set size virtualized environment knowing working set size virtual machine allocating amount memory hosted environments popular common vms running simultaneously physical host situation knowing theworking setsize ofeach vmallows thevmm toallocate dynamically re-allocate amount memory competing migrating vms grid computing environment working set size information enables job scheduler intelligently select host adequate amount memory techniques estimating working set size virtual machine explored waldspurger part vmware esx server product esx server technique determine working set size virtual machines full allocation guest begins thrash sampling technique esx server simply reports working set memory allocation fact larger determine true working set size esx technique trial error vmm repeatedly giveathrashing virtualmachine incrementallymorememory re-measure working set size drops system physical memory accommodate full working set trial error method fail contrast vmm detect eviction events virtual machine vmm directly model hit rate virtual machine function amount memory result vmm quickly efficiently determine physical memory give competing virtual machine migrate virtual machine secondary-level caching avirtualized environment knowing contents buffer cache implementing effective secondary-level cache multiple vms run machine thevmmcanmanage ashared secondary cache initsownmemory thevmssharepages additionally hosted legacy system address large amount memory secondary cache enable legacy exceed natural addressing limits finally vmm explicitly communicate remote storage server cache informing itofwhich pages cached withineach designing secondary cache management policy non-trivial secondary storage caches exhibit locality client caches stream filtered client cache fact secondary storage caches size client caches led innovations cache replacement policies cache placement policies promising placement policy called eviction-based placement inserts blocks secondary cache evicted client cache approach make caches overlap leads effective secondary cache utilization eviction-based placement similar micro-architectural victim caches processor cache hierarchy modify eviction-based cache placement straight-forward wong extend block-based storage interface demote operation explicitly notifies interested parties remote storage caches pages evicted client caches goal modify vmm passive techniques infer page evicted page cache vmm explicitly notify storage cache passive eviction detection explored extent exclusive caching storage systems x-ray file system semantic information storage blocks inodes snoop updates file accessed time field knowing files recently accessed x-ray build approximate model client cache x-ray limited 
inferences storage system access block stream exclusive caching work assumed access information chen perform inferencing pseudo-device driver access addresses memory pages read written infer eviction occurred memory page storing disk data reused disk data geiger approach similar chen additional information toa vmm improve itsability infer cache events geiger builds previous work important ways geiger handles guest operating systems implement unified buffer cache virtual memory system unified buffer cache events disk evict pages geiger techniques handle anonymous memory allocation cache evictions geiger recognizes blocks disk freed block free disk reuse memory buffer recently held contents imply eviction distinction important counterproductive cache blocks file system believes free geiger supports journaling file systems file system writes block distinct locations disk occurs journaling file system geiger avoids reporting false evictions additional techniques geiger handle range situations occur modern operating systems geiger techniques section discuss techniques geiger begin providing relevant background virtual machine monitors andcontinue describing thebasictechniques geigerusestoinfer page cache promotion eviction describe geiger performs complex inferences handles unified buffer caches virtual memory systems present inallmodernoperating systems due storage system interactions background virtualization studied technique recently revitalized ubiquitous environment virtualized environment thin layer software virtual machine monitor vmm virtualizes components host computer system allowing guest operating systems safely share resources transparently key feature virtualized environment guest operating systems execute unprivileged mode processor vmm runs full privilege guest accesses sensitive system components mmu peripherals exception control transferred vmm point vmm decide action emulate behavior privileged hardware operation software paper advantage vmm entry points observe interesting activity geiger observes architecturally visible events page faults page table updates disk reads disk writes infer occurrence buffer cache eviction promotion major benefit observing entry points performance adding small piece observation code points induces overhead basic techniques buffer cache promotion occurs disk page added cache buffer cache eviction occurs cache page freed operating system previous contents remain reloaded disk eviction occurs contents anonymous page written swap partition page freed similarly eviction occurs page read file system freed writing back disk data reloaded original location disk eviction occur frees page contents lost anonymous page process exits detect promotion eviction geiger performs tasks geiger tracks contents page diskand ifso wecalltheondisk location memory page page disk location adl geiger detect page freed describe steps turn disk locations geiger associates disk location physical memory page disk location adl issimply pair device block offset representing recent disk location vmm associate page vmm associates disk location memory page page involved disk read write operation page target read disk location page similarly page source write disk location page associations persist replaced association memory page freed relevant disk blocks freed vmm virtualizes disk disk reads writes initiatedby guest areexplicitly visibleto thevmm special action part vmm required establish adl page tocorrectlyinvalidate anadlwhen thedisk block refers longer requires detecting disk block freed discuss section detecting page reuse geiger mustalso determine memory page freed guest explicitly notify vmm frees page difference active free page entry private data structure free list bitmap assume vmm detailed os-specific information required locate interpret data structures detecting page freed geiger detects page reused reuse implies page freed proxy page free event geiger numerous heuristics detect page reused heuristic corresponds scenario guest allocates page memory geiger detects page allocation newly allocated page current adl geiger signals previous contents page defined adl evicted basic techniques geiger monitoring disk reads disk writes builds previous work chen monitors reads writes device driver disk read geiger disk reads infer page allocated page read disk page allocated buffer cache allocated page current adl refers disk location read geiger reports page previous contents evicted adl affected page updated point disk location consequence kind eviction disk write geiger disk writes infer page allocated full page data written disk page reside page cache allocate page buffer data asynchronously written disk geiger detects case observing disk writes signaling eviction write source page current adl target disk location write note thatifa previous read writecaused diskblock toalready exist cache geiger erroneously signal duplicate eviction page adl change read-eviction heuristic adl affected page updated refer target disk location techniques unified caches techniques previous research work old-style file system buffer caches distinct virtual memory system virtually modern operating systems including linux bsd solaris windows unified buffer cache virtual memory system unification complicates inferences geiger detect page reuse additional cases virtual memory system introduce detection techniques microbenchmark description read evict sequentially reads section file larger memory multiple times write evict sequentially writes file larger memory repeated multiple times cow evict allocates memory buffer approximately size physical memory writes virtual page ensure physical page allocated forks writes page child allocation evict allocates memory buffer exceeds size memory writes virtual page ensure page allocated figure microbenchmark workloads table describes microbenchmarks isolate specific type page eviction application description read write cow alloc dbench file system benchmark simulating load network file server mogrify scales converts large bitmap image osdl-dbt tpc-w-like web commerce benchmark simulating web purchase transactions online store spc web search storage performance council block device traces web search engine server traces replayed real file system figure application workloads table describes application workloads reports percentage total eviction events caused eviction type copy write copy-on-write cow technique widely operating systems implement efficient read sharing memory page shared cow marked read-only process virtual address space shares processes attempts write cow-shared page action page fault operating system transparently allocates private page copies data page page subsequently writable virtual memory mapping established refers page private copy requires allocation free page lead page reuse geiger detects page reuse occurs result cow observing page faults page table updates geiger detects page fault write read-only page saves affected virtual address page table entry small queue short time guest creates writable mapping virtual address physical page geiger infers physical page newly allocated newly allocated page active adl geiger signals eviction modified private copy existing page disk location allocation modern operating systems allocate memory lazily application requests memory brk anonymous mmap immediately allocate physical memory virtual address range reserved physical memory allocated on-demand page accessed property means physical memory allocation occurs context servicing page 
fault similar cow heuristic geiger observes page faults due guest accessing virtual page virtualto-physical mapping saves affected virtual address small queue short time guest creates writable mapping faulting virtual address geiger infers page allocation newly allocated physical page current adl geiger signals eviction techniques storage storage systems introduce nuances inferences made geiger file system features journaling lead aliasing problem fact disk blocks deleted leads problem liveness detection describe issues geiger handles turn journaling basic write heuristic signals eviction contents page adl written location disk match adl page adl written disk location eviction reported contents disk location basic write heuristic over-reports evictions cases data written buffer cache page multiple disk locations view aliasing problem page wrongly disk addresses journaling file systems linux ext reiserfs jfs andxfs diskfrom cache page journal location fixed disk location inthe worst-case journaling scenario dataand metadata written journal actual number write evictions reported common case metadata-only journaling smaller penalty incurred negative effect journaling virtual memory mitigated vmm identifies reads writes file system journal straightforward systems journal separate easily identifiable partition file file system partition made file system superblock avoid problem journal aliasing geiger monitors disk addresses write requests ignores writes directed journal block liveness geiger signals page evicted page current adl blocks adl refers deallocated disk time adl mapping established geiger detects page reused case geiger falsely report eviction adl exists data adl refers deallocated longer accessible problem block liveness lead large numbers false evictions workloads files regularly deleted truncated processes die significant parts virtual memory swapped disk eviction count time allocation eviction actual inferred eviction count time cow eviction actual inferred eviction count time read eviction actual inferred eviction count time write eviction actual inferred figure eviction inference counts figure compares inferred actual eviction counts time microbenchmarks isolate eviction type inferred geiger fraction evictions lag time allocation lag fraction evictions lag time cow lag fraction evictions lag time read lag fraction evictions lag time write lag figure eviction lag figure shows cumulative lag distribution microbenchmarks isolate eviction type file systems virtual machine monitor passively track file systemblock liveness inthesameway asmartdisksystem cantrack block liveness allocation state file system block typically noted on-disk structure bitmap file system superblock stored fixed location disk locate bitmap structures examining guest operating system writes on-disk areas vmm snoop file system determine disk blocks adl refers freed blocks adl refers deallocated adl invalidated future reuse affected page misinterpreted eviction implementing block liveness observing disk writes significant drawback substantial lag file system structure allocation bitmap updated memory written disk operating systems interval seconds geiger observe file system blocks page adl points deallocated page reused false eviction occur timeliness block deallocation notification important avmmcan deallocation notification tracking updates in-memory versions allocation bitmaps locations bitmaps vmm observe bitmaps loaded disk memory time vmm mark buffers read-only guest updates in-memory bitmap minor page fault occur vmm observe fault due attempted bitmap update respond invalidating affected adls geigerimplements thisstyleof in-memory block livenesstracking bitmap blocks identified reading parsing file system superblock forknown filesystem types pagesused tocache file system allocation bitmaps marked read-only memory geiger write page detected due page protection fault effect faulting instruction emulated guest memory register state faulting instruction skipped observed handled vmm overhead block liveness tracking low spite additional minor page faults due low frequency disk bitmap updates sivathanu embedding file system layout information format superblock vmm reasonable technique commonly file systems on-disk data structure formats file systems change slowly vmm provided layout information commonly file systems information expected remain valid long time on-disk format ext changed introduction longer interval typical system software upgrade cycle swapspace liveness tracking techniques geiger file system partitions apply disk space swap area rule swap space on-disk data structures track block allocation data swap expected persist system restarts swap allocation information managed exclusively volatile system memory swap liveness tracking techniques found effective workloads preventing false evictions due adls point deallocated swap space technique invalidates adl points set disk blocks overwritten disk blocks overwritten data adl refers destroyed adl invalidation isappropriate thistechnique isimplemented maintaining reverse mapping cached disk blocks adls technique makes implicitly obtained process lifetime information provided antfarm accurate information guest processes mapping memory pages owning process adls invalidated process exits specifically adl page belonging dead process points swap space disk block invalidated technique appears promising buthas fully implemented inthe current version ofgeiger implementation geiger implemented extension xen virtual machine monitor version xen open source virtual machine monitor intel architecture xen paravirtualized processor interface enables lower overhead virtualization expense porting system software explicitly make feature xen mechanisms describe equally applicable conventional virtual machine monitor vmware geiger consists set patches xen hypervisor xen block device backends concentrated handlers events page faults page table updates block device reads writes geiger patches consist approximately workload false neg false pos read evict write evict cow evict alloc evict figure microbenchmark heuristic accuracy table reports false positive false negative ratios complete set eviction heuristics microbenchmark workloads workload journal opt journal opt neg pos neg pos journal metadata data figure effect journaling table reports false positive false negative ratios write-eviction microbenchmark workload run journaling metadata journaling ordered mode data journaling linux ext file system table shows benefits turning geiger specialization detect writes journal lines code files files xen hypervisor linux kernel required small order implement instrumentation tracing allexperiments paper performed witha ghzpentiumivprocessor gbofsystem memory ata disk drives linux kernel version xen control domain linux kernel version unprivileged domains ext ext file system depending theexperiment thexencontrol domain configured memory noted unprivileged guest virtualmachine isassigned mbof memory evaluation section evaluate ability geiger accurately infer page cache evictions promotions occurring guest operating systems begin describing workloads metrics evaluate geiger set microbenchmarks application workloads conclude measuring overheads geiger imposes system workloads experimental evaluation geiger sets workloads workload set consists microbenchmarks microbenchmarks constructed generate specific type page cache eviction read write copy-on-write cow orallocate thesemicrobenchmarks isolate geiger ability track evictions due specific events microbenchmarks detail figure set workloads consists application benchmarks represent realistic workloads workload mix eviction types read write cow allocation figure lists application workloads breakdown eviction types generated application workloads 
stress geiger ability track evictions occur reasons metrics methodology evaluating accuracy geiger compare trace evictions signaled geiger trace evictions produced guest operating system modified linux kernel generate trace guest operating system complete information pages evicted comparison ideal eviction detector workload geiger opts false neg false pos dbench block liveness dbench block liveness mogrify block liveness mogrify block liveness tpc-w spc web figure application heuristic accuracy table reports false positive false negative ratios geiger application workloads dbench mogrify workloads evaluate geiger optimizations detect block live disk alloc-evict thrash dbench thrash alloc-evict thrash dbench thrash runtime geiger runtime overhead unmodified xen geiger figure geiger runtime overhead figure shows geiger imposes small runtime overheads workloads stress inference heuristics eviction records traces physical memory address disk address evicted data time stamp weconsider thefirstmetric simply eviction count reported geiger compared reported guest time metric detection lag time eviction takes place detected geiger finally metric detection accuracy tracks percentage records inferred actual traces match one-toone mapping report percentage false negatives actual evictions detected geiger false positives toos-reportedevictions microbenchmarks begin running workloads consisting microbenchmarks figure shows resulting eviction count time-lines microbenchmarks eviction counts inferred geiger closely match actual counts depending workload interesting differences occur cow workload guest reclaims pages groups leading slight stair-step eviction pattern geiger inferences lag slightly case write workload guest begins evicting pages early continues evict eagerly experiment pages reused time geiger inferences based page reuse eviction detected page reused inferred evictions lag noticeably actual evictions caused writes figure shows thecumulative microbenchmarks expected lag times read cow allocation eviction concentrated small values lag times write microbenchmark concentrated seconds due operating system eager reclamation behavior figure reports geiger detection accuracy false negatives false positives workloads false negatives uncommon worst fewer total number evictions missed geiger false positives common worst geiger over-reports inferred evictions final microbenchmark experiment explore geiger ability detect aliased writes file system journal write workload stress detection figure shows accuracy geiger specialization disregard write traffic file system journal specialization geiger performs satisfactorily journaling disabled metadata journaled linux ext ordered-mode metadata journaling blocks aliases data journaling blocks aliases result half evictions reported un-specialized geiger false positives contrast full version geiger accurately handles journaling modes linux ext data journaling geiger false positive percentage application benchmarks workloads realistic applications figure reports detection accuracy geiger application workloads workloads false negative ratios small worst case geiger misses evictions reported dbench mogrify workloads interesting behavior false positives block liveness dbench mogrify workloads illustrate benefit geiger attempt track liveness block disk dbench creates deletes files result pages memory reused files disk blocks mogrify large amounts swap allocated deallocated execution vmm change association memory page disk block infer eviction vmm concludes evictions occurred false positives live block detection geiger false positive rate dbench false positive rate mogrify geiger tracks disk block free detect page simply reused previous contents evicted result false positive rate improves dramatically dbench mogrify adequately handle deleteintensive truncate-intensive workloads geiger includes techniques track disk block liveness limitations mentioned previously expect current techniques tracking block liveness swap space adequate situations demonstrate remaining problem microbenchmark crafted results large numbers false positives efforts geiger track block liveness program forces large buffer allocated mmap swapped disk buffer released linux buffer released swap space deallocated geiger detect event additional memory allocated program pages reused adls point deallocated swap space resulting eviction false positive ratio overhead geiger observes events intrinsically visible vmm page faults page table updates disk case disk block liveness tracking additional memory protection figure memrxoperation figure shows schematic cache simulation implemented memrx page evicted guest event detected geiger entry added head series queues queue entries ripple tail queue head reload queue entry removed array entry queue incremented entry tracks sub-queue appears enable fast depth estimation traps requests caused geiger liveness tracking imposes additional minor page fault disk bitmap update occur rarely expect runtime overhead imposed geiger small validate expectation compare runtime workloads running unmodified version xen geiger interested performance regimes regime common case workload sufficient memory evictions occur regime occurs machine thrashing implies evictions taking place geiger inference mechanisms stressed evaluate cases carefully chosen workloads geiger interposes code paths handling page faults page table updates disk microbenchmark allocation-evict figure dbench figure allocation-evict page faults page-table updates stressing portion geiger inference machinery dbench large number file creations reads writes deletes exercise portions geiger heuristics figure shows results experiment shown average runs standard deviation shown error bars largest observed overhead occurs thrashing dbench cases results geiger unmodified xen comparable geiger requires extra space physical memory page track adls prototype amounts bytes memory page testsystem configured physical memory total additional memory allocated vmm leading space overhead approximately space overhead concern substantially reduced preallocated fixed size sparsely-populated data structures prototype hardware trends major microprocessor vendors intel amd ibm begun include optional hardware virtualization features server desktop products reduce overhead imposed virtualization features hide information vmm favor reducing guest-to-vmm transitions cases page faults guest page table updates vmm invoked geiger page fault page table update information detect cache eviction events absence impact geiger functionality future benchmark activity sequential sequentially scan section file system file times sequential sequentially scan section allocated virtual memory times random randomly read page-sized blocks file system file times random randomly touch virtual memory pages virtual memory allocation times figure calibrated microbenchmarks table describes microbenchmarks evaluate vmm-memrx techniques required provide geiger-like functionality latest vmm-aware architectures summary order handle modern operating systems unified system caches journaling file systems geiger number sophisticated inferencing techniques microbenchmarks geiger highly accurate measured eviction counts oneto-one eviction accuracy write-intensive workloads geiger experience significant lag detects eviction occurred application workloads geiger swap-intensive workloads additional techniques required avoid detection false evictions due difficulty tracking liveness swap shown geiger full range techniques needed circumstances cow allocation techniques needed handle mogrify tpc-w workloads unified buffer cache live block detection improves accuracy delete-intensive workloads finally writes journal isolated handle file system data journaling case study working set size estimation eviction detection techniques geiger implementing number pieces functionality case study show geiger implement memrx vmm tracks working sets guest vms begin describing implementation memrx present 
performance results memrx implementation previous research waldspurger esx server shown vmm determine system working set size memory footprint fits physical memory memrx complements esx server technique enabling vmm determine working set size thrashing virtual machine memrx accomplishes thisusing geiger toobserve evictions subsequent reloads guest operating system buffer cache memrx quantifies number memory accesses transformed misses hits memory sizes memrx simulates page cache behavior virtual machine memory increment method similar patterson ghost buffering figure shows schematic page cache simulation implemented memrx page evicted page location disk inserted head queue maintained lru order memrx subsequent evictions push previous deeper inthe queue previously evicted page read disk page removed queue distance head queue computed distance approximately equal number evictions place page eviction subsequent reload memrx compute amount memory required prevent original eviction taking place sizepage information compute miss-ratio curve working set size read miss-ratio curve locating curve primary knee evaluation evaluate accuracy memrx measure working set size microbenchmark workloads working set size approximately table lists microbenchmarks actions perform working set size approximately virtual machine configured memory compare working set size predicted memrx working set size determined trialand errorfor realisticapplication workloads mogrify dbench figure shows predicted actual miss ratio curves microbenchmark workloads miss ratio curve shows fraction capacity cache misses occurring smallest memory configuration remain misses larger memory configurations predicted curve calculated memrx measurements single run smallest memory configuration simulating page cache behavior guest operating system on-line larger memory configurations increments actual curve calculated running workload noted memory sizes counting actual capacity misses page cache calibrated tests show memrx locate working set size simple workloads accurately prediction made memrx identical found direct measurement trial error result surprising simple workloads geiger incurs eviction false positives figure shows results application workloads mogrify dbench leftmost graphs show predicted actual missratiocurves cases inferred working set size predicted memrx slightly larger actual working set size found trial error determine discrepancy due geiger false positive negative evictions lag memrx cache simulation error implemented memrx linux compared predicted actual miss ratio curves produced version operating system memrx access precise eviction promotion information eliminates geiger source error rightmost graphs figure show miss ratio curves obtained mogrify dbench workloads operating system implementation memrx dbench workload version memrx shows deviation produced memrx vmm leads conclude deviation memrx simulation error memrx models guest buffer cache strict lru policy match policy linux akin difference modeled policy true policy leads simulation errors shown case mogrify os-based miss ratio curve matches actual curve closely leading error observed vmmpredicted working set size due small inference errors imposed geiger granularity experiment summary information provided geiger enabling vmm estimate working set sizes thrashing vms predictions made memrx accurate highly allocating memory competing vms single machine selecting target host virtual machine migration miss ratio memory size sequential predicted actual miss ratio memory size sequential predicted actual miss ratio memory size random predicted actual miss ratio memory size random predicted actual figure vmm-memrxpredicted actual miss ratio figure shows miss ratio predicted vmm-memrx actual miss ratio measured varying memory sizes working set marked vertical dashed line miss ratio memory size dbench vmm predicted actual miss ratio memory size mogrify vmm predicted actual miss ratio memory size dbench predicted actual miss ratio memory size mogrify predicted actual figure application predicted actual miss ratio figure shows miss ratio curve predicted memrx actual miss ratio measured varying memory sizes application workloads results memrx implemented vmm left memrx implemented shown cache hit ratio cache size mogrify eviction-os eviction-geiger eviction-buffer demand cache hit ratio cache size dbench cache hit ratio cache size tpc-w cache hit ratio cache size spc web search figure secondary cache hit ratio figure compares cache hit ratio secondary storage cache workloads demand placement demand eviction placement based inferred evictions eviction-buffer eviction-geiger eviction placement based actual evictions eviction-os experiments performed cache sizes case study eviction-based cache placement case study show geiger convey eviction information secondary cache basic idea vmm geiger infer pages evicted buffer cache sends information demoteoperation tothe storage server ispotentially remote storage server explicitinformation perform eviction-based cache placement implementation implementation eviction-based secondary cache components vmm interposes virtual block device interface provided byxen tosee block request streamgenerated workload vmm geiger infer blocks evicted page cache events communicated remote storage server simulate behavior storage server actual trace gathered running geiger workload input refer approach eviction-geiger evaluate implementation compare alternatives approach eviction-os operating system modified report actual evictions represents ideal case approach eviction-buffer vmm performs eviction detections client buffer addresses chen read write evictions finally simulate storage cache information client evictions performs traditional demand-based placement cases lru-based replacement policy evaluation application workloads listed figure evaluate vmm-implementation eviction-based cache placement workload remote caches evaluate placement policies eviction-os evictiongeiger eviction-buffer demand metric cache hit ratio figure shows graphs cache hit ratio cache size workloads cache policies cases geiger eviction-based placement outperform demand-based placement significantly largest gains occur moderate cache sizes working set application fits client cache storage cache individually fit aggregate cache geiger evictionbased placement improve cache hit rate percentage points workloads mogrify workload secondary cache size cache hit ratio demand placement eviction-based placement secondary cache size large full system working set geiger eviction-based placement perform similarly demandbased placement case spc web search traces exhibit locality results included completeness workload dbench eviction-based placement support outperforms inferred evictions geiger secondary cache size observe difference hit rates percentage points performance difference due significant time lag actual inferred write-eviction events approximately seconds events experiment inferred evictions delayed secondary cache loses opportunity place block prior block referenced client cache miss occurs eviction-based approaches perform significantly demand-based placement buffer fact eviction-buffer performs significantly worse straight-forward demand-based placement problem occurs eviction-buffer detect fewer evictions occur large false negatives workloads mogrify tpc-w significant number non-i based evictions occur missing evictions lead poorer cache performance missing evictions problem large secondary caches blocks effectively adequate cache space case tpc-w missing eviction events change cache hit rate percentage points mogrify difference points summary geiger effectively notify secondary cache evictions performed clients confirmed studies secondary caches eviction-based placement perform demand-based placement results show eviction information provided geiger good provided directly 
modified exception occurs significant lag occurs time actual eviction inference case geiger enables hit rates simple demand-based placement eviction-based placement essential miss evictions clients eviction detection based reads writes miss important evictions leading hitrates thatare worse simple demand-based placement full set techniques geiger buffer cache inferences conclusion backend servers desktop pcs virtualization commonplace virtual machine monitor sole resource manager system pieces interesting functionality migrate operating system vmm key enabling vmm-level functionality information knowledge os-level constructs typically needed implement features paper explored techniques required make inferences pages added removed buffercache wehave found thatcertain key featuresof modern operating systems including unified buffer caches andvirtualmemorysystems journalingfilesystems diskblock liveness techniques efficient implement prototype case studies working set size estimator eviction-based cache placement second-level caches inferring information boundary vmm itsguestoperating systemsisapowerful technique thatenables systems innovation implemented portably vmm accurate timely general techniques made successfully applied commercial domain acknowledgments anonymous reviewers thoughtful comments suggestions research sponsored sandia national laboratories doctoral studies program nsf ccritr- cnsand generous donations network appliance emc arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october bairavasundaram sivathanu arpaci-dusseau arpaci-dusseau x-ray non-invasive exclusive caching mechanism raids proceedings annual international symposium computer architecture isca munich germany june ballmer keynote address microsoft management summit april jfs overview ibm developerworks library jfs html bressoud schneider hypervisor-based fault tolerance sosp proceedings fifteenth acm symposium operating systems principles pages acm press bugnion devine rosenblum disco running commodity operating systems scalable multiprocessors proceedings acm symposium operating systems principles sosp pages saint-malo france october chen noble virtual real hotos proceedings eighth workshop hot topics operating systems page ieee computer society chen ahang zhou scott schiefer empirical evaluation multi-level buffer cache collaboration storage systems proceedings acm sigmetrics conference measurement modeling computer systems sigmetrics banff canada june chen zhou eviction-based placement storage caches proceedings usenix annual technical conference usenix pages san antonio texas june clark fraser hand hansen jul limpach pratt warfield live migration virtual machines proceedings symposium networked systems design implementation nsdi boston massachusetts denning working set model program behavior communications acm denning working sets past present ieee transactions software engineering sejanuary dragovic fraser hand harris pratt warfield barham neugebauer xen art virtualization proceedings acm symposium operating systems principles sosp bolton landing lake george york october figueriredo dinda fortes case grid computing virtual machines proceedings international conference distributed computing systems icdcs fraser hand neugebauer pratt warfield williamson safe hardware access xen virtual machine monitor oasis asplos workshop garfinkel pfaff chow rosenblum boneh terra virtual machine-based platform trusted computing proceedings acm symposium operating systems principles sosp bolton landing lake george york october goldberg survey virtual machine research ieee computer gum system extended architecture facilities virtual machines ibm journal research development november imagemagick studio llc imagemagick image processing software http imagemagick intel corporation intel virtualization technology specification ftp download intel technology computing vptech pdf johnson shasha low-overhead high performance buffer management replacement algorithm proceedings international conference large databases vldb pages santiago chile september jones arpaci-dusseau arpaci-dusseau antfarm tracking processes virtual machine environment proceedings usenix annual technical conference usenix boston massachusetts june jouppi improving direct-mapped cache performance addition small fully-associative cache prefetch buffers proceedings annual international symposium computer architecture isca pages seattle washington king chen backtracking intrusions proceedings acm symposium operating systems principles sosp banff canada october muntz honeyman multi-level caching distributed file systems cache ain nuthin trash proceedings usenix winter conference pages january open source development labs osdl database test suite http osdl lab activities kernel testing osdl database test suite patterson gibson ginting stodolsky zelenka informed prefetching caching proceedings acm symposium operating systems principles sosp pages copper mountain resort colorado december reiser reiserfs namesys sapuntzakis chandra pfaff chow lam rosenblum optimizing migration virtual computers proceedings symposium operating systems design implementation osdi pages boston massachusetts december sivathanu bairavasundaram arpaci-dusseau arpaci-dusseau lifeordeath atblock level proceedings symposium operating systems design implementation osdi pages san francisco california december sivathanu prabhakaran arpaci-dusseau arpaci-dusseau improving storage system availability graid proceedings usenix symposium file storage technologies fast san francisco march storage performance council spc web search engine storage traces http traces umass storage sugerman venkitachalam lim virtualizing devices vmware workstation hosted virtual machine monitor proceedings usenix annual technical conference usenix boston massachusetts june sweeney doucette anderson nishimoto peck scalability xfs file system proceedings usenix annual technical conference usenix san diego california january tridgell dbench filesystem benchmark http samba ftp tridge dbench tweedie future directions ext filesystem proceedings usenix annual technical conference freenix track monterey california june tweedie ext journaling filesystem olstrans sourceforge net release ols -ext ols -ext html july waldspurger memory resource management vmware esx server proceedings symposium operating systems design implementation osdi boston massachusetts december whitaker shaw gribble scale performance denali isolation kernel proceedings symposium operating systems design implementation osdi boston massachusetts december wong wilkes cache making storage exclusive proceedings usenix annual technical conference usenix monterey california june zhao zhang figueriredo distributed file system support virtual machines grid computing proceedings high performance distributed computing hpdc july zhou philbin multi-queue replacement algorithm level buffer caches proceedings usenix annual technical conference usenix pages boston massachusetts june 
studies internet studies conducted internet-based polls results highly skewed pollees consist people visit homepage asked people guess age surprisingly elicited humor actual data case results presented majority people guessed guessed ages guessed people considered quot friends quot study interesting time premise quantify good random-number generator humans pollee asked produce random number inclusive told people responded two-year period guesses thrown leaving valid responses results presented major hypothesis test people produce quot random quot number data shows case number surprisingly popular coming study 
remzi music wrote music remzi wrote hard find good sounding piano midi music don blame bad sound classical style fatigue rain jazzy sweet jazz 
gridiron gridiron tcl football game wrote football video game tcl check written pure tcl requires decent machine run animation smooth luck read screen dump focus graphics game play download version 
test page aabbccdd test font 
remzi arpaci-dusseau peaceful home page function mouseover link src link src src function mouseout link src link src src remzi arpaci-dusseau associate professor quotes ways live life miracle miracle albert einstein master art living makes distinction work play labor leisure mind body education recreation love religion simply pursues vision excellence leaving decide working playing zen philosophy family layered world iron file systems adsl geiger asplos semantic disks sigmetrics antfarm usenix corrupting dsn logic file systems fast database-aware storage fast journal-guided resync fast iron sosp model-based failure dsn deconstructing storage isca sba usenix life death osdi shear asplos x-ray isca d-graid fast complete list undergraduate graduate distributed systems advanced storage fast dsnstoragess usenix vldb wcw hpdc fast google-based ranking departments research hamming computer systems research lampson intelligence jeff hawkins lsaquo free culture rsaquo lessig things homes falls george saunders reading list alan kay bush intelligence state journal obey thirst 
semantically-smart disk systems past present future andrea arpaci-dusseau remzi arpaci-dusseau lakshmi bairavasundaram timothy denehy florentina popovici vijayan prabhakaran muthian sivathanu computer sciences department google wisconsin madison mountain view california abstract paper describe research on-going group past years semantically-smart disk systems semantically-smart system typical blockbased storage systems extracting higher-level information stream traffic disk enables interesting pieces functionality implemented lowlevel storage systems describe development efforts past years highlighting key technologies needed build semantically-smart systems main weaknesses approach discuss future directions design implementation smarter storage systems introduction past years group working ways increase functionality performance reliability security storage systems approach consistent build storage systems tomorrow living constraints real world notion design constraint major research thrusts group real world deal things world storage main constraints encounters presented interface storage typically disk raid presents linear array blocks clients block read written scsi good interface advantages primarily simple portable file systems direct clients storage access disk drives virtually complexity head positioning error handling details drive access hidden client high-level abstraction downsides lampson famously don hide power array-based interface storage preventing large number interesting pieces functionality implemented research suggests rotationally-aware disk schedulers greatly improve performance low-level information required perform scheduling hidden disk interface examples exist flavor desired functionality requires information higher-level system file system lowerlevel system disk natural solution problem simply change interface storage change fraught peril requiring broad industry consensus massive upheaval existing infrastructure embarked alternate required build storage systems tomorrow limitations today interfaces researchers including high road end building file systems awareness disk system underneath chose low road enhancing low-level storage systems knowledge file system motivating reason choosing storage system target innovation practical multi-billion dollar storage industry largely builds ships block-level storage systems paper describe work semantically-smart disk systems compared typical dumb storage device semantically-smart system knowledge file system data structures operations knowledge build interesting storage systems work focused improving performance reliability security storage systems applying techniques typical devices present development work past years discussing key pieces technology reflecting step led paths discuss technology filter industrial world utility semantically-smart techniques time surprising aspect work sound theoretical underpinnings theory practice required build correctly functioning semantically-smart disks rest paper organized section provide background describing work gray-box techniques present generation semantically-smart disk prototypes sections discuss importance theoretical framework section present future directions section conclude section background work semantically-smart disk systems finds roots earlier research gray-box techniques basic idea gray-box approach simple building component system great deal knowledge components system designed implemented taking advantage knowledge component building exploiting fact components black boxes inner-workings exploited knowledge components perfect white boxes dealing imperfect knowledge critical challenge leveraging gray-box techniques application scan set files application underlying operating system files cache application flexibility choose order access access cached files improves latency files cache accessed quickly bandwidth files accessed displace files cache operating system fetch disk problem arises operating system reveal information challenge advantage gray-box knowledge operating systems caches cache replacement policies well-known determine contents cache approaches earlier work demonstrated utility probing cache accessing blocks file timing long takes access application determine file present cache high probability subsequent work route learning behavior cache-replacement algorithm recencyor frequency-based history make replacement decisions application simulate replacement algorithm build accurate model contents cache initial line work targeting applicationos boundary began interface file systems block-level storage systems beneath clear simple interface storage benefits limited interesting optimizations enhancements functionality require information file system storage system information difficult layer storage stack information layer solution information gap change interface storage people advocating change years change problematic reasons broad industry consensus required instantiate change enormous disks raids add capabilities clients systems migrate benefits obvious chicken-and-egg problem changing successful interface requires anticipate usage scenarios good design team relevant situations account finally change expensive huge investments required enable make pervasive problem presented limited interface file systems storage explicit interface change unattractive variety reasons found wondering didn change interface built smarter storage systems learned inferred information file systems essence obtain benefits interface requiring change storage interface first-generation systems mindset began work effort semantically-smart storage systems published fast work major thrusts tool eof automatically infer data structures client file system set run-time techniques disk requires determine relevant pieces file system information collection case studies demonstrate utility semantic-awareness storage additional case study published isca discuss pieces turn describing challenges learned offline techniques extracting static information eof challenge simple disk raid system gain knowledge file system data structures approach simply embed static file system information disk raid system built-in knowledge file system data structures locations disk approach work initially felt approach limiting wondered automate process eof extraction file systems tool basic operation simple userlevel process host issues series disk requests disk in-disk agent monitors resultant traffic carefully controlling exact file operations issued file system eof infer great deal knowledge on-disk structures technique eof isolation combined patterns blocks written disk test data block inode identify fill data block pattern monitoring contents written blocks storage system detect data blocks disk workload inode data block written disk successfully isolate inode block block filled pattern manner eof acquire remarkable amount detailed information on-disk structures file system on-line techniques classification association operation inferencing eof realized important component semantically-smart disk system on-line inference specifically static knowledge disk system monitor current traffic make inferences state file system disk system block live dead make inference simply knowing static location bitmaps examine contents bitmap complicated section developed set basic on-line techniques semantically-smart disk systems garner type knowledge basic called direct classification technique disk system examines block address read write request determine type block read write directed inode region disk simply checking address sufficient determine block inodes slightly sophisticated form classification indirect classification technique examines contents blocks determine type block determine block holds directory contents typical unix file system examine inode points block call process monitoring inode contents inode snooping indirect blocks similarly identified technique call block association technique connect related blocks simple efficient manner data block read written inode block belongs table maps associations delivers information final technique term operation inferencing method semantically-smart disk infer higher-level operations invoked file system infer file creations deletions unix file system operations 
detected monitoring file system state observing change inode bitmap infer creation deletion file bit set creation bit deletion case studies basic infrastructure techniques place constructed set prototype semantically-smart disks demonstrate utility prototypes built software pseudo-device drivers mounted beneath real file systems cases mentioned utilized simulation explore idea case study discuss in-disk implementation track-aligned extents basic idea allocate files fit track avoiding costly track-switches file access performance improved disk-level implementation semantic knowledge file system structures influence file system placement track-aligned specifically marking blocks track boundaries allocated disk coerce file system allocating files proper manner resulting performance improvement noticeable case study focuses caching system x-ray infer contents cache monitoring stream traffic disk generates key insight x-ray time file read inode updated access time eventually flushed disk watching inode accesstime updates x-ray build coarse model cache x-ray cache job managing cache aiming exclusivity simulations show performance dramatically improved smarter second-level caching strategy x-ray employs final case study focus implementation journaling beneath non-journaling file system turned difficult case study implement block level semantically-smart disk infer file system transaction taking place group related updates occurring makes challenging file system behavior file systems fundamentally delay reorder filter operations disk disk difficult time decoding happened solution problem point simple mount file system synchronously guaranteeing updates reflected disk complete timely manner result disk implemented journaling benefits non-journaling file system case linux ext lessons learned year working project yielded interesting results infer on-disk structures automatically techniques developed eof developed numerous online techniques determine true state file system infer operations invoking finally case studies observed great potential semantically-smart disk systems enabling interesting storage functionality change file system initial work demonstrated numerous difficulties approach originally thought on-line techniques challenging develop understood asynchronous nature modern file systems greatly complicate on-line inference wished perform understood embedding static information data structures disk reasonable on-disk data structures tend evolve slowly file systems world work improve eof automatic data structure inference tools assuming semantically-smart ship built-in knowledge important file system structures surprised learn difficulties working underneath linux ext file system chose ext thought simplest operate underneath proved challenging primary reason hardship laissez faire manner ext writes blocks disk unlike unix-based file systems ext imposes ordering kind disk writes making semantic inference challenging discuss broadest conclusion work experience case studies clear case study learned lot technology needed build semantically-smart systems develop technology find interesting pieces storage functionality develop semantically-smart found ruminating possibilities bit functionality lucky found second-generation systems generation semantically-smart prototypes semantically-smart technology heights greatly increasing understanding systems work began limitations approach extremes pushed technology primary contribution work understanding operate file systems asynchronous operations correctness required generation semantically-smart systems comprised in-depth case studies d-graid raid array degrades gracefully faded secure-deleting disk operates asynchronous file systems removing major limitation earlier attempt secure delete discuss turn present lessons learned works d-graid degrading gracefully d-graid exploits semantic intelligence disk array place file system structures disks fault-contained manner unexpected failure disk occurs d-graid continues operate serving files accessed key techniques d-graid provide higher level availability technique replicate naming metadata structures file system high degree standard redundancy techniques data small amount overhead excess disk failures render entire array unavailable entire directory hierarchy traversed fraction files missing proportional number missing disks technique fault-isolated data placement ensure meaningful units data failure d-graid places semantically-related blocks blocks file storage array unit fault-containment disk observing natural failure boundaries found array failures make semantically-related groups blocks unavailable leaving rest file system intact fault-isolated data placement improves availability cost related blocks longer striped drives reducing parallelism found raid techniques remedy d-graid implements access-driven diffusion improve throughput frequently-accessed files copying blocks hot files drives system underneath linux ext determining blocks semantically-related challenging blocks dynamically typed block user-data block indirect-pointer block directory-data block order writes file system disk arbitrary result storage system accurately classify type block block filled indirect pointers identified observing inode due reordering behavior file system time disk writes inode indirect block block freed original inode reallocated file normal data block disk operations place memory reflected disk inference made semantic disk wrong due inherent staleness information d-graid deals uncertainty allowing fault-isolated placement file compromised limited amount time time bounded inode file written d-graid detect correct classification move block d-graid optimizations reduce number misclassifications checking contents indirect blocks valid number valid unique pointers null pointers slots non-null implemented d-graid ext vfat d-graid behaves desired analysis shows d-graid users access files additional disk failures occur raid naming meta-data replication percentage accessible files matches percentage working disks utilize process availability figure merit number processes run unaffected disk failure d-graid degrades expected linear drop-off processes access user files run successfully storage unavailable faded forgotten smarter storage systems understand blocks live dead investigated block liveness inferred semanticallysmart storage specifically explored difficult case infer generational liveness block belongs live file context implemented faded file-aware dataerasing disk implements secure delete ensuring deleted data recovered disk secure delete functionality pushes disk ability perform correct inferences false positive detecting delete leads irrevocable deletion valid data false negative results deleted data recoverable faded detects file deleted faded shreds blocks belonging file overwriting block multiple times specific patterns fact block shredded detected ways faded bit bitmap cleared indicating block freed generation count inode incremented indicating inode freed reallocated block pointed inode indicating block freed reallocated file challenge address reordering reuse file system block pointed inode faded definitively current contents block file faded deal uncertainty conservative converting apparent correctness problem performance problem faded perform shredding operations required mechanism introduce conservative overwrite erases past layers data block leaves current contents block intact conservative overwrites means valid data inadvertently shredded overhead suspicious blocks tracked shredded multiple times prototype implementation found minor needed ext operate correctly top faded ensures file truncates treated deletes ensures inability definitively classify indirect blocks lead missed deletes faded typical unix workload find implicit inferences conservative overwrites impose approximately overhead compared disk perfect information lessons learned implementing challenging case studies learned great deal semantically-smart disk systems fundamental challenges pose system designers important lesson living uncertainty core building systems due asynchronous nature file systems worst case disk system receives incomplete 
information state file system time learned imprecision interesting prototypes constructed careful design d-graid faded worked lack complete information achieved goals cases subtle reasoning required order build robust working prototypes handled corner cases times deep implementation realized problem approach requiring back drawing board rethink realized needed careful needed theory file systems disks interacted systems theory began effort build formal logic file system disk interactions logic began means reasoning semantically-smart disks realized possibilities broader logic file system developers understand complex interactions file systems disks logic begins set basic entities containers pointers generations file system simply collection containers linked pointers container reused freed represents generation logic formulated beliefs actions belief model state file system on-disk in-memory action state file system beliefs true time fundamental understanding impact actions beliefs ordering actions special care constructing temporal relationship actions proofs finally constructed starting basic axioms applying series event sequence substitutions implies observe simply replace subsequence initial results prove correctness existing file system consistencymaintenance techniques soft updates show linux ext file system needlessly conservative performs transaction commit demonstrating logic enable aggressive performance optimizations show logic aid development functionality building analyzing correctness consistent undelete functionality linux found simple logical framework critical development semantic technology reasoning disk interaction required formal approach required build robust correct systems future directions semantic disks project learned great deal file systems disk systems interactions harness experience forward ruminate future semantic disk technology block-level storage primary question semantic techniques applicability real world case studies complex industry fundamentally conservative adopt approach successful industry adoption aimed radical case studies imagine disk array performed smarter prefetching paying attention file boundaries requires semantic knowledge require wrong performance suffer question semantic inference applied clients disk systems database management systems performed initial work lines met mixed success techniques translate readily complex specific data structures typical dbms complicate matters occasionally dbms structures ripe kind reverse engineering advocate transaction log replete information dbms candidate future semantic technology lines noticed sea change modern file systems journaling make semantic inference easier difficult dbms file system journal takes chaotic update sequence simple file system ext turns orderly understandable affair linux ext perfect file system study semantically-smart disks underneath pushed deal extreme asynchrony arbitrary ordering writes future systems interpret log contents simpler easily verified correct major change storage interface object-based disks horizon change semantic inference obviated drives generally information clients typical block-based disks straight oneto-one file-to-object mapping drive easily determine blocks free evolved interface room inference semantic technology directory structure part interface journaling file systems databases place logs disk structures require semantic inference valuable sources information storage systems finally broader place semantic inference technology simply building storage systems current work explores low-level tracing fault injection understand file system performance failure characteristics systems grow increasingly complex tools deconstruct behavior integral part design implementation maintenance systems conclusions presented retrospective work semantically-smart disk systems work began simple question smart make block-level disks changing disk interface evolved development series increasingly challenging case studies beginnings formal theory understanding file system disk interactions modern world avoiding constraints layering system structuring artifacts impossible semantic inference provided means reclaim lost nature designs anderson osd drives snia events past developer dba snia osd pdf arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october bairavasundaram sivathanu arpaci-dusseau arpaci-dusseau x-ray non-invasive exclusive caching mechanism raids proceedings annual international symposium computer architecture isca pages munich germany june burnett bent arpaci-dusseau arpaci-dusseau exploiting gray-box knowledge buffer-cache contents proceedings usenix annual technical conference usenix pages monterey california june denehy arpaci-dusseau arpaci-dusseau bridging information gap storage protocol stacks proceedings usenix annual technical conference usenix pages monterey california june denehy arpaci-dusseau arpaci-dusseau journalguided resynchronization software raid proceedings usenix symposium file storage technologies fast pages san francisco california december denehy bent popovici arpaci-dusseau arpaci-dusseau deconstructing storage arrays proceedings international conference architectural support programming languages operating systems asplos pages boston massachusetts october ganger blurring line oses storage devices technical report cmu-cs- carnegie mellon december ganger patt metadata update performance file systems proceedings symposium operating systems design implementation osdi pages monterey california november ganger worthington hou patt disk subsystem load balancing disk striping conventional data placement proceedings twenty-sixth annual hawaii international conference system sciences volume pages gibson nagle amiri chang gobioff riedel rochberg zelenka filesystems network-attached secure disks technical report cmu-cs- carnegie mellon gray computers stop international conference reliability distributed databases june gunawi agrawal arpaci-dusseau arpaci-dusseau schindler deconstructing commodity storage clusters proceedings annual international symposium computer architecture isca pages madison wisconsin june jacobson wilkes disk scheduling algorithms based rotational position technical report hpl-csp- hewlett packard laboratories lampson hints computer system design proceedings acm symposium operating system principles sosp pages bretton woods hampshire october lumb schindler ganger nagle riedel higher disk head utilization extracting free bandwidth busy disk drives proceedings symposium operating systems design implementation osdi pages san diego california october nugent arpaci-dusseau arpaci-dusseau controlling place file system gray-box techniques proceedings usenix annual technical conference usenix pages san antonio texas june prabhakaran arpaci-dusseau arpaci-dusseau analysis evolution journaling file systems proceedings usenix annual technical conference usenix pages anaheim california april prabhakaran arpaci-dusseau arpaci-dusseau modelbased failure analysis journaling file systems proceedings international conference dependable systems networks dsnpages yokohama japan june prabhakaran bairavasundaram agrawal gunawi arpaci-dusseau arpaci-dusseau iron file systems proceedings acm symposium operating systems principles sosp pages brighton united kingdom october ridge field book scsi starch june schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon november schindler griffin lumb ganger track-aligned extents matching access patterns disk drive characteristics proceedings usenix symposium file storage technologies fast monterey california january schindler schlosser shao ailamaki ganger atropos disk array volume manager orchestrated disks proceedings usenix symposium file storage technologies fast san francisco california april seltzer chen ousterhout disk scheduling revisited proceedings usenix winter technical conference usenix winter pages washington january sivathanu arpaci-dusseau arpaci-dusseau jha logic file systems proceedings usenix symposium file storage technologies fast pages san francisco california december sivathanu bairavasundaram arpaci-dusseau arpaci-dusseau life death block level proceedings symposium operating systems design implementation osdi pages san francisco california december sivathanu bairavasundaram arpaci-dusseau arpaci-dusseau database-aware semantically-smart storage proceedings usenix symposium file storage 
technologies fast pages san francisco california december sivathanu prabhakaran arpaci-dusseau arpacidusseau improving storage system availability d-graid proceedings usenix symposium file storage technologies fast pages san francisco california april sivathanu prabhakaran popovici denehy arpacidusseau arpaci-dusseau semantically-smart disk systems proceedings usenix symposium file storage technologies fast pages san francisco california april talagala arpaci-dusseau patterson microbenchmarkbased extraction local global disk characteristics technical report csd- california berkeley wang anderson patterson virtual log-based file systems programmable disk proceedings symposium operating systems design implementation osdi orleans louisiana february wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february wong wilkes cache making storage exclusive proceedings usenix annual technical conference usenix monterey california june gum chen wang krishnamurthy anderson trading capacity performance disk array proceedings symposium operating systems design implementation osdi san diego california october 
dependability analysis virtual memory systems lakshmi bairavasundaram andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison west dayton madison wilaksh dusseau remzi wisc abstract recent research shown modern hard disks complex failure modes conform failstop operation disks exhibit partial failures block access errors block corruption commodity operating systems required deal failures commodity hard disks failure-prone important operating system component exposed disk failures virtual memory system paper examine failure handling policies virtual memory systems classes partial disk errors type context aware fault injection explore internal code paths experiments find failure handling policies current virtual memory systems simplistic inconsistent absent fault injection technique identifies bugs failure handling code systems study identifies reasons poor failure handling design failure-aware virtual memory system introduction modern commodity operating systems assume disk drives work perfectly fail perfectly modern hard disks perfect operate fail-stop fashion exhibit complex partial failures set blocks inaccessible data stored blocks silently corrupted complex errors study worse errors expected diminish disk technology improves increase disk drive complexity increased low-cost unreliable ata disks incidence errors increase commodity operating systems equipped deal partial disk failures highend systems typically employed mechanisms deal disk faults techniques checksumming disk scrubbing commodity operating systems explicitly failure handling mechanisms policies recent work explored failure handling policies commodity file systems paper explore failure handling capabilities virtual memory systems integral part modern operating system file systems significant user disk storage type context aware fault injection techniques elicit failure handling policies virtual memory systems operating systems linux freebsd perform preliminary study windows virtual memory system characterize policies systems based internal robustness iron taxonomy proposed earlier work find virtual memory systems wellequipped deal partial failures file systems studied earlier virtual memory systems policies illogically inconsistent failure handling routines bugs cases failure handling policy simplistic cases absent disregard partial disk failures leads problems ranging loss physical memory abstraction data corruption system security violations paper organized section background partial disk failures virtual memory systems iron taxonomy section describes fault injection analysis methodology section presents experimental results analyzes failure handling approaches systems section discusses related work section concludes background section discusses partial failures commodity hard disks background virtual memory systems finally presents taxonomy failure handling policies paper characterize failure handling virtual memory systems partial disk failures section presents partial failures disk subsystem discusses suitable failure model disks layers storage stack contribute partial failures exhibited disk subsystem range classic problems media errors due bit rot head crashes errors bus controllers recent problems arising buggy firmware code additionally shown device drivers bugs rest operating system entire range sources disk failures documented recent paper proposes failure model disks called fail-partial failure model adopt model injecting disk errors study study makes aspects fail-partial failure model types errors partial disk failures errors blocks read written error code returned disk block corruption contents disk block read operating system altered error code returned disk transience errors disk failures permanent sticky temporary transient case transient failure errors operation performed failure model incorporate specific frequencies error types data frequency partial disk failures scarce drive manufacturers loathe provide information schwarz estimate partial disk errors occur times absolute disk failures recent experiments gray ingen sata disk drives uncovered uncorrectable read errors point view operating system -month experiment period partial disk failures occur dealt question arises component deal failures instance argue disk mirroring deal errors belief operating system components rely mirrored disks provide dependable computing environment component-specific policies optimizations employed simple mirroring operating system component disks include failure handling policy virtual memory systems virtual memory system disk storage provide applications address space larger physical memory helps system execute multiple processes large address spaces simultaneously disk area virtual memory system called swap space virtual memory system swap space store memory pages expected typically systems tend remove pages accessed recently accessed frequently memory store disk called page-out page stored disk accessed brought back physical memory called page-in page-out pagein process transparent applications performance effects virtual memory system responsible handling disk errors maintaining illusion page physical memory virtual memory systems make file systems situations directly on-disk space swap space maintained file file system virtual memory systems applications memory-map file data mmap system call file portion file memory mapped applications operate file data memory locations user code pages memory-mapped executable file program executed situations involving file system virtual memory system depends file system recover propagate disk errors subsections outline features virtual memory systems linux freebsd failure handling policies studied paper features windows virtual memory system discussed evaluation section linux linux virtual memory system largely derived previous linux versions performs swapping user-mode pages user-mode pages data stack code pages form user process order virtual memory system simple pages belong kernel paged simplification highly restrictive kernel pages occupy small portion main memory page replacement algorithm similar algorithm paged-out pages accessed space created pages read disk system issues reads advance read-ahead based application accesses improve performance swap area separate disk partition file file system swap header information swap area number blocks list faulty blocks level technique comment detection assumes disk works errorcode check return codes lower levels assumes lower level detect errors sanity check data structures consistency require extra space block redundancy redundancy blocks detect corruption end-to-end table levels iron detection taxonomy table describes levels detection iron taxonomy levels developed earlier paper level technique comment recovery assumes disk works propagate propagate error informs user record record operation succeed prevents dependent actions proceeding stop stop activity crash prevent writes limit amount damage guess return guess block contents wrong failure hidden retry retry read write handles failures transient repair repair data structs lose data remap remaps block file locale assumes disk informs system failures redundancy block replication forms enables recovery loss corruption table levels iron recovery taxonomy table describes levels recovery iron taxonomy levels developed earlier level record added paper freebsd freebsd open source operating system derived bsd unix design virtual memory system freebsd originally based mach virtual memory system considerable updates years freebsd virtual memory system allocates pages requested free list pages maintains sufficient free pages paging frequently inactive pages freebsd virtual memory system paging entire processes implies 
addition user-mode pages kernel thread stacks processes paged page tables freed system extreme memory pressure unlike linux freebsd virtual memory system perform extra read-ahead issue separate block read commands read blocks part read command block needed linux freebsd swap area disk partition file freebsd swap area data structures linux swap header failure handling policy taxonomy paper extend iron taxonomy proposed earlier paper taxonomy originally designed describe failure handling policies file systems find applicable virtual memory systems iron taxonomy consists axis detection recovery table table describe levels detection recovery addition levels proposed previously include recovery level record level system records operation succeed level recovery prevents system performing action assumes successful completion operation write error detected system recovers record free dirty memory page assuming successfully written disk avoiding data loss extend iron taxonomy adding axis prevention prevention axis encompasses techniques avoid loss due partial disk failures table describes levels prevention system special prevention techniques case system assumes disk works errors dealt occur remember basic prevention strategy remember specific block bad system bad experience block strategy prevent future data loss reboot phenomenon observed long time systems fail faults cured systems rebooted reinitialized systems rid effects transient bugs accumulated time fact failure prevention strategy periodically rebooting subsystems rebooting strategy virtual memory systems range disabling enabling swap area periodically re-initializing drivers disk controllers loadbalance prevention technique attempts reduce wear data blocks balancing load level technique comment prevention assumes disk works remember remembers disk errors prevents usage blocks errors reboot periodically re-initializes system avoid bugs due excess state loadbalance balances read write load disk blocks attempts reduce effects wear blocks scan performs read write checks bogus data detects possibly sticky block errors table levels iron prevention taxonomy table describes levels prevention technique wearleveling file systems flash drives jffs scan final prevention technique scanning disk bad blocks performing accesses bogus data technique raid systems weed potential bad blocks process called disk scrubbing technique classified eager detection technique earlier feel employed prevention technique virtual memory systems scan swap area periodically disk idle time freeblock scheduling avoid disk blocks found bad scan methodology section describe fault injection analysis methodology fault injection framework consists components benchmark injector benchmark layer sets system exposure disk faults layer consists types user processes coordinator managing benchmarking fault injection victims allocate large memory region sleep read memory region aggressors allocate large memory regions force victims pages swap area file system disk errors injected victims pages paged disk read back victims error injection performed injector layer interposes virtual memory system hard disk specifically injector built pseudo-device driver linux geom layer freebsd upper filter driver windows injector located device drivers drivers significant source errors virtual memory system equipped handle errors policies virtual memory system observed isolation method types errors injected injector read errors write errors corruption errors case read write errors error code returned virtual memory system ensure valid data memory read failed error code technique needed virtual memory system ignore error code returned case valid data respective memory page system work fine corruption errors block contents altered block experiments case corruption detected perform detailed analysis corrupting field data structure field-specific values separate experiments perform type context aware fault injection injecting disk errors specific disk blocks specific times data type user-level private data segment user data error injected disk block holds private user data page type-aware context basic function performed virtual memory system interface offered virtual memory system applications context swapoff system call error injected disk block swapoff progress context-aware table presents data types errors injected virtual memory systems table presents contexts error injection performed types contexts explored dependent system study order perform type-aware error injection injector detect type blocks read written detection accomplished variety ways benchmark layer communicates type information data pages injector benchmark allocates data pages initializes pages specific values conveys values injector cases injector block contents determine block type method employed determine type location block linux swap header located block failure handling policy system identified manual observation results error injection specifically sources information injector injector logs operations detail enabling determine failure handling policies instance virtual memory system performing retries read write repeated disk block number remapping disk write repeated disk block memory page benchmark benchmark records return values signals received helps determining error propagated benchmark checks reports validity data read back helps checking block type description detection virtual memory system swap header describes swap space location linux user data page private user data segment content linux freebsd user stack page user stack segment content linux freebsd shared shared memory page processes content linux freebsd mmapped memory-mapped file data content linux freebsd user code page user code segment location linux freebsd kernel stack page kernel thread stack user process kernel information freebsd table data types table describes types blocks failed detection method applicable virtual memory system type order detect kernel thread stack pages made simple modification freebsd kernel obtain memory addresses pages context workload virtual memory system actions swapon makes swap space swapping read swap header initialize in-core structures swapoff removes swap space page-in valid blocks free swap space pagetouch page accessed victim read page disk readahead workload induces readahead reading nearby pages perform read-ahead reading blocks disk madvise victim issues madvise madv willneed page-in blocks hint future reads specifiedinhint pageout aggressors create memory pressure causing page-out write inactive memory pages disk umount file system unmounted write dirty mmaped file data complete process scheduled complete page-out page-in essential data structures process table contexts table shows workload contexts experiments actions performed virtual memory system context data corruption system messages operating system emit error messages system message log techniques determine failure handling policies adopted virtual memory systems combinations data type context error type techniques primarily determine detection recovery policies discuss experiments determine prevention policies section analysis section present results experiments virtual memory systems analyze failure handling approach systems finally discuss experience fault injection techniques experimental results performed detailed analysis linux freebsd virtual memory systems preliminary analysis windows virtual memory system focus detection recovery techniques linux freebsd discuss prevention techniques systems finally evaluate windows present scenarios combinations data 
type context error type linux freebsd experiments involving swap space performed separate disk partition swap space windows experiments involving memory-mapped files user code pages ext file system linux unix file system ufs freebsd observed failure handling policy experiments involving file system combination policies virtual memory system file system linux tables present results fault injection linux virtual memory system detection find read errors detected errorcode checking return codes exceptions occur swapoff virtual memory system pages valid blocks memory error detected application data belongs junk data future memory access lead application crashes data corruption write errors detected read page write error virtual memory system page-in disk block previous contents missing errors lead application crashes application data corruption bad data system security problems application possibly read data belongs process swapon swapoff pagetouch readahead madvise pageout umount user data user stack shared mmapped user code rea err swap header user data user stack shared mmapped user code ite swap header user data user stack shared mmapped user code uptio swap header symbols errorcode sanity experiment applicable comments sanity checks swap space signature version number bad block count table linux detection techniques table presents linux detection techniques read write corruption errors combinations data type rows context columns comments provided tables corruption errors detected corrupted data returned application exception sanity swap header swapon sanity checks correct swap space signature correct version number number bad blocks maximum allowable recovery cases disk error detected linux basic recovery mechanisms read error application-accessed page sigbus signal inform application error propagate case shared memory page processes touch page read error occurs receive sigbus signal words virtual memory system retry read process accesses page propagate swap header corrupted case error returned swapon call experiments memory-mapped file data user code retry observed retry specific disk block system original operation involved disk blocks retry performed block retry initiated file system virtual memory system read swap header fails swapon aretryisperformed retry due implementation bugs results retry swapon returns success read errors call fails swapon swapoff pagetouch readahead madvise pageout umount user data user stack shared mmapped user code rea err swap header user data user stack shared mmapped user code ite swap header user data user stack shared mmapped user code uptio swap header symbols propagate retry record experiment applicable comments sigbus signal separate retry block needed original request retry operation fails success returned error propagated operation remembered page touched error propagates processes touch page read error occurs table linux recovery techniques table presents linux recovery techniques read write corruption errors combinations data type rows context columns bug implementation comments provided tables internally propagate error record handle read errors readahead madvise byusingr record system records failure read future readaheadand madvise data required immediately read-ahead optimization virtual memory system madvise hint block accessed readahead case error propagated page touched madvise retry performed page touched actions fact read unsuccessful freebsd tables present results fault injection freebsd virtual memory system detection errorcode single case detecting read write errors freebsd virtual memory system checks error code returned freebsd detect block corruption leads application crash data corruption cases leads kernel crash corruption kernel swapon swapoff pagetouch madvise complete pageout umount user data user stack shared mmapped user code rea err kernel stack user data user stack shared mmapped user code ite kernel stack user data user stack shared mmapped user code uptio kernel stack symbols errorcode experiment applicable table freebsd detection techniques table presents freebsd detection techniques read write corruption errors combinations data type rows context columns freebsd read block swapon read pages madvise table thread stack blocks detected case errors system unbootable recovery recovery mechanisms freebsd deal detected errors retry memory-mapped data written file system unmount fact system retries times umount call retries performed file system virtual memory system document behavior behavior observed application memory-mapped file data feature supported virtual memory system read errors page accesses virtual memory system deliver sigsegv segmentation fault application instance propagate experiments showed case shared memory unlike linux processes sharing memory region operate independently error propagated processes accessed page disk access retried process accesses page propagate write retries failed umount error returned application stop read errors swapoff read errors page-in kernel thread stack cases result kernel panic conservative action pageout virtual memory system attempts free memory pages writing swap swapon swapoff pagetouch madvise complete pageout umount user data user stack shared mmapped user code rea err kernel stack user data user stack shared mmapped user code ite kernel stack user data user stack shared mmapped user code uptio kernel stack symbols propagate retry record stop experiment applicable comments kernel crashes stack sigsegv signal kernel panic memory page freed alternate victim chosen page-out upto retries write operation blocks error returned table freebsd recovery techniques table presents freebsd recovery techniques read write corruption errors combinations data type rows context columns comments provided tables freebsd read block swapon read pages madvise table space write errors occur page-out process freebsd virtual memory system recovers record case virtual memory system remembers write operation performed successfully memory page freed virtual memory system successfully free memory page proceeds select alternate victim page-out prevention techniques determining prevention policies difficult determining detection recovery policies prevention policy triggered disk fault methodology uncovering prevention policy specific test prevention technique remember technique triggered faults test remember injecting sticky error repeatedly disk block checking virtual memory system stops disk block workload performs iterations page-out page-in victim pages linux freebsd find bad disk block repeatedly spite returning error time results obtained read write errors linux freebsd track bad blocks remember test loadbalance causing virtual memory system page-out pages numerous times checking blocks swap area fairly evenly workload performs iterations pageout page-in victim pages linux freebsd disk blocks reused repeatedly blocks swap area written systems perform wear-leveling loadbalance finally detect reboot scan simply observe activities occur interval virtual memory system observe instance ofp reboot orp scan experiments infer linux freebsd techniques summary experiments linux freebsd prevention techniques windows section outlines features windows virtual memory system discusses failure handling policies windows file ntfs partition store memory pages paged-out failure handling 
policy extract combination policies ntfs virtual memory system windows paging user kernel memory inject faults user data pages read corruption errors injected pagetouch write errors injected pageout error code status device data error read write errors detection windows error code returned disk detect read write errors errorcode corruption errors detected recovery recovery read errors terminating user application reporting error inpageerror propagate recovery write errors involved primarily record memory pages error occurs written selected paging disk block error read back read succeeds half-block write performed read fails half-block read performed irrespective success failure halfblock operations block future writes record deal errors writes identify purpose half-block operations transient write error disk blocks subsequently successfully written read back application accesses data leading application receiving junk data bug handling write errors investigation required ascertain behavior prevention error injection experiments demonstrated disk block re-used errors block remember block added bad cluster file disk re-formatted failure handling approaches section discuss approaches current virtual memory systems adopt handle disk failures contrasting techniques identifying deficiencies systems compare approach virtual memory systems file systems explored start summarizing approaches virtual memory systems linux linux fails detect disk errors error codes returned simple recovery schemes deal detected errors respect corruption swap header corruption detected freebsd freebsd correctly detects disk errors error codes ignores corruption errors simple recovery schemes deal errors conservative linux cases kernel calls panic stop entire system read fails swapoff read affects single application windows windows detects disk errors error codes ignores corruption errors simple recovery schemes system observed prevention technique remember general systems suffer deficiencies simple recovery techniques virtual memory systems studied simple recovery techniques deal disk errors attempt techniques redundancy completely recover disk errors ignoring data corruption data corruption experiments case linux swap header detected virtual memory systems assume disks store data reliably true commodity hardware under-developed mechanisms aprimeexampleofan under-developed mechanism remembering bad blocks linux swap header provision store list bad blocks list effectively prevent data loss remember list initialized mkswap updated afterward errors occur hand windows actively updates bad cluster file avoid error-prone blocks memory abstraction mismatch applications expect pages behave memory virtual memory system maintain memory abstraction disk errors important part maintaining abstraction error reporting error handled system propagated manner fits memory abstraction linux thesigbussignal propagate page read errors definition hardware failures sigbus generated freebsd sigsegv signal intended programming error propagate read errors retries instances retrying operation error occurs retrying solve problem case transient error systems benefit greatly employing retries illogical inconsistency error recovery techniques employed inconsistent cases freebsd read error user data page result propagate case pagetouch results kernel panic swapoff buggy implementation observed linux failure handling code buggy result retry making useless suspect failure handling code rarely tested bugs security issues system fairly secure normal operation insecure partial failure linux data read back failed write disk block previous contents returned application possibly delivering data application authorized read failures dealt increasing awareness exploiting transient hardware errors attack systems kernel exposure systems special care kernel-mode data stored disk freebsd corruption kernel thread stack detected result undesirable crashes severe data corruption policies virtual memory systems compared file systems observe kinds systems share problems illogical inconsistency implementation bugs failure handling code points general disregard partial disk errors exposing commodity computer systems data loss data corruption inexplicable crashes linux virtual memory system file systems misses large number write errors virtual memory systems file systems deal corruption errors elegant manner file systems perform sanity checking deal corruption file system data structures protection user data data handled virtual memory systems part freebsd windows leverage important difference file systems virtual memory systems writes required succeed file systems virtual memory systems alternatives choosing page victim writing disk experience experimenting multiple systems helps compare systems insight advantages limitations methodology experience techniques simple applied systems tool rewritten environment find task onerous observed limitation easy identify source disk accesses accesses attributed error recovery unrelated problem occurs read error injected user data page freebsd windows observe retry read retry succeeds application terminated indicating bug retry code closer examination revealed read performed create core dump recover error interesting explore techniques identify exact source disk accesses future work related work techniques developed years inject faults systems techniques fault injection studies explore operating system behavior errors studies explore partial disk failures detail bring techniques policies operating system deal failures study similar spirit brown patterson study failure policies software raid systems software raids type context agnostic behavior virtual memory system differs considerably data types contexts requires complex fault injection analysis study related earlier studies file systems handle partial disk failures file systems virtual memory system important operating system components disks significantly applications aware disk store files disks virtual memory system completely transparent applications requiring virtual memory system robust disk failures conclusions commodity hardware increasingly unreliable due escalating complexity cost pressures operating systems longer assume hardware components hard disks work fail virtual memory system important subsystem modern operating system virtual memory systems designed deal partial disk failures fault injection experiments find current virtual memory systems employ consistent failure policies provide complete recovery partial failures improving failure-awareness systems enable virtualize memory providing applications robust memory abstraction acknowledgments meenali rungta helping experimental setup windows nitin agrawal comments paper anonymous reviewers thoughtful suggestions finally computer systems lab csl providing great environment research work sponsored nsf ccritr- cnsnetwork appliance emc freebsd operating system http freebsd journalling flash file system version http sourceware jffs anderson drive manufacturers typically don talk disk failures personal communication dave anderson seagate anderson dykes riedel interface scsi ata proceedings usenix symposium file storage technologies fast san francisco california april bartlett spainhower commercial fault tolerance tale systems ieee transactions dependable secure computing january barton czeck segall siewiorek fault injection experiments fiat ieee transactions computers april bovetandm cesati understanding linux kernel edition reilly december brown patterson maintainability availability growth benchmarks case study software raid systems proceedings usenix annual technical conference usenix pages san diego california june candea kawamoto fujiki friedman fox microreboot technique cheap recovery proceedings symposium operating systems design implementation osdi pages san francisco california december chou yang chelf hallem engler empirical 
study operating system errors proceedings acm symposium operating systems principles sosp pages banff canada october corbett english goel grcanac kleiman leong sankar row-diagonal parity double disk failure correction proceedings usenix symposium file storage technologies fast pages san francisco california april engler chen hallem chou chelf bugs deviant behavior general approach inferring errors systems code proceedings acm symposium operating systems principles sosp pages banff canada october govindavajhala appel memory errors attack virtual machine proceedings ieee symposium security privacy page washington usa gray van ingen empirical measurements disk failure rates error rates microsoft research technical report msrtr- december green eide controller flaws version http mindprod eideflaw html february kalbarczyk iyer yang characterization linux kernel behavior error proceedings international conference dependable systems networks dsnpages san francisco california june ishikawa nakajima oikawa hirotsu proactive operating system recovery poster session acm symposium operating systems principles sosp brighton united kingdom october johnson shasha low-overhead high performance buffer management replacement algorithm proceedings international conference large databases vldb pages santiago chile september kanawati kanawati abraham ferrari flexible software-based fault error injection system ieee transactions computing kari saikkonen lombardi detection defective media disks ieee international workshop defect fault tolerance vlsi systems pages venice italy october lumb schindler ganger nagle riedel higher disk head utilization extracting free bandwidth busy disk drives proceedings symposium operating systems design implementation osdi pages san diego california october lun kao iyer tang fine fault injection monitoring environment tracing unix system behavior faults ieee transactions software engineering pages mckusick neville-neil design implementation freebsd operating system addison-wesley professional august musuvathi park chou engler dill cmc pragmatic approach model checking real code proceedings symposium operating systems design implementation osdi boston massachusetts december prabhakaran arpaci-dusseau arpaci-dusseau model-based failure analysis journaling file systems proceedings international conference dependable systems networks dsnpages yokohama japan june prabhakaran bairavasundaram agrawal gunawi arpaci-dusseau arpaci-dusseau iron file systems proceedings acm symposium operating systems principles sosp pages brighton united kingdom october schwarz xin miller long hospodor disk scrubbing large archival storage systems proceedings annual meeting ieee international symposium modeling analysis simulation computer telecommunication systems mascots volendam netherlands october shah elerath reliability analysis disk drive failure mechanisms proceedings annual reliability maintainability symposium pages alexandria january swift bershad levy improving reliability commodity operating systems proceedings acm symposium operating systems principles sosp bolton landing lake george york october talagala patterson analysis error behaviour large storage system ieee workshop fault tolerance parallel distributed systems san juan puerto rico april data clinic hard disk failure http dataclinic hard-disk-failures htm tsai iyer measuring fault tolerance ftape fault injection tool international conference modeling techniques tools computer performance evaluation pages september tweedie journaling linux ext file system fourth annual linux expo durham north carolina wehman den haan enhanced ide fast-ata faq http thef-nym sci kun cgi-pieterh atazip atafq html 
logic file systems muthian sivathanu andrea arpaci-dusseau remzi arpaci-dusseau somesh jha google computer sciences department wisconsin madison muthian google fdusseau remzi jhag wisc abstract years innovation systems highly successful improving performance functionality cost complicating interaction disk variety techniques exist ensure consistency integrity system data precise set correctness guarantees provided technique unclear making hard compare reason absence formal framework hampered detailed veri cation system correctness present logical framework modeling interaction system storage system show apply logic represent prove correctness properties demonstrate logic main bene enables reasoning existing system mechanisms allowing developers employ aggressive performance optimizations fear compromising correctness logic simpli introduction adoption system functionality facilitating rigorous proof correctness finally logic helps reason smart storage systems track semantic information system key aspect logic enables incremental modeling signi cantly reducing barrier entry terms actual system designers general framework transforms hitherto esoteric error-prone art system design readily understandable formally veri process introduction reliable data storage cornerstone modern computer systems file systems responsible managing persistent data essential ensure function correctly modern systems evolved extremely complex pieces software incorporating sophisticated performance optimizations features disk key bottleneck system performance optimizations aim minimizing disk access cost complicating interaction system storage system early systems adopted simple update policies easy reason modern systems signi cantly complex interaction disk stemming asynchrony updates metadata work wisconsin-madison reasoning interaction system disk paramount ensuring system corrupts loses data complex update policies precise set guarantees system obscured reasoning behavior translates manual intuitive exploration scenarios developers hoc exploration arduous possibly error-prone recent work found major correctness errors widely systems ext reiserfs jfs paper present formal logic modeling interaction system disk formal modeling show reasoning system correctness simple foolproof formal model illustrated existence similar frameworks areas correctness paramount existing models authentication protocols database reliability database recovery examples general theories modeling concurrent systems exist frameworks general model systems effectively domainspeci logic greatly simpli modeling logic systems serves important purposes enables prove properties existing system designs resulting understanding set guarantees enabling aggressive performance optimizations preserve guarantees signi cantly lowers barrier providing mechanisms functionality system enabling rigorous reasoning correctness absence framework designers tend stick time-tested alternatives finally logic helps design functionality class storage systems facilitating precise characterization proof properties key goal logic framework simplicity order general system designers barrier entry terms applying logic low logic achieves enabling incremental modeling complete model system starting logic simply model piece functionality mechanism isolation prove properties case studies demonstrate utility cacy logic reasoning system correctness properties represent prove soundness important guarantees provided existing techniques system consistency soft updates journaling logic prove linux ext system needlessly conservative transaction commits resulting sub-optimal performance case study demonstrates utility logic enabling aggressive performance optimizations illustrate utility logic developing system functionality propose system mechanism called generation pointers enable consistent undelete les prove correctness design incremental modeling mechanism logic demonstrating simplicity process implement mechanism linux ext system verify correctness logic empirically show inconsistency occur undeletes absence mechanism rest paper organized rst present extended motivation background systems present basic entities logic formalism represent common system properties logic logic prove consistency properties existing systems prove correctness unexploited performance optimization ext reason technique consistent undeletes apply logic semantic disks finally present related work conclude extended motivation systematic framework reasoning interaction system disk multifarious benets describe key applications framework reasoning existing systems important usage scenario logic model existing systems key bene modeling enables clear understanding precise guarantees mechanism assumptions guarantees hold understanding enables correct implementation functionality system layers disk system ensuring adversely interact system assumptions write-back caching disks results reordering writes media negate assumptions journaling based logic enables aggressive performance optimizations reasoning complex interactions hard system developers tend conservative perform unnecessarily waits logic helps remove barrier enabling developers aggressive performance optimizations con dent correctness section analyze real opportunity optimization linux ext system show logic framework prove correctness nal bene logic framework potential implementation-level model checkers clear model expected behavior validate existing system enable comprehensive cient model checking current technique relying fsck mechanism expensive cost fsck explored state limits scalability model checking building system functionality recovery consistency traditionally viewed tricky issues reason classic illustration view arises database recovery widely aries algorithm pointed correctness issues earlier proposals ironically success aries stalled innovation database recovery due dif culty proving correctness techniques innovation system deals interaction disk correctness implications inertia changing time-tested alternatives sti incorporation functionality systems systematic framework reason piece functionality greatly reduce barrier entry section propose system functionality logic prove correctness illustrate cacy logic reasoning functionality examine section common system feature journaling show starting simple logical model journaling systematically arrive corner cases handled involve complex interactions developers linux ext designing semantically-smart disks logic framework signi cantly simpli reasoning class storage systems called semantically-smart disk systems provide enhanced functionality inferring system operations inferring information accurately underneath modern systems complex dependent dynamic system properties section show logic simplify reasoning semantic disk turn enable aggressive functionality background system organizes disk blocks logical les directories order map blocks logical entities les system tracks forms metadata section rst describe forms metadata systems track discuss issue system consistency finally describe asynchrony systems major source complexity interaction disk file system metadata file system metadata classi types directories directories map logical perle metadata mapped directory directories enable hierarchy les user opens path system locates perle metadata reading directory path required file metadata file metadata information speci examples information set disk blocks comprise size systems fat metadata embedded directory entries systems metadata stored separately inodes pointed directory entries pointers metadata disk blocks indirected indirect pointer blocks case large les allocation structures file systems manage resources disk set free blocks allocated les track resources systems maintain structures bitmaps free lists point free resource instances addition systems track metadata super block focus types file system consistency proper operation internal metadata system data blocks consistent state metadata consistency state metadata structures obeys set invariants system relies directory entry point valid metadata structure directory points metadata uninitialized marked free system inconsistent systems provide metadata consistency crucial correct operation stronger form consistency data consistency system guarantees data block contents correspond metadata structures point discuss issue section modern systems linux ext 
reiserfs provide data consistency file system asynchrony important characteristic modern systems asynchrony exhibit updates data metadata updates simply buffered memory written disk delay interval reordering writes asynchrony crucial performance complicates consistency management due asynchrony system crash leads state arbitrary subset updates applied disk potentially leading inconsistent on-disk state asynchrony updates principal reason complexity interaction system disk raison etre logic basic entities notations section basic entities constitute system logic present notations section build entities present formalism operation system basic entities basic entities model containers pointers generations system simply collection containers containers linked pointers system differs exact types containers nes relationship container types abstraction based containers pointers general describe system containers system freed reused container considered free pointed container live instance container reuse free called generation generation speci incarnation container generations reused container reused previous generation container freed generation container life generation fully ned container logical generation number tracks times container reused note generation refer contents container abstraction current incarnation contents change affecting generation illustrate notion containers generations simple typical unix-based system system xed set designated inodes inode slot container point inode slot inode generation corresponds speci deleted inode generation deleted forever inode container simply marked free created reuse inode container logically inode generation note single container inode point multiple containers data blocks single container pointed multiple containers hard links unix systems notations notations depict basic entities relationships listed table note notations table ned section containers denoted upper case letters generations denoted lower case letters entity description represents container generation symbol description set entities point container set entities pointed container jaj container tracks container live set entities point generation set entities pointed generation denotes container pointer denotes entity points kth epoch container type kth epoch container generation kth epoch container container generation generation container table notations containers generations pointer denoted symbol container pointer container paper pointers containers live section relax assumption introduce notation pointers involving dead containers attributes containers make logic expressive modern systems extend vocabulary attributes container generation attributes container epoch epoch container ned time contents container change memory epoch incremented system sets elds inode step results epoch inode container system batch multiple contents due buffering set epochs visible disk subset total set epochs container denote epoch superscript notation denotes kth epoch note nition epoch expressivity logic imply system tracks epoch note distinction epoch generation generation change occurs reuse container epoch change contents container reused type containers type type container static change lifetime system dynamic container belong types points time ffsbased systems inode containers statically typed block containers change type data directory indirect pointers denote type container notation shared unshared container pointed container called shared container container pointer leading unshared default assume containers shared denote unshared containers operator unshared note unshared property container type system ensures container belonging type unshared pointer pointing systems designate data block containers unshared memory disk versions containers system manage structures domains volatile memory disk accessing contents container system read on-disk version container memory subsequently system makes modi cations inmemory copy container modi contents periodically written disk system writes modi container disk contents container memory disk formalism present formal model operation system rst formulate logic terms beliefs actions introduce operators logic proof system basic axioms logic beliefs state system modeled beliefs belief represents state memory disk statement enclosed represents belief beliefs memory beliefs disk beliefs denoted fgm fgd bgm belief system memory container points memory bgd means disk belief timing belief begins hold determined context formula logic describe subsection terms timing belief ned relative beliefs actions speci formula isolated belief temporal dimension memory beliefs represent state system tracks memory on-disk beliefs ned belief holds disk time crash system conclude belief purely based scan on-disk state time ondisk beliefs solely dependent on-disk data system manages free reuse containers beliefs terms generations fak bjgm valid note refers generation container on-disk beliefs deal containers generation information lost disk sections propose techniques expose generation information disk show enables improved guarantees actions component logic actions result system state actions alter set beliefs hold time actions ned logic read operation system read contents on-disk container current generation memory system container memory modify read contents memory on-disk fagm fagd write operation results ushing current contents container disk operation contents memory on-disk fagd fagm ordering beliefs actions fundamental aspect interaction system disk ordering actions ordering actions determines order beliefs established order actions resulting beliefs operators means occurred time note ordering beliefs notation indicating event creation belief state existence belief belief agm represents event system assigns pointers special ordering operator called precedes belief left operator operator ned means belief occurs means belief holds occurs implies intermediate action event invalidates belief operator transitive imply belief hold necessarily note simply shortcut note implies beliefs grouped parentheses semantics precedes group beliefs precedes belief belief parentheses precedes belief proof system primitives sequencing beliefs actions rules formulas logic terms implication event sequence sequence traditional operators implication double implication logical combine sequences logical rule notation means time event action occurs event occurs point occurrence rule occurs absolute time occur order occurs rule valid occurred general left hand side rule involves complex expression disjunction components belief rhs holds point occurrence rst event makes lhs true occurrence makes sequence true rule rule denotes time occurs occurred note rule event occurs sides event constitutes temporal point referring time instant lhs rhs temporal interpretation identical events crucial rule serving intended implication rhs refer instant rules logical proofs event sequence substitution rule subsequence occurs sequence events logically implies event apply rule event sequence replacing subsequence matches left half rule half rule postulate proof system enables deriving invariants system building basic axioms basic axioms subsection present axioms govern transition beliefs memory disk container points memory current generation points memory fbx agm agm points memory write lead disk belief points agm write agd converse states disk belief implies belief rst occurred memory agd agm agd similarly points disk read result system inheriting belief agd read agm on-disk contents container pertain epoch generation pointed generation memory write converse holds faygd write faygd akgm write faygd note refers generation rule generation 
points akg ajg hold memory points time container freed instants akgm ajgm akgm ajgm note rule includes scenario intermediate generation occurs container pointed disk subsequently system removes pointer memory write lead disk belief point agd bgm write bgd unshared container write lead disk belief container points free agd write dynamically typed container type instants freed xgm ygm xgm ygm completeness notations notations discussed section cover wide range set behaviors model system means complete set notations model aspect system show section section speci system features require notations main contribution paper lies putting framework formally reason system correctness notations introduced speci system features framework apply modi cation connections temporal logic logic bears similarity linear temporal logic syntax linear temporal logic ltl dened formula ltl formula set atomic propositions ltl formulas ltl formulas nition time future release temporal operators formalism fragment ltl set atomic propositions consists memory disk beliefs actions temporal operators allowed formalism equivalent execution sequence states ltl formula denotes true execution system satis ltl formula executions satisfy precise semantics satisfaction relation meaning found chapter semantics formalism standard semantics ltl proof system set axioms section desired property data consistency property section prove axioms denoted system satis properties set satisfy property file system properties systems provide guarantees update behavior guarantee translates rules logical model system complement basic rules reasoning system section discuss properties container exclusivity system exhibits container exclusivity guarantees on-disk container dirty copy container contents system cache requires system ensure in-memory contents container change container written disk systems bsd ffs linux ext vfat exhibit container exclusivity journaling systems ext exhibit property equations refer containers memory refer latest epoch container memory case systems obey container exclusivity means time container latest epoch memory points similarly write means latest epoch time written referring speci version epoch notation container exclusivity holds epoch container exists memory container exclusivity stronger converse agd agm agd assume unshared stronger equation equation disk belief agd hold written system note containers typical systems data blocks unshared agd agm write agd reuse ordering system exhibits reuse ordering ensures reusing container commits freed state container disk pointed generation memory freed generation made point freed state container generation pointer removed written disk reuse occurs agm agm write agm reuse results commit freed state extend rule agm agm write agm ffs soft updates linux ext examples systems exhibit reuse ordering pointer ordering system exhibits pointer ordering ensures writing container disk system writes containers pointed agm write agm write write ffs soft updates system exhibits pointer ordering modeling existing systems ned basic formalism logic proceed logic model reason system behaviors section present proofs properties important system consistency discuss data consistency problem system model journaling system reason non-rollback property journaling system data consistency rst problem data consistency system crash data consistency contents data block containers consistent metadata data blocks words end data system recovers crash assume metadata container pointers data blocks respective data block container disk belief points holds on-disk contents written generation epoch pointed time past kth generation memory generation rule summarizes fbx agd faygd fbx akgm fbx agd prove system exhibits reuse ordering pointer ordering suffers data consistency violation show system obey ordering data consistency compromised crashes simplicity make assumption data containers system nonshared les share data block pointers assume system obeys container exclusivity property modern systems ext vfat properties block exclusivity fbx agd fbx agm fbx agd rewrite rule fbx akgm fbx agd faygd rule hold means represented generation points generation contents written generation case data corruption show rule hold assume negation prove reachable sequence valid system actions faygd write event sequences implied lhs fbx akgm fbx agd write order prove prove interleaving sequences clause invalid disprove prove interleavings valid fbx akgm fbx agd event occur events due container exclusivity unshared similarly fbx akgm occur write interleavings fbx akgm fbx agd write write fbx akgm fbx agd case applying akgm fbx agd write applying akgm fbx agd write step valid sequence system execution generation freed due delete represented generation subsequent generation block reallocated represented generation memory shown violation occur assume system obeys reuse ordering equation additional constraint equation imply akgm fbx agd write write akgm fbx agd write facgd contradiction initial assumption started bgd reuse ordering shown scenario arise case write fbx akgm fbx agd applying write akgm fbx agd eqn write akgm fbx agd valid system sequence generation pointed data block generation generation deleted generation container assigned generation consistency violation occur scenario interestingly apply write write akgm fbx agd apply case belief agd hold rule led belief immediately write belief overwritten fbx agd sequence invalidate sequence reuse ordering guarantee data consistency case make assumption system obeys pointer ordering assume unshared container exclusivity holds apply equation write akgm write fbx agd applying pointer ordering rule eqn write akgm write write fbx agd agm write faygd write fbx agd faygd fbx agd contradiction implies contents disk belong generation started assumption reuse ordering pointer ordering system suffers data consistency violation system obey ordering ext data consistency compromised crashes note inconsistency fundamental xed scan-based consistency tools fsck veri inconsistency occurs practice reproduce case experimentally ext system modeling system journaling extend logic rules behavior journaling system model reason key property journaling system journaling technique commonly systems ensure metadata consistency single system operation spans multiple metadata structures system groups transaction guarantees transaction commits atomically preserving consistency provide atomicity system rst writes writeahead log wal propagates actual on-disk location transaction committed log transaction committed logged special commit record written log indicating completion transaction system recovers crash checkpointing process replays belong committed transactions model journaling logical transaction object determines set log record containers belong transaction logically pointers log copies containers modi transaction denote log copy journaled container symbol top container container log journal system note assume physical logging block-level logging ext physical realization transaction object commit record logically points containers changed transaction wal property hold commit container written log copy modi containers transaction points written commit container wal property leads rules axgm write axgm write write axgm write axgm write write rst rule states transaction committed commit record written containers belonging transaction 
written disk rule states on-disk home copy container written transaction container modi committed disk note unlike normal pointers considered point containers generations pointers container rules point epochs epoch pointers commit record speci epoch snapshot container replay checkpointing process depicted rules axgd ftgd write faxgd axgd aygd write faygd rst rule container part transaction transaction committed disk on-disk copy container updated logged copy pertaining transaction rule container part multiple committed transactions on-disk copy container updated copy pertaining transactions belief transitions hold bxgm fbx agm write fbx agd axgm write faxgd rule states points belongs transaction commit leads disk belief fbx agd rule disk belief faxgd holds immediately commit transaction part creation belief require checkpoint write happen disk belief pertains belief system reach start current disk state journaling systems containers types journaled updates containers directly disk transaction machinery proofs cases complete journaling containers journaled selective journaling containers type selective case address possibility container changing type journaled type non-journaled type vice versa container belongs journaling type converse equation fbx agd bxgm fbx agm write fbx agd show complete journaling data inconsistency occurs omit due space constraints non-rollback property introduce property called non-rollback pertinent system consistency rst formally property reason conditions required hold journaling system non-rollback property states contents container disk overwritten older contents previous epoch property expressed faxgd faygd faxgm faygm rule states on-disk contents move epoch logically imply epoch occurred epoch memory non-rollback property crucial journaling systems absence property lead data corruption proof logically derive corner cases handled property hold show journal revoke records effectively ensure disk believes xth epoch possibilities type journaled type belonged transaction disk observed commit record transaction belief faxgd occurs immediately commit point actual contents written system part checkpoint propagation actual on-disk location re-establishing belief faxgd set journaled types faxgd jgm faxgm axgm write faxgd write faxgd possibility type journaled case disk learnt prior commit faxgd jgm faxgm write faxgd journaled rst assume belong journaled type prove non-rollback property lhs faxgd faygd journaled sequence events led beliefs faxgm axgm write faxgd write faxgd faygm aygm write faygd write faygd omitting write actions sequences simplicity sequences events faxgm faxgd faxgd faygm faygd faygd note sequence instances disk belief created rst instance created transaction committed instance checkpoint propagation time snapshot-based coarse-grained journaling systems ext transactions committed order epoch occurred committed rst instance faxgd occur rst instance faygd property true journaling checkpointing in-order committed transactions copies data version pertaining transaction propagated checkpoint sequences events lead interleavings depending epoch occurs epoch vice versa ordering epoch xed rest events constrained single sequence interleaving faxgm faygm faxgd faygd faygd faxgm faygm interleaving faygm faxgm faygd faxgd faxgd faygd faxgd interleaving results contradiction initial statement started faxgd faygd rst interleaving legal sequences events combined rst interleaving implies faxgm faygm proved epochs journaled non-rollback property holds journaled case type epochs belongs journaled type start statement faxgd faygd equations sequences events faygm aygm write faygd write faygd faxgm write faxgd omitting write actions sake readability sequences faygm faygd faygd faxgm faxgd prove non-rollback property show interleaving sequences faygm faxgm results contradiction co-exist faxgd faygd interleavings faygm faxgm faygm faxgm faxgd faygd faygd faygm faygd faxgm faxgd faygd faygm faygd faygd faxgm faxgd faygm faxgm faygd faxgd faygd faygm faxgm faygd faygd faxgd faygm faygd faxgm faygd faxgd scenarios imply faygd faxgd invalid interleavings scenarios valid interleavings contradict initial assumption disk beliefs time imply faygm faxgm scenarios violate non-rollback property dynamic typing journaling mechanism guarantee nonrollback due violation contents corrupted stale metadata generations scenario occur checkpoint propagation earlier epoch journaled occurs overwritten non-journaled epoch prevent impose checkpoint propagation container context transaction happen on-disk contents container updated commit journal revoke records ext precisely guarantee revoke record encountered log replay pre-scan log block propagated actual disk location scenario epoch committed disk transaction modi earlier epoch committed prevent form reuse ordering imposes container type reused memory transaction freed previous generation committed transactions commit order freeing transaction occur transaction guarantee jgm jgm faygm faxgm faygm write faxgm rule scenario handled revoke record solution properties non-rollback property holds redundant synchrony ext examine performance problem ext system transaction commit procedure arti cially limits parallelism due redundant synchrony disk writes ordered mode ext guarantees newly created point stale data blocks crash ext ensures guarantee ordering commit procedure transaction committed ext rst writes disk data blocks allocated transaction waits writes complete writes journal blocks disk waits complete writes commit block inode container data block container transaction commit container commit procedure ext expressed equation fix fkgm ixgm write fix fkgm ixgm write write write examine condition ensure no-stale-data guarantee rst formally depict guarantee ext ordered mode seeks provide equation fix fkgm fix fgd ffygd fix fgd equation states disk acquires belief fix contents data container disk pertain generation pointed memory note ext obeys reuse ordering ordered mode guarantee cater case free data block container allocated prove equation examining conditions hold equation true lhs equation fix fkgm fix fgd applying equation fix fkgm ixgm write fix fgd applying equation fix fkgm ixgm write write write fix fgd equation fix fkgm ixgm ygd write write fix fgd ygd fix fgd current ext commit procedure equation guarantees no-stale-data property waits procedure required reorder actions write write fix fkgm ixgm write write write fix fgd applying equation ygd fix fgd ordering actions write write inconsequential guarantee ext ordered mode attempts provide conclude wait ext employs write data blocks redundant unnecessarily limits parallelism data journal writes severe performance implications settings log stored separate disk illustrated previous work speci points general problem system design developers rigorous frameworks reason correctness tend conservative conservatism translates unexploited opportunities performance optimization systematic framework enables aggressive optimizations ensuring correctness support consistent undelete section demonstrate logic enables quickly formulate prove properties system features mechanisms explore functionality traditionally considered part core system design ability undelete deleted les consistency guarantees ability recover deleted les demonstrated large number tools purpose tools rebuild deleted les scavenging on-disk metadata extent systems freed metadata containers simply marked free unix system block pointers deleted inode blocks belong deleted existing tools undelete guarantee consistency assert recovered contents 
valid undelete fundamentally best-effort les recovered blocks subsequently reused user trustworthy recovered contents demonstrate logic existing systems consistent undelete impossible provide simple solution prove solution guarantees consistent undelete finally present implementation solution ext undelete existing systems model undelete logic express pointers containers holding dead generation introduce notation pointer call dead pointer operator container denotes set dead live entities pointing container undel undelete action container undelete process summarized equation undel fbx agd fbggd fbx agd fby agd words dead free container points disk container alive dead pointing undelete makes generation live makes point guarantee hold consistency dead pointer brought alive ondisk contents time pointer brought alive correspond generation epoch originally pointed memory similar data consistency formulation fbx akgm fbx agd fby agd fbx agd fazgd note clause required lhs cover case generation brought life true undelete show guarantee hold necessarily negation rhs fazgd show condition co-exist conditions required undelete equation words show undel fbx agd fbggd fazgd arise valid system execution utilize implications proof fbx agd fbx akgm write fazgd write interleaving event sequences write fbx akgm write valid system sequence represented generation points written disk block freed killing generation generation allocated generation deleted written disk disk beliefs fbx agd fazgd initial state disk sequence simultaneously lead disk belief fbggd shown conditions fbx agd fbggd fazgd hold simultaneously undelete point lead violation consistency guarantee associate stale generation undeleted shown reuse ordering pointer ordering guarantee consistency case undelete generation pointers propose notion generation pointers show pointers consistent undelete guaranteed assumed pointers disk point containers discussed section pointer pointed speci generation leads set system properties implement generation pointers on-disk container generation number incremented time container reused addition on-disk pointer embed generation number addition container generation pointers on-disk contents container implicitly generation fbkgd valid belief means disk contents belong generation generation pointers criterion undelete undel fbx akgd fakgd fbx akgd fby akgd introduce additional constraint fazgd left hand side equation previous subsection fbx akgd fakgd fazgd denote on-disk container holds generation number fahgd equation fbx akgd fakgd fahgd contradiction means ondisk container generations simultaneously undelete occur scenario alternatively agged inconsistent undeletes occurring generation pointers consistent implementation undelete ext proof consistent undelete implemented generation pointer mechanism linux ext block generation number incremented time block reused generation numbers maintained separate set blocks ensuring atomic commit generation number block data straightforward data journaling mode ext simply add generation update create transaction block pointers inode extended generation number block implemented tool undelete scans on-disk structures restoring les undeleted consistently speci cally restored generation information metadata block pointers match block generation data blocks ran simple microbenchmark creating deleting directories linux kernel source tree observed roughly deleted les les roughly detected inconsistent undeletable remaining les successfully undeleted illustrates scenario proved section occurs practice undelete tool generation information wrongly restore les corrupt misleading data application semantic disks interesting application logic framework systems enables reasoning recently proposed class storage systems called semanticallysmart disk systems sds sds exploits system information storage system provide functionality admitted authors reasoning correctness knowledge tracked semantic disk hard formalism memory disk beliefs sds model extra system state tracked sds essentially disk belief section rst logic explore feasibility tracking block type semantic disk show usage generation pointers system simpli information tracking sds block typing important piece information required semantic disk type disk container identifying type statically-typed containers straightforward dynamically typed containers hard deal type dynamically typed container determined contents parent container indirect pointer block identi observing parent inode block indirect pointer eld tracking dynamically typed containers requires correlating type information typedetermining parent information interpret contents dynamic container accurate type detection sds guarantee hold kgd kgm words disk interprets contents epoch belonging type contents belonged type memory guarantees disk wrongly interpret contents normal data block container indirect block container note equation impose guarantee disk identies type container states association type contents correct prove rst state algorithm disk arrives belief type sds snoops metadata traf type-determining containers inodes container written observes pointers container concludes type pointers assume pointer type points container disk examines container written time freed interprets current contents belonging type written time contents type equation kgd fby agd faxgd words interpret belonging type disk container points current on-disk epoch type function abstracts indication disk contents epoch order associate contents type explore logical events led components side equation applying fby agd fby agm fby agd fby agm kgm fby agd similarly component faxgd faxgd write faxgd verify guarantee equation assume hold observe leads valid scenario add clause jgm equation equation prove fby agd faxgd jgm event sequences fby agm kgm fby agd jgm write type epoch unique write container implies type jgm write jgm write sequences interleaved ways epoch occurs epoch kgm interleaving fby agm kgm fby agd jgm write fby agm kgm fby agd jgm write valid sequence container freed disk acquired belieffb agand version written actual type changed memory leading incorrect interpretation belonging type order prevent scenario simply reuse ordering rule rule sequence imply fby agm kgm fby agd write jgm write fby agm kgm fby agd jgm write written disk treating free wrongly associate type interleaving proceeding similarly interleaving epoch occurs assigned type arrive sequence jgm write fby agm kgm fby agd simply applying reuse ordering rule prevent sequence stronger form reuse ordering freed state includes containers pointed allocation structure jaj tracking liveness rule sequence jgm write write jaj fby agm kgm fby agd add behavior sds states sds observes allocation structure indicating free inherits belief free write jaj applying sds operation eqn jgm write fby agm kgm fby agd sequence sds observe write treated free associate type subsequently written shown sds accurately track dynamic type underneath system ordering guarantees shown system exhibits strong form reuse ordering dynamic type detection made reliable sds utility generation pointers subsection explore utility systemlevel generation pointers context sds illustrate utility show tracking dynamic type sds straightforward system tracks generation pointers generation pointers equation kgd fby aggd faggd causal event sequences explored previous subsection fby aggm kgm fby aggd jgm write sequences imply generation types violates rule straightaway arrive contradiction proves violation 
rule occur related work previous work recognized modeling complex systems formal frameworks order facilitate proving correctness properties logical framework reasoning authentication protocols proposed burrows related work spirit paper authors formulate domain-speci logic proof system authentication showing protocols veri simple logical derivations domain-speci formal models exist areas database recovery database reliability body related work involves generic frameworks modeling computer systems wellknown tla framework automaton framework frameworks general model complex systems generality curse modeling aspects system extent paper tedious generic framework tailoring framework domain-speci knowledge makes simpler reason properties framework signi cantly lowering barrier entry terms adopting framework speci cations proofs logic lines contrast thousands lines tla speci cations automated theorem-proving model checkers bene generic framework tla previous work explored veri cation correctness system implementations recent body work model checking verify implementations body work complementary logic framework logic framework build model invariants hold model implementation veri finally system properties listed section identi previous work soft updates recent work semantic disks conclusions dependability computer systems important essential systematic formal frameworks verify reason correctness systems critical component system dependability formal veri cation correctness largely making systems vulnerable hidden errors absence formal framework sti innovation skepticism correctness proposals proclivity stick time-tested alternatives paper step bridging gap system design showing logical framework substantially simplify systematize process verifying system correctness acknowledgements lakshmi bairavasundaram nathan burnett timothy denehy rajasekar krishnamurthy florentina popovici vijayan prabhakaran vinod yegneswaran comments earlier drafts paper anonymous reviewers excellent feedback comments greatly improved paper work sponsored nsf ccrccr- ccrngs- itribm network appliance emc attie lynch dynamic input output automata formal model dynamic systems acm podc jfs overview ibm developerworks library jfs html bjorner browne colon finkbeiner manna sipma uribe verifying temporal properties reactive systems step tutorial formal methods system design fmsd burrows abadi needham logic authentication acm sosp pages clarke grumberg peled model checking mit press ganger mckusick soules patt soft updates solution metadata update problem file systems acm tocs hadzilacos theory reliability database systems acm hagmann reimplementing cedar file system logging group commit sosp nov kuo model veri cation data manager based aries acm trans database systems lamport temporal logic actions acm trans program lang syst mckusick joy lef fabry fast file system unix acm transactions computer systems august mogul update policy usenix summer boston june mohan haderle lindsay pirahesh aries transaction recovery method supporting finegranularity locking artial rollbacks write-ahead logging acm tods march musuvathi park chou engler dill cmc pragmatic approach model checking real code osdi dec pnueli temporal semantics concurrent programs theoretical computer science tcs prabhakaran arpaci-dusseau arpaci-dusseau analysis evolution journaling file systems usenix r-undelete r-undelete file recovery software http undelete reiser reiserfs namesys restorer restorer data recovery software http bitmart net sivathanu bairavasundaram arpaci-dusseau arpaci-dusseau life death block level osdi pages san francisco december sivathanu prabhakaran arpaci-dusseau arpaci-dusseau improving storage system availability graid fast tweedie future directions ext filesystem freenix monterey june tweedie ext journaling file system http olstrans sourceforge net release ols -ext ols ext html july yang twohey engler musuvathi model checking find file system errors osdi dec manolios lamport model checking tla specications lecture notes computer science 
database-aware semantically-smart storage muthian sivathanu lakshmi bairavasundaramy andrea arpaci-dusseauy remzi arpaci-dusseauy google ycomputer sciences department wisconsin madison abstract recent research demonstrated potential bene building storage arrays understand systems semantically-smart disk systems knowledge system structures operations improve performance availability security ways precluded traditional storage system architecture paper study applicability semantically smart disk technology underneath database management systems case studies analyze differences building database-aware storage semantically-smart disk systems successfully applied underneath database techniques log snooping explicit access statistics needed introduction processing power increasing modern storage systems symmetrix storage array highend raid emc processors memory ability leverage computational power traditional storage systems limited due narrow blockbased interface protocols scsi storage arrays receive simplest commands read write range blocks storage system knowledge blocks part block live dead bridge information gap recent research proposed idea semantically smart disk system learns embedded knowledge system semantic information storage system vendors build functional reliable higher-performing secure storage systems exploiting knowledge directory structures storage system deliver improved data availability failure previous research semantically smart disk systems assumed commodity work wisconsin-madison system linux ext linux ext netbsd ffs windows fat windows ntfs interacting disk paper explore techniques semanticallysmart disk systems operate beneath database management systems dbms database systems form signi important group clients storage systems bene semantically smart storage applied realm operating beneath system database semantically smart disk system performs similar operations tracking table block allocated dbms tracks information organizes data disk differently system systems record metadata statistics recent access modi time dbms specialized track general statistics system workloads directory structure reasonable approximation semantic groupings users place related les single directory dbms semantic grouping tables indexes dynamic depending query workload general nding differences fundamental require semantically smart storage build database-aware storage investigate techniques required systems explore log snooping storage system observes write-ahead log wal records written dbms monitoring log storage system observe operation performed dbms effect reaches disk explore bene dbms explicitly gather access statistics write statistics storage simple add statistics dbms investigate database-aware storage implement analyze case studies found work underneath systems study improve storage system availability d-graid raid system degrades gracefully failure implement dbms-specialized version faded storage system guarantees data unrecoverable user deleted finally explore improve second-level storage-array cache hit rates technique x-ray experience semantically-smart disks work underneath database systems cases database systems systems semantically-smart storage secure delete case presence transactional semantics dbms disk accurately track dynamic information result functionality requires absolutely correct inferences implemented changing dbms contrast functionality required system case studies d-graid x-ray dbms supply desired access information storage system result results obtained slightly modify dbms rest paper organized section review related work database-aware storage discuss advantages disadvantages semantically-smart disks section describe general techniques needed semantic disk extract information dbms sections present case studies finally discuss range techniques section conclude section background placing intelligence disk systems database systems favor years summary work area keeton dissertation page earliest examples idea logic track devices proposed disk computational ability head natural application lter data passes rest system idea database-speci machines refuted boral dewitt primary reason failure approaches required non-commodity components outperformed technology moved ahead worse database vendors rewrite substantial code base advantage speci features offered specialized architectures processing power faster cheaper idea active disks focus recent work includes acharya riedel efforts portions applications downloaded disks tailoring disk running program research focuses partition applications host disk cpus minimize data transferred contrast previous work semantically-smart approach require specialized hardware components sophisticated programming environments high-end storage arrays good match technology multiple processors vast quantities memory building semantic knowledge higher-level systems storage array bene drawbacks main bene semantic-disk approach increases functionality placing high-level semantic knowledge storage system enables systems require low level control storage array high level knowledge dbms systems precluded traditional storage architectures previous research shown semantic disks improve performance layout caching improve reliability provide additional security guarantees semantically-smart approach leads concerns concern processing required disk system researchers noted trend increasing intelligence disk systems modern storage arrays exhibit fruits moore law emc symmetrix storage server con gured processors ram resources idle nonetheless hint relative simplicity adding intelligence concern placing semantic knowledge disk system ties disk system intimately system dbms dbms on-disk structure storage system change systems ondisk formats rarely change format ext system signi cantly changed years existence current modi cations great pains preserve full backwards compatibility older versions system case dbms format concern gain insight storage vendor deliver rmware updates order pace dbms-level studied development postgres times revision history dump restore required migrate version found dump restore needed months average frequent expected commercial databases store terabytes data requiring dump restore migrate tolerable users recent versions oracle great lengths avoid on-disk format nal concern storage system semantic knowledge layer system dbms possibly run fortunately systems database systems supported cover large fraction market functionality semantic disk independent layer small portion code handle issues speci system dbms finally storage vendor reduce burden supporting database platforms target single important database oracle provide standard raid functionality systems interestingly highend raid systems perform bare minimum semantically-smart behavior storage systems emc recognize oracle data block provide extra checksum assure block write comprised multiple sector writes reaches disk atomically summary storage vendors commit resources support database technology database-aware techniques implement powerful functionality storage system leverage higher-level semantic information system dbms running top section describe types information semantic disk requires underneath dbms discuss information acquired database-speci semantic information broadly categorized types static dynamic experience primarily predator dbms built shore storage manager illustrate techniques speci examples predator techniques general database systems static information static information comprised facts database change database running storage system obtain static information knowledge embedded rmware explicitly communicated out-of-band channel system installation cases static information describes format on-disk structures knowing format database log record semantic disk observe update operation disk knowing structure b-tree pages disk determine internal pages versus leaf pages nally understanding format data pages semantic disk perform operations scanning page holes byte ranges deleted cases static information describes location on-disk structures predator knowing names ids system catalog tables rootindex sindxs table dynamic information dynamic information pertains information dbms continually operation examples dynamic information include set disk 
blocks allocated table disk block belongs table index unlike static information dynamic information continually tracked disk track dynamic information semantic disk utilizes static information data structure formats monitor key data structures correlated higher level operations systems databases buffer reorder writes performing accurate inference higher level operations complex solve problem technique log snooping storage system observes log records written dbms log snooping storage system leverages fact database write-ahead log wal track operation on-disk contents wal property log operation reaches disk effect operation strong ordering guarantee makes inferences underneath dbms accurate straightforward implementation log snooping assume log record log sequence number lsn lsn byte offset start record log volume lsn semantic disk accurately infer exact ordering events occurred database presence group commits log blocks arrive order order events disk maintains expected lsn pointer lsn log record expected disk semantic disk receives write request log block block log record semantic disk processes log record advances expected lsn pointer point record log blocks arrive order semantic disk utilizes lsn ordering process blocks order log blocks arriving order deferred expected lsn reaches block describe detail implementation database-aware storage log snooping infer important pieces dynamic information transaction status block ownership block type relationships blocks describe importance nal piece dynamic information access statistics transaction status basic piece dynamic information current state transaction written disk transaction pending committed pending transaction aborted performing work transaction semantic disk choose pessimistically recognize committed transactions optimistically begin work pending transactions trade-offs pessimistic optimistic approaches pessimistic approach semantic disk implements functionality requires correctness implementing secure delete section semantic disk shred data belonging pending transaction transaction abort dbms require data pessimistic approach worse performance optimistic approach pessimistic version delay work require signi amount buffering optimistic approach bene cial aborts rare dbms implements group commits delay committing individual transactions long period determining status transaction straightforward log snooping semantic disk observes log record written adds list pending transactions disk observes commit record log determines transactions committed moves committed list block ownership semantic disk understand logical grouping blocks tables indices involves associating block table index store logically owns block performing association semantic disk straight forward effect allocating block recoverable dbms rst logs operation performing allocation semantic disk observes traf disk block simple associate block owning table index show cases suf cient semantic disk map blocks store owning table cases semantic disk map store actual table index allocating block shore writes create extlog record block number owning store semantic disk observes log entry records block number store internal block store hash table map store actual table index disk static knowledge system catalog tables predator mapping maintained tree called rootindex logical store statically disk observes btree add records log rootindex semantic disk identify newly created mappings add store hash table block type piece information semantic disk type store block block data page index page track information semantic disk watches updates system catalog tables names part static information disk predator sindxs table indexes database tuple sindxs index table attribute index built semantic disk detects inserts table page insert records log semantic disk determine block part table index owning store information derived sindxs table block relationships type information consists relationships blocks relationships semantic disk table set indices built table stated predator association indices tables sindxs catalog table semantic disk consult information derived sindxs table associate table indices vice versa access patterns addition previous dynamic information semantic disk tables indexes accessed current workload transaction status block ownership block type block relationships inferred easily log snooping access patterns dif cult infer inferring access patterns found easy underneath general-purpose system fact set les lies directory implicitly conveys information storage system les accessed similarly systems track time accessed periodically write information disk modern database systems track access statistics performance diagnosis statistics gathered coarse granularity automatic workload repository oracle maintains access statistics experience revealed dbms track types statistics information optimize behavior dbms write statistics periodically disk additional catalog tables transactional avoid logging overhead basic statistic dbms communicate semantic disk access time block table statistic derive statistics statistic summarizes access correlation entities tables indexes dbms record query set tables indexes accessed correlation statistics capture semantic groupings tables collocating related tables finally statistic tracks access counts number queries accessed table duration piece information conveys importance tables indexes case studies actual static dynamic information required database-aware disk depends functionality disk implementing investigate number case studies previously implemented underneath systems investigate d-graid raid system degrades gracefully failure implement faded guarantees data unrecoverable user deletes finally explore x-ray implements second-level storage-array cache partial availability d-graid rst case study implement d-graid underneath dbms d-graid semantically-smart storage system lays blocks ensures graceful degradation availability unexpected multiple failures d-graid enables continued operation system complete unavailability multiple failures previous work shown approach signi cantly improves availability systems section begin reviewing motivation partial availability d-graid summarize past experience implementing d-graid underneath systems describe techniques implementing d-graid underneath dbms finally evaluate version d-graid discuss lessons motivation importance data availability emphasized settings downtime cost millions dollars hour cope failures systems database systems store data raid arrays employ redundancy automatically recover small number disk failures existing raid schemes effectively handle catastrophic failures number failures exceeds tolerance threshold array multiple failures occur due primary reasons faults correlated single controller fault component error render number disks unavailable system administration main source failure systems large percentage human failures occur maintenance maintenance person typed wrong command unplugged wrong module introducing double failure page extra failures existing raid schemes lead complete unavailability data contents array restored backup effect severe large arrays disks roughly raidarray fully operational disk system database completely unavailable availability cliff arises traditional storage systems employ simplistic layout techniques striping oblivious semantic importance blocks relationships blocks excess failures occur odds semantically-meaningful data table remaining low modern storage arrays export abstract logical volumes single disk system dbms control data placement ensure semantically-meaningful data remains single disk failure filesystem-aware d-graid basic goal d-graid make semantically meaningful fragments data failures workloads access fragments run completion oblivious data loss parts system working top redundancy technique raidd-graid graceful degradation number failures exceed tolerance threshold redundancy technique implemented 
d-graid system found layout techniques important fault-isolated data placement needed ensure semantic fragments remain entirety fault isolated placement entire semantic fragment collocated single disk found system workloads reasonable semantic fragment consists single entirety data blocks inode block potentially indirect blocks les single directory selective replication needed ensure essential meta-data data required system context essential meta-data found consist directories data inode blocks structures system superblock bitmap blocks essential data found system binaries directories usr bin bin lib access-driven diffusion popular data striped disks needed improve throughput large single disk found popular data dynamically identi tracking logical segments semantic knowledge access-driven diffusion implemented manner beneath system dbms database-aware d-graid describe techniques implementing graid underneath dbms explore techniques fault-isolated data placement target widely database usage patterns moderately-sized tables coarse-grained fragmentation large tables ne-grained fragmentation explore structures selectively replicated describe implementation accessdriven diffusion finally describe infallible writes technique required systems identifying semantic fragments fundamental differences dbms versus system dbms extremely large tables single disk describe techniques separately moderately-sized tables coarse-grained fragmentation entire table disk large tables ne-grained fragmentation stripe tables indexes multiple disks dbms queries performed directly impact tables indexes accessed describe semantic groupings affected popular types queries scans index lookups joins fault-isolated placement coarse-grained simplest case occurs database large number moderately-sized tables situation semantic fragment ned terms entire table present layout strategies improved availability query type scenario scans queries selection queries lter non-indexed attribute aggregate queries single table involve sequential scan entire table scan requires entire table order succeed simple choice semantic fragment set blocks belonging table entire table single disk failures occur subset tables entirety scans involving tables continue operate oblivious failure index lookups index lookups form common class queries selection condition applied based indexed attribute dbms index tuple record ids reads relevant data pages retrieve tuples traversing index requires access multiple pages index collocation index improves availability index table viewed independently placement index query fails index table unavailable decreasing availability strategy improve availability collocate table indexes call strategy dependent index placement joins queries involve joins multiple tables queries typically require joined tables order succeed improve availability join queries d-graid collocates tables joined single semantic fragment laid single disk identi cation join groups requires extra access statistics tracked dbms implementation modi predator dbms record set stores tables indexes accessed query construct matrix access correlation pair stores information written disk periodically seconds modi cations predator straight-forward involving lines code d-graid information collocate tables accessed fault-isolated placement fine-grained collocation entire tables indexes single disk enhanced availability single table index large single disk disk capacities roughly doubling year scenario require ne-grained approach semantic fragmentation approach graid stripes tables indexes multiple disks similar traditional raid array adopts techniques enable graceful degradation detailed scans scans fundamentally require entire table striping strategy impact availability scan queries availability hierarchical approach large table split minimal number disks hold disk group treated logical faultboundary d-graid applied logical fault-boundaries alternatively database supports approximate queries provide partial availability scan queries missing data index lookups large tables index-based queries common oltp workload tpc-c involves index lookups small number large tables queries require entire index table d-graid simple techniques improve availability queries internal pages b-tree index aggressively replicated failure instance root b-tree index page collocated data pages tuples pointed index page collocation d-graid probabilistic strategy leaf index page written d-graid examines set rids contained page rid determines disk tuple places index page disk greatest number matching tuples note assume table clustered index attribute page-level collocation effective case non-clustered indexes joins similar indexes page-level collocation applied tables join group collocation feasible tables join group clustered join attribute alternatively tables join group small replicated disks larger tables striped selective replication data structures dbms query system run system catalogs information table index frequently consulted structures unavailable partial failure fact data remains accessible practical d-graid aggressively replicates system catalogs extent map database tracks allocation blocks stores experiments employ -way replication important meta-data -way replication feasible readmostly nature meta-data minimal space overhead entails database log plays salient role recoverability database ability make partial availability important log multiple failures providing high availability log size active portion log determined length longest transaction factored concurrency workload portion log highly reasonable modern storage arrays large amounts persistent ram obvious locations place log high availability replicating multiple nvram stores addition normal on-disk storage log ensure log remains accessible face multiple disk failures access-driven diffusion stated coarse-grained fragmentation entire table single disk table large accessed frequently performance impact parallelism obtained disks wasted remedy d-graid monitors accesses logical address space tracks logical segments bene parallelism d-graid creates extra copy blocks spreads disks array normal raid blocks hot d-graid regains lost parallelism due collocated layout providing partial availability guarantees reads writes rst diffused copy background updates actual copy technique underneath dbms essentially identical underneath system infallible writes partial availability data introduces interesting problems transaction recovery mechanisms dbms transaction declared committed ected log partially system crash redo transaction fail pages affect durability semantics transactions problem considered solved aries context handling ine objects deferred restart ensure transaction durability d-graid implements infallible writes guarantees write succeeds block written destined dead disk d-graid remaps live disk writes assuming free space remaining live disk remapping prevents failure ushing committed transaction disk evaluation evaluate availability improvements performance d-graid prototype implementation d-graid prototype functions software raid driver linux kernel operates underneath predator shore dbms availability improvements evaluate availability improvements d-graid d-graid array disks study fraction queries database serves successfully increasing number disk failures layout techniques d-graid complementary existing raid schemes parity mirroring show d-graid level redundancy data measurements simplicity microbenchmarks analyze availability provided layout techniques d-graid coarse-grained fragmentation rst evaluate availability improvements due coarse-grained fragmentation techniques d-graid figure presents availability scan index lookup join queries synthetic workloads multiple disk failures percentage queries complete successfully reported leftmost graph figure shows availability scan queries database tables tuples workload query chooses table random computes average non-indexed attribute requiring scan entire table graph shows collocation tables enables database partially serving proportional fraction queries comparison queries succeed failed disks table scans availability queries succeed failed disks index lookup queries dependent 
index placementindependent index placement queries succeed failed disks join queries join collocationwithout collocation figure coarse-grained fragmentation graphs show availability degradation scans index lookups joins varying number disk failures -disk d-graid array steeper fall availability higher number failures due limited -way replication metadata straight diagonal line depicts ideal linear degradation queries succeed failed disks split tables indexes replication colocationwith replication plain striping queries succeed failed disks split tables indexes hot-cold tuples hot-cold -wayhot-cold -way hot-cold -way figure index lookups ne-grained fragmentation graphs show availability degradation index lookup queries left graph considers uniformly random workload graph considers workload small set tupes popular failure traditional raidsystem results complete unavailability note redundancy maintained parity mirroring d-graid traditional raid tolerate failure availability loss middle graph figure shows availability index lookup queries similar workload layouts layouts entire store index table collocated disk independent index placement d-graid treats index table independent stores possibly allocates disks dependent index placement d-graid carefully allocates index disk table dependent placement leads availability failure finally evaluate bene join-group collocation micro-benchmark database pairs tables joins involving tables pair join queries randomly select pair join tables rightmost graph figure shows collocating joined tables d-graid achieves higher availability fine-grained fragmentation evaluate effectiveness ne-grained fragmentation focus availability index lookup queries interesting category workload study consists index lookup queries randomly chosen values primary key attribute single large table plot fraction queries succeed varying number disk failures left graph figure shows results layouts examined graph lowermost line shows availability simple striping replication system catalogs availability falls drastically multiple failures due loss internal b-tree nodes middle line depicts case internal b-tree nodes replicated aggressively expected achieves availability finally line shows availability data index pages collocated addition internal b-tree replication techniques ensure linear degradation availability graph figure considers similar workload small subset tuples hotter compared speci cally tuples accessed queries workload simple replication collocation provide linear degradation availability hot pages spread uniformly disks hot-cold workload d-graid improve availability replicating data index pages d-graid raidslowdown table scan index lookup bulk load table insert table time overheads d-graid table compares performance d-graid ne-grained fragmentation default raidunder microbenchmarks array disks hot tuples lines depict availability hot pages replicated factors small fraction read data hot d-graid utilizes information enhance availability selective replication performance overheads evaluate performance implications faultisolated layout d-graid experiments section -disk d-graid array comprised ibm ultrastar lzx disks peak throughput database single table records sized bytes index primary key time space overheads rst explore time space overheads incurred d-graid prototype tracking information database laying blocks facilitate graceful degradation table compares performance graid ne-grained fragmentation linux software raid basic query workloads workloads examined scan entire table index lookup random key table bulk load entire indexed table inserts indexed table graid performs raidfor workloads scans poor performance scans due predator anomaly scan workload completely saturated cpu table disks extra cpu cycles required d-graid impacts scan performance interference prototype competes resources host hardware raid system interference exist overheads d-graid reasonable evaluated space overheads due aggressive metadata replication found minimal overhead scales number tables database tables overhead -way replication important data access-driven diffusion evaluate bene diffusing extra copy popular tables table shows time scan scan time raidd-graid d-graid diffusion table diffusing collocated tables table shows scan performance -disk array coarse-grained fragmentation table coarse-grained fragmentation d-graid simple collocation leads poor scan performance due lost parallelism extra diffusion aimed performance d-graid performs closer default raidcomparison implementation d-graid underneath dbms uncovered fundamental challenges present system notion semantically-related groups complex dbms inter-relationships exist tables indexes system case les directories reasonable approximations semantic groupings dbms goal graid enable serving higher level queries notion semantic grouping dynamic depends query workload identifying popular data aggressively replicated easier systems standard system binaries libraries obvious targets independent speci system running dbms set popular tables varies dbms dependent query workload effectively implementing d-graid underneath dbms requires slightly modifying dbms record additional information finally ensure transaction durability implemented infallible writes version dbms comparing d-graid performs beneath dbms versus system similarities versions d-graid successfully enable graceful degradation availability versions enable expected number processes queries complete successfully xed number disk failures fact versions enable expected number complete subset data popular similarly versions d-graid introduce time overhead interestingly slowdowns database version generally lower system version finally versions require access-driven diffusion obtain acceptable performance secure delete faded case study implement faded underneath dbms faded semantically smart disk detects deletes records tables dbms level securely overwrites shreds relevant data make irrecoverable extend previous work implemented functionality systems motivation deleting data recovery impossible important system security government regulations require guarantees sensitive data forgotten requirements important databases recent legislations data retention sarbanes-oxley act accentuated importance secure deletion secure deletion data magnetic disks involves overwriting disk blocks sequence writes speci patterns cancel remnant magnetic effects due past layers data block early work overwrites block required secure erase recent work shows overwrites suf modern disks system dbms ensure secure deletion functions top modern storage systems transparently perform optimizations storage system buffer writes nvram writing disk presence nvram buffering multiple overwrites system dbms collapsed single write physical disk making overwrites ineffective presence block migration storage system overwrites system dbms miss past copies secure deletion requires low level information control storage system time higher level semantic information system dbms detect logical deletes semanticallysmart disk system ideal locale implement secure deletion filesystem-aware faded running underneath system faded infers deleted tracking writes inodes indirect blocks bitmap blocks due asynchronous nature systems faded guarantee current contents block belong deleted newly allocated shredded ensure shred valid data faded conservative overwrites shreds version block restoring current contents block previous work implemented faded systems linux ext linux ext windows vfat faded work correctly system changed linux ext modi ensure data bitmap blocks ushed indirect block allocated freed windows vfat changed track generation number nally linux ext modi list modi data blocks included transaction database-aware faded implement faded beneath dbms semantic disk identify handle deletes entire tables individual records discuss cases turn simplest case faded table deleted drop table command issued faded shred blocks belonging table faded log snooping identify log records freeing extents stores 
shore free ext list log record written extent freed faded list freed blocks issue secure overwrites pages transaction aborts undoing deletes contents freed pages required faded pessimistically waits transaction committed performing overwrites handling record-level deletes faded challenging speci tuples deleted sql delete statement speci byte ranges pages tuples shredded delete dbms typically marks relevant page slot free increments free space count page freeing slots logged faded learn record deletes log snooping faded shred page records page valid read current page disk defer shredding faded receives write page ecting relevant delete receiving write faded shreds entire page disk writes data received complications basic technique rst complication identify correct version page deleted record assume faded observes record delete page waits subsequent write written faded detect version written reects version stale dbms wrote page delete block reordered disk scheduler arrives disk issue similar le-system version faded conservative overwrites database-aware version wal property dbms ensure correct operation speci cally database-aware faded pagelsn eld page identify ects delete pagelsn page tracks sequence number run time workload workload default faded faded faded table overheads secure deletion table shows performance faded overwrites workloads workload deletes contiguous records workload deletes records randomly table latest log record describing change page faded simply compare pagelsn lsn delete complication dbms bytes belonged deleted records result data remains page faded observes page write scans page free space explicitly zeroes deleted byte ranges page remain dbms cache subsequent writes page scanned zeroed appropriately evaluation brie evaluate cost secure deletion faded prototype implementation prototype implemented device driver linux kernel works underneath predator workloads operating table -byte records rst workload perform delete rows half table deleted deleted pages contiguous workload tuples deleted selected random table compares default case faded faded overwrite passes expected secure deletion performance cost due extra disk multiple passes overwrites modern disks effectively shred data overwrites focus faded case performance slower overhead incurred deletes sensitive data deleted manner costs reasonable situations additional security required comparison primary difference versions faded database-aware version leverage transactional properties dbms nitively track block shredded result system version faded required system exception data journaled ext implementation faded require dbms version require detailed information on-disk page layout dbms record-level granularity deletes dbms makes secure deletion complex system counterpart versions faded incur overhead depending workload number overwrites delete-intensive database workloads faded slower overwrites similarly system workloads faded slower overwrites table summary slowdown incurred faded depends workload number overwrites dbms system exclusive caching x-ray nal case study implement x-ray underneath dbms x-ray exclusive caching mechanism storage arrays attempts cache disk blocks present higher-level buffer cache providing illusion single large lru cache previous work demonstrated approach performs buffer cache maintained system motivation modern storage arrays possess large amounts ram caching disk blocks instance high-end emc storage array main memory caching typically cache second-level cache system database system maintains buffer cache host main memory current caching mechanisms storage arrays account block array cache read duplicating blocks cached cache space wasted due inclusion strategy contents buffer cache disk array cache exclusive wong proposed avoid cache inclusion modifying system disk interface support scsi demote command enables treating disk array cache victim cache database system approach require dbms inform disk evictions buffer pool requiring explicit change scsi storage interface makes scheme hard deploy industry consensus required adopting change filesystem-aware x-ray x-ray predicts contents system buffer pool chooses cache recent victims cache x-ray requires storage interface x-ray access time statistics block accessed perform predictions hit rate array cache size blocks hit rate x-ray multi-queue lru execution time seconds array cache size blocks execution time lru multi-queue x-ray hit rate write period write period variation period variation hit rate segment size blocks segment size variation segment size variation figure x-ray performance gure presents evaluation x-ray tpc-c benchmark dbms buffer cache set blocks studies hit rate x-ray compared caching mechanisms segment size blocks access information written execution times compared times based buffer cache hit time disk array cache hit time disk read time hit-rate x-ray measured segment sizes write period write period varied x-ray hit rate measured segment size blocks systems linux ext access statistics recorded granularity directly inodes x-ray access statistics maintain ordered list block numbers lru block mru block complicated fact access statistics tracked perle basis ordered list updated x-ray obtains information system reads disk making read block recently accessed system writes access time disk disk read arrives block x-ray infers evicted buffer cache time past infer block earlier access time evicted assuming lru policy access time block updated x-ray observe disk read x-ray infers block blocks access time present buffer cache higher-level cache policy lru usual case blocks close mru end list predicted system buffer cache blocks lru part list considered exclusive set x-ray caches recent blocks exclusive set extra internal array bandwidth idle time disk requests read blocks cache database-aware x-ray database-aware version x-ray similar system-aware version primary difference creating database-aware x-ray occurs dbms typically track access statistics database systems maintain access statistics administrative purposes awr oracle statistics coarse granularity written long intervals implement database-aware x-ray modify database buffer manager write access statistics periodically speci cally table index divided xed-sized segments buffer manager periodically writes disk access time segments accessed period time x-ray assumes blocks segment accessed sees access time statistic updated accuracy x-ray predict contents database cache sensitive size segment update interval advantage explicitly adding information tune implementation changing size segment update interval alternative adding access information modify dbms directly report evicted block cache demote adding access statistics approach statistics general semantic disks implementing functionality d-graid evaluation evaluate performance database-aware version x-ray simulation database buffer cache disk array cache evaluation lesystem-aware x-ray performed simulation database buffer cache maintained lru fashion dbms periodically writes access information granularity segment array cache managed x-ray assume x-ray suf cient internal bandwidth block reads instrumented buffer cache manager postgres dbms generate traces page requests buffer cache level postgres predator programming api linux required implement tpc-c approximate implementation tpc-c benchmark evaluation adheres tpc-c speci cation access pattern total transactions performed evaluate performance x-ray terms array cache hit rate execution time 
compare static dynamic catalog tables log record format b-tree page format data page format ransaction status block wnership block type block relationships access statistics d-graid basic ne-grained frags join-collocation faded basic record-level delete x-ray basic table dbms information required case studies table lists static information embedded semantic disk dynamic state automatically tracked disk ray plain lru multi-queue mechanism designed level caches explore sensitivity segment size access time update periodicity figure compares hit rate x-ray schemes figure compares execution times segment size set blocks access information written study x-ray hit rate lru multi-queue hit rate advantage extends execution time overhead writing access information x-ray performs lru multi-queue figure evaluates sensitivity x-ray cache hit rate segment size expected hit rate drops slightly increase segment size figure shows sensitivity access information update interval x-ray tolerate reasonable delay seconds obtaining access updates comparison system database versions x-ray similar implement x-ray semantic disk requires access statistics blocks accessed layer systems track periodically write statistics dbms x-ray dbms modi explicitly track access times segments table advantage explicitly adding information tune statistics appropriately size segment update interval running beneath system database ray found substantially improve array cache hit rate relative lru multi-queue information case studies section review static dynamic information required database-aware disk needed information depends functionality implemented exact information required variants case studies listed table biggest concern database vendors static information exported storage system understands format catalog table database vendor loathe change format amount static information varies bit case studies case studies format catalog tables log records d-graid support ne-grained fragmentation faded record-level deletes detailed knowledge b-tree page format data page format dynamic information varies case studies fundamental piece dynamic information block ownership shown fact required case study block type generally property needed d-graid faded pieces dynamic information widespread faded precisely transaction committed correct pessimistic determining overwrite data d-graid associate blocks table blocks index vice versa finally access correlation access count statistics needed d-graid variants collocate related tables aggressively replicate hot data simple access time statistic needed x-ray predict contents higher-level buffer cache conclusions today database community sort simple-minded model disk arm platter holds database fact holding database raid arrays storage area networks kinds architectures underneath hood masked logical volume manager written operating system people databases transparency good makes productive care details hand optimizing entire stack elds talk hand accept things -pat selinger semantic knowledge storage system enables powerful functionality constructed storage system improve performance caching improve reliability provide additional security guarantees paper shown semantic storage technology deployed beneath commodity systems beneath database management systems found techniques required handle database systems investigated impact transactional semantics dbms cases transactions simplify work semantic disk log snooping enables storage system observe operations performed dbms nitively infer dynamic information changing dbms storage system ensure interfere transactional semantics found infallible writes ensure transaction durability disks failed explored lack access statistics dbms complicates interactions semantic disk case found helpful slightly modify database system gather relay simple statistics acknowledgements david black encouraging extend semantic disks work databases david dewitt jeff naughton rajasekar krishnamurthy vijayan prabhakaran insightful comments earlier drafts paper jeniffer beckham pointing pat selinger quote finally anonymous reviewers thoughtful suggestions greatly improved paper work sponsored nsf ccrccr- ccrngs- itribm network appliance emc acharya uysal saltz active disks programming model algorithms evaluation proceedings international conference architectural support programming languages operating systems asplos viii san jose california october agrawal kiernan srikant hippocratic databases vldb bairavasundaram sivathanu arpaci-dusseau arpaci-dusseau x-ray non-invasive exclusive caching mechanism raids isca bauer priyantha secure data deletion linux file systems usenix security august boral dewitt database machines idea time passed international workshop database machines brown yamaguchi oracle hardware assisted resilient data oracle technical bulletin note chen lee gibson katz patterson raid high-performance reliable secondary storage acm computing surveys june denehy arpaci-dusseau arpaci-dusseau bridging information gap storage protocol stacks usenix pages emc corporation symmetrix enterprise information storage systems http emc ganger blurring line oses storage devices technical report cmu-cs- carnegie mellon december gray computers stop international conference reliability distributed databases june gribble robustness complex systems eighth workshop hot topics operating systems hotos viii schloss elmau germany grochowski emerging trends data storage magnetic hard disk drives datatech september gutmann secure deletion data magnetic solidstate memory usenix security july hellerstein haas wang online aggregation sigmod pages hughes coughlin secure erase disk drive data idema insight magazine keeton computer architecture support database applications phd thesis california berkeley keeton wilkes automating data dependability proceedings acm-sigops european workshop pages saint-emilion france september carey shoring persistent applications proceedings acm sigmod conference mohan haderle lindsay pirahesh schwarz aries transaction recovery method supporting finegranularity locking partial rollbacks write-ahead logging acm tods march oracle self-managing database automatic performance diagnosis https oracleworld published doc patterson gibson katz case redundant arrays inexpensive disks raid sigmod pages patterson availability maintainability performance focus century key note lecture fast postgres postgresql database http postgresql riedel gibson faloutsos active storage largescale data mining multimedia vldb selinger winslett pat selinger speaks sigmod record december seshadri paskin predator or-dbms enhanced data types sigmod sivathanu bairavasundaram arpaci-dusseau arpaci-dusseau life death block level proceedings symposium operating systems design implementation osdi pages san francisco california december sivathanu prabhakaran arpaci-dusseau arpaci-dusseau improving storage system availability graid fast sivathanu prabhakaran popovici denehy arpaci-dusseau arpaci-dusseau semantically-smart disk systems usenix symposium file storage technologies fast pages slotnick logic track devices volume pages academic press tpc-c transaction processing performance council http tpc tpcc tweedie future directions ext filesystem proceedings usenix annual technical conference freenix track monterey california june wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february wong wilkes cache making storage exclusive usenix zhou philbin multi-queue replacement algorithm level buffer caches usenix pages 
model-based failure analysis journaling file systems vijayan prabhakaran andrea arpaci-dusseau remzi arpaci-dusseau wisconsin madison computer sciences department west dayton street madison wisconsin vijayan dusseau remzi wisc abstract propose method measure dependability journaling file systems approach build models journaling file systems behave journaling modes models analyze file system behavior disk failures techniques measure robustness important linux journaling file systems ext reiserfs ibm jfs analysis identify design flaws correctness bugs present file systems file system errors ranging data corruption unmountable file systems introduction disks fail modern file systems storage systems include internal machinery cope failures ensure file system integrity reliability presence failures disks fail changing traditional systems assume disks fail-stop assumption disk working failure easily detectable disk complexity increases pressures time-to-market cost increase disk failure modes common specifically latent sector faults occur specific block faulty transient permanent manner disk viewing disk working longer paper investigate modern file systems cope class fault modern file systems journaling systems logging data separate journal writing fixed locations file systems maintain file system integrity presence crashes analyze file systems develop modelbased fault-injection technique specifically file system test develop abstract model update behavior orders writes disk maintain file system consistency model inject faults interesting points file system transaction monitor system reacts failures paper focus write failures file system writes change on-disk state potentially lead corruption properly handled fault-injection methodology test widely linux journaling file systems ext reiserfs ibm jfs analysis find design flaws file systems catastrophically affect on-disk data specifically find ext ibm jfs designed handle sector failures failures file systems shown commit failed transactions disk lead problems including unmountable file system contrast find reiserfs part paranoid write failures specifically reiserfs crashes system write journal fails crashing manner reiserfs ensures file system integrity maintained cost potentially expensive restart configurations reiserfs abide general policy coerced committing failed transactions result corrupted file system reiserfs assumes failures transient repeated failure block result repeated crashes restarts rest paper organized give introduction journaling file systems explain methodology analyzing journaling file systems discuss results analysis ext reiserfs jfs present related work finally conclude background file system update takes place set blocks written disk system crashes middle sequence writes file system left inconsistent state repair inconsistency earlier systems ffs ext scan entire file system perform integrity checks fsck mounting file system scan time-consuming process hours large file systems journaling file systems avoid expensive integrity check recording extra information disk form write-ahead log writes successfully committed log transfered final fixed locations disk process transferring writes log fixed location disk referred checkpointing crash occurs middle checkpointing file system recover data log write fixed locations modern file systems provide flavors journaling subtle differences update behavior disk discuss approaches data journaling ordered journaling writeback journaling journaling modes differ kind integrity provide type data write log order data written data journaling strongest data integrity block written disk irrespective data metadata block written log transaction committed journaled data written fixed file system locations writeback journaling logs file system metadata enforce ordering data writes journal writes ensuring metadata consistency writeback journaling guarantee data consistency specifically file metadata updated in-place data reaches disk file data contents data block ordered journaling adds data consistency writeback mode enforcing ordering constraint writes data blocks written fixed locations metadata blocks committed ordering constraint ensures file system metadata points corrupt data methodology section describe methodology testing reliability journaling file systems basic approach simple inject disk faults beneath file system key points operation observe resultant behavior testing framework shown figure consists main components device driver called fault-injection driver user-level process labeled coordinator driver positioned file system disk observe traffic file system inject faults points stream coordinator monitors controls entire process informing driver specific fault insert running workloads top file system observing resultant behavior flow diagram benchmarking process shown figure describe entire process detail fault-injection driver fault-injection driver driver pseudodevice driver appears typical block device file system internally simply interposes requests real underlying disk driver main roles system classify block written disk based type specific file-system data structure write represents developed techniques perform classification simply employ techniques driver model journaling file system specifically model represents correct sequence states transaction committing disk inserting failures specific points transaction sequence observe file system handles types faults judge correctly handles faults injected driver inject faults system faults occur state transitions based model file system stream coordinator coordinator monitors entire benchmarking process inserts fault-injection driver linux kernel coordinator constructs file system passes fault specification driver spawns child process run workload errors running tests coordinator process moves file system state mounting file system cleanly depending type block fail coordinator process passes fault specification driver spawns child process run workload top file system expected block written file system driver injects linux vfs layer jfsreiserfsext idescsi log system log workload fault injection driver ioctl coordinator block match fault pass request disk inject fault block match model pass error file system receive file system read write requests save fault specification model build journaling specification classify block types report error yesno yesno coordinator figure benchmarking framework algorithm flow figure shows benchmarking framework measure fault tolerance journaling file systems write failures main components figure user level process issues fault sba driver classifies blocks injects faults figure shows simplified flowchart benchmarking algorithm implemented sba driver fault failing block write errors manifest numerous locales log errors coordinator collate specifically child process receive errors file system driver observe errors sequence state transitions coordinator system logs errors reported file system reflected calling child process journaling models describe model journaling file systems explained section journaling modes journaling modes differs type data journals order writes blocks build model journaling modes based functionality models represent journaling modes type data accept order data written model ordered journaling mode specifies ordered data written metadata committed log build models construct regular expression journaling mode regular expressions represent journaling modes concisely easy construct understand build model based regular expression figure shows models journaling mode journaling models consist states states represent state on-disk file system ondisk file system moves state based type write receives file system track state change moving correspondingly model explain 
briefly regular expression journaling mode represent journal writes represent data writes represent journal commit writes represent journal super block writes represent checkpoint data writes represent write failures data journaling data journaling expressed regular expression data journaling mode file system writes journaled represented ordered unordered writes writing journal blocks commit block represented byc written file system mark end transaction file system write transactions log transactions committed file system write checkpoint blocks represented fixed locations journal super block represented mark head tail journal convert regular expression state diagram shown figure add failure state ordered journaling ordered journaling exs data journaling model ordered journaling model writeback journaling model figure journaling models figure shows models verifying journaling modes model built based regular expression state represents state reached write failure added models represents journal writes represents data writes represents journal commit writes represents checkpoint writes represents journal super block writes represents write failure pressed regular expression ordered mode ordered data writes written metadata blocks committed journal note data blocks parallel journal writes writes commit block written commit block written transaction transactions similar data journaling file system write checkpoint blocks journal super block transactions regular expression converted state diagram failure state added shown figure writeback journaling writeback journaling regular expression writeback journaling mode unordered data written time file system written journal writes journal writes commit block written transaction committed file system write journal super block checkpoint blocks unordered writes writeback journaling model figure obtained regular expression adding state error model error model assume latent errors originate storage subsystem errors accurately modeled software-based fault injection linux low-level errors reported file system uniform manner errors device-driver layer errors inject block write stream attributes similar classification faults injected linux kernel coordinator passes fault specification fault-injection driver attributes specifies file system test driver understands ext reiserfs ibm jfs file system semantics attribute specifies block type determines request traffic stream failed request types supported file systems attribute change file system request failed dynamically-typed journal commit block statically typed journal super block long determines fault injected transient error fails requests succeeds permanent fails subsequent requests failure classification classify ways file system fail due write failures type losses incur write failure loss file system handles write failure properly prevents data corrupted lost data corruption case write failures lead data corruption metadata corruption file system metadata structures remain consistent data files corrupted type failure occur data block pointers metadata blocks point invalid contents disk note type errors detected fsck data loss type failure file data lost due transient permanent write failures data loss occur data block pointers updated correctly files directories loss case file system metadata corrupted result lost files directories unmountable file system write failures happen file system corrupt important metadata blocks super block group descriptors result unmountable file system crash write failures lead file system reactions system-wide crash failure initiated explicit call panic due reasons dereferencing null pointer semantic fault injection question address fault injection technique file-system aware conduct similar analysis semantic knowledge device driver fail disk writes understands file system block types transaction boundaries high-level information driver type block receives determine failing journal block data block information important file systems behave differently block-write failures reiserfs crashes journal write failures crash data-block write failures depending type block failed file system errors vary data corruption unmountable file systems filesystem knowledge answer file system fails higher-level semantic knowledge enables identify design flaws identified fault injection performed semantic information analysis putting fault injection conclude methodology section fault injected journaling model figure shows sequence steps fault-injection driver track file system writes inject fault failing commit block write transaction ordered journaling mode step figure captures transition state initially transaction starts set ordered data writes figure data writes journal blocks logged figure commit block written data journal writes failed figure file system oblivious commit block failure continue checkpoint journaled blocks figure file system recognize failure steps figure fault injection figure shows sequence steps fault-injection driver track file system writes fail specific writes prevent file system corruption moving state figure state file system abort failed transaction bad block remapping remount read-only crash system sufficient block types inject fault file system requests model fault-injection driver reason requests write failure belong failed transaction transactions file system keeping track writes journaling model fault-injection driver explain block write failure leads file system errors fault injection experiments statistical carefully choose fault injection points inject faults main points ordered data writes journal writes commit writes checkpoint writes superblock writes journal writes perform fault injection journal metadata journal data blocks fault injection experiment proceeds file system tested freshly created files directories needed testing created fault specification attributes passed sba driver controlled workload creating file directory generate block write failed run child process driver injects fault reports file system writes violate journaling model fault injected coordinator collects error logs child process system log driver process automated error logs interpreted manually figure extent file system damaged extraneous writes analysis section explain failure analysis linux based journaling file systems ext reiserfs ibm jfs ext analysis ext journaling file system based ext file system ext logs file system writes journal block level types journal metadata blocks track transactions blocks logged journal descriptor blocks store fixed location block numbers journaled data journal revoke blocks prevent file system replaying data replayed recovery journal commit blocks mark end transactions journal super block stores information journal head tail transaction journal metadata blocks log stores journal data blocks journaled versions fixed location blocks ext designed journal metadata blocks journal super block descriptor block revoke block commit block magic number identifies journal metadata blocks journal metadata blocks sequence number denotes transaction number transaction occur recovery block read journal correct magic number treated journal data block magic number sequence number match transaction expected blocks skipped based ext analysis found design flaws handling write failures committing failed transactions write transaction fails ext continues write transaction log commits fixing failed write affect file system integrity ordered data write fails ordered journaling mode expect file system abort transaction commits transaction metadata blocks end pointing wrong data contents disk problem occurs 
ext failure ordered write data corruption checkpointing failed transactions write transaction fails file system checkpoint blocks journaled part transaction checkpointing crash occurs file system replay failed transaction properly recovery phase result corrupted file system ext commits transaction transaction write fails committing failed transaction ext checkpoints blocks journaled transaction depending journaling mode checkpointing partial complete partial checkpointing cases ext checkpoints blocks failed transaction data journaling mode journal descriptor block journal commit block write fails cases checkpointing file system metadata blocks transaction checkpointed data blocks checkpointed data journaling mode file created data blocks transaction descriptor block fails metadata blocks file inode data bitmap inode bitmap directory data directory inode blocks written fixed locations data blocks file journaled data journaling mode written data blocks written fixed locations metadata blocks file end pointing wrong contents disk complete checkpointing ordered writeback journaling mode file system metadata blocks journaled data blocks written log modes ext checkpoints journaled blocks failed transaction describe generic case file system corruption transactions committed block journaled blocks journaled assume transaction fails file system continues checkpoint blocks failed transaction crash occurs writing blocks fixed locations file system log recovery runs mount recovery transaction recovered failed transaction recovered contents block overwritten contents recovery file system inconsistent state block transaction block transaction problem occurs ext happen journal metadata block descriptor block revoke block commit block fails lead file system corruptions resulting loss files inaccessible directories replaying failed checkpoint writes checkpointing process writing journaled blocks log fixed locations checkpoint write fails file system attempt write mark journal checkpoint write happen log replay ext replay failed checkpoint writes data corruption data loss loss files directories replaying transactions journaling file systems maintain state variable mark log dirty clean file system mounted log dirty transactions log replayed fixed locations journaling file systems update state variable starting transaction checkpointing transaction write update state variable fails things possibly happen file system replay transaction replayed fail replay transaction recovery replaying transaction integrity problems possibility replaying journal contents lead corruption loss data files directories ext maintains journal state journal super block ext clears field writes journal super block clean journal mark journal dirty journal super block written non-zero field journal super block write fails ext attempt write save super block locations journal super block failure ext continues commit transactions log journal super block written mark journal dirty failed journal appears clean mount transaction needed replay due previous crash ext fails replay result lost files directories replaying failed transactions journal data block write fails transaction aborted replayed transaction replayed journal data blocks invalid contents read written fixed location handled properly lead file system errors earlier ext abort failed transactions continues commit log recovery write invalid contents file system fixed location blocks corrupt important file system metadata result unmountable file system show created transaction journaled group descriptor block file system failed journal write group descriptor block ext committed transaction failed mark invalid commit crashed file system forced ext recovery mount recovery ext read block journal supposed group descriptor block overwrote fixed location group descriptor block invalid contents journal corrupted group descriptor block resulted unmountable file system ext summary find ext designed system crash mind ext effectively handle single block write failures features ext designed ext crash entire system failed writes magic numbers transaction ids journal metadata blocks ext prevents replay invalid contents main weakness ext design abort failed transactions continues commit lead file system errors ranging data corruption unmountable file system found ext logs empty transactions transactions blocks commit block affect integrity result unnecessary disk traffic reiserfs analysis journaling reiserfs similar ext reiserfs circular log capture journal writes logs file system writes block level reiserfs supports journaling modes journal metadata blocks journal descriptor block journal commit block journal super block describe transactions fixed location blocks journal metadata blocks reiserfs magic number transaction number similar ext based analysis found design flaws reiserfs crashing file system write fails reiserfs time crashes file system making panic call necessitates entire system rebooted affect processes running reiserfs affects processes running system crashing entire file system single write error benefit journal write journal data journal metadata fails system crashes failed transaction committed disk system boots mounts file system reiserfs performs recovery recovery replays transactions successfully committed failed transaction failed transactions committed replayed file system remains consistent state recovery avoids problems ext checkpointing failed transactions replaying successful transactions replaying failed transactions words reiserfs converts problem fail-stutter fault tolerance fail-stop journal block write fails reiserfs repeatedly crash system reiserfs crashes system checkpoint write fails crash recovery takes place failed checkpoint write replayed properly note works fine transient write failures permanent write errors reiserfs requires fsck run handle replay failures crashing checkpoint write failures prevents problem replaying failed checkpoint writes ext committing failed transactions write failures reiserfs crash continues commit failed transaction ordered journaling mode ordered data block write fails reiserfs journals transaction commits handling write error result corrupted data blocks failed transactions metadata blocks file system end pointing invalid data contents reiserfs uniform failure handling policy crashes write failures file system corruption prevented reiserfs crashing system ordered write failures reiserfs summary find reiserfs avoids mistakes ext expensively cost crashing entire file system basically reiserfs converts fail-stutter system fail-stop handle write errors find committing failed transaction reiserfs desirable design decision solve problems ext block write errors permanent reiserfs make system unusable repeated crashing model find bug reiserfs linux data journaling mode version behaving ordered journaling mode journaling model find bugs semantics journaling violated jfs analysis ibm jfs works ordered journaling mode unlike ext reiserfs support data writeback journaling modes jfs differs ext reiserfs information written log ext reiserfs log blocks journal jfs writes records modified blocks log ordered data block writes written blocks similar file systems jfs record level journaling log blocks classified journal data blocks journal commit blocks single log write journal data records commit records hard separate commit record journal records transactions small fit single journal block modified ordered journaling model work jfs record level journaling performed failure analysis jfs found design mistakes crashing file system similar reiserfs jfs crashes file system 
write failures system crashes journal super block write fails mount operation earlier crashing system affects processes running system crashing system graceful provide fault tolerance write errors permanent replaying failed checkpoint writes checkpoint block write fails jfs attempt rewrite mark transaction replay jfs simply ignores error lead corrupted file system behavior similar ext file systems record failed checkpoint writes identifying transactions replayed committing failed transactions found journaling file systems commit failed transaction ordered block write failure jfs notify application ordered write failure commits transaction lead data corruption failing recover journal block write fails jfs abort failed transaction commits crash journal write failure logredo routine jfs fails unrecognized log record type lead unmountable file system jfs summary jfs design flaws ext reiserfs jfs commits failed transactions replay failed checkpoint writes crashes file system reiserfs journal super block write failures found bug jfs jfs flush blocks file sync call created sized file called fsync file descriptor fsync call returned flushing blocks ext reiserfs ibm jfs committing failed transactions checkpointing failed transactions replaying failed checkpoint writes replaying transactions replaying failed transactions crashing file system table design flaws table summary type design flaws identified ext reiserfs ibm jfs ext reiserfs ibm jfs block type journal descriptor block journal revoke block journal commit block journal super block journal data block checkpoint block data block table analysis summary table presents summary type failures occur ext reiserfs ibm jfs block writes fail data block represents ordered unordered writes ext reiserfs represents ordered writes jfs dcmeans data corruption means data loss fdl means files directory loss ufs means unmountable file system means crash means block type file system jfs separate commit revoke blocks records type journal expect file system write metadata blocks file disk analysis summary summary analysis presented table table table lists design flaws identified linux journaling file systems table types file system failures happen block writes fail find linux journaling file systems uniform failure handling policies handle fail-stutter systems related work section discuss related work talk related work fault injection general specific work file storage systems testing fault injection fault injection long time measure robustness systems koopman argues faults injected directly modules test give representative results dependability evaluation fault injected external environments module test fault activated inputs real execution similar approach inject faults external file system module activate running workloads top file system software simulate effects hardware faults inject faults dynamically determining block types file system ftape tool performs dynamic workload measurements inject faults automatically determining time location maximize fault propagation fiat early systems fault injection techniques simulate occurrences hardware errors changing contents memory registers fine tool developed kao inject hardware induced software faults unix kernel trace execution flow kernel recent work fault injection techniques test linux kernel behavior errors file storage system testing file system testing tools test file system api types invalid arguments siewiorek develop benchmark measure system robustness test dependability file system libraries similarly koopman ballista testing suite find robustness problems safe fast sfio library test file system robustness model checking techniques apply file system code recent work yang model checking comprehensively find bugs file systems ext reiserfs jfs formal verification techniques systematically enumerate set file system states verify valid file system states work identify problems deadlock null pointers work focuses file systems handle latent sector errors previous work studied reliability storage systems brown developed method measure system robustness applied measure availability software raid systems linux solaris windows emulate disk disk emulator inject faults test software raid systems work targets file systems file system knowledge carefully select fail specific block types don require semantic information fault injection studies evaluated raid storage systems reliability availability studies developed detailed simulation models raid storage arrays network clusters obtain dependability measures conclusion paper propose evaluate robustness journaling file systems disk write failures build semantic models journaling modes semantic block-level analysis technique inject faults file system disk requests evaluate widely linux journaling file systems analysis find ext ibm jfs violate journaling semantics block write failures result corrupt file systems contrast reiserfs maintains file system integrity crashing entire system write failures permanent write failures result repeated crashes restarts based analysis identify design flaws correctness bugs file systems catastrophically affect on-disk data find modern file systems uniform failure handling policy jfs overview ibm developerworks library jfs html brown patterson maintainability availability growth benchmarks case study software raid systems proceedings usenix annual technical conference usenix pages san diego california june corbett english goel grcanac kleiman leong sankar row-diagonal parity double disk failure correction proceedings usenix symposium file storage technologies fast pages san francisco california april devale koopman performance evaluation exception handling libraries dependable systems networks june gray reuter transaction processing concepts techniques morgan kaufmann kalbarczyk ravishankar yang characterization linux kernel behavior error dependable systems networks pages june huang kalbarczyk iyer dependability analysis cache-based raid system fast distributed simulation ieee symposium reliable distributed systems barton czeck fault injection experiments fiat ieee transactions computers volume pages april kaniche romano kalbarczyk iyer karcich hierarchical approach dependability analysis commercial cache-based raid storage architecture twenty-eighth annual international symposium fault-tolerant computing june koopman wrong fault injection dependability benchmark workshop dependability benchmarking conjunction dsn washington july lun kao iyer tang fine fault injection monitoring environment tracing unix system behavior faults ieee transactions software engineering pages mckusick joy leffler fabry fsck unix file system check program unix system manager manual bsd virtual vaxversion april prabhakaran arpaci-dusseau arpaci-dusseau analysis evolution journaling file systems proceedings usenix annual technical conference usenix april reiser reiserfs namesys schneider implementing fault-tolerant services state machine approach tutorial acm computing surveys december siewiorek hudak suh segal development benchmark measure system robustness twenty-third international symposium fault-tolerant computing sweeney doucette anderson nishimoto peck scalability xfs file system proceedings usenix annual technical conference usenix san diego california january tsai iyer measuring fault tolerance ftape fault injection tool intl conf modeling techniques tools conp perf evaluation pages sept tweedie journaling linux ext file system fourth annual linux expo durham north carolina yang twohey engler musuvathi model checking find file system errors proceedings symposium operating systems design implementation osdi san francisco california december 

journal-guided resynchronization software raid timothy denehy andrea arpaci-dusseau remzi arpaci-dusseau department computer sciences wisconsin madison abstract investigate problem slow scan-based software raid resynchronization restores consistency system crash augmenting raid layer quicken process leverage functionality present journaling file system analyze linux ext introduce mode operation declared mode guarantees provide record outstanding writes case crash utilize information augment software raid interface verify read request repairs redundant information block combination features provide fast journal-guided resynchronization evaluate effect journal-guided resynchronization find improved software raid reliability availability crash suffering performance loss normal operation introduction providing reliability storage level entails raid prevent data loss case disk failure high-end storage arrays specialized hardware provide utmost performance reliability solutions multimillion dollar price tags infeasible small medium businesses organizations cost-conscious users turn commodity systems collection disks house data popular low-cost solution reliability arena software raid range platforms including linux solaris freebsd windows-based systems software-based approach attractive specialized cluster-in-a-box systems instance emc centera storage system built cluster commodity machines linux software raid manage disks life storage arrays pay case software raid lack non-volatile memory introduces consistent update problem specifically write issued raid layer disks updated consistent manner possibility crashes makes challenge raidarray untimely crash occurs parity write completes data block written writes issued parallel completed stripe left inconsistent state inconsistency introduces window vulnerability data disk fails stripe made consistent data disk lost automatic reconstruction missing data block based inconsistent parity silently return bad data client hardware raid circumvents problem gracefully non-volatile memory buffering update nvram disks consistently updated hardware-based approach avoids window vulnerability outcome ideal performance reliability excellent current software-based raid approaches performance reliability trade-off made current software raid implementations choose performance reliability simply issue writes disks parallel hoping untimely crash occur crash occur systems employ expensive resynchronization process scanning entire volume discrepancies found repaired large volumes process hours days alternate software raid approach chooses reliability performance applying write-ahead logging array record location pending updates issued systems avoid time-consuming resynchronization recovery raid simply repairs locations recorded log removing window vulnerability high performance cost update raid preceded synchronous write log greatly increasing total load disks solve consistent update problem software raid develop solution high performance reliability global view storage stack leverage functionality layers system assist cases client software raid system modern journaling file system default linux file system ext reiserfs jfs windows ntfs standard journaling techniques maintain consistency file system data structures solve consistent update problem raid level find journaling readily augmented specifically introduce mode operation linux ext declared mode writing permanent locations declared mode records intentions file system journal functionality guarantees record outstanding writes event crash consulting activity record file system blocks midst updated dramatically reduce window vulnerability crash complete process file system communicate information vulnerabilities raid layer purpose add interface software raid layer verify read receiving verify read request raid layer reads requested block mirror parity group verifies redundant information irregularity found raid layer re-writes mirror parity produce consistent state combine features integrate journal-guided resynchronization file system recovery process record write activity vastly decreases time needed resynchronization cases period days mere seconds approach avoids performance reliability trade-off found software raid systems performance remains high window vulnerability greatly reduced general key solution cooperative nature removing strict isolation file system software raid layer subsystems work solve consistent update problem sacrificing performance reliability rest paper organized section illustrates software raid consistent update problem quantifies likelihood crash lead data vulnerability section introduction ext file system operation section analyze ext write activity introduce ext declared mode addition software raid interface merge raid resynchronization journal recovery process section evaluates performance declared mode effectiveness journal-guided resynchronization discuss related work section conclude section consistent update problem introduction task raid maintain invariant data redundant information stores invariants provide ability recover data case disk failure raidthis means mirrored block data parity schemes raidthis means parity block stripe stores exclusive-or data blocks blocks reside disk updates applied atomically maintaining invariants face failure challenging crash occurs write array blocks left inconsistent state mirror successfully written disk data block written parity update note consistent update problem solutions distinct traditional problem raid disk failures failure occurs redundant information array lost data vulnerable disk failure situation solved process reconstruction regenerates data located failed disk failure models illustrate consistent update problem shown figure diagram depicts state single stripe blocks disk raidar- ray time progresses left software raid layer residing machine servicing write data block update parity block machine issues data block write time written disk time machine notified completion time similarly parity block issued time written time notification arrives time data write block time stripe enters window vulnerability denoted shaded blocks time failure disks result data loss stripe data parity blocks exist inconsistent state data residing failed disk reconstructed inconsistency corrected time write failure models possibility independent failures host machine time cpczip zdisk array machine figure failure scenarios diagram illustrates sequence events data block write parity update disk raidarray time progresses left boxes labeled request issued labeled represent completions shaded blocks denote window vulnerability array disks discuss turn relate consequences figure machine failure model includes events operating system crashes machine power losses machine crashes times array remains active stripe left inconsistent state write completes time model disk failure model considers power losses disk array failure occurs time time stripe left vulnerable state note disk failure model encompasses non-independent failures simultaneous power loss machine disks measuring vulnerability determine crash failure leave array inconsistent state instrument linux software raidlayer scsi driver track statistics record amount time write issued stripe write issued stripe measures difference times figure corresponds directly period vulnerability machine failure model record amount time write completion stripe write completion stripe measures difference time time note vulnerability disk failure model occurs time time measurement approximation results slightly overestimate underestimate actual vulnerability depending vulnerable time number writers software raid vulnerability disk failure model write completion machine failure model write issue figure software raid vulnerability graph plots percent time duration experiment inconsistent disk state exists raidarray number writers increases x-axis vulnerabilities due disk failure machine failure plotted separately time takes completion processed host machine finally track number stripes 
vulnerable models calculate percent time stripe array vulnerable type failure test workload consists multiple threads performing synchronous random writes set files array experiments performed intel pentium xeon ghz processor ram running linux kernel machine ibm lzx disks configured software raidarray raid volume sufficiently large perform benchmarks small reduce execution time resynchronization experiments figure plots percent time duration experiment array stripe vulnerable number writers workload increased x-axis expected cumulative window vulnerability increases amount concurrency workload increased vulnerability disk failure model greater dependent response time write requests small number writers disk failure result inconsistent state higher concurrency array exists vulnerable state length experiment period vulnerability machine failure model lower depends processing time needed issue write requests experiment vulnerability reaches approximately higher concurrencies ability issue requests impeded full disk queues case machine vulnerability depend disk response time increase solutions solve problem high-end raid systems make non-volatile storage nvram write request received log request data written nvram updates propagated disks event crash log records data present nvram replay writes disk ensuring consistent state array functionality expense terms raw hardware cost developing testing complex system software raid hand frequently employed commodity systems lack non-volatile storage system reboots crash record write activity array indication raid inconsistencies exist linux software raid rectifies situation laboriously reading contents entire array checking redundant information correcting discrepancies raidthis means reading data mirrors comparing contents updating states differ raidscheme stripe data read parity calculated checked parity disk re-written incorrect approach fundamentally affects reliability availability time-consuming process scanning entire array lengthens window vulnerability inconsistent redundancy lead data loss disk failure additionally disk bandwidth devoted resynchronization deleterious effect foreground traffic serviced array exists fundamental tension demands reliability availability allocating bandwidth recover inconsistent disk state reduces availability foreground services giving preference foreground requests increases time resynchronize observed brown patterson default linux policy addresses trade-off favoring availability reliability limiting resynchronization bandwidth disk slow rate equate days repair time vulnerability moderately sized arrays hundreds gigabytes figure illustrates problem plotting analytical model resynchronization time disk array raw size array increases x-axis disks default linux policy minutes time scan repair gigabyte disk space equates half days terabyte capacity disregarding availability array modern interconnects approximately hour full bandwidth resynchronize terabyte array days days hours hour mins time raw array size software raid resynchronization time linux default disk gigabit ethernet sata fibre channel ultra scsi serial attached scsi figure software raid resynchronization time graph plots time resynchronize disk array raw capacity increases x-axis solution problem add logging software raid system manner similar discussed approach suffers drawbacks logging array disks decrease performance array interfering foreground requests high-end solution discussed previously benefits fast independent storage form nvram adding logging maintaining acceptable level performance add considerable complexity software instance linux software raid implementation buffering discarding stripes operations complete logging solution buffer requests significantly order batch updates log improve performance solution perform intent logging bitmap representing regions array mechanism solaris volume manager veritas volume manager provide optimized resynchronization implementation linux software raidis development merged main kernel logging array approach suffer poor performance instance linux implementation performs synchronous write bitmap updating data array ensure proper resynchronization performance improved increasing bitmap granularity cost performing scanbased resynchronization larger regions software raid layer storage hierarchy configuration modern journaling file system layer logging disk updates maintain consistency on-disk data structures sections examine journaling file system solve software raid resynchronization problem ext background section discuss linux ext file system operation data structures details analysis write activity description modifications support journal-guided resynchronization section focus ext techniques general apply journaling file systems reiserfs jfs linux ntfs windows linux ext modern journaling file system aims complex on-disk data structures consistent state file system updates written log called journal journal records stored safely disk updates applied home locations main portion file system updates propagated journal records erased space occupied re-used mechanism greatly improves efficiency crash recovery crash journal scanned outstanding updates replayed bring file system consistent state approach constitutes vast improvement previous process fsck relied full scan file system data structures ensure consistency natural make journaling mechanism improve process raid resynchronization crash modes ext file system offers modes operation data-journaling mode ordered mode writeback mode data-journaling mode data metadata written journal coordinating updates file system strong consistency semantics highest cost data written file system written journal home location ordered mode ext default writes file system metadata journal file data written directly home location addition mode guarantees strict ordering writes file data transaction written disk metadata written journal committed guarantees file metadata data block written mechanism strong consistency data-journaling mode expense multiple writes file data writeback mode file system metadata written journal ordered mode file data written directly home location unlike ordered mode writeback mode ordering guarantees metadata data offering weaker consistency instance metadata file creation committed journal file data written event crash journal recovery restore file metadata contents filled arbitrary data writeback mode purposes weaker consistency lack write ordering transaction details reduce overhead file system updates sets grouped compound transactions transactions exist phases lifetimes transactions start running state file system data metadata updates current running transaction buffers involved linked in-memory transaction data structure ordered mode data running transaction written time kernel pdflush daemon responsible cleaning dirty buffers periodically running transaction closed transaction started occur due timeout synchronization request transaction reached maximum size closed transaction enters commit phase buffers written disk home locations journal transaction records reside safely journal transaction moves checkpoint phase data metadata copied journal permanent home locations crash occurs checkpoint committed transaction checkpointed journal recovery phase mounting file system checkpoint phase completes transaction removed journal space reclaimed journal structure tracking contents journal requires file system structures journal superblock stores size journal file pointers head tail journal sequence number expected transaction journal transaction begins descriptor block lists permanent block addresses subsequent data metadata blocks descriptor block needed depending number blocks involved transaction finally commit block signifies end transaction descriptor blocks commit blocks begin magic header sequence number identify transaction design implementation goal resynchronization correct raid inconsistencies result system crash failure identify outstanding write requests time crash significantly narrow range blocks inspected result faster resynchronization 
improved reliability availability hope recover record outstanding writes file system journal end begin examining write activity generated phase ext transaction ext write analysis section examine ext transaction operations detail emphasize write requests generated phase characterize disk states resulting crash specifically classify write request targeting location unknown location bounded location based record activity journal goal restarting system failure recover record outstanding write requests time crash running ext ordered mode pdflush daemon write dirty pages disk transaction running state crash occurs state affected locations unknown record ongoing writes exist journal commit ext writes un-journaled dirty data blocks transaction home locations waits complete step applies ordered mode data datajournaling mode destined journal crash occurs phase locations outstanding writes unknown ext writes descriptors journaled data metadata blocks journal waits writes complete ordered mode metadata blocks written journal blocks written journal data-journaling mode system fails phase specific record ongoing writes exist writes bounded fixed location journal ext writes transaction commit block journal waits completion event crash outstanding write bounded journal block type data-journaling mode superblock fixed location journal bounded fixed location home metadata journal descriptors home data journal descriptors block type ordered mode superblock fixed location journal bounded fixed location home metadata journal descriptors home data unknown table journal write records table lists block types written transaction processing locations determined crash checkpoint ext writes journaled blocks home locations waits complete system crashes phase ongoing writes determined descriptor blocks journal affect locations ext updates journal tail pointer superblock signify completion checkpointed transaction crash operation involves outstanding write journal superblock resides fixed location recovery ext scans journal checking expected transaction sequence numbers based sequence journal superblock records committed transaction ext checkpoints committed transactions journal steps write activity occurs locations table summarizes ability locate ongoing writes crash data-journaling ordered modes ext case data-journaling mode locations outstanding writes determined bounded crash recovery journal descriptor blocks fixed location journal file superblock existing ext datajournaling mode amenable assisting problem raid resynchronization side data-journaling typically performance ext family ext ordered mode hand data writes permanent home locations recorded journal data structures located crash recovery address deficiency modified ext ordered mode declared mode ext declared mode previous section concluded crash occurs writing data directly permanent location ext ordered mode journal record outstanding writes locations raid level inconsistencies caused writes remain unknown restart overcome deficiency introduce variant ordered mode declared mode declared mode differs ordered mode key guarantees write record data block resides safely journal location modified effectively file system declare intent write permanent location issuing write track intentions introduce journal block declare block set declare blocks written journal beginning transaction commit phase collectively list permanent locations data blocks transaction written construction similar descriptor blocks purpose descriptor blocks list permanent locations blocks journal declare blocks list locations blocks journal descriptor commit blocks declare blocks begin magic header transaction sequence number declared mode adds single step beginning commit phase proceeds declared commit ext writes declare blocks journal listing permanent data locations written part transaction waits completion ext writes un-journaled data blocks transaction home locations waits complete ext writes descriptors metadata blocks journal waits writes complete ext writes transaction commit block journal waits completion declare blocks beginning transaction introduce additional space cost journal cost varies number data blocks transaction case declare block added data blocks space overhead worst case declare block needed transaction single data block investigate performance consequences overheads section implementing declared mode linux requires main guarantee data buffers written disk declared journal accomplish refrain setting dirty bit modified pages managed file system prevents pdflush daemon eagerly writing buffers disk running state mechanism metadata buffers data buffers data-journaling mode ensuring written written journal track data buffers require declarations write declare blocks beginning transaction start adding declare tree in-memory transaction structure ensure declared mode data buffers tree existing data list beginning commit phase construct set declare blocks buffers declare tree write journal writes complete simply move buffers declare tree existing transaction data list tree ensures writes occur efficient order sorted block address point commit phase continue modification implementation minimizes shared commit procedure ext modes simply bypass empty declare tree software raid interface initiating resynchronization file system level requires mechanism repair suspected inconsistencies crash viable option raidarrays file system read re-write blocks deemed vulnerable case inconsistent mirrors newly written data data restored block achieves results current raidresynchronization process raidlayer imposes ordering mirrored updates differentiate data data chooses block copy restore consistency read re-write strategy unsuitable raidhowever file system re-writes single block desired behavior raid layer calculate parity entire stripe data raid layer perform read-modify-write reading target block parity re-calculating parity writing blocks disk operation depends consistency data parity blocks reads disk consistent produce incorrect results simply prolonging discrepancy general interface required file system communicate inconsistencies software raid layer options interface requires file system read vulnerable block re-write explicit reconstruct write request option raid layer responsible reading remainder block parity group re-calculating parity writing block parity disk dissuaded option perform unnecessary writes consistent stripes vulnerabilities event crash opt add explicit verify read request software raid interface case raid layer reads requested block rest stripe checks make parity consistent newly calculated parity written disk correct problem linux implementation verify read request straight-forward file system wishes perform verify read request marks buffer head raid synchronize flag receiving request software raidlayer identifies flag enables existing synchronizing bit stripe bit perform existing resynchronization process presence read entire stripe parity check functionality required verify read request finally option added software raidlayer disable resynchronization crash significant modification strict layering storage stack raid module asked entrust functionality component good system apprehensive software raid implementation delay efforts hopes receiving verify read requests file system requests arrive start resynchronization ensure integrity data parity blocks recovery resynchronization ext data-journaling mode declared mode guarantees accurate view outstanding write requests time crash restart utilize information verify read interface perform fast file system guided resynchronization raid layer make file system journal ordering constraints operations combine process journal recovery dual process file system recovery raid resynchronization proceeds recovery resync ext performs verify reads superblock journal superblock ensuring consistency case written crash ext 
scans journal checking expected transaction sequence numbers based sequence journal superblock records committed transaction committed transaction journal ext performs verify reads home locations listed descriptor blocks ensures integrity blocks undergoing checkpoint writes time crash transaction examined checkpoints occur order checkpointed transaction removed journal processed note verify reads place writes replayed guarantee parity up-to-date adding explicit reconstruct write interface mentioned earlier negate step process ext issues verify reads committed transaction head journal length maximum transaction size corrects inconsistent blocks result writing transaction journal reading ahead journal ext identifies declare blocks descriptor blocks uncommitted transaction descriptor blocks found performs verify reads permanent addresses listed declare block correcting data writes outstanding time crash declare blocks transactions descriptors presence constitutes evidence completion data writes permanent locations ext checkpoints committed transactions journal section implementation re-uses existing framework journal recovery process issuing verify reads means simply adding raid synchronize flag buffers reading journal replaying blocks verify reads locations listed descriptor blocks handled replay writes processed journal verify reads declare block processing uncommitted transaction performed final pass journal recovery bandwidth random write performance ext ordered sorted ext declared ext ordered ext journaled slowdown amount written figure random write performance top graph plots random write performance amount data written increased x-axis data-journaling mode achieves writing data bottom graph shows relative performance declared mode compared ordered mode sorting evaluation section evaluate performance ext declared mode compare ordered mode datajournaling mode hope declared mode adds overhead writing extra declare blocks transaction performance evaluation examine effects journal-guided resynchronization expect greatly reduce resync time increase bandwidth foreground applications finally examine complexity implementation ext declared mode begin performance evaluation ext declared mode microbenchmarks random write sequential write test performance random writes existing file call fsync end experiment ensure data reaches disk figure plots bandwidth achieved ext mode amount written increased x-axis graphs plot experimental trials identify points interest graph data-journaling mode underperforms ordered mode amount written increases note data-journaling mode achieves writing data random write stream transformed large sequential write fits journal amount data written increases outgrows size journal performance datajournaling decreases block written journal home location ordered mode garners performance writing data directly permanent location bandwidth sequential write performance ext ordered ext declared ext journaled slowdown amount written figure sequential write performance top graph plots sequential write performance amount data written increased x-axis bottom graph shows relative performance declared mode compared ordered mode find declared mode greatly outperforms ordered mode amount written increases tracing disk activity ordered mode reveals part data issued disk sorted order based walking dirty page tree remainder issued unsorted commit phase attempts complete data writes transaction adding sorting commit phase ordered mode solves problem evidenced performance plotted graph rest performance evaluations based modified version ext ordered mode sorted writing commit finally bottom graph figure shows slowdown declared mode relative ordered mode sorting performance modes extremely close differing experiment tests sequential write performance existing file figure plots performance ext modes amount written increased x-axis fsync ensure data reaches disk ordered mode declared mode greatly outperform data-journaling mode achieving compared bottom graph figure shows slowdown ext declared mode compared ext ordered mode declared mode performs ordered mode data points disk traces reveal performance loss due fact declared mode waits fsync begin writing declare blocks data ordered mode begins writing data disk slightly earlier declared mode alleviate delay implement early declare mode begins writing declare blocks journal data blocks modified fill declare block operations sprite microbenchmark create phase ext ordered ext declared ext journaled slowdown number files figure sprite create performance top graph plots performance create phase sprite lfs microbenchmark number files increases x-axis bottom graph shows slowdown declared mode compared ordered mode modification result performance improvement early writing declare blocks data blocks offset seek activity journal home data locations shown examine performance sprite lfs microbenchmark creates reads unlinks number files figure plots number create operations completed number files increased x-axis bottom graph shows slowdown declared mode relative ordered mode declared mode performs ordered mode cases performance declared mode ordered mode identical phases benchmark ssh benchmark unpacks configures builds version ssh program tarred compressed distribution file figure plots performance mode stages benchmark execution time stage normalized ext ordered mode absolute times seconds listed bar data-journaling mode slighter faster ordered mode configure phase slower build slower unpack declared mode comparable ordered mode running faster unpack configure slower build phase examine ext performance modified version postmark benchmark creates files directories performs number transactions deletes files directories modification involves addition call sync phase benchmark ensure data written disk unmodified version exhibits unusually high variances modes operation execution time benchmark shown figbuildconfigureunpack normalized execution time ssh benchmark ext ordered ext journaled ext declared figure ssh benchmark performance graph plots normalized execution time unpack configure build phases ssh benchmark compared ext ordered mode absolute execution times seconds listed bar execution time postmark ext journaled ext ordered ext declared slowdown number transactions figure postmark performance top graph plots execution time postmark benchmark number transactions increases x-axis bottom graph shows slowdown declared mode compared ordered mode ure number transactions increases axis data-journaling mode extremely slow concentrate modes identify interesting points large numbers transactions declared mode compares favorably ordered mode differing approximately worst cases small number transactions declared mode outperforms ordered mode disk traces reveal reason ordered mode relies sorting provided per-file dirty page trees write requests scattered disk declared mode sort performed commit global view data written transaction sending write requests device layer efficient order finally examine performance tpc-blike workload performs financial transaction execution time tpc-b ext journaled ext declared ext ordered slowdown number transactions figure tpc-b performance top graph plots execution time tpc-b benchmark number transactions increases x-axis bottom graph shows slowdown declared mode compared ordered mode files adds history record fourth file commits disk calling sync execution time benchmark plotted figure number transactions increased x-axis case declared mode consistently underperforms ext ordered mode approximately data-journaling mode performs slightly worse highly synchronous nature benchmark presents worst case scenario declared mode tpc-b transaction results small ext transaction data blocks descriptor block journaled metadata block commit block declare block 
beginning transaction adds overhead number writes performed benchmark compound problem data writes serviced parallel array disks accentuating penalty declare blocks examine problem test modified version benchmark forces data disk frequently effect increasing size application level transaction alternatively simulating concurrent transactions independent data sets figure shows results running tpc-b benchmark transactions interval calls sync increases x-axis interval increases performance declared mode datajournaling mode quickly converge ordered mode declared mode performs ordered mode sync intervals transactions conclusion find declared mode routinely outperforms data-journaling mode performance close ordered mode random write sequential write file creation microbenchmarks performs ordered mode macrobenchmarks execution time tpc-b varied sync intervals ext journaled ext declared ext ordered slowdown tpc-b transactions sync figure tpc-b varied sync intervals top graph plots execution time tpc-b benchmark interval calls sync increases x-axis bottom graph shows slowdown declared mode compared ordered mode ssh postmark worst performance declared mode occurs tpc-b small application-level transactions improves greatly effective transaction size increases results declared mode attractive option enabling journal-guided resynchronization journal-guided resynchronization final set experiments examine effect journal-guided resynchronization expect significant reduction resync time shortening window vulnerability improving reliability addition faster resynchronization increase amount bandwidth foreground applications crash improving availability compare journal-guided resynchronization linux software raid resync default rate rates availability versus reliability spectrum experimental workload consists single foreground process performing sequential reads set large files amount read bandwidth achieves measured intervals approximately seconds experiment machine crashed rebooted machine restarts raid resynchronization process begins foreground process reactivates figure shows series experiments plotting foreground bandwidth y-axis time progresses x-axis note origin x-axis coincides beginning resynchronization duration process shaded grey top left graph figure shows results default linux resync limit disk prefers availability reliability process takes seconds bandwidth time software raid resync default disk bandwidth time software raid resync disk bandwidth time software raid resync disk bandwidth time software raid resync journal-guided resync resync foreground vulnerability vulnerability type rate limit bandwidth window default default disk medium disk high disk journal-guided figure software raid resynchronization graphs plot bandwidth achieved foreground process performing sequential scans files software raid array system crash ensuing array resynchronization recovery period highlighted grey duration listed graphs bandwidth allocated resynchronization varied default disk disk disk final graph depicts recovery journal guidance table lists availability foreground service vulnerability array compared default resynchronization period seconds restart scan raw disk space raidarray time period foreground process bandwidth drops unimpeded rate resynchronization completes foreground process receives full bandwidth array linux resynchronization rate adjusted sysctl variable top graph figure shows effect raising resync limit disk representing middle ground reliability availability case resync takes seconds bandwidth afforded foreground activity drops bottom left graph resync rate set disk favoring reliability availability effect reducing resync time seconds foreground bandwidth drops period bottom graph figure demonstrates journal-guided resynchronization knowledge write activity crash performs work correct array inconsistencies process finishes seconds greatly reducing window vulnerability present previous approach foreground service activates access full bandwidth array increasing availability results experiments summarized table figure metric calculated period restart machine order compare default linux resynchronization resync processes sacrifice availability foreground bandwidth variability improve reliability array reducing vulnerability windows default journal-guided resync process hand improves availability foreground process reliability array reducing vulnerability default case important note execution time scan-based approach scales linearly raw size array journal-guided resynchronization hand dependent size journal expect complete matter seconds large arrays complexity table lists lines code counted number semicolons braces modified added linux software raid ext file system journaling modules modifications needed add verify read interface software raid module core functionality existed needed activated requested stripe ext involved hiding dirty buffers declared mode orig mod percent module lines lines lines change software raid ext journaling total table complexity linux modifications table lists lines code counting semicolons braces original linux source number modified added software raid ext file system journaling modules verify reads recovery majority occurred journaling module writing declare blocks commit phase performing careful resynchronization recovery point comparison experimental version linux raidbitmap logging consists approximately lines code increase raidalone journaling module increasing size modifications consist lines code change modules observations support claim leveraging functionality cooperating layers reduce complexity software system related work brown patterson examine software raid systems work availability benchmarks find linux solaris windows implementations offer differing policies reconstruction process regenerating data parity disk failure solaris windows favor reliability linux policy favors availability unlike work authors focus improving reconstruction processes identifying characteristics general benchmarking framework stodolsky examine parity logging raid layer improve performance small writes writing parity blocks directly disk store log parity update images batched written disk large sequential access similar discussion nvram logging authors require fault tolerant buffer store parity update log reliability performance efforts avoid small random writes support argument maintaining performance raid level logging complex undertaking veritas volume manager facilities address faster resynchronization dirty region log speed raidresynchronization examining regions active crash log requires extra writes author warns coarse-grained regions needed maintain acceptable write performance volume manager supports raidlogging non-volatile memory solid state disk recommended support extra log writes contrast declared mode offers fine-grained journal-guided resynchronization performance degradation additional hardware schindler augment raid interface provide information individual disks atropos volume manager exposes disk boundary track information provide efficient semi-sequential access two-dimensional data structures database tables similarly raid disk boundary performance information augment functionality informed file system verify read interface complex providing file system access functionality exists software raid layer conclusions examined ability journaling file system provide support faster software raid resynchronization order obtain record outstanding writes time crash introduce ext declared mode mode guarantees declare intentions journal writing data disk extra write activity declared mode performs predecessor order communicate information software raid layer file system utilizes verify read request request instructs raid layer read block repair redundant information combining features implement fast journal-guided resynchronization process improves software raid reliability availability hastening recovery process crash general approach advocates system-level view developing storage stack file system journal improve raid system leverages existing functionality maintains performance avoids duplicating complexity multiple layers layers implement abstractions protocols mechanisms policies interactions define properties system acknowledgements john bent nathan burnett anonymous reviewers excellent feedback work sponsored 
nsf ccrccr- ngsitr- network appliance emc jfs overview ibm developerworks library jfs html brown patterson maintainability availability growth benchmarks case study software raid systems proceedings usenix annual technical conference usenix pages san diego california june clements bottomley high availability data replication proceedings linux symposium ottawa canada june denehy arpaci-dusseau arpaci-dusseau bridging information gap storage protocol stacks proceedings usenix annual technical conference usenix pages monterey california june emc emc centera content addressed storage system http emc emc corporation symmetrix enterprise information storage systems http emc mckusick joy leffler fabry fsck unix file system check program unix system manager manual bsd virtual vaxversion april patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod conference management data sigmod pages chicago illinois june reiser reiserfs namesys rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february schindler schlosser shao ailamaki ganger atropos disk array volume manager orchestrated disks proceedings usenix symposium file storage technologies fast san francisco california april solomon inside windows microsoft programming series microsoft press stodolsky gibson holland parity logging overcoming small write problem redundant disk arrays proceedings annual international symposium computer architecture isca pages san diego california sun solaris volume manager administration guide http docs sun app docs doc july teigland mauelshagen volume managers linux proceedings usenix annual technical conference freenix track boston massachusetts june tweedie future directions ext filesystem proceedings usenix annual technical conference freenix track monterey california june tweedie journaling linux ext file system fourth annual linux expo durham north carolina tweedie ext journaling file system olstrans sourceforge net release ols -ext ols ext html july veritas features veritas volume manager unix veritas file system http veritas products volumemanager whitepaperhtml july 
improving storage system availability d-graid muthian sivathanu vijayan prabhakaran andrea arpaci-dusseau remzi arpaci-dusseau wisconsin madison present design implementation evaluation d-graid gracefully degrading quickly recovering raid storage array d-graid ensures files file system remain unexpectedly high number faults occur d-graid achieves high availability aggressive replication semantically critical data fault-isolated placement logically related data d-graid recovers failures quickly restoring live file system data hot spare graceful degradation live-block recovery implemented prototype scsi-based storage system underneath unmodified file systems demonstrating powerful file-system functionality implemented semantically smart disk system narrow block-based interface categories subject descriptors operating systems storage management secondary storage operating systems reliability fault tolerance general terms design algorithms reliability additional key words phrases disk array raid block-based storage fault isolation file systems smart disks introduction tree falls forest hears make sound george berkeley storage systems comprised multiple disks backbone modern computing centers storage system entire center grind halt downtime expensive on-line business world millions dollars hour lost systems keeton wilkes patterson work sponsored nsf ccrccr- ccrngs- itritr- ibm emc wisconsin alumni research foundation earlier version article appeared proceedings usenix symposium file storage technologies fast san francisco authors addresses computer sciences statistics wisconsin madison dayton street madison muthian vijayan dusseau remzi wisc permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit direct commercial advantage copies show notice page initial screen display full citation copyrights components work owned acm honored abstracting credit permitted copy republish post servers redistribute lists component work works requires prior specific permission fee permissions requested dept acm broadway york usa permissions acm acm acm transactions storage vol pages sivathanu storage system availability formally defined time failure mtbf divided sum mtbf time recovery mttr mtbf mtbf mttr gray order improve availability increase mtbf decrease mttr surprisingly researchers studied components storage availability increase time failures large storage array data redundancy techniques applied bitton gray burkhard menon chen gray hsiao dewitt orji solworth park balasubramanian patterson savage wilkes wilkes keeping multiple copies blocks sophisticated redundancy schemes parity-encoding storage systems tolerate small fixed number faults decrease time recovery hot spares employed holland menon mattson park balasubramanian reddy banerjee failure occurs spare disk activated filled reconstructed data returning system normal operating mode quickly problem reduced availability due semantic ignorance techniques proposed improve storage availability narrow interface file systems storage ganger curtailed opportunities improving mtbf mttr raid redundancy schemes typically export simple failure model fewer disks fail raid continues operate correctly disks fail raid unavailable problem corrected time-consuming restore tape raid schemes small disks working users observe failed disk system availability cliff result storage system laying blocks oblivious semantic importance relationship files corrupted inaccessible extra disk failure storage array information blocks live file system recovery process restore blocks disk unnecessary work slows recovery reduces availability ideal storage array fails gracefully disks system data unavailable ideal array recovers intelligently restoring live data effect important data disappear failure data restored earlier recovery strategy data availability stems berkeley observation falling trees file isn process access recovered failure solution d-graid explore concepts provide storage array graceful failure semantics present design implementation evaluation d-graid raid system degrades gracefully recovers quickly d-graid exploits semantic intelligence sivathanu disk array place file system structures disks fault-contained acm transactions storage vol improving storage system availability d-graid manner analogous fault containment techniques found hive operating system chapin distributed file systems saito unexpected double failure occurs gray d-graid continues operation serving files accessed d-graid utilizes semantic knowledge recovery specifically blocks file system considers live restored hot spare aspects d-graid combine improve effective availability storage array note d-graid techniques complementary existing redundancy schemes storage administrator configures d-graid array utilize raid level single disk fail data loss additional failures lead proportional fraction unavailable data article present prototype implementation d-graid refer alexander alexander semantically-smart disk system sivathanu built underneath narrow block-based scsi storage interface disk system understands on-disk file system data structures including superblock allocation bitmaps inodes directories important structures knowledge central implementing graceful degradation quick recovery intricate understanding file system structures operations semantically smart arrays tailored file systems alexander functions underneath unmodified linux ext vfat file systems make important contributions semantic disk technology deepen understanding build semantically smart disk systems operate correctly imperfect file system knowledge demonstrate technology applied underneath widely varying file systems demonstrate semantic knowledge raid system apply redundancy techniques based type data improving availability key techniques key aspects alexander implementation graceful degradation selective meta-data replication inwhich alexander replicates naming system meta-data structures file system high degree standard redundancy techniques data small amount overhead excess failures render entire array unavailable entire directory hierarchy traversed fraction files missing proportional number missing disks fault-isolated data placement strategy ensure semantically meaningful data units failure alexander places semantically related blocks blocks file storage array unit fault-containment disk observing natural failure boundaries found array failures make semantically related groups blocks unavailable leaving rest file system intact fault-isolated data placement improves availability cost related blocks longer striped drives reducing natural acm transactions storage vol sivathanu benefits parallelism found raid techniques ganger remedy alexander implements access-driven diffusion improve throughput frequently-accessed files spreading copy blocks hot files drives system alexander monitors access data determine files replicate fashion finds space replicas preconfigured performance reserve opportunistically unused portions storage system evaluate availability improvements d-graid trace analysis simulation find d-graid excellent job masking arbitrary number failures processes enabling continued access important data evaluate prototype alexander microbenchmarks trace-driven workloads find construction d-graid feasible imperfect semantic knowledge powerful functionality implemented block-based storage array find run-time overheads d-graid small storage-level cpu costs compared standard array high show access-driven diffusion crucial performance live-block recovery effective disks under-utilized combination replication data placement recovery techniques results storage system improves availability maintaining high level performance rest article structured section present extended motivation section discuss related work present design principles d-graid section section present trace analysis simulations discuss semantic knowledge section section present prototype implementation evaluate prototype section section present custom policies levels d-graid discuss resilience d-graid incorrect information section conclude section extended motivation section discuss graceful degradation multiple failures describe semantically smart disk system locale incorporate support graceful 
degradation case graceful degradation motivation graceful degradation arises fact users applications require entire contents volume present matters set files question arises realistic expect catastrophic failure scenario raid system raidsystem high mtbf reported disk manufacturers disk failure highly occur failed disk repaired multiple disk failures occur primary reasons correlated faults common systems expected gribble raid carefully designed orthogonal manner single controller fault component error render fair number acm transactions storage vol improving storage system availability d-graid disks unavailable chen redundant designs expensive found higher end storage arrays gray pointed system administration main source failure systems large percentage human failures occur maintenance maintenance person typed wrong command unplugged wrong module introducing double failure gray evidence suggests multiple failures occur ibm serveraid array controller product includes directions attempt data recovery multiple disk failures occur raidstorage array ibm organization data stored file servers raidin servers single disk failed indicator informed administrators problem problem discovered disk array failed full restore backup ran days scenario graceful degradation enabled access large fraction user data long restore approach dealing multiple failures employ higher level redundancy alvarez burkhard menon enabling storage array tolerate greater number failures loss data techniques expensive three-way data mirroring bandwidth-intensive write redundant store graceful degradation complementary techniques storage administrators choose level redundancy common case faults graceful degradation enacted worse expected fault occurs mitigating ill effect semantically smart storage basic design principles d-graid apply equally implementation alternatives tradeoffs subsection motivate decision implement d-graid semantically smart disk system discuss benefits approach addressing obvious concerns compare semantic disk approach alternatives implementing d-graid benefits semantic disk approach implementing functionality semantically smart disk system key benefit enabling wide-scale deployment underneath unmodified scsi interface modification working smoothly existing file systems software base desire evolve interface file systems storage gibson reality current interfaces survive longer anticipated bill joy systems protocols live forever similarly modern processors innovate beneath unchanged instruction sets semantic disk-level implementation nonintrusive existing infrastructure making technology d-graid adopted semantically smart storage systems require detailed knowledge file system concerns arise commercial feasibility systems main concerns acm transactions storage vol sivathanu concern arises placing semantic knowledge disk system ties disk system intimately file system on-disk structure file system storage system change issue problematic on-disk formats evolve slowly reasons backward compatibility basic structure ffs-based file systems changed introduction period years mckusick linux ext file system introduced roughly exact layout lifetime finally ext journaling file system tweedie backward compatible ext on-disk layout extensions freebsd file system dowse malone backward compatible evidence storage vendors maintain support software specific file system emc symmetrix storage system emc corporation software understand format common file systems concern storage system semantic knowledge file system interacts fortunately large number file systems supported cover large fraction usage population semantic storage system file system support storage system detect turn special functionality case d-graid revert normal raid layout detection simple techniques observing file system identifier partition table final concern arises processing required disk system major issue general trend increasing disk system intelligence acharya riedel processing power increases disk systems substantial computational abilities modern storage arrays exhibit fruits moore law emc symmetrix storage server configured processors ram emc corporation comparison alternative approaches semantic disk approach clear benefits detailed cost rediscovering semantic knowledge underneath modern file system entails fair amount complexity alternative approach change interface file systems storage convey richer information layers instance storage system expose failure boundaries file system denehy file system explicitly allocate blocks fault-isolated manner placing semantically related blocks alternatively file system tag write logical fault-container storage system implement fault-isolated data placement techniques conceivably complex approach drawback intrusive existing infrastructure software base requiring wide industry agreement adopted acm transactions storage vol improving storage system availability d-graid object-based storage gibson interface considered makes file boundaries visible storage layer object-based interface semantically smart technology relevant discover semantic relationships objects instance inferring directory object points set file objects single fault boundary finally approximate version fault-isolated layout implemented traditional block based storage system semantic understanding storage system simply identify sequences blocks accessed infer blocks logically related main disadvantage black-box approach fragile concurrent interleavings independent streams scheme identify critical data purposes aggressive replication hot blocks cached file system frequent reads visible storage system related work d-graid draws related work number areas including distributed file systems traditional raid systems discuss turn distributed file systems designers distributed file systems long ago realized problems arise spreading directory tree machines system walker discussed importance directory namespace replication locus distributed system popek coda mobile file system takes explicit care regard directory tree kistler satyanarayanan specifically file cached coda makes cache directory root directory tree coda guarantee file remains accessible disconnection occur interesting extension work reconsider host-based in-memory caching availability mind slice anderson route namespace operations files directory server recently work wide-area file systems reemphasized importance directory tree pangaea file system aggressively replicates entire tree root node file accessed saito island-based file system points fault isolation context wide-area storage systems island principle similar fault-isolated placement d-graid finally systems past place entire file single machine similar load balancing issues rowstron druschel problem difficult space due constraints file placement block migration simpler centralized storage array traditional raid systems draw long history research classic raid systems autoraid wilkes learned complex functionality acm transactions storage vol sivathanu embedded modern storage array background activity utilized successfully environment afraid savage wilkes learned flexible tradeoff performance reliability delaying updates raid research focused redundancy schemes early work stressed ability tolerate single-disk failures bitton gray park balasubramanian patterson research introduced notion tolerating multiple-disk failures array alvarez burkhard menon stress work complementary line research traditional techniques ensure full file system availability number failures d-graid techniques ensure graceful degradation additional failures related approach parity striping gray stripes parity data parity striping achieve primitive form fault isolation layout oblivious semantics data blocks level redundancy irrespective importance meta-data data multiple failures make entire file system inaccessible number earlier works emphasized importance hot sparing speed recovery time raid arrays holland menon mattson park balasubramanian work semantic recovery complementary approaches finally note term graceful degradation refer performance characteristics redundant disk systems failure hsiao dewitt reddy banerjee type graceful degradation 
discuss article systems continues operation unexpected number failures occurs design d-graid expectations discuss design d-graid present background information file systems data layout strategy required enable graceful degradation important design issues arise due layout process fast recovery file system background semantic knowledge system specific discuss d-graid design implementation widely differing file systems linux ext tweedie microsoft vfat microsoft corporation file systems inclusion vfat represents significant contribution compared previous research operated solely underneath unix file systems ext file system intellectual descendant berkeley fast file system ffs mckusick disk split set block groups akin cylinder groups ffs bitmaps track inode data block allocation inode blocks data blocks information file including size block pointers found file inode vfat file system descends world operating systems article linux vfat implementation fatvfat acm transactions storage vol improving storage system availability d-graid operations centered eponymous file allocation table entry allocatable block file system entries locate blocks file linked-list fashion file block address entry fat find block file entry hold end-of-file marker setting block free unlike unix file systems information file found inode vfat file system spreads information fat directory entries fat track blocks belong file directory entry information size permission type information graceful degradation ensure partial availability data multiple failures raid array d-graid employs main techniques fault-isolated data placement strategy d-graid places semantically related set blocks unit fault containment found storage array simplicity discussion assume file semantically related set blocks single disk unit fault containment generalize easily generalized failure boundaries observed scsi chains refer physical disk file belongs home site file disk fails fault-isolated data placement ensures files disk home site unavailable files remain accessible files technique selective meta-data replication inwhich d-graid replicates naming system meta-data structures file system high degree directory inodes directory data unix file system d-graid ensures live data reachable orphaned due multiple failures entire directory hierarchy remains traversable fraction missing user data proportional number failed disks d-graid lays logical file system blocks availability single file depends disks traditional raid array dependence set entire set disks group leading entire file system unavailability unexpected failure unix-centric typical layout fault-isolated data placement selective meta-data replication depicted figure note techniques d-graid work meaningful subset file system laid single d-graid array file system striped multiple d-graid arrays single array meaningful view file system scenario d-graid run logical volume manager level viewing arrays single disk techniques remain relevant d-graid treats file system block type differently traditional raid taxonomy longer adequate describing d-graid behaves fine-grained notion raid level required d-graid employ redundancy techniques types acm transactions storage vol sivathanu fig comparison layout schemes parts figure depict layouts file foo bar unix file system starting root inode directory tree file data vertical column represents disk simplicity assumes data redundancy user file data top typical file system layout non-d-graid disk system blocks pointers spread file system single fault render blocks file bar inaccessible left figure bottom fault-isolated data placement files directories scenario access inode file access data indirect pointer blocks constrained disk finally bottom selective meta-data replication replicating directory inodes directory blocks d-graid guarantee users files requisite pointers removed rightmost figure simplicity color codes white user data light shaded inodes dark shaded directory data data d-graid commonly employs n-way mirroring naming system meta-data standard redundancy techniques mirroring parity encoding raidfor user data note administrative control determines number failures d-graid degrade gracefully section explore data availability degrades varying levels namespace replication design considerations layout replication techniques required enable graceful degradation introduce number design issues highlight major challenges arise semantically related blocks fault-isolated data placement d-graid places logical unit file system data file faultisolated container disk blocks d-graid considers related acm transactions storage vol improving storage system availability d-graid determines data remains failure basic approach file-based grouping single file including data blocks inode indirect pointers treated logical unit data technique user find files directory unavailable frustration confusion groupings preserve meaningful portions file system volume failure directory-based grouping d-graid ensures files directory unit fault containment automated options allowing users arbitrary semantic groupings d-graid treats unit load balance fault-isolated placement placing blocks file disks blocks isolated single home site isolated placement improves availability introduces problem load balancing space time components terms space total utilized space disk maintained roughly level fraction disks fail roughly fraction data unavailable balancing addressed foreground data allocated background migration files directories larger amount free space single disk handled potentially expensive reorganization reserving large extents free space subset drives files larger single disk split disks pressing performance problems introduced fault-isolated data placement previous work striping data disks performance compared sophisticated file placement algorithms ganger wolf d-graid makes additional copies user data spread drives system process call access-driven diffusion standard d-graid data placement optimized availability access-driven diffusion increases performance files frequently accessed surprisingly access-driven diffusion introduces policy decisions d-graid including place replicas made performance files replicate create replicas meta-data replication level degree meta-data replication d-graid determines resilient excessive failures high degree replication desirable meta-data replication costs terms space time space overheads tradeoffs obvious replicas imply resiliency difference traditional raid d-graid amount space needed replication naming system meta-data dependent usage volume directories induces greater amount overhead time overheads higher degree replication implies lowered write performance naming system meta-data operations observed lack update activity higher levels directory tree popek lazy update propagation employed reduce costs savage wilkes acm transactions storage vol sivathanu fast recovery main design goal d-graid ensure higher availability fast recovery failure critical straightforward optimization d-graid recover live file system data assume restoring data live mirror hot spare straightforward approach d-graid simply scans source disk live blocks examining file system structures determine blocks restore process readily generalized complex redundancy encodings d-graid potentially prioritize recovery number ways restoring important files importance domain specific files orindicated users manner similar hoarding database coda kistler satyanarayanan exploring graceful degradation section simulation trace analysis evaluate potential effectiveness graceful degradation impact semantic grouping techniques quantify space overheads d-graid demonstrate ability d-graid provide continued access proportional fraction meaningful data arbitrary number failures importantly demonstrate d-graid hide failures users replicating important data simulations file system traces collected labs riedel cover days activity data 
spread logical volumes space overheads examine space overheads due selective meta-data replication typical d-graid-style redundancy calculate cost selective meta-data replication percentage overhead measured volumes trace data laid ext vfat file system running underneath ext selective meta-data replication applied superblock inode data block bitmaps inode data blocks directory files blocks replicated case vfat comprise fat directory entries calculate highest percentage selective meta-data replication overhead assuming replication user data user data mirrored overheads cut half table shows selective meta-data replication induces mild space overhead high levels meta-data redundancy linux ext vfat file systems -way redundancy meta-data space overhead incurred worst case vfat -kb blocks increasing block size ext space due internal fragmentation larger directory blocks overheads decrease vfat phenomenon due structure vfat fixed-sized file system block size grows file allocation table shrinks blocks directory data grow acm transactions storage vol improving storage system availability d-graid table space overhead selective meta-data replication table shows space overheads selective meta-data replication percentage total user data level naming system meta-data replication increases leftmost column percentage space overhead meta-data replication shown columns depict costs modest four-way paranoid -way schemes row shows overhead file system ext vfat block size set level replication -way -way -way ext ext vfat vfat fig static data availability percent entire directories shown increasing disk failures simulated system consists disks loaded trace strategies semantic grouping shown file-based directory-based line varies level replication namespace meta-data point shows average deviation trials trial randomly varies disks fail static availability examine d-graid availability degrades failure semantic grouping strategies strategy file-based grouping information single file failure boundary disk directory-based grouping allocates files directory analysis place entire files directories trace simulated -disk system remove simulated disks measure percentage directories assume user data redundancy d-graid level figure shows percent directories directory files accessible subdirectories files figure observe graceful degradation works amount data proportional number working acm transactions storage vol sivathanu antfarm tracking processes virtual machine environment stephen jones andrea arpaci-dusseau remzi arpaci-dusseau department computer sciences wisconsin madison stjones dusseau remzi wisc abstract virtualized environment vmm system primary resource manager services implemented layer scheduling kinds security monitoring naturally implemented inside vmm implementing services vmm layer complicated lack vmm paper describes techniques vmm independently overcome part semantic gap separating guest operating systems supports techniques enable vmm track existence activities operating system processes antfarm implementation techniquesthat works detailed knowledge guest internal architecture implementation evaluation antfarm virtualization environments operating systems shows accurately infer process events incurring small runtime overhead worst case demonstrate practical benefits process information vmm implement anticipatory disk scheduler vmm level case study shows significant disk throughput improvements virtualized environment exploiting process information vmm introduction virtual machine technology increasingly deployed range platforms high-end servers desktop pcs large growing list reasons virtualization diverse computing environments including server consolidation support multiple operating systems including legacy systems sandboxing security features fault tolerance optimization specialized architectures software hardwaresupport develops virtualization included dominant commercial operating systems expect virtualized computing environments ubiquitous virtualization prevalent virtual machine monitor vmm naturally supplants operating system primary resource manager machine main target innovationin systemservices oneshouldnowconsiderhow implement services vmm transition functionality vmm potential benefits implementing feature single time vmm becomesavailabletoall vmm place features introduced system operating system legacy closed-source finally vmm locale system total control system resources make informed resource management decisions pushing functionality layer software stack vmm drawbacks significant problem lack higher-levelknowledge vmm referred semantic gap previousworkin partially recognized dilemma researchers developed techniques infer higher-level hardware resource utilization techniques vmm manage resources system reallocating idle page virtual machine virtual machine addition recently proposed vmm-based services explicit information software abstractions operating systems running bridgethe semantic gap previouswork thoroughlyexplored vmm learn operatingsystemsrunning information explicitly implicitly learn operating systems vmm important guest proprietary untrusted managed entity proceedings usenix annual technical conference june boston managing vmm cases explicit information details guest memory layout implementation unavailable unreliable paper developa set techniquesthat enable virtual machine monitor implicitly discover exploit information important operating system abstractions process monitoring lowlevelinteractionsbetweenguestoperatingsystemsandthe memory management structures depend show vmm accurately determine guest operating system creates processes destroys context-switches techniques operate explicit information guest operatingsystem vendor version implementationdetails demonstrate utility efficacy vmm-level process awareness building anticipatory disk scheduler vmm virtual machine environment anticipatory disk scheduler requires information vmm layers implemented exclusively making vmm process aware overcomesthis limitation os-neutral implementation vmm layer modifications detailed knowledge implementation vmm improve throughput competing sequential streams processes virtual machines single guest operating system factor addition scheduling process information vmm applications security domain system monitoringtools malicious software identify code data sensitive processes monitored runtime modification patterns system calls process recognize process compromised additiontodetection trusions process level affecting process scheduling finally process information parent-child relationship processes identify groups related processes user applications feasible vmm process information antfarm implementation process identification techniques virtualization environments xen simics antfarm evaluated applied linux windows sparc linux guest operating systems range environments spans processor families significantly virtualmemory managementinterfacesand operating systems process management semantics antfarm imposes small runtime overhead worst case scenario common process-intensive compilation environment rest paper organized section place antfarm context related work section cover required background material relating implementation architectures virtual machines general section discussion techniques underlying antfarm section covers implementation details antfarm evaluate accuracy overhead imposed antfarm section section present anticipatory scheduling case study conclude section related work antfarm informs vmm important operating system abstraction process aboutwhich information research recognized information explicitly vmm implementing vmm features services cases information relates hardware disco determines guest executing idle loop detecting enters lowpower processor mode vmware esx server page sampling determine utilization physical memoryassigned virtualmachines antfarm differs efforts focuses inferring information processes software construct projects recognized oslevel information vmm cases detailed version-specific memory layout information semantic knowledge make information exported directly vmm vmi implement security techniques detecting malicious hidden processes guest introvirt memory layout implementation details enable host-based intrusion detection features vmm antfarm contrast enables limited inexact levelof informationto inferredbya vmm itdoesthis explicit information memory layout implementation affected guests deployed broader set environments work uhlig similar shows infer guest-level information processor managementmore intelligentlyin multiprocessor environment specifically deduce kernel locks held observing executing user versus kernel mode antfarm complementary observes virtual resource mmu infer information operating system processes proceedings usenix annual technical conference june boston finally alternative inferring os-level information knowledge passed explicitly vmm extent paravirtualized architectures explicit information supplied paravirtualized guaranteedto match inside metric paravirtual information considered gold standard information vmm important environments explicitapproachis lessvaluable paravirtualization requires os-level modification implies functionality deployed vmm running beneath legacy closed-source operating systems reasons dependence explicit interfaces forces innovation vmm requiresos-levelinformationtobe coupledwithchangesto supported operating systems inferring guest information vmm innovate independent implementation finally case security applications guest trusted report activities compromised intentionally mislead vmm background techniques describe paper based observations vmm make interactions guest virtual hardware specifically antfarm monitors guest virtual mmu implement virtual address spaces section review pertinent details intel sparc architectures antfarm discuss basic features virtual machine monitors runtime information virtual memory architecture implementation platform intel family microprocessors chose frequently virtualized processor architecture today section reviews features virtual memory architecture important inference techniques architecture two-level in-memory architecturally-defined page table page table organized tree single memory page called page directory root -byte entry page directory point page page table process page table entry pte active address physical page virtual mapping exists page protection status bits pte page writable access page restricted privileged software single address space active processor time system software informs processor mmu address space active writing physical address page directory newaddressspace processorcontrolregister access register privileged vmm virtualize behalf guest operating systems tlb entries loaded on-demand active page tables processor operating system participate handling tlb misses operatingsystem tlb ways single entry removed invlpg instruction non-persistent entries entries page table entries marked global flushed tlb writing address space process tag maintained tlb non-shared entries flushed context switch sparc virtual memory architecture section review key aspects sparc mmu differsfrom chose sparc implementation architecture significantly memory management interface system software architecturally-defined hardware-walked page tables sparc software managed tlb system software implements virtual 
address spaces explicitly managing contents hardware tlb memory made tlb entry translation processor raises exception operating system opportunity supply valid translation deliver error offending process cpu aware operating system page table organization order avoid flushing entire tlb process context switches sparc supplies tag tlb entry called context associates entry specific virtual address space memory current context supplied mmu desired virtual address order match virtual page number context tlb entry identical supplied values entries distinct address spaces exist tlb simultaneously operatingsystem tlb granularity single page granularity entire address space operations called page demap context demap proceedings usenix annual technical conference june boston virtual machines vmm implements hardware interface software interface includes privileged system portions microprocessor architecture peripherals disk network user interface devices note non-privileged user portion microprocessor instruction set virtualized running unprivileged instructions guest directly executes processor additional overhead key feature virtualized system environment guest operating systems execute unprivileged mode processor vmm runs full privilege guest accesses sensitive system components mmu peripherals processor trap vmm vmm virtualizesensitive system featuresby mediatingaccess feature emulating mmu virtualized attempts guest operating system establish trapped vmm vmm observe attempts similarly request virtual disk device vmm examine vmm choose service request made virtualized interface sees fit requests virtual mappings altered disk requests reordered process identification key process inference techniques logical correspondencebetween abstraction process directly visible vmm virtual address space correspondence due traditional single address space process paradigm shared modern operating systems major process events seek observe creation exit context switch extent address spaces correspond processes events approximated address space creation destruction context switch techniques track processes tracking address spaces approach tracking address spaces sparc identify vmm-visible associate specific address space call address space identifier asid tracking address space creation context switch simply observing piece vmmvisible operating system state asid asid observed infer address space created asid replaced asid conclude address space contextswitch hasoccurred thetechniquewe identify address space deallocation consists detecting asid reuse assume address space asid refers beendeallocatedif asid reuse techniques architecture physical address page directory asid page directory serves root page table tree describes address space address page directory characteristic single address space process creation context switch detect address space creation observe page directories page directory physical address resides vmm notified guest writes privileged register observe asid usedthathas notbeen inferthata addressspace hasbeencreated whenan asidis seenfor time vmm adds asid registry akin operating system process list tracking purposes writes imply addressspace contextswitch monitoring events vmm asid active process exit detect address space deallocation knowledge generic responsibilities operating system maintain address space isolation requirements lead distinctive behavior observed exploited vmm infer address space destroyed operating systems strictly control contents page tables implement virtual address spaces process isolation breached page directory page table page reused distinct processes withoutfirst cleared previousentries ensure invariant holds windows linux systematically clear non-privilegedportionsof page table pages process prior reusing privileged portions page tables implement protected kernel address space cleared shared processes map memory accessible untrusted software ensure stale entries remain tlb address space deallocated architecture provide entries multiple address spaces coexist tlb tlb completely flushed prior reusing address space structures page directory tlb proceedings usenix annual technical conference june boston flushed writing event vmm observe detect user address space deallocation vmm count number user virtual mappingspresent page tables describing address space count drops vmm infer itis simplefora vmmtomaintainsucha counterbecause vmm informed updates process page tables order updates effective requirement vmm role virtualizing mmu multi-threading introduce additional complexity updates process page tables synchronized vmm correctness monitoring tlb flushes processors vmm detect requirementfor address space deallocation met events observed asid vmm address space dead entry asid registry removed subsequent asid implies creation distinct process address space techniques sparc key aspect enable process awareness present sparc vmm-visible identifier virtual address space physical address page directory sparc virtual address space context asid making obvious substitution leads process detection technique sparc similar creation context switch sparc installing contextid privilegedoperationandsoitisalwaysvisibletoavmm byobserving operation vmm maintain registry asids asid observed asid registry vmm infers creation address space context switch detected sparc context installed processor exit requirement reuse context sparc stale entries previously address space removed processor tlbs sparc context demap operation thispurpose vmm observe contextdemap operations entries context flushed sparc asid page directory context creation asid asid exit user mappings tlb flushed context demap context switch change context change table process identification techniques table lists techniques antfarm detect process event sparc architectures processorit impliesthatthe addressspace longer valid implementation antfarm implemented virtualization environments xen true vmm low-level system simulator called simics architectures supported xen antfarm xen xen open source virtual machine monitor intel architecture xen paravirtualized processor interface enables lower overhead virtualization expense porting system software explicitly make feature xen mechanisms describe equally applicable conventional virtual machine monitor vmware operating systems ported run xen proprietary commercial operating systems microsoft windows supported antfarm xen implemented set patches xen hypervisor concentrated handlers events page faults page table updates privileged register access additional hooks added xen back-end block device driver antfarm patches xen including debugging measurement infrastructure total approximately lines files antfarm simics simics isafullsystem unmodified commercial operating systems applications variety processor architectures simics virtual machine monitor strict sense direct execution user instructions play proceedings usenix annual technical conference june boston role vmm allowing antfarm observe interpose operating system application hardware requests vmm simics explore process awareness techniques sparc linux windows xen-only implementation antfarm simics implemented simics extension module simics extension modules shared libraries dynamically linked main simics executable extension modules read write application memory registers vmm simics hooks called haps hardwareeventsforwhichextensionmodulescanregistercall- back functions antfarm simics hap detect writes antfarm simics sparc hap detect processor context changed invocation callback akin exception raised guest accesses privileged processor registers true vmm memory write breakpoint installed antfarm simics pages page tables page table updates detected vmm xen marks page tables read-only detect event antfarm simics consists lines code simics sparc total approximately lines process awareness evaluation section explorethe accuracyof antfarmin implementation environments characterize runtime overhead antfarm xen analysis accuracy decomposed components thefirstis abilityto correctlydetectprocess creations exits context switches call aspect completeness component time difference lag process events occur operating 
system detected vmm evaluation evaluation xen version version linux kernel xen privileged control linux kernel version unprivileged vms noted evaluation hardware consists ghz pentium ram virtual machines allocated ram environment microsoft windows windows run xen simics purpose simics virtual machines configured ghz pentium ram completeness quantify completeness guest operating system exit andcontext switch event records include asid time event obtained processor cycle counter traces compared similar traces generated antfarm guest traces functionally equivalent information provided paravirtualized included process event interface evaluation implicitly compares accuracy antfarm ideal represented paravirtual interface addition process creation exit context switch guests report address space creation destruction events discriminate errors caused mismatch processes address spaces errors induced inaccurate address space inferences made antfarm categorize incorrect inferences false negatives false positives false negative occurs true process event missed antfarm false positive occurs antfarm incorrectly infers events exist determine false negatives occurred one-to-one matches found os-reported event pair traces required matching event asid occur range event plausible match process-creation event inferred event occur previous os-reported process os-reported process creation events asid table reports process address space event countsgatheredby ourguest oses antfarmduring experiment utilizing process intensive workloads workload synthetic creates processes runs seconds exits process creation rate processes linux synthetic workload variants creates processes fork fork exec employs vfork exec windows processes created createprocess api workload parallel compile bash shell sources command make clean object directory compilation workload chosen creates large number short-lived processes stressing antfarm ability track concurrent processes varying runtimes antfarm incurs false negatives tested proceedings usenix annual technical conference june boston process addr spc inferred process addr spc inferred context create create create exit exit exit switch inferred linux fork fork exec vfork exec compile linux fork fork exec vfork exec compile windows create compile table completeness table shows total number creations exits processes address spaces reported operating system total number process creations exits inferred antfarm shown comparison antfarm detects process creates exits false positives false negatives linux windows fork exec lead false positives linux bold face values false positives due mismatch address spaces processes matching counts address space creates inferred creates actual inferred context switch counts shown completeness accurate expected cases process-related events reported instrumented oses detected vmm fact inferred counts greater equal reported counts suggests verified os-reported event properly matched vmm-inferred event linux windows false positives occur indicatingantfarmcan precisely detectaddressspace events one-to-one match address spaces processes operating systems linux false positives occur indicatedin table bythe os-reported counts discrepancy due implementationof linux fork exec system calls unix programscreate user processes invoking theforksystemcallwhich amongotherthings constructs address space child process child address space copy parent address space cases newly created child process immediately invokes exec system call replaces child virtual memory image program read disk linux exec invoked existing process address space cleared reused newly loaded program contrast linux destroys releases address space process invoking exec address space allocated newly exec program linux process invokes exec distinct address spaces overlap time words runtime process partitioned segments segment corresponds period fork exec corresponds period exec process exit antfarm based address space tracking concludes processes created leading inferred process creations exits occurred due idiomatic fork exec process partitioned distinctive linux case figure depicts temporal relationship inferred pseudo-processes duration pseudo-process small case compilation workload average time fork exec compared average lifetime pseudoprocess seconds difference orders magnitude pseudo-processesare separated shorttime period active interval corresponds time original address space destroyed address space created compilation workload interval averaged larger user instructions executed absence user address space combination pseudo-processes detected antfarm encompasses user activity true process conventional fork exec imply proceedings usenix annual technical conference june boston figure effects error figure shows type process identification error occurs tested platform error lag true event occurs vmm detects figure consists falsely partitioning single process multiple inferred processes linux occurs exec typically immediately fork sparc partitioning process calls fork exec create lag linux avg max exit lag linux concurrent processes windows figure lag system load figure shows average maximum create exit lag time measurements variety system load levels evaluation environments average worst case create lag affected system load linux windows small constant linux large exit lag competing processes linux exit lag sensitive system load substantive activity true user process captured pseudo-process lag aspect process identification accuracy consideristhe timedifferencebetweena processevent eventis detected vmm define process exist instant fork equivalent system call invoked exit defined start exit system call definitions maximally conservative figure create lag labeled exit lag labeled lag similar nature response time expect sensitive system load evaluate sensitivity conduct experiment measures lag times levels system load linux linux windows experiment cpubound processes created additional test processes created create exit lag time computed test process creationswere separated test process slept exiting results experiments presented figure graph x-axis shows number concurrent cpu-bound processes y-axis shows lag time create lag sensitive system load linux windows steadily increasing lag time increasing system load result intuitive call scheduler occur invocation create process api parent process begins child process runs vmm detects linux exhibits process creation policy leads small constant creation lag antfarm detects process creation process runs vmm informed process existence user instructions executed exception idle linux shows large exit lag average reason anomaly linux kernel tasks including idle task user address space borrow previously active user address space run mechanism kernel task run incurring expense tlb flush case experiment test processes started intervals process sleeps processes ready run approximately mselapse processexitand process begins interval linux idle task active preventsthe previousaddress space released leads observed delay big picture figure shows set timelines depicting antfarm tracksprocessactivity overtime parallelcompilation proceedings usenix annual technical conference june boston process count vmm linux bash compile time diff process count vmm linux bash compile time diff process count vmm bash compile time diff figure compilation workload timelines linux linux windows process count timeline shown timeline depicts os-reported process count vmm-inferred process count difference versus time lag larger impact accuracy false positives linux exhibits significantly smaller lag linux track process counts accurately workload platforms top curve eachgraphshowsthetrue reported operating system middle curve shows current process count inferred antfarm bottom 
curve shows difference curves calculated inferred actual result large creation lag linux apparent larger negative process count differencescomparedto linux workload metriccombination false positives experienced linux environmentsuch lightly loaded system tend reduce lag metric total cumulative process count false positives incurred linux problematic exit lag prominent graphs large persistent exit lag effects show significant positive deviations difference curves fact errors due fork exec accumulate time linux apparent increasing inaccuracy trend present overhead evaluate overhead process awareness techniqueswe measure comparethe runtime workloads antfarm pristine build xen workload microbenchmark represents worst case performance scenario antfarm experiments performed linux guests vmm extensions affect code paths page tables updated microbenchmark focuses execution paths program allocates memory touches page ensure page table entry allocated page created exits causing page tables cleared released program run times total elapsed time computed experiment repeated times average duration reported negligible variance experiments unmodified version xen experiment required average seconds complete antfarm xen experiment average seconds complete average slowdown worst case runtime configuringand buildingbash compared modified unmodified versions xen unmodifiedcase average measured runtime trials average runtime experiment modified xen variance experiments negligible yielding slowdown process-intensive application workload proceedings usenix annual technical conference june boston process addr spc inferred process addr spc inferred context create create create exit exit exit switch inferred sparc linux fork fork exec vfork compile table completeness sparc table shows results experiments reported table sparc linux false positives occur fork due implementation copy-on-write antfarm infers additional non-existent exit create event pair exec error due multiple address spaces process stems flush occurs clear caller address space exec sparc evaluation implementation process tracking sparc simics virtual machine configured mhzultrasparc iiprocessorand mbofram sparc linux version guest operating system tests guest operating system instrumented report information completeness criteria evaluate process awareness sparc table lists total event counts process creation micro-benchmark bash compilation workload false negatives occur contrast fork-only variant microbenchmark incurs false positives reason copy-on-write implementation fork linux fork writable portionsof parent saddress space marked read-only copy-on-write shared child entries parent page tables updated tlb entries flushed sparc linux accomplishes efficiently flushing parent current tlb entries context demap operation context demap incorrectlyinterpretedbyantfarmasa processexit assoonas parent scheduled run detect address space signal matching spurious process creation false positives caused fork sparc character caused exec errors limited convention tiny time interval fork exec fork invoked processes user shell occur repeatedly process lifetime linux sparc case figure depicts process repeatedly invokes fork partitioned inferred pseudo-processesby antfarm execis additionalfalse positives reason linux case process inference technique falsely reports creation address spaces don treally exist behavior tlb demap operation occurswhena error mode differentthan observed errors due faulty assumption single address space process sparc error occurs chosen indicator context demap happen correspondingaddress space deallocated sources false positives expect compilation workload experience approximately multiple false positives fork exec synthetic benchmark fewer false positives expect due vfork gnu make gcc vfork creates process duplicate parent address space parent page tables changed flush required exec invoked detect creation single address space vfork exec linux antfarmexperiences false positives build process consists processes created make gcc processes created calls external shell process creations induce false positives observe lag lag os-recorded vmm-inferred process events sparc linux comparable linux average maximum lag values sparc linux system loads shown figure create lag sensitive system load exit lag unaffected load proceedings usenix annual technical conference june boston create lag sparc-linux avg max exit lag concurrent processes figure lag system load sparc figure shows average maximum create exit lag time measurements experiments figure create lag grows system load exit lag small constant independent load process count vmm sparc linux bash compile time diff figure compilation workload timeline compilation timeline comparable figure sparc linux limitations sparc inferencetechnique simple suffers drawbacks relative shown technique incurs false positives techniques spite additional false positives figure shows technique track process events parallel compilation workload accurately linux unlike assume page directory page shared multiple runnable processes make assumption context ids sparc reason vastly smaller space unique context ids sparc bits field distinct contexts represented concurrently system exceeds number active processes context ids necessarily recycled cases system softprocess count vmm sparc context overflow time diff figure context overflow processes exist represented sparc context ids techniques fail detect context reuse ware limit number concurrent contexts supports linux sparc architectures context bits concurrent address spaces supported recycling figure shows behavior sparc process detection techniques processes exist distinguished context ids limit reached technique fails detect additional process creations importance limitation reduced busy servers rarely active processes fact doubt influenced selection context field size discussion process event detection techniques antfarm based mechanisms provided cpu architecture implement manage virtual address spaces responsibilities general-purpose operating systems maintain process isolation techniques assume follow address space conventions suggested mmu features architecture deviates convention detection accuracy differ reported evaluation shows widely operatingsystems adhereto ourassumptions antfarmprecisely identifies desired process events windows linux false positives occur linux andsparc linux thefalsepositivesare stylized affectthe ability antfarmto accurate process count architectures devoted hardware-assisted virtualization configurations reduce eliminate vmm track guest page taproceedings usenix annual technical conference june boston ble updates context switches amd private guest-cr options secure virtual machine svm architecture fact prevent vmm observing guest operating systems shadow page tables explicitly supported architectures increase performancepenalty exacted techniques antfarm case study anticipatory scheduling order disk requests serviced make large difference disk performance requests adjacent locations disk serviced consecutively time spent moving disk head unproductively minimized primary performance goal disk scheduling algorithms case study explores application innovative scheduling algorithm called anticipatoryscheduling virtualmachine environment ofantfarmforxen background iyer demonstrated phenomenon call deceptive idleness disk access patterns generated competing processes performing synchronous sequential reads deceptive idleness leads excessive seeking locations disk solution called anticipatory scheduling introduces small amount waiting time completion request initiation process disk request completed issue request nearby location strategy leads substantial seek savings throughput gains concurrent disk access streams exhibit spatial locality anticipatory scheduling makes process-specific information decides wait process issue read request long wait based statistics disk scheduler processes recent disk accesses average distance request stored estimate process access distance large sense waiting process issue request nearby statistics long 
process waits request completes issues order determine long make sense wait request issued anticipatory scheduling work virtual machine environment system-wide information disk requests required estimate disk head located essential deciding request nearby obehavior requiredto determine whetherand howlong wait information completely single guest requests vmm distinguish guestlevel processes guests vmm cooperate implement anticipatory scheduling requires introduction additional specialized vmm-to-guest interfaces interfaces case legacy binary-only components case interfaces exist today information implement anticipatory scheduling effectively vmm vmm distinguish guest processes additionally associate disk read requests specific guest processes pieces information vmm implementation anticipatory scheduling maintain average seek distance inter-request waiting time processes guests antfarm inform implementation anticipatory scheduling inside xen associate disk read requests processes employ simple context association strategy associates read request process active simple strategy potential asynchrony operating system account due request queuing inside read issued vmm process originated blocked context switched processor leads association error researched accurate ways associating reads true originating process tracking movement data disk memory requesting process methods proven effective overcoming association error due queuing limited space present techniques implementation anticipatory scheduling paper simple context association implementation xen implements device driver virtual machines ddvm ddvm virtual machine allowed unrestricted access physical devices ddvms logically part xen vmm operationally guests runningin disk requests ddvm idealized disk device interface ddvm carries behalf current versions xen driver vms run linux advantage broad device support offers device back-end driver services requests submitted instance front-end driver located proceedings usenix annual technical conference june boston vmas aggregate throughput sec scheduler configuration comparison layer schedulers processes vms process vms processes figure benefit process awareness anticipatory scheduling graph shows theaggregate throughput forvarious configurations scheduler number virtual machines number processes virtual machine experiment linux deadline scheduler standard anticipatory scheduler vmm-level anticipatory scheduler vmas adding process awareness enables vmas achieve single process sequential read performance aggregate competing sequential streams running guest layer effective process case global disk request information normal vms standard linux kernel includes implementation anticipatory scheduling implement anticipatory scheduling vmm layer enabling linux anticipatory scheduler xen ddvm manages disk drive make existing implementationprocessaware resents processes running vms disk request arrives foreign virtual machine xen hypervisorabout process active foreign virtual machine ability distinguish processes expect vmm-level anticipatory scheduler vmas competing processes exist vms evaluation vmas repeat experiments original anticipatory scheduling paper virtual machine environment experiment consists running multiple instances program sequentially reads segment private file vary number processes assignment processes virtual machines disk scheduler guests vmm explore process awareness influences effectiveness anticipatory scheduling vmm make linux deadline scheduler nonanticipatory baseline results scheduler configurations combined workloads shown figure workloads virtual machine processes virtual machines process virtual machines processes experiment shows results configuration anticipatory scheduling demonstrates expected performance anticipation workloads test system results aggregate throughputof sec configurationenables anticipatory scheduling guest deadline scheduler xen virtual machine process case guest complete information processes actively reading disk expect anticipatory scheduler guest level effective figure shows fact case anticipatory scheduling improve aggregate throughput sec sec cases deadline scheduler due lack information processes virtual machines experiment demonstrates performance unmodified anticipatory scheduling vmm layer similar case anticipatory scheduling running guest layer expect performance improvement two-virtual-machine one-process-each case good vmm distinguish virtual machines operating system distinguish processes improvement occur implementation detail xen ddvmback-enddriver requestsin thecontextofa single dedicatedtask anticipatory scheduler interprets presented stream single process making alternating requests parts disk performance comparable configuration anticipation workloads final configuration shows benefit process awareness anticipatory scheduling implemented vmm layer workload configurations anticipatory scheduling works improving aggregate throughput factor sec sec implemented atthevmm layer anticipatoryschedulingin thisconfiguration complete information requests reaching disk process awareness extensions track statistics individual process enabling make effective anticipation decisions proceedings usenix annual technical conference june boston conclusion widespread adoption virtual machines brings interesting research opportunities reevaluate operating system services implemented implementing os-like services vmm made challenging lack high-level application information techniquesdevelopedin paperand implementation antfarm explicit information important operating system abstraction process inside vmm observing interaction guest virtual hardware method alternative explicitly exporting required information vmm directly enabling vmm independently infer information vmm decoupled specific vendor version correctness guests supports acknowledgments work sponsored sandia national laboratories doctoral studies program nsf ccritr- cnsand generous donations network appliance emc amd amd programmer manual volume system programming december ballmer keynote address microsoft management summit april bressoud schneider hypervisor-based fault tolerance proceedings acm symposium operating systems principles sosp pages copper mountain resort colorado december bugnion devine rosenblum disco running commodity operating systems scalable multiprocessors proceedings acm symposium operating systems principles sosp pages saint-malo france october chen noble virtual real hotos proceedings eighth workshop hot topics inoperating systems page ieeecomputer society dragovic fraser hand harris pratt warfield barham neugebauer xen art virtualization proceedings acm symposium operating systems principles sosp bolton landing lake george york october fraser hand neugebauer pratt warfield williamson safe hardware access xenvirtual machine monitor oasis asplos workshop gao reiter song gray-box program tracking foranomaly detection proceedings usenix security symposium pages san diego usa august garfinkel pfaff chow rosenblum boneh terra virtual machine-based platform fortrusted computing proceedings acm symposium operating systems principles sosp bolton landing lake george york october garfinkel rosenblum virtual machine introspection based architecture intrusion detection proc network distributed systems security symposium february goldberg survey virtual machine research ieee computer gum system extended architecture facilities virtual machines ibm journal research development november intel intel virtualization technology specification iaintel architecture april iyer druschel anticipatory scheduling disk scheduling framework overcome deceptive idleness synchronous proceedings acm symposium operating systems principles sosp pages banff canada october joshi king dunlap chen detecting past present intrusions vulnerabilityspecific predicates proceedings acm symposium operating systems principles sosp pages brighton united kingdom october king chen backtracking intrusions proceedings acm symposium operating systems principles sosp banff canada october magnusson christensson eskilson forsgren allberg ogberg larsson moestedt werner simics full system simulation platform ieee computer february popek goldberg formal requirements virtualizable generation architectures communications acm sekar bowen segal preventing intrusions process behavior monitoring proc workshop intrusion detection network monitoring pages berkeley usa usenixassociation sivathanu bairavasundaram arpacidusseau arpaci-dusseau life death block level proceedings symposium operating systems design implementation osdi pages san francisco california december somayaji forrest automated response system-call 
delays proceedings usenix annual technical conference usenix san diego california june sugerman venkitachalam lim virtualizing devices vmware workstation hosted virtual machine monitor proceedings usenix annual technical conference usenix boston fig dynamic data availability figure plots percent processes run unaffected disk failure busy hour trace degree namespace replication set aggressively line varies amount replication popular directories oneway implies directories replicated eight-way -way show modest extreme amount replication means deviations trials shown disks contrast traditional raid disk crashes lead complete data unavailability fact availability degrades slightly expected strict linear fall-off due slight imbalance data placement disks directories modest level namespace replication four-way leads good data availability failure conclude file-based grouping files directory disappear failure leading user dissatisfaction dynamic availability finally simulating dynamic availability examine users applications oblivious d-graid operating degraded mode specifically run portion trace simulator number failed disks record percent processes observed failure run experiment find namespace replication files needed processes replicated experiment set degree namespace replication full replication vary level replication contents popular directories usr bin bin lib figure shows replicating contents directories percentage processes run ill-effect lower expected results figure directories replicated percentage processes run completion disk failure expected reason clear substantial number processes require executable libraries run correctly popular directory replication excellent availability acm transactions storage vol improving storage system availability d-graid failure fortunately popular files read-only directories wide-scale replication raise write performance consistency issues space overhead due popular directory replication minimal sized file system trace directories account total file system size semantic knowledge move construction d-graid prototype underneath block-based scsi-like interface enabling technology underlying d-graid semantic knowledge sivathanu understanding file system utilizes disk enables d-graid implement graceful degradation failure quick recovery exact details acquiring semantic knowledge disk raid system sivathanu assume basic understanding file system layout structures storage system specifically assume d-graid static knowledge file system layout including regions disk block types contents specific block types fields inode describe d-graid builds basic knowledge infer detailed dynamic information file system file system behaviors article extend understanding semantically smart disks presenting techniques handle general file system behaviors previous work required file system mounted synchronously implementing complex functionality disk relax requirement describe set typical file system properties important viewpoint semantically smart disk modern file systems adhere behaviors blocks file system dynamically typed file system locate types blocks physical location disk lifetime file system unix file system block data region user-data block indirect-pointer block directory-data block file system delay updates disk delayed writes file system facilitate batching small writes memory suppressing writes files subsequently deleted consequence delayed writes order file system writes data disk arbitrary file systems order writes carefully ganger remain general make assumptions ordering note properties identified practical reasons linux ext file system exhibits aforementioned behaviors accuracy information assumptions general file system behavior imply storage system accurately classify type block block classification straightforward type block depends location disk acm transactions storage vol sivathanu berkeley fast file system ffs mckusick regions disk store inodes fixed file system creation traffic regions inodes type information spread multiple blocks block filled indirect pointers identified observing inode specifically inode indirect pointer field address indirect block formally identify indirect block semantic disk inode block indirect pointer field relevant inode block written disk disk infers indirect block observes block written information classify treat block indirect block due delayed write reordering behavior file system time disk writes block freed original inode reallocated inode type normal data block disk operations place memory reflected disk inference made semantic disk block type wrong due inherent staleness information tracked implementing correct system potentially inaccurate inferences challenges address article implementation making d-graid discuss prototype implementation d-graid alexander alexander fault-isolated data placement selective metadata replication provide graceful degradation failure employs access-driven diffusion correct performance problems introduced availability-oriented layout alexander replicates namespace system meta-data administrator-controlled stores user data raidor raidmanner refer systems d-graid levels pursuing d-graid level implementation log-structuring rosenblum ousterhout avoid small-write problem exacerbated fault-isolated data placement section present implementation graceful degradation live-block recovery complexity discussion centered graceful degradation simplicity exposition focus construction alexander underneath linux ext file system end section discuss differences implementation underneath vfat graceful degradation present overview basic operation graceful degradation alexander describe simple cases proceeding intricate aspects implementation indirection map similarly scsi-based raid system alexander presents host systems linear logical block address space acm transactions storage vol improving storage system availability d-graid internally alexander place blocks facilitate graceful degradation 
control placement alexander introduces transparent level indirection logical array file system physical placement disks indirection map imap similar structures english stepanov wang wilkes unlike systems imap maps live logical file system block replica list physical locations unmapped blocks considered free candidates d-graid reads handling block read requests d-graid level straightforward logical address block alexander imap find replica list issues read request replicas choice replica read based criteria wilkes alexander randomized selection presence access-driven diffusion diffused copy preference fault-isolated copy writes contrast reads write requests complex handle alexander handles write request depends type block written figure depicts common cases block static meta-data block inode bitmap block unmapped alexander allocates physical block disks replica reside writes copies note alexander easily detect static block types inode bitmap blocks underneath unix file systems simply observing logical block address inode block written d-graid scans block newly added inodes understand inodes d-graid compares newly written block copy process referred block differencing inode d-graid selects home site lay blocks belonging inode records inode-to-home-site hashtable selection home site balance space allocation physical disks d-graid greedy approach selects home site free space write unmapped block data region data block indirect block directory block allocation d-graid file block belongs actual home site case d-graid places block deferred block list write disk learns file block crash inode write make block inaccessible file system in-memory deferred block list reliability concern d-graid newly added block pointers inode indirect block written newly added block pointer refers unmapped block d-graid adds entry imap mapping logical block physical block home site assigned inode newly added pointer refers block deferred list d-graid removes block deferred list issues write physical block writes deferred blocks written acm transactions storage vol sivathanu fig anatomy write parts figure depicts control flow sequence write operations alexander figure inode block written alexander observes contents inode block identifies newly added inode selects home site inode creates physical mappings blocks inode home site inode block aggressively replicated part alexander observes write data block inode mapped write directly physical block part alexander write unmapped data block defers writing block alexander finally observes inode fourth part creates relevant mappings observes blocks deferred issues deferred write relevant home site owner inode blocks inode written subsequent data writes mapped disk directly block type interest d-graid data bitmap block data bitmap block written d-graid scans newly freed data blocks freed block d-graid removes logical-to-physical mapping exists frees physical blocks block deferred list freed block removed deferred list write suppressed data blocks written file system deleted inode written disk generate extra disk traffic similarly optimizations found file systems rosenblum ousterhout removing blocks deferred list important case freed blocks alexander observe owning inode deferred block stays deferred list bounded amount time inode owning block written bitmap acm transactions storage vol improving storage system availability d-graid block indicating deletion block written exact duration depends delayed write interval file system block reuse discuss intricate issues involved implementing graceful degradation issue block reuse existing files deleted truncated files created blocks part file reallocated file d-graid place blocks correct home site reuse blocks detected acted d-graid handles block reuse manner inode block indirect block written d-graid examines valid block pointer physical block mapping matches home site allocated inode d-graid mapping block correct home site write block made context file home site copied physical location location blocks copied added pending copies list background thread copies blocks homesite frees physical locations copy completes dealing imperfection difficulty arises semantically smart disks underneath typical file systems exact knowledge type dynamically typed block impossible obtain discussed section alexander handle incorrect type classification data blocks file data directory indirect blocks d-graid understand contents indirect blocks pointers place file blocks home site due lack perfect knowledge fault-isolated placement file compromised note data loss corruption issue goal dealing imperfection conservatively avoid eventually detect handle cases specifically block construed indirect block written assume valid indirect block live pointer block d-graid action cases case pointer refer unmapped logical block mentioned d-graid creates mapping home site inode indirect block belongs indirect block pointer valid mapping correct mapping indirect block misclassified pointer invalid d-graid detects block free observes data bitmap write point mapping removed block allocated file bitmap written d-graid detects reallocation inode write file creates mapping copies data contents home site discussed case potentially corrupt block pointer point mapped logical block discussed type block reuse results mapping copy block contents home site indirect block pointer valid mapping acm transactions storage vol sivathanu correct block indirect block misclassification alexander wrongly copies data home site note data accessible original file block belongs blocks incorrect home site fortunately situation transient inode file written d-graid detects reallocation creates mapping back original home site restoring correct mapping files accessed properly laid infrequent sweep inodes rare cases improper layout optimizations d-graid eventually move data correct home site preserving graceful degradation reduce number times misclassification occurs alexander makes assumption contents indirect blocks specifically number valid unique pointers null pointers alexander leverage assumption greatly reduce number misclassifications performing integrity check supposed indirect block integrity check reminiscent work conservative garbage collection boehm weiser returns true pointers -byte words block point valid data addresses volume nonnull pointers unique set blocks pass integrity check corrupt data contents happened evade conditions test run data blocks local file system small fraction data blocks pass test blocks pass test reallocated file data block indirect block misclassified access-driven diffusion issue d-graid address performance fault-isolated data placement improves availability cost performance data accesses blocks large file directorybased grouping files directory longer parallelized improve performance alexander performs access-driven diffusion monitoring block accesses determine block ranges hot diffusing blocks replication disks system enhance parallelism access-driven diffusion achieved logical physical levels disk volume logical approach access individual files monitored considered hot diffused per-file replication fails capture sequentiality multiple small files single directory pursue physical approach alexander replicates segments logical address space disks volume file systems good allocating contiguous logical blocks single file files directory replicating logical segments identify exploit common access patterns sensitive data contents semantically smart disks place requirement file system traces include user data 
blocks privacy concerns campaign encounter difficult overcome acm transactions storage vol improving storage system availability d-graid implement access-driven diffusion alexander divides logical address space multiple segments normal operation gathers information utilization segment background thread selects logical segments remain hot number consecutive epochs diffuses copy drives system subsequent reads writes replicas background updates original blocks imap entry block copy date policy deciding segments diffuse simplistic prototype implementation detailed analysis policy space access-driven diffusion left future work amount disk space allocate performance-oriented replicas presents important policy decision initial policy alexander implements reserve minimum amount space system administrator replicas opportunistically free space array additional replication approach similar autoraid mirrored data wilkes autoraid identify data considered dead file system written contrast d-graid semantic knowledge identify blocks free live-block recovery implement live-block recovery d-graid understand blocks live knowledge correct block live considered dead lead data loss alexander tracks information observing bitmap data block traffic bitmap blocks liveness state file system reflected disk due reordering delayed updates uncommon observe write data block bit set data bitmap account d-graid maintains duplicate copy bitmap blocks sees write block sets bit local copy bitmap duplicate copy synchronized file system copy data bitmap block written file system conservative bitmap table reflects superset live blocks file system perform live-block recovery note assume preallocation state bitmap written disk subsequent allocation locking linux modern systems ensures technique guarantees live block classified dead disk block live longer situation arise file system writes deleted blocks disk implement live-block recovery alexander simply conservative bitmap table build list blocks restored alexander proceeds list copies live data hot spare aspects alexander number aspects implementation required successful prototype subsection briefly describe key aspects acm transactions storage vol sivathanu physical block allocation logical array blocks exported scsi property block numbers contiguous logical address space mapped contiguous physical locations disk property empowers file systems place data contiguously disk simply allocating contiguous logical blocks data traditional raid property straightforward preserve physical blocks assigned round-robin fashion disks contiguity guarantees continue hold physical block assign logical block simple arithmetic calculation logical block number d-graid deciding physical block allocate newly written logical block straightforward decision depends file logical block belongs logical offset file fault-isolated placement set contiguous logical blocks belong single file map contiguous physical blocks disk logical block set mapped physical block block set mapped physical block order preserve contiguity expectations larger granularity d-graid balances space utilization files allocation policy large values block map physical block number disks array choice policies requires estimates file size dynamic prototype addresses issue simple technique space reservations alexander utilizes knowledge inodes indirect blocks priori estimates exact size entire file deconstructing commodity storage clusters haryadi gunawi nitin agrawal andrea arpaci-dusseau remzi arpaci-dusseau jiri schindler computer sciences department emc corporation wisconsin madison hopkinton massachusetts abstract traditional approach characterizing complex systems run standard workloads measure resulting performance end user unique opportunities exist characterizing system constructed standardized components inside system instrumenting components paper show intra-box instrumentation understand behavior large-scale storage cluster emc centera analysis leverage standard tools tracing disk network traffic emanating node cluster correlating traffic running workload infer structure software system write update protocol policies performs caching replication load-balancing imposing variable intra-box delays network disk traffic confirm causal relationships network disk events infer semantics messages nodes examining single line source code introduction systems community long understood benefits separating architecture implementation clean separation clients assured consistent standard interface designers freedom innovate interface common result simple interface hides growing amount internal implementation complexity trend occurred implementation microprocessors instruction sets storage systems modern storage systems simple interfaces hide great deal internal complexity high-end storage servers continue scsi interface simple read write interface exporting array blocks client storage servers implement range complex functionality tens processors gigabytes memory hundreds disks emc symmetrix storage server implements redundant data paths end-to-end checksumming machinery fence portions caches failure disk scrubbing technology discover latent errors proactively standard scsi interface today fundamental change occurring storage systems past storage systems built specialized parts assembled commodity components high-end storage servers built collections commodity pcs running commodity operating system connected ethernet network modern storage systems simply instances cluster workstations domains users understand behavior systems understanding enables critical evaluation design implementation choices users build models system behaves workloads tune debug performance enables administrators identify system behaving correctly drawbacks standard interfaces hide interesting information internal behavior measure evaluate systems application-level benchmarks microbenchmarks traditional approaches assume observe behavior system external interface shift storage system design leverage commodity components greatly increases ability analyze storage system behaves effect building system commodity components opens box users directly observe occurring inside users leverage existing standardized tools perform analysis paper develop set intra-box techniques analyze structure policies commodity-based storage clusters analysis major components monitor perturb network disk traffic internal storage cluster order deduce structure main communication protocols build protocol knowledge dissect internal policy decisions caching prefetching write buffering load balancing apply techniques important instance commodity storage cluster emc centera content-addressable storage system centera designed provide low-cost easy-to-manage scalable storage fixed content data medical images electronic documents archives content addressability centera advantage massive redundancy present data attachments reduce capacity requirements main contribution paper analysis centera protocols policies note results appears proceedings international symposium computer architecture isca achieved assistance emc verify accuracy relevance include metaanalysis results emc find centera chooses simplicity reliability sophisticated performance optimization good choice early implementation analysis reveals structure write update protocol standard two-phase commit writes committed synchronously disks policies centera caching prefetching mechanisms massachusetts june uhlig levasseur skoglund dannowski scalable multiprocessor virtual machines proceedings virtual machine research technology symposium pages san jose california waldspurger memory resource management vmware esx server proceedings symposium operating systems design implementation osdi boston massachusetts december whitaker shaw gribble scale performance denali isolation kernel proceedings symposium operating systems design implementation osdi boston massachusetts december 
commodity file systems storage nodes leaving complicated caching schemes client applications derive interesting properties load balancing centera storage nodes gather disperse load information locally global effects network link performance account main contribution paper development intra-box techniques applied solely centera techniques widely applicable general lesson draw power probe points system observation internal cluster network disk traffic crucial approach future systems architectural support enable type detailed analysis paper structured present methodology structural analysis centera protocols policy inference analyze results including accuracy confirmation emc engineer discuss related work conclude methodology section begin presenting general overview storage cluster test emc centera describe intra-box techniques analyzing structure policies distributed systems system overview emc centera content addressable storage cas cluster designed storing retrieving fixed content information centera handles management physical storage resources transparently applications designed highly scalable no-singlepoint-of-failure platform centera content addressing applications access data objects blobs binary large objects -bit content address derived contents object hash function applied data architecture centera cluster redundant array independent nodes rain nodes connected private lan node runs centrastar software linux kernel operates storage node access node storage nodes hold objects local disks access nodes manage read write requests external client application server storage nodes general protocol centera application contacts access node delivers data object file centera write blobwrite api centera calculates unique content address object records metadata object separate file called c-clip descriptor file cdf cdf calculated returned application copies cdf blob stored data objects retrieved contacting access node read blobread api providing c-clip evaluate centera cluster access storage nodes utilizing smaller clusters experimental purposes node runs linux centrastar version secondgeneration hardware -ghz pentium memory intel etherexpress pro ethernet ports maxtor ata disks access node connected clients ethernet intra-box analysis traditional approach understanding behavior systems run standard workloads measure resulting performance end user unique opportunities exist characterizing system constructed standardized components intra-box analysis inside system instrumenting constituent components analyze behavior distributed storage server intra-box techniques observation delay traffic nodes disks passive observation network disk traffic track correlations requests general idea protocol structure internal policies observation enable definitively conclude causality requests infer message depends specific previous event delay messages disk requests observation derive general protocol structure policies begin simply observing traffic node disk case traffic observed straightforward tools trace tcp udp communication nodes tcpdump trace disk traffic insert kernel pseudo-device driver disk mount file system driver records start time end time block number read write request collect suitable observations run simple workload client application server workload repeatedly creates objects trace traffic network disk assume large workload running centera perform multiple trials filter traffic occur consistently analysis performed offline avoid interference system activity analysis determine general properties communication disk activity system appears proceedings international symposium computer architecture isca nodes send messages nodes nodes read write local disk size network message time delay network disk events infer properties specific centera nodes cluster act access nodes versus primary secondary storage nodes delay passive observation network disk events correlate events observation enable determine exact dependencies events precisely repeatedly observes event occurs event infer depends correlation derive causality successful number potential weaknesses unrelated events consistently occur order simply due performance characteristics system large number iterations required observe event orderings occur consistently filter background noise finally difficult discover event dependent multiple preceding events derive causal 
relationships events delay network disk event observe subsequent events delayed delay receipt message observe sending message delayed infer dependent indirectly delayed infer independent complicating factor determining amount event delayed important issue events dependent multiple events suppose sending message dependent receiving messages arrives delay arrive usual time event triggers incorrectly conclude independent avoid situation inject large delay exceeds durations system tuned system interest delaying dependent events delayed desired delay network traffic employ nistnet modified version sits top tcpdumpand delays incoming packets framework select amount delay define criteria packets delayed centera messages uniquely identified size size protocol type tcp udp determine messages delayed utilize fields protocol headers addresses port numbers delay disk traffic pseudo-device driver tracing requests configure duration delay requests delayed reads writes delayed requests separate queue delay time expires deducing system structure section apply intra-box analysis derive internal structural protocols employed emc centera begin passive observations infer basic protocol storing accessing objects actively delay network disk events determine relationships events storing objects passive observations step passively trace network disk traffic emc centera analyze distinct protocols events occur user stores objects writes events occur user accesses objects reads analysis focused writes complex object write protocol figure pictorial representation findings centera protocol writing objects figure shows network disk events occur client centera nodes request figure reports duration intervals tcp message analysis presented diagram infer basic centera protocol storing objects note description tend nodes perform action action send udp message disk operation completes verified causal relationship events section sequences conjectures object write protocol begins client contacts access node directly sending -byte message access node issues disk read sets tcp connection primary storage node communicates primary storage node performs disk read sets connection secondary storage node communicates time client stores object tcp connection created access node storage nodes structural analysis protocol determine access node storage nodes selected selection policy decision explore section series messages propagates back secondary storage node client client receives response sends variable number messages access node infer messages data object size varies size objects access node forwards data primary storage node forwards data secondary storage node sending transfer acknowledgment storage node writes local disk communicates udp centera storage nodes udpx udpy events storage nodes propagate series -byte -byte acknowledgments access node finally access node informs client request appears proceedings international symposium computer architecture isca commit node access primary commit commit ack setuptcp conn tcp conn abe bce req complete tcp conn transfer ack req ack write req write req req ack transfer ack transfer fin commit tear downtcp conn write req req ack transfer fin commit commit ack tear transfer fin setup client storage secondary storage disk writes sync timeout storage node secondary primary storage node storage node transfer ack data transfer transfer fin udpy udpy update ack write update udpx udpx udpx snx commit figure anatomy centera write protocol figure left pictorial representation findings shows network disk events occur client centera nodes -kb object write blobwrite api tcp messages labeled values message unique label identifying endpoints simple message initial message nodes access node primary storage node average size bytes protocol message shown message assigned label reflecting understanding semantic purpose protocol interval tcp events centera node labeled unique identifier duration intervals reported figure single block disk reads occur intervals figure top shows detail events occur intervals udp messages shown designated label identifying destination node simple message udpx udp message storage node round protocol complete centera nodes tear tcp connections abe bce timing results reported figure reveal time spent storing -kb objects note client sees object stored latency approximately roughly sum times figure shows latency occurs intervals matching intervals figure corresponds access node waiting storage nodes read disk data object transferred access node storage nodes writing object disk object read protocol reads client node communicates access node turn reads segment file case indirect block observes inode written file size blocks reserves contiguous blocks home site assigned file actual logical blocks written subsequently reserved space note blocks deferred inodes indirect blocks observed write logical block prior reservation inodes indirect blocks written periodically size information obtained writes stable just-in-time commit space reservations depend size information extracted inode indirect blocks indirect block detection fundamentally inaccurate misclassified indirect block result spurious reservations hold physical space prevent alexander employs lazy allocation actual physical blocks committed logical block written reservation priori reservations viewed soft space reclaimed required interaction deferred writes sync alexander defers disk writes logical blocks observed owning inode arbitrary deferral potentially conflict application-level expectations sync operation issued sync returns application expects acm transactions storage vol improving storage system availability d-graid data disk preserve semantics d-graid handles inode indirect block writes specially d-graid return success write inode indirect block deferred writes blocks pointed inode indirect block reached disk sync operation complete inode block write returns deferred writes guaranteed complete sync returns argument extends fsync return writes pertaining file complete weakness approach application performs equivalent fdatasync flushes data blocks disk metadata technique preserve expected semantics inconsistent fault behavior linux ext interesting issue required change design behavior linux ext partial disk failure process read data block unavailable ext issues read returns failure process block recovery process issues read ext issue read works expected process open file inode unavailable ext marks inode suspicious issue request inode block alexander recovered block avoid change file system retain ability recover failed inodes alexander replicates inode blocks namespace meta-data collocating data blocks file persistence data structures number structures alexander maintains imap reliably committed disk preferably good performance buffered small amount nonvolatile ram note nvram serve cache actively accessed entries data structures space requirements acceptable level current prototype simply stores data structures memory complete implementation require backed persistently popular directory replication important component missing alexander prototype decision popular read-only directories usr bin replicate widely alexander proper mechanisms perform replication policy space remains unexplored initial experience simple approach based monitoring frequency inode access time updates effective alternative approach administrators directories treated manner alexander fat surprised similarities found implementing d-graid underneath ext vfat vfat overloads data blocks user data blocks directories alexander acm transactions storage vol sivathanu defer classification blocks manner similar ext implementation expected implementation basic mechanisms d-graid physical block allocation allocation home sites files tracking replicas critical blocks shared versions d-graid instances vfat implementation d-graid differed interesting ways ext version fact pointers file located file allocation table made number aspects d-graid simpler implement vfat indirect pointers worry copy fat block written version directly compared previous contents block accurate information blocks newly allocated deleted ran occasional odd behavior linux implementation vfat linux write disk blocks allocated freed avoiding obvious common file system optimization behavior vfat estimate set live blocks strict superset blocks live indicative untuned nature linux implementation served indicator semantic disks wary assumptions make file system behavior evaluating alexander present performance evaluation alexander focus primarily linux ext variant include baseline measurements vfat system answer questions alexander work correctly time overheads introduced effective access-driven diffusion fast live-block recovery benefits expect d-graid complex implementation platform alexander prototype constructed software raid driver linux kernel file systems mount pseudodevice normal disk environment excellent understanding issues involved construction real hardware d-graid system limited ways importantly alexander runs system host applications interference due competition cpu memory resources performance characteristics microprocessor memory system found actual raid system 
experiments utilize -mhz pentium iii k-rev min ibm disks acm transactions storage vol improving storage system availability d-graid fig errors placement figure plots number blocks wrongly laid alexander time running busy hour trace experiment run disks total number blocks accessed trace alexander work correctly alexander complex simple raid systems ensure alexander operates correctly put system numerous stress tests moving large amounts data system problems extensively tested corner cases system pushing situations difficult handle making system degrades gracefully recovers expected repeatedly crafted microbenchmarks stress mechanisms detecting block reuse handling imperfect information dynamically typed blocks constructed benchmarks write user data blocks disk worst-case data data appears valid directory entries indirect pointers cases alexander detect blocks indirect blocks move files directories proper disk fault-isolated locations verify establishes alexander places blocks tcp connection disk instrumented storage nodes file system log storage block node allocations receives addition request alexander reads logs events disk interest sends data assignment object home back site access inode node creation access node mapping transmits logical object block remapping blocks home client site exchanges acknowledgments receipt logical writes storage node file tears system tcp evaluate connection behavior alexander storage node workload finally ran informs workload client alexander request obtained complete time-ordered log figure events shown due occurred space file system limitation delaying alexander events observing processed network log disk off-line events enables looked learn number blocks wrongly internal laid protocol centera time ran test observations hours conclude traces events found occur hours delay examined events number infer blocks dependencies misplaced network disk temporarily events low write fewer protocol due blocks space report constraints detailed results present hour trace observed greatest number misplaced blocks hours examined figure shows results acm transactions storage similar vol analysis read sivathanu protocol fig message time overheads protocol figure determine plots set time overheads events observed depends d-graid level delaying versus raid preceding level events series node microbenchmarks observing tests delay run subsequent sending disk message systems structure discussion investigating type event turn tcp traffic udp traffic completion disk reads writes appears proceedings international symposium computer architecture isca latency a-xx period access node latency b-xx period primary storage node latency c-xx period secondary storage node figure intervals writing objects figures report average duration intervals tcp message events graphs examine access node primary storage node secondary storage node graph examine intervals node x-labels match figure send receive time access node primary storage node secondary storage node abe send receive time packet abe bce packet bcebc packet figure impact delaying tcp packets write protocol delay interesting subset tcp packets pairs graphs involved centera nodes access primary storage secondary storage nodes y-axis report send receive time packet relative start request sharp increase send receive time packet packet delayed packet depends packet stands delay tcp traffic begin investigating straightforward case dependency outgoing tcp packet depends previously-arriving tcp packets note determine outgoing message dependent multiple tcp packets node due nature tcp tcp reliable byte-stream protocol receiver guaranteed packets order sender transmitted packets delayed lost subsequently resent check dependent receiving receiving dependent receiving guaranteed arrive depends waiting sufficient figure shows impact delaying interesting subset tcp packets pairs graphs report send experiment receive operations time enacted packet file creations operation -kb file figure parts bottom part shows normal operation alexander capability react block reuse remapping copying blocks correct homesite figure shows alexander quickly centera detect nodes wrongly involved blocks access primary remap storage secondary appropriately storage nodes note number sharp increase blocks misplaced send temporarily receive time packet packet delayed packet total depends number packet blocks accessed measurements imply trace dependencies top part initial request figure exchange shows sending number primary misplaced storage node blocks depends receiving experiment secondary assuming storage node remapping serves acknowledgment occur primary expected secondary storage nodes delinquent blocks received remain request misplaced sending dip primary storage end node depends trace receiving occurs acknowledges misplaced primary blocks secondary storage assigned nodes received file data object home site sending primary storage preceding node delete depends accidentally receiving correcting secondary original serves misplacement acknowledgment time overheads storage nodes introduced written object explore disk time details overheads finally arise due measurements show semantic interesting inference set primarily occurs blocks written file system file creation figure shows relationships performance request alexander complete specifically simple delaying microbenchmark impacts 
delaying impacts delaying impact protocol packet serves acknowledgment primary storage node received packet access node secondary storage node independence confirmed delay technique passive measurements observed udp traffic isolate events dependent arriving udp traffic interesting udp traffic occurs intervals primary secondary storage nodes non-trivial amount additional udp traffic occurs measurements udp traffic filtered occur regular points write protocol found delaying protocol events impact background udp traffic conclude udp traffic related write protocol appears proceedings international symposium computer architecture isca trial time delay send udp recv udp send time sec delay udp sec send udp recv udp send time sec delay udp sec send udp recv udp send figure impact delaying udp packets write protocol graphs show time primary storage node sends receives udp packets udp udp sends tcp packet graph default case extra delay graph delay udp graph delay udp seconds experiment repeated times total data received file size understanding cas snsn- figure content addressability figure plots amount data written storage nodes storing file file size increased file filled single repeated byte candidate space-savings due content-based addressing figure addresses relationship udp traffic events measurements performed primary storage node relationships identical secondary storage node graph independent trials show time udp packets storage nodes udp packets received tcp packet back access node graph reports observed timings default centera system delays udp traffic figure shows ordering sending udp packet storage node receiving udp packet storage node fact udpx allocating writes slower due extra cpu cost involved tracking fault-isolated placement reads overwrites perform comparably raidthe high unlink times d-graid fat fat writes data pertaining deleted files processed d-graid newly allocated data implementation untuned infrastructure suffers cpu memory contention host worst-case estimates overheads cost d-graid explored overhead metadata replication purpose chose postmark katcher acm transactions storage vol improving storage system availability d-graid table performance postmark table compares performance d-graid level raidon postmark benchmark row marked d-graid specific level metadata replication column reports benchmark run-time column shows number disk writes incurred column shows number disk writes metadata blocks fourth column number unique metadata blocks written experiment run disks blocks written run-time total meta-data unique raidd-graid d-graid d-graid d-graid meta-data-intensive file system benchmark slightly modified postmark perform sync deletion phase meta-data writes accounted making pessimistic evaluation costs table shows performance alexander degrees meta-data replication table synchronous replication meta-data blocks significant effect performance meta-data-intensive workloads file sizes postmark range bytes note alexander performed default raidfor lower degrees replication physical block allocation ext contiguous free chunk blocks allocate file layout suboptimal small files pack table shows number disk writes incurred benchmark percentage extra disk writes roughly accounts difference performance replication levels extra writes meta-data blocks counted number unique physical writes meta-data blocks absolute difference replication levels small suggests lazy propagation updates meta-data block replicas idle time freeblock scheduling greatly reduce performance difference cost added complexity lazy update propagation replicas updated d-graid incur extra disk writes played back portion traces min standard raidsystem d-graid disks playback engine issued requests times trace optional speedup factor speedup implies idle time requests reduced factor speedup factors d-graid delivered per-second operation throughput raidutilizing idle time trace hide extra cpu overhead scaling factor operation throughput lagged slightly d-graid showing slowdown one-third trace execution caught due idle time acm transactions storage vol sivathanu fig access-driven diffusion figure presents performance d-graid level standard raidunder sequential workload experiment number files size read sequentially total volume data fixed d-graid performs smaller files due physical block layout effective access-driven diffusion show benefits access-driven diffusion trial experiment performed set sequential file reads files increasing size compared standard raidstriping d-graid access-driven diffusion figure shows results experiment figure access-driven diffusion sequential access larger files ran rate single disk system benefit potential parallelism access-driven diffusion performance improved reads directed diffused copies disks system note case arranged files diffused start experiment reading threshold number times investigating sophisticated policies initiate access-driven diffusion left future work fast live-block recovery explore potential improvement live-block recovery figure presents recovery time d-graid varying amount live file system data figure plots lines worst-case best-case live-block recovery worst case live data spread disk case compacted single portion volume graph live-block recovery successful reducing recovery time disk half full note difference worst-case best-case times difference suggests periodic disk reorganization ruemmler wilkes speed recovery moving live data localized portion acm transactions storage vol improving storage system availability d-graid fig live-block recovery figure shows time recover failed disk hot spare d-graid level mirrored system live-block recovery lines d-graid plotted worst case live data spread entire -mb volume case compacted smallest contiguous space plotted recovery time idealized raid level fig availability profile figure shows operation d-graid level raid failures -gb array consisted data disks hot spare failure data reconstructed hot spare d-graid recovering faster raid failures occur raid loses files d-graid continued serve files workload consisted read-modify-writes -kb files randomly picked froma -gb working set benefits expect d-graid demonstrate improved availability alexander failures figure shows availability performance observed process randomly accessing -kb files running d-graid raidto ensure fair comparison d-graid raidlimited reconstruction rate acm transactions storage vol sivathanu table iii code size alexander implementation number lines code needed implement alexander shown column shows number semicolons column shows total number lines including white spaces comments semicolons total d-graid generic setup fault-isolated placement physical block allocation access driven diffusion mirroring live block recovery internal memory management hashtable avl tree file system specific sds inferencing ext sds inferencing vfat total figure shows reconstruction -gb volume -gb live data completed faster d-graid compared raids extra 
failure occured availability raiddropped d-graid continued availability surprisingly restore raidstill failed files linux retry inode blocks fail remount required raidreturns full availability complex implementation briefly quantify implementation complexity alexander table iii shows number statements required implement components alexander table core file system inferencing module ext requires lines code counted number semicolons core mechanisms d-graid contribute lines code rest spent hash table avl tree wrappers memory management compared tens thousands lines code comprising modern array firmware added complexity d-graid significant academic prototype complexity numbers slight underestimate required production quality implementation analysis intended approximate estimate d-graid levels discussion focused implementing d-graid storage system redundancy user data raidor mirrored storage system raidhowever mentioned layout mechanisms d-graid orthogonal underlying redundancy scheme section formalize levels d-graid popular traditional raid levels present custom policies d-graid level tailored underlying redundancy mechanism acm transactions storage vol improving storage system availability d-graid note contrast traditional raid levels levels d-graid differ type redundancy normal user data system meta-data maintained raidwith configured replication degree d-graidno redundancy simplest d-graid level redundancy mechanism employed normal user data single disk failure results data loss contrast traditional raidwhere single disk failure results complete data loss d-graidensures proportional data availability failure figure shows d-graidconfiguration absence redundancy normal data additional storage required access-driven diffusion d-graidneeds separate performance reserve asdescribed section reserve fixed percentage storage volume size tunable administrator tuning parameter administrator control tradeoff performance storage efficiency issue changing size performance reserve dynamically file systems equipped deal variable volume size limitation addressed simple technique administrator creates file file system reserved diffuse size file implicitly conveys d-graid size performance reserve file system blocks assigned reserved file file d-graid free storage space file system runs short storage administrator prune size special file dynamically reducing size performance reserve d-graidmirroring mirrored d-graid system stripes data multiple mirrored pairs similar raidnote d-graid meaningful storage system comprised single mirrored pair raidbecause system fundamentally partial failure mode access-driven diffusion policy d-graidis similar d-graidwhere dynamic performance reserve hold diffused copies figure depicts configuration note diffused copies mirrored d-graidrequires half percentage space d-graidrequires order achieve level diffusion slight variant d-graidcan make access-driven diffusion effective cost slight degradation reliability disks mirrored pair physical mirrors discussed employ logical mirroring impose logical disk block copies disks relaxed definition d-graid store copy file traditional striped fashion copy file stored fault-isolated fashion figure depicts configuration file fault-isolated copy laid single disk copy striped disks single disk failure result data loss logical mirroring data achieves benefits acm transactions storage vol sivathanu fig d-graid levels figures depict data layout d-graid redundancy schemes style shading represents file d-graidfigure color shading physical raidstripe diffusion segments striped region d-graidlogical separate regions disk simplicity practice interleaved fault-isolated copies acm transactions storage vol improving storage system availability d-graid fault-isolated placement impact performance parallelism striped copies note scenario extra space required access-driven diffusion variant d-graidimproves performance efficient access-driven diffusion reduces reliability compared traditional d-graidin traditional d-graidi physical mirroring single disk failure failure mirror disk lead loss data logical mirroring failure results loss data proportionally irrespective disk incurred failure d-graidparity d-graidis counterpart traditional raidredundancy user data maintained form parity encoding small number disks resulting space efficiency fine grained block-level striping fundamental raidwould conflict fault isolated placement d-graid techniques orthogonal fine-grained striping required raidoccurs physical level actual physical disk blocks fault-isolated placement logical assignment files physical blocks d-graidwould maintain invariant kth parity block xor kth block disk difference kth block disk data pertaining file d-graid raid part file configuration shown figure blocks belonging physical raidstripe shaded color fault-isolated placement raidlike redundancy leads performance issue blocks raidstripe longer part single file logically related full stripe writes uncommon block allocation policies writes partial stripes small writes performance problem requiring disk operations block written patterson address small write problem d-graidwe customized block allocation policy allocation policies section targeted preserving logical contiguity perceived file system d-graidrequires policy minimizes impact small writes policy log-structured allocation rosenblum ousterhout wilkes blocks written place allocated empty segments invalidating locations log structured allocation d-graidwould simply divide disk multiple segments time d-graidwould operate segment stripe comprises kth segment disk write arrives fault isolation module d-graidwould decide disk block laid allocate tail physical block segment logical block typical workload writes spread multiple files graid balances space utilization disks writes acm transactions storage vol sivathanu multiple files spread segments current segment stripe resulting full stripe writes note technique effective log cleaner coordinate cleaning entire set disks set freed segments comprise full segment stripes summary summary find basic layout techniques d-graid orthogonal underlying redundancy mechanism building top physical redundancy scheme d-graid strictly improves availability storage array custom policies access-driven diffusion physical block allocation make d-graid effective redundancy mechanism discussion impact wrong section fair amount complexity identifying logical file block belongs order place correct home site graceful degradation interesting question arises light complexity d-graid makes wrong inference d-graid udpy parallel passive observations sufficient show dependency permanently associates messages block graph wrong show file udp places arrives wrong udp home site incorrect inferences affect udp parts arrives d-graid confirm design differently true graceful dependencies degradation component delay udp d-graid messages robust incorrect graph inferences delay incorrect request association udp block seconds wrong results file show udp affect fault isolation delayed impact udp correctness d-graid acknowledgment miscalculates udp large fraction interesting associations property reliability apparent resulting udp storage layout unreliable protocol strictly centera software implements traditional raid level timeout-retry policy resend d-graid messages builds top response existing raid received redundancy incorrect association lead layout completely graph fault isolated alayout centera implements exhibit timeout fault isolation compared traditional udp raid packets face point incorrect resends inference packets storage system explore correctness impact affected making timeout d-graid policy ideal candidate depth make aggressive graph semantic experiments information contrast increase live block delay recovery component d-graid depend semantic information correctness requires conservative estimate set live blocks volume d-graid requires estimate strictly conservative live block inferred dead lead loss data udp section tracking seconds block liveness information circumstances conservatively storage node simple receives straightforward acknowledgment packet realize udp centera protocol performs timeout-retry intervals stops retrying point storage node sends final tcp packet receiving udp depends receiving udpx udpy waiting time-out approximately seconds disk events determine tcp udp messages dependent completion disk reads disk writes disk read operations occur centera nodes request initiated intervals disk write operations occur storage nodes data object received intervals figure shows delaying disk reads writes storage nodes impact subsequent messages graphs examine access node primary storage node secondary storage node make observations measurements storage nodes tcp message immediately disk read fact dependent disk read send times increase disk read delayed confirms initial intuition related note delaying reads nodes subsequent events delayed indicating reads overlapped storage nodes delaying disk writes delays sending udpx packet send time udpx delayed seconds storage nodes perform disk writes succession conclusion delaying network disk events centera write protocol identify events dependent cases analysis passive observations correlations case occurs end write protocol primary storage node sends commit-ack message access node received an-commit message access node received commit-ack storage node relying correlations determine commit-ack primary independent commit-ack secondary occurred case occurs storage nodes written disk storage nodes send tcp message data committed disk node attempted communicate udp storage nodes udp messages succeeded relying correlations inferred storage nodes receive udp replies sending tcp commit appears proceedings international symposium computer architecture isca abe send receive time packet access node write pri write sec read pri read sec read bce udp send receive time packet primary pri storage node write pri write sec read pri read sec read bcebc udpbc send receive time packet secondary sec storage node write pri write sec read pri read sec read figure impact delaying disk activity write protocol delay reading writing disk graphs involved centera nodes access primary storage secondary storage nodes y-axis graph report send receive time packet relative start request udp sending udpx sharp increase send receive time packet disk event delayed packet depends disk event inferring policies previous section analyzed protocol structure centera write read operations section infer policy decisions protocols analysis focus important functionality expect storage system replication load balancing caching prefetching key approach utilize derived structure write figure read shown protocols fine-tune analysis analysis caching information enable fine-grained accounting disk accesses enabling filter traffic system unrelated current request object write policies begin analyzing decisions occur write protocol originally shown figure continue assume observe delay network disk traffic content addressability begin inferring basic decision large units data centera segments file multiple blobs stored replicated accessed independently blob unit granularity content hashing duplicate detection performed storage allocated storage nodes determine size blob write file byte repeated size file written blob size file internally comprised identical blobs amount traffic halved behavior observed multiples blob size figure shows amount data transferred storage nodes primary secondary network increase size file written amount data transferred climbs steadily x-axis increases point drops cyclical pattern repeats indicating unit content addressability level replication centera data replication protect data unavailability corruption face failures fundamental choice level replication number copies data objects level readily apparent previous structural analysis figure shows replicas made object written experimentation shown range object sizes reveals level replication objects load balancing dissect load balancing strategy writes write enters system centera chooses primary storage node data primary storage node chooses secondary location infer load balancing policy factors determine storage nodes selected factors influence decision nodes place data item including current performance amount space analysis focus performance factors cpu utilization disk usage network connections network delay vary factors time controlled manner cpu run high priority loop varying fraction sleep time network delay varied modified nistnet disk usage generate background traffic file copy program open varying number tcp connections primary secondary nodes observe internal message traffic determine induced load impact centera placement decisions figure plots amount data written node load experiments figure factors influence selection nodes writes heavily skewing writes unloaded nodes cpu load disk load number network connections node interestingly observe increasing network delay incoming link storage node affect load balancing performance writes decreases dramatically shown increase latency incoming link storage node centera incorporate delay load balancing strategy hypothesize centera d-graid requires accuracy simple piece semantic information implementing fast recovery design complexity d-graid related fault isolation graceful degradation component robust incorrect inference wrong bad acm transactions storage vol improving storage system availability d-graid conclusions robust system continues operate correctly presence class errors robert hagmann hagmann d-graid turns simple binary failure model found storage systems continuum increasing availability storage continuing operation partial failure quickly restoring live data failure occur article shown potential benefits d-graid established limits semantic knowledge shown successful d-graid implementation achieved limits simulation evaluation prototype implementation found d-graid 
built underneath standard block-based interface file system modification delivers graceful degradation live-block recovery access-driven diffusion good performance conclude discussions lessons learned process implementing d-graid limited knowledge disk imply limited functionality main contributions article demonstration limits semantic knowledge proof implementation limitations interesting functionality built inside semantically smart disk system semantic disk system careful assumptions file system behavior hope work guide pursue similar semantically smart disks easier build file systems reorder delay hide operations disks reverse engineering scsi level difficult small modifications file systems substantially lessen difficulty file system inform disk believes file system structures consistent on-disk state challenges disk lessened small alterations ease burden semantic disk development semantically smart disks stress file systems unexpected ways file systems built operate top disks behave d-graid specifically behave part volume address space unavailable heritage inexpensive hardware linux file systems handle unexpected conditions fairly exact model dealing failure inconsistent data blocks missing reappear true inodes semantically smart disks push functionality storage file systems potentially evolve accommodate acknowledgments anurag acharya erik riedel yasushi saito john bent nathan burnett timothy denehy brian forney florentina popovici lakshmi bairavasundaram insightful comments earlier drafts article jack harwood helpful discussions acm transactions storage vol sivathanu richard golding excellent shepherding earlier version article anonymous reviewers thoughtful suggestions greatly improved content article finally computer systems lab providing terrific environment computer science research acharya uysal saltz active disks programming model algorithms evaluation proceedings international conference architectural support programming languages operating systems asplos viii san jose alvarez burkhard cristian tolerating multiple failures raid architectures optimal storage uniform declustering proceedings annual international symposium computer architecture isca denver anderson chase vahdat interposed request routing scalable network storage acmtrans comput syst feb bitton gray disk shadowing proceedings international conference large data bases vldb los angeles boehm weiser garbage collection uncooperative environment softw pract exper sep burkhard menon disk array storage system reliability proceedings international symposium fault-tolerant computing ftcstoulouse france chapin rosenblum devine lahiri teodosiu gupta hive fault containment shared-memory multiprocessors proceedings acm symposium operating systems principles sosp copper mountain resort chen lee gibson katz patterson raid highperformance reliable secondary storage acm comput surv june denehy arpaci-dusseau arpaci-dusseau bridging information gap storage protocol stacks proceedings usenix annual technical conference usenix monterey dowse malone recent filesystem optimisations freebsd proceedings usenix annual technical conference freenix track monterey emc corporation symmetrix enterprise information storage systems emc corporation hopkinton web site http emc english stepanov loge self-organizing disk controller proceedings usenix winter technical conference usenix winter san francisco ganger blurring line oses storage devices tech rep cmu-cs- carnegie mellon pittsburgh ganger mckusick soules patt soft updates solution metadata update problem file systems acmtrans comput syst ganger worthington hou patt disk subsystem load balancing disk striping conventional data placement hicss gibson nagle amiri butler chang gobioff hardin riedel rochberg zelenka cost-effective high-bandwidth storage architecture proceedings international conference architectural support programming languages operating systems asplos viii san jose gray computers stop proceedings international conference reliability distributed databases gray horst walker parity striping disc arrays low-cost reliable storage acceptable throughput proceedings international conference large data bases vldb brisbane australia gribble robustness complex systems proceedings eighth workshop hot topics operating systems hotos viii schloss elmau germany acm transactions storage vol improving storage system availability d-graid hagmann reimplementing cedar file system logging group commit proceedings acm symposium operating systems principles sosp austin texas holland gibson siewiorek fast on-line failure recovery redundant disk arrays proceedings international symposium fault-tolerant computing ftcstoulouse france hsiao dewitt chained declustering availability strategy multiprocessor database machines proceedings international data engineering conference ibm serveraid recovering multiple disk failures web site http ibm qtechinfo migrhtml felten wang singh archipelago island-based file system highly scalable internet services proceedings usenix windows symposium katcher postmark file system benchmark tech rep trnetwork appliance sunnyvale web site http netapp keeton wilkes automating data dependability proceedings acm-sigops european workshop saint-emilion france kistler satyanarayanan disconnected operation coda file system acm trans comput syst feb mckusick joy leffler fabry fast file system unix acmtrans comput syst aug menon mattson comparison sparing alternatives disk arrays isca gold coast australia microsoft corporation web site http microsoft hwdev orji solworth doubly distorted mirrors proceedings acm sigmod international conference management data sigmod washington park balasubramanian providing fault tolerance parallel secondary storage systems tech rep cs-tr- princeton princeton patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod conference management data sigmod chicago patterson availability maintainability greatermuch performance focus century key note speech fast popek walker chow edwards kline rudisin thiel locus network transparent high reliability distributed system proceedings acm symposium operating systems principles sosp pacific grove reddy banerjee gracefully degradable disk arrays proceedings international symposium fault-tolerant computing ftcsmontreal canada riedel gibson faloutsos active storage large-scale data mining multimedia proceedings international conference large databases vldb york riedel kallahalla swaminathan framework evaluating storage system security proceedings usenix symposium file storage technologies fast monterey rosenblum ousterhout design implementation log-structured file system acmtrans comput syst feb rowstron druschel storage management caching past large-scale persistent peer-to-peer storage utility proceedings acm symposium operating systems principles sosp banff alto canada ruemmler wilkes disk shuffling tech rep hpl- hewlett packard laboratories palo alto saito karamanolis karlsson mahalingam taming aggressive replication pangaea wide-area file system proceedings symposium operating systems design implementation osdi boston acm transactions storage vol sivathanu savage wilkes afraid frequently redundant array independent disks proceedings usenix annual technical conference usenix san diego sivathanu prabhakaran popovici denehy arpaci-dusseau arpacidusseau semantically-smart disk systems fast san francisco tweedie future directions ext filesystem proceedings usenix annual technical conference freenix track monterey wang anderson patterson virtual log-based file systems programmable disk proceedings symposium operating systems design implementation osdi orleans wilkes golding staelin sullivan autoraid hierarchical storage system acmtrans comput syst feb wolf placement optimization problem practical solution disk file assignment problem proceedings acm sigmetrics conference measurement modeling computer systems sigmetrics berkeley received august revised august accepted september acm transactions storage vol 
collecting performance appears proceedings international symposium computer architecture isca net delay tcp conn disk 
load cpu ratio normalized variety pertubation snsn- figure write load balancing results experiments shown run system normal mode time labeled add load resource storage node labeled y-axis plot normalized ratio traffic primary storage nodes storage node configuration load addition expect writes roughly balanced nodes expect imbalance skewing unloaded primary node number writes ----sn- --------- sn----- time delay reaction delay sec delay sec delay sec delay figure impact delaying udp message traffic graph illustrates impact delaying distribution load information y-axis plots difference number writes snand sninitially writes served snthe bold vertical line sec marks cpu load addition snthe arrows point times writes switch loaded node snto unloaded node sndue write load balancing strategy vary udp traffic delay seconds ratio writes normalized unload-load combination storage nodes distribution writes storage nodes unloaded loaded figure write constraints graph shows percentage writes directed pair nodes system configured storage nodes pair storage nodes loaded cpu load induced unloaded load induced experiment varied x-axis pair nodes unloaded loaded pair bars y-axis plots percentage writes directed loaded unloaded pair statistics storage node distributing information system periodically basing load balancing decisions confirm belief run experiment increase load storage node cpu load case delay udp message traffic cluster protocol analysis tcp centera writes reads udp virtually inter-node communication slowing udp messages hope slow spread load information confirm hypothesis figure reveals method load information dispersed figure longer udp message traffic delayed longer takes load balancing decision affected increased cpu load storage node confirm hypothesis load information dispersal finally additional constraints determine primary secondary copies data item isolate constraints experiments identical cpu loads pairs storage nodes figure shows results cases greater cpu load pair nodes greater fraction writes unloaded storage nodes cases number writes adjust cpu load pair nodes nodes unloaded load balancing policy react writes allocated roughly evenly loaded unloaded pairs centera ensures data item copy node node copy node node inspection power distribution centera reveals reason pair nodes separate power supply centera write load balancing sensitive performance factors constrained factors influence reliability power source caching buffering important performance optimization present storage systems write buffering write transforming writes asynchronous operations application-perceived latency greatly reduced copying data in-memory buffer faster committing disk trade-off terms reliability delaying commit disk chance data loss failure increases protocol analysis shown figure revealed access client nodes notified disk write committed storage nodes conclude centera performs write operations synchronously centera developers chose safety reliability performance object read policies turn attention read protocol reads complex performance characteristics crucial applications caching begin determining caching data objects performed centera read protocol demonstrate benefits intra-box techniques begin assuming access internals centera observe performance client begin simple workload repeatedly reads file comparing difference time read subsequent reads environments determine caching present identical latency numbers row table conclude caching taking place case wrong appears proceedings international symposium computer architecture isca client latency delay delay data read an-cli sn-an disk-sn table read caching table left shows time read file centera column shows time read column shows average time subsequent reads row shows experiment large disk delay induced table shows breakdown traffic access node client storage node access node disk storage node leverage ability observe delay events inside centera insert substantial disk delay read disk storage node row table illustrates numbers show large difference time read subsequent reads file caching taking place centera presence caching observable centera mbit ethernet delivers data quickly ide disks inserting delay disks change relative ratios network disk observe caching taking place system experiment reveal system caching occurring complete read caching analysis monitor network disk traffic previously-described experiment results analysis presented table table shows data transferred access node client storage node access node disk storage node subsequent file accesses table shows requests amount data transferred access node client storage node access node client access nodes performing caching table shows data transferred disk storage node subsequent requests storage node performs in-memory caching prefetching prefetching important optimization storage systems experiments determine centera performs prefetching components perform prefetching experiment read data sequentially file small chunks time read client slow disks exacerbate difference on-disk in-memory accesses graph figure shows results experiment graph observe read takes significant amount time requests completed rapidly clientperceived timing result conclude prefetching taking place centera specifically centera time seconds iteration client-perceived prefetching disk delay byte bytes transferred request size read request sequential requests access node prefetching sn-an an-client figure prefetching graph left shows time sequential read file graph shows amount bytes transferred network storage node access node access node client workload rightmost graph run multiple tests varying size request byte prefetches block read caching unearth system prefetching occurs graph figure plots network traffic experiment x-axis vary size read file y-axis plot data transferred request graph shows amount data transferred centera nodes slightly size requested data specifically client requests bytes centera bytes storage node access node bytes access node client results draw conclusions extra bytes passed centera nodes prefetching occuring network prefetching occuring storage node extra information roughly bytes passed header storage node access node node passed client load balancing examine load balancing reads load balancing writes great deal flexibility large-scale system primary copy half nodes secondary node half reads constrained read storage nodes data located experiments seek understand factors centera determine copy data accessed examine performance factors cpu utilization disk usage network connections network delay surprisingly found centera read balancing policy completely insensitive loads induced shown node responds slowly read requests nodes read requests directed appears proceedings international symposium computer architecture isca analysis analyze design implementation centera storage server subsection present perspectives wisconsin emc adding emc perspective offer insight accuracy relevance wisconsin analysis protocol structure wisconsin protocol structure reveals basic elements centera design observe basic two-phase commit protocol writes generation secondary copy handled primary storage node implementation access node send data storage nodes trade-off clear reasonable centera latency potentially higher load access node decreased finally tcp udp purposes centera communication system tcp important aspects data transfer writes reads udp contrast traffic periodic heartbeats load balancing propagating load information observe tcp connection created data transfer large cost current generation system future centera implementations 
caching connections storage nodes avoiding costly three-way tcp handshake teardown emc analysis correctly identifies majority protocol features illuminates centera design principles workload characteristics centera designed on-line archival fixed content mostly-write operations mediumand large-sized objects reliability write-ingest important read performance lower latency extra latency writes introduced storage node relay typically small congestion occurs rarely internal network dual paths switches shielded traffic finally cost setting tearing tcp connection write initially deemed negligible targeted object sizes provided simple scalable solution clusters nodes recent centrastar versions reuse tcp connections tune number open connections based cluster size load udp messages write protocol updates distributed hash table translating content address location constant time message delivered attempts write transaction reports success logs exceptional case retries update time observed occasional disk reads observed intervals directly related write transaction priori knowledge content address write protocol performs lookup distributed hash table found data transferred cluster observed analysis read caching prefetching wisconsin analysis reveals storage nodes perform caching prefetching expect nodes runs commodity file system caching prefetching performed client access nodes decision reasonable benefit client terms latency data fetched access node storage node cases data cross network client host remember user application accesses data running host designers consume precious memory resources client node caching prefetching emc emphasis leveraging commodity components storage node file system disk drive caches emphasis access latencies extra hop internal network warrant impact complexity performance access nodes file server-like environments repeated reads objects centera offers separate gateway sits front cluster translates nfs cifs requests centera api operations implements caching avoids accesses cluster altogether design goal provide light-weight centera api library applications existing caches implement short gateway application-specific caching reduce caching access nodes write caching buffering wisconsin analysis shows centera synchronous system writes write buffering performed centera leans simplicity reliability write completes successfully means reliably committed disks storage nodes synchronous writing slow next-generation centera options improve performance nvram found higher-end emc products emc patch developed linux community centera ensures data reliably written media arguably non-commodity nvram increase complexity handling exceptional states hardware costs emc products include nvram make trade-off favor increased performance read-modify-write workloads replication load balancing wisconsin investigation centera replication reveals uniform approach objects found disks system control applications enabling create copies valuable data centera found perform load balancing storage nodes writes deappears proceedings international symposium computer architecture isca cisions based locally observable storage nodes demonstrated inducing delay incoming network link centera approach load balancing perform load measurable perspective storage node future important gather information load balancing decisions higher levels system measuring write perspective access node measured history make robust placement decisions centera takes power distribution network account system built similar orthogonal raid designs sources failure account placing data replicas disks finally clear presence load balancing machinery writes centera perform load balancing reads node performing poorly read performance system suffers future versions centera correcting oversight emc network delays issue paths node node load balanced paths load observations local node propagated nodes periodic broadcasts observations additional udp traffic piggybacked messages observations extra data transfers section access nodes information selecting storage nodes nature content addresses distribution data storage nodes reads spread equally nodes balancing load aggregate emphasis write operations fact network delays due congestion occur centrastar version analyzed employ load balancing individual read operations added versions similar load balancing writes intra-box analysis observed node balances load internal disks finally current hardware power distribution system eliminates constraints placing replicas nodes content addressability wisconsin observed centera blob size potentially missing opportunities capacity savings achieved smaller blobs smaller blobs imply metadata blob tracking desirable application wishes maximize usage content addressability expecting system find detailed content similarity objects emc implementing single-instance storage object level chunks efficient storage management hundreds millions objects applications advantage single-instance feature combine fast lookup potentially eliminate unnecessary data transfer related work intra-box techniques similar recent line work performance debugging complex systems major difference work related work level detail infer assume knowledge storage systems generally function support caching prefetching domain-specific functions discover specific structural policy details general techniques goals work related work differ specifically work seeks understand structure policies storage system approaches primarily aimed performance debugging specifically aguilera infer causal paths distributed systems message level traces techniques finding component performance bottleneck approach limited assume message dependent arrival previous message complex dependencies found storage systems similarly chen detect failures diagnose performance problems runtime path analysis unlike aguilera analysis chen assume existence message tags system track dependencies advantage approaches intra-box techniques run system interest online running real workload contrast approach applied quiesced system controlled workloads future hope extend approach operational systems previous research characterizing behavior storage systems operated domains work focused single disk worthington identify characteristics disk mapping logical block numbers physical locations size prefetch window prefetching algorithm caching policy previous work characterize traditional raid systems automatically infer number disks chunk size level redundancy layout scheme related work similar approach slowing components learn behavior system brown table locking infer dependence higher-level queries database tables comparison slow network disk traffic understand aspects storage system test communication slowdown mechanism similar presented martin approach learn aspects network performance affects application performance network slowdown infer dependencies components storage cluster appears proceedings international symposium computer architecture isca conclusion paper shown intra-box techniques applied deconstruct protocols policies modern commodity-based storage cluster emc centera analysis infer design implementation system access single line source code general study demonstrates power probe points system observing slowing system components learned structure complex system systems continue grow complexity intra-box techniques much-needed addition toolbox systems analysts techniques developed hope systems built intra-box approach mind externally visible probe points opening box systems readily understood analyzed debugged result generation higher performing robust reliable computer systems centera generation hardware centrastar releases place version observations made longer apply nonetheless work slow-down causality analysis helped emc fine-tune aspects centera protocols acknowledgments lakshmi bairavasundaram todd jones james nugent florentina popovici vijayan prabhakaran muthian sivathanu helpful discussions comments paper ana bizarro assistance setting access centera finally anonymous reviewers helpful suggestions work sponsored nsf ccrccr- ngsitr- itribm network appliance emc aguilera mogul wiener reynolds muthitacharoen performance debugging distributed systems black boxes sosp bolton landing 
amdahl blaauw brooks architecture ibm system ibm journal research development april anderson culler patterson team case networks workstations ieee micro february arpaci culler krishnamurthy steinberg yelick empirical evaluation cray-t compiler perspective isca santa margherita ligure italy bagchi kar hellerstein dependency analysis distributed systems fault injection international workshop distributed systems nancy france october barham isaacs mortier narayanan magpie real-time modeling performance-aware systems hotos lihue hawaii bohossian fan lemahieu riedel bruck computing rain reliable array independent nodes ieee transactions parallel distributed computing brown kar keller active approach characterizing dynamic dependencies problem determination distributed environment ifip ieee internationalsymposium integrated network management cantin hill cache performance selected spec cpu benchmarks computer architecture news september carson santay nist network emulation tool snad ncsl nist gov nistnet january cas-community http cascommunity chen accardi kiciman patterson fox brewer path-based failure evolution management nsdi san francisco march chen lee gibson katz patterson raid high-performance reliable secondary storage acm computing surveys june chen patterson approach performance evaluation self-scaling benchmarks predicted performance sigmetrics pages santa clara cypher konstantinidou messina architectural requirements parallel scientific applications explicit communication isca san diego denehy bent popovici arpaci-dusseau arpaci-dusseau deconstructing storage arrays asplos pages boston massachusetts october emc emc centera content addressed storage system http emc gray reuter transaction processing concepts techniques morgan kaufmann hennessy patterson editors computer architecture quantitative approach edition morgan-kaufmann lee thekkath petal distributed virtual disks asplos vii cambridge october martin vahdat culler anderson effects communication latency overhead bandwidth cluster architecture isca denver mcvoy staelin lmbench portable tools performance analysis usenix san diego january panasas panasas active-scale storage cluster http panasas patterson gibson ginting stodolsky zelenka informed prefetching caching sosp pages copper mountain resort december policroniades pratt alternatives detecting redundancy storage systems data usenix boston june rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february saavedra smith measuring cache tlb performance effect benchmark runtimes ieee trans-actions computers saito frolund veitch merchant spence fab building reliable enterprise storage systems cheap asplos boston massachusetts october schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon november staelin mcvoy mhz anatomy micro-benchmark usenix pages orleans june sterling editor beowulf cluster computing linux mit press october talagala arpaci-dusseau patterson microbenchmark-based extraction local global diskcharacteristics technical report csd- california berkeley woo ohara torrie shingh gupta splashprograms characterization methodological considerations isca santa margherita ligure italy worthington ganger patt wilkes online extraction scsi disk drive parameters sigmetrics pages ottawa canada 
iron file systems vijayan prabhakaran lakshmi bairavasundaram nitin agrawal haryadi gunawi andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison vijayan laksh nitina haryadi dusseau remzi wisc abstract commodity file systems trust disks work fail completely modern disks exhibit complex failure modes suggest fail-partial failure model disks incorporates realistic localized faults latent sector errors block corruption develop apply failure-policy fingerprinting framework investigate commodity file systems react range realistic disk failures classify failure policies taxonomy measures internal robustness iron includes failure detection recovery techniques show commodity file system failure policies inconsistent buggy generally inadequate ability recover partial disk failures finally design implement evaluate prototype iron file system linux ixt showing techniques in-disk checksumming replication parity greatly enhance file system robustness incurring minimal time space overheads categories subject descriptors operating systems file systems management operating systems reliability general terms design experimentation reliability keywords iron file systems disks storage latent sector errors block corruption fail-partial failure model fault tolerance reliability internal redundancy introduction disks fail commodity file systems expect years file system storage system designers assumed disks operate fail stop manner classic model disks working perfectly fail absolutely easily detectable manner fault model presented modern disk drives complex modern drives exhibit latent sector faults block set blocks inaccessible worse blocks silently corrupted finally disks exhibit transient performance problems permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee sosp october brighton united kingdom copyright acm reasons complex failures disks buggy disk controller issue misdirected write placing correct data disk wrong location interestingly failures exist today simply waiting disk technology improve remove errors errors worsen time due increasing drive complexity immense cost pressures storage industry escalated reliable ata disks desktop pcs large-scale clusters storage systems developers high-end systems realized nature disk faults built mechanisms systems handle redundant storage systems incorporate background disk scrubbing process proactively detect subsequently correct latent sector errors creating copy inaccessible blocks recent storage arrays incorporate extra levels redundancy lessen potential damage undiscovered latent errors similarly highly-reliable systems tandem nonstop utilize end-to-end checksums detect block corruption occurs technology filtered realm commodity file systems including linux file systems ext reiserfs ibm jfs windows file systems ntfs file systems pervasive home environment storing valuable non-archived user data photos home movies tax returns internet services google paper question pose modern commodity file systems react failures common modern disks answer query aggregate knowledge research literature industry field experience form model disk failure label model fail-partial failure model emphasize portions disk fail block errors data corruption model place develop apply automated failure-policy fingerprinting framework inject realistic disk faults beneath file system goal fingerprinting unearth failure policy system detects recovers disk failures approach leverages gray-box knowledge file system data structures meticulously exercise file system access paths disk characterize failure policy develop internal robustness iron taxonomy catalogs broad range detection recovery techniques output fingerprinting tool broad categorization iron techniques file system constituent data structures study focuses important substantially open-source file systems ext reiserfs ibm jfs closed-source file system windows ntfs platforms find great deal illogical inconsistency failure policy due diffusion failure handling code kernel inconsistency leads substantially detection recovery strategies similar fault scenarios resulting unpredictable undesirable fault-handling strategies discover systems implement portions failure policy incorrectly presence bugs implementations demonstrates difficulty complexity correctly handling classes disk failure observe tolerance transient failures file systems assume single temporarilyinaccessible block fatal whole-disk failure finally show file systems recover partial disk failures due lack in-disk redundancy behavior realistic disk failures leads question change file systems handle modern disk failures advocate single guiding principle design file systems don trust disk file system view disk utterly reliable component blocks corrupt file system apply measures detect recover corruption running single disk approach instance end-to-end argument top storage stack file system fundamentally responsible reliable management data metadata initial efforts develop family prototype iron file systems robust variants linux ext file system iron ext ixt investigate costs checksums detect data corruption replication provide redundancy metadata structures parity protection user data show techniques incur modest space time overheads greatly increasing robustness file system latent sector errors data corruption implementing detection recovery techniques iron taxonomy system implement well-defined failure policy subsequently provide vigorous protection broader range disk failures contributions paper define realistic failure model modern disks fail-partial model formalize techniques detect recover disk errors iron taxonomy develop fingerprinting framework determine failure policy file system analyze popular commodity file systems discover handle disk errors build prototype version iron file system ixt analyze robustness disk failure performance characteristics bring paper close discuss related work finally conclude disk failure reasons file system errors storage system section discuss common disk failure present realistic failpartial model disks discuss aspects model storage subsystem figure presents typical layered storage subsystem file system error occur layers propagate file system generic block device driver device controller firmware media transport host disk generic file system specific file system storage subsystem electrical mechanical cache figure storage stack present schematic entire storage stack top file system beneath layers storage subsystem gray shading implies software firmware white unshaded hardware bottom storage stack disk magnetic storage media mechanical motor arm assembly electrical components busses important component firmware code embedded drive control higher-level functions including caching disk scheduling error handling firmware code substantial complex modern seagate drive roughly lines code connecting drive host transport low-end systems transport medium bus scsi networks common higher-end systems fibrechannel top stack host hardware controller communicates device software device driver controls hardware block-level software forms layer providing generic device interface implementing optimizations request reordering software file system layer split pieces high-level component common file systems specific component maps generic operations data structures file system standard interface vnode vfs positioned disks fail motivate failure model describe errors layers storage stack failures media primary errors occur magnetic media classic problem bit rot occurs magnetism single bit bits flipped type problem detected corrected low-level ecc embedded drive physical damage occur media quintessential head crash culprit drive head contacts 
surface momentarily media scratch occur particle trapped drive head media dangers well-known drive manufacturers modern disks park drive head drive reduce number head crashes scsi disks include filters remove particles media errors lead permanent failure corruption individual disk blocks mechanical wear tear eventually leads failure moving parts drive motor spin irregularly fail completely erratic arm movements head crashes media flaws inaccurate arm movement misposition drive head writes leaving blocks inaccessible corrupted subsequent reads electrical power spike surge damage in-drive circuits lead drive failure electrical problems lead entire disk failure drive firmware interesting errors arise drive controller consists thousands lines real-time concurrent firmware disks return correct data circularly shifted byte memory leaks lead intermittent failures firmware problems lead poor drive performance firmware bugs well-enough field specific names misdirected writes writes place correct data disk wrong location phantom writes writes drive reports completed reach media phantom writes caused buggy misconfigured cache write-back caching enabled summary drive firmware errors lead sticky transient block corruption lead performance problems transport transport connecting drive host problematic study large disk farm reveals systems tested interconnect problems bus timeouts parity errors occurred frequency causing requests succeed slowly fail altogether transport transient errors entire drive bus controller main bus controller problematic eide controller series motherboards incorrectly completion disk request data reached main memory host leading data corruption similar problem controllers return status bits data floppy drive time hard drive observed ide protocol version problems yield corrupt data summary controller problems lead transient block failure data corruption low-level drivers recent research shown device driver code bugs rest operating system bugs crash operating system issue disk requests bad parameters data resulting data corruption fail-partial failure model discussion root failure ready put realistic model disk failure model failures manifest ways entire disk failure entire disk longer accessible permanent classic fail-stop failure block failure blocks accessible referred latent sector errors block corruption data individual blocks altered corruption insidious silent storage subsystem simply returns bad data read term model fail-partial failure model emphasize pieces storage subsystem fail discuss key elements fail-partial model including transience locality frequency failures discuss technology market trends impact disk failures time transience failures model failures sticky permanent transient temporary behavior manifests depends root problem low-level media problem portends failure subsequent requests contrast transport higher-level software issue block failure corruption operation succeed retried locality failures multiple blocks disk fail block failures dependent root block failure suggest forms block failure exhibit spatial locality scratched surface render number contiguous blocks inaccessible failures exhibit locality corruption due misdirected write impact single block frequency failures block failures corruptions occur commercial storage system developer succinctly stated disks break lot guarantees fiction frequently errors occur modeling reliability deciding failures important handle talagala patterson point disk drive manufacturers loathe provide information disk failures people industry refer implicit industry-wide agreement publicize details surprisingly actual frequency drive errors errors disk fail well-known literature previous work latent sector errors errors occur commonly absolute disk failure recent research estimates errors occur times absolute disk failures terms relative frequency block failures occur reads writes due internal error handling common disk drives failed writes sector remapped distant sector allowing drive transparently handle problems remapping imply writes fail failure component media stuttering transport lead unsuccessful write attempt move network-attached storage serves increase frequency class failures remapping succeed free blocks large scratch render blocks unwritable quickly reserved space reads problematic media unreadable drive choice return error trends areas processor performance technology market trends combine improve aspects computer systems contrast technology trends market forces combine make storage system failures occur frequently time reasons reliability greater challenge drives made increasingly dense bits packed smaller spaces drive logic complexity increases low-end drive market cost-per-byte dominates corners cut save pennies ide ata drives low-cost class drives tend tested internal machinery prevent failures occurring result field ata drives observably reliable cost pressures serve increase usage server environments finally amount software increasing storage systems noted software root errors storage system hundreds thousands lines software present lower-level drivers firmware low-level code generally type code difficult write debug source increased errors storage stack iron taxonomy section outline strategies developing iron file system file system detects recovers range modern disk failures main focus develop strategies disks common storage arrays single disk internal robustness iron needed protection file system cope failures modern disks iron file system includes machinery detect level partial faults recover level tables present iron detection recovery taxonomies note taxonomy means complete techniques exist raid variations proposed years detection recovery mechanisms employed file system define failure policy difficult discuss failure policy system iron taxonomy describe failure policy file system describe cache replacement file-layout policy levels detection level techniques file system detect problem occurred block accessed corrupted simplest detection strategy file system assumes disk works check return codes approach surprisingly common applied unintentionally errorcode pragmatic detection strategy file system implement check return codes provided lower levels storage system sanity sanity checks file system verifies data structures consistent check performed single block blocks checking single block file system verify individual fields pointers valid ranges verify type block file system superblocks include magic number older file systems pilot include header data block checking block correct type information file system guard forms block corruption checking blocks involve verifying blocks bitmap corresponds allocated blocks involve periodically scanning structures determine intact consistent similar fsck journaling file systems benefit periodic full-scan integrity checks buggy journaling file system unknowingly corrupt on-disk structures running fsck background detect recover problems redundancy final level detection taxonomy redundancy forms redundancy detect block corruption checksumming reliable systems years detect corruption recently applied improve security checksums number reasons assist detecting classic bit rot bits media flipped in-media ecc catches corrects errors checksums well-suited detecting corruption higher levels storage system stack buggy controller misdirects disk updates wrong location write block disk checksums carefully implemented detect problems specifically checksum level technique comment dzero detection assumes disk works derrorcode check return codes assumes lower level lower levels detect errors dsanity check data structures require extra consistency space block dredundancy redundancy detect corruption blocks end-to-end table levels iron detection taxonomy level technique 
comment rzero recovery assumes disk works rpropagate propagate error informs user rstop stop activity limit amount crash prevent writes damage rguess return guess wrong block contents failure hidden rretry retry read write handles failures transient rrepair repair data structs lose data rremap remaps block file assumes disk informs locale failures rredundancy block replication enables recovery forms loss corruption table levels iron recovery taxonomy stored data checksums detect misdirected phantom writes higher levels redundancy block mirroring parity error-correction codes detect corruption file system copies block reading comparing determine corrupted techniques designed correction discussed assume presence lower-overhead detection mechanism detection frequency detection techniques discussed applied lazily block access eagerly scanning disk idle time iron file systems form lazy detection additionally eager methods disk scrubbing classic eager technique raid systems scan disk discover latent sector errors disk scrubbing valuable means recovery replica exists repair nowunavailable block detect error occurred scrubbing typically leverages return codes explicitly provided disk discovers block failure corruption combined detection techniques checksums scrubbing discover block corruption levels recovery level iron taxonomy facilitates recovery block failure single disk drive techniques handle latent sector errors block corruptions simplest approach implement recovery strategy notifying clients failure occurred propagate straightforward recovery strategy propagate errors file system file system informs application error occurred assumes client program user respond appropriately problem stop recover disk failure stop current file system activity action levels granularity coarsest level crash entire machine positive feature recovery mechanism turns detected disk failures fail-stop failures preserves file system integrity crashing assumes problem transient faulty block repeatedly-accessed data script run initialization system repeatedly reboot attempt access unavailable data crash intermediate level kill process triggered disk fault subsequently mount file system read-only mode approach advantageous entire system processes continue finest level journaling file system abort current transaction approach lead system complex implement guess recently suggested rinard reaction failed block read manufacture response allowing system running spite failure negative artificial response desirable failing retry simple response failure retry failed operation retry appropriately handle transient errors wastes time retrying failure permanent repair iron file system detect inconsistency internal data structures repair fsck block pointed marked allocated bitmap freed discussed techniques context journaling file systems bugs lead corruption file system integrity remap iron file systems perform block remapping technique fix errors occur writing block recover failed reads specifically write block fails file system choose simply write block location sophisticated strategies remap entire semantic unit time user file preserving logical contiguity redundancy finally redundancy forms recover block loss simplest form replication block copies locations disk redundancy approach employs parity facilitate error correction similar raid adding parity block block group file system tolerate unavailability corruption block group complex encodings tornado codes subject worthy future exploration redundancy disk negative consequences replicas account spatial locality failure surface scratch corrupts sequence neighboring blocks copies allocated remote parts disk lower performance in-disk redundancy techniques incur high space cost desktop settings drives sufficient free space iron file system natural question file system implement detection recovery disk modern disks internal mechanisms detecting recovering errors sufficient view primary reason detection recovery file system found end-to-end argument lower-levels system implement forms fault tolerance file system implement guard forms failure file system place detect corruption data higher levels storage stack device driver drive controller reason implementing detection recovery file system file system exact knowledge blocks file system apply detection recovery intelligently block types file system provide higher level replication metadata leaving failure detection correction user data applications specific solution explore similarly file system provide machinery enable application-controlled replication important data enabling explicit performance reliability trade-off reason performance file systems storage systems unwritten contract file system lay blocks achieve high bandwidth unwritten contract stipulates adjacent blocks logical disk address space physically proximate disk-level recovery mechanisms remapping break unwritten contract performance problems file system assumes responsibility remap logically-related blocks file avoid problems complexities placing iron functionality file system techniques require persistent data structures track redundant copies parity blocks located mechanisms require control underlying drive mechanisms recover on-disk data modern drives attempt positioning reading strategies interface exists control low-level strategies current systems doesn raid make storage reliable question answered simply raid techniques provide reliable robust storage raid improve storage reliability complete solution reasons systems incorporate disk sine qua redundant storage systems desktop pcs ship single disk included cost driving force marketplace adding disk solely sake redundancy palatable solution raid protect failures higher storage stack shown figure layers exist storage subsystem file system errors occur layers file system ultimately responsible detecting recovering errors ironically complex raid controller consist millions lines code source faults depending raid system employed types disk faults handled lower-end raid controller cards checksums detect data corruption recently companies included machinery cope latent sector errors iron techniques file system single-disk systems multiple drives raid-like manner focus single-disk systems paper rich space left exploration iron file systems redundant storage arrays failure policy fingerprinting describe methodology uncover failure policy file systems main objective failure-policy fingerprinting determine detection recovery techniques file system assumptions makes underlying storage system fail comparing failure policies file systems learn file systems robust disk failures suggest improvements analysis helpful inferring iron techniques implemented effectively approach inject faults beneath file system observe file system reacts fault policy consistent file system simply run workload fail blocks accessed conclude reaction block failure fully demonstrates failure policy system file systems practice complex employ techniques depending operation performed type faulty block extract failure policy system trigger interesting cases challenge coerce file system code paths observe path handles failure requires run workloads exercising relevant code paths combination induced faults file system data structures describe create workloads inject faults deduce failure policy applied workload goal applying workloads exercise file system claim stress code path leaving avenue future work strive execute interesting internal cases workload suite sets programs run unix-based file systems fingerprinting ntfs requires set similar programs set programs called singlets focus single call file system api mkdir set generics stresses functionality common api path traversal table summarizes test suite file system test introduces special cases stressed ext inode imbalanced tree indirect doubly-indirect triply-indirect pointers support large 
files workloads ensure sufficiently large files created access structures file systems similar peculiarities make exercise -tree balancing code reiserfs type-aware fault injection step inject faults emulate disk adhering fail-partial failure model standard fault injectors fail disk blocks type oblivious manner block failed file system repeatedly injecting faults random blocks waiting uncover aspects failure policy laborious time-consuming process yielding insight key idea test file system efficient manner type-aware fault injection builds previous work semantically-smart disk systems type-aware fault injection failing blocks obliviously fail blocks specific type inode type information crucial reverse-engineering failure policy allowing discern strategies file system applies data structures disadvantage type-aware approach fault injector tailored file system tested requires solid understanding workload purpose singlets access chdir chroot stat statfs lstat open utimes read readlink exercise getdirentries creat posix api link mkdir rename chown symlink write truncate rmdir unlink mount chmod fsync sync umount generics path traversal traverse hierarchy recovery invoke recovery log writes update journal table workloads table presents workloads applied file systems test set workloads stresses single system call group invokes general operations span calls path traversal on-disk structures benefits typeawareness outweigh complexities block types file systems test listed table mechanism injecting faults software layer directly beneath file system pseudo-device driver layer injects block failures reads writes block corruption reads emulate block failure simply return error code issue operation underlying disk emulate corruption change bits block returning data cases inject random noise cases block similar expected corrupted fields software layer models transient sticky faults injecting failures file system emulate faults caused layers storage subsystem unlike approaches emulate faulty disks additional hardware imitate faults introduced buggy device drivers controllers drawback approach discern lower layers handle disk faults scsi drivers retry commands failure characterizing file systems react faults correct layer fault injection failure policy inference running workload injecting fault final step determine file system behaved determine fault affected file system compare results running fault perform comparison observable outputs system errors codes data returned file system api contents system log low-level traces recorded fault-injection layer human-intensive part process requires manual inspection visible outputs summary developed three-step fingerprinting methodology determine file system failure policy approach strikes good balance straightforward run exercises file system test workload suite roughly programs file system order block types block failed read write data corrupted file system amounts roughly relevant tests ext structures purpose inode info files directories directory list files directory data bitmap tracks data blocks group inode bitmap tracks inodes group indirect large files exist data holds user data super info file system group descriptor holds info block group journal super describes journal journal revoke tracks blocks replayed journal descriptor describes contents transaction journal commit marks end transaction journal data blocks journaled reiserfs structures purpose leaf node items kinds stat item info files directories directory item list files directory direct item holds small files tail file indirect item large files exist data bitmap tracks data blocks data holds user data super info tree file system journal header describes journal journal descriptor describes contents transaction journal commit marks end transaction journal data blocks journaled root internal node tree traversal jfs structures purpose inode info files directories directory list files directory block alloc map tracks data blocks group inode alloc map tracks inodes group internal large files exist data holds user data super info file system journal super describes journal journal data records transactions aggregate inode info disk partition bmap descriptor describes block allocation map imap control summary info imaps ntfs structures purpose mft record info files directories directory list files directory volume bitmap tracks free logical clusters mft bitmap tracks unused mft records logfile transaction log file data holds user data boot file info ntfs volume table file system data structures table presents data structures interest file systems test ext reiserfs jfs ntfs table list names major structures purpose note knowledge ntfs data structures incomplete closed-source system failure policy results present results failure policy analysis commodity file systems ext reiserfs version ibm jfs linux ntfs windows file system present basic background information discuss general failure policy uncovered bugs illogical inconsistencies source code explain problems discover due sheer volume experimental data difficult present results reader inspection file system studied depth present graphical depiction results showing workload blocktype pair detection recovery technique figure presents complex graphical depiction results caption interpretation details provide qualitative summary results presented figure linux ext linux ext similar classic unix file systems berkeley fast file system ext divides disk set block groups statically-reserved spaces bitmaps inodes data blocks major addition ext ext journaling ext includes set ondisk structures manage write-ahead log detection detect read failures ext primarily error codes derrorcode write fails ext record error code dzero write errors potentially leading file system problems checkpointing transaction final location ext performs fair amount sanity checking dsanity ext explicitly performs type checks blocks superblock journal blocks type checking important blocks directories bitmap blocks indirect blocks ext performs numerous sanity checks file-size field inode overly-large open detects reports error recovery detected errors ext propagates error user rpropagate read failures ext aborts journal rstop aborting journal leads readonly remount file system preventing future updates explicit administrator interaction ext retry rretry sparingly prefetch read fails ext retries originally requested block bugs inconsistencies found number bugs inconsistencies ext failure policy errors propagated user truncate rmdir fail silently important cases ext immediately abort journal failure implement rstop journal write fails ext writes rest transaction including commit block journal journal recovery file system easily corrupted ext perform sanity checking unlinkdoes check thelinkscount field modifying corrupted lead system crash finally ext redundant copies superblock rredundancy copies updated file system creation reiserfs reiserfs comprised vastly data structures ext virtually metadata data balanced tree similar database index key advantage tree structuring scalability allowing files coexist directory read failure write failure corruption ext detection j-dataj-commit j-descj-revoke j-superg-desc superdata indirecti-bitmap bitmapdir inode ext recovery j-dataj-commit j-descj-revoke j-superg-desc superdata indirecti-bitmap bitmapdir inode reiserfs detection internalroot j-dataj-commit j-descj-header superdata indirectbitmap dir itemstat item reiserfs recovery internalroot j-dataj-commit j-descj-header superdata indirectbitmap dir itemstat item jfs detection imap-cntlbmap-desc aggr-inodej-data j-supersuper datainternal imapbmap 
dirinode jfs recovery imap-cntlbmap-desc aggr-inodej-data j-supersuper datainternal imapbmap dirinode figure file system failure policies tables detection recovery policies ext reiserfs jfs read write corruption faults injected block type range workloads workloads path traversal access chdir chroot stat statfs lstat open chmod chown utimes read readlink getdirentries creat link mkdir rename symlink write truncate rmdir unlink mount fysnc sync umount recovery log write operations gray box workload applicable block type multiple mechanisms observed symbols superimposed key detection key recovery dzero rzero derrorcode rretry dsanity rpropagate rredundancy rstop detection analysis reveals reiserfs pays close attention error codes reads writes derrorcode reiserfs performs great deal internal sanity checking dsanity internal leaf nodes balanced tree block header information level block tree number items free space super block journal metadata blocks magic numbers identify valid journal descriptor commit blocks additional information finally inodes directory blocks formats reiserfs checks blocks expected values fields blocks checked carefully bitmaps data blocks type information type-checked recovery prominent aspect recovery policy reiserfs tendency panic system detection virtually write failure rstop reiserfs calls panic file system crashes leading reboot recovery sequence reiserfs attempts ensure ondisk structures corrupted reiserfs recovers read write failures differently read failures reiserfs propagates error user rpropagate performs single retry rretry data block read fails indirect block read fails unlink truncate write operations reiserfs retries write failure bugs inconsistencies reiserfs exhibits inconsistencies bugs ordered data block write fails reiserfs journals commits transaction handling error rzero expected rstop lead corrupted data blocks metadata blocks point invalid data contents dealing indirect blocks reiserfs detects ignores read failure atruncate unlink updates bitmaps super block incorrectly leaking space reiserfs calls panic failing sanity check simply returning error code finally sanity type checking detect corrupt journal data replaying corrupted journal block make file system unusable block written super block ibm jfs jfs modern techniques manage data block allocation journaling scalable tree structures manage files directories block allocation unlike ext reiserfs jfs record-level journaling reduce journal traffic detection error codes derrorcode detect read failures ext write errors dzero exception journal superblock writes jfs employs minimal type checking superblock journal superblock magic version numbers checked sanity checks dsanity block types internal tree blocks directory blocks inode blocks number entries pointers block jfs checks make number maximum block type equality check field performed block allocation maps verify block corrupted recovery recovery strategies jfs vary dramatically depending block type error occurs journal superblock write jfs crashes system rstop write errors rzero block read failure primary superblock jfs accesses alternate copy rredundancy complete mount operation corrupt primary results mount failure rstop explicit crashes rstop block allocation map inode allocation map read fails error codes metadata reads handled generic file system code called jfs generic code attempts recover read errors retrying read single time rretry finally reaction failed sanity check propagate error rpropagate remount file system read-only rstop journal replay sanity-check failure replay abort rstop bugs inconsistencies found problems jfs failure policy jfs built-in redundancy expect jfs secondary copies aggregate inode tables special inodes describe file system error code returned aggregate inode read blank page returned user rguess design bug occurs read internal tree block pass sanity check bugs limit utility jfs recovery generic code detects read errors retries bug jfs implementation leads ignoring error corrupting file system windows ntfs ntfs non-unix file system study analysis requires detailed knowledge on-disk structures complete analysis figure find ntfs error codes derrorcode detect block read write failures similar ext jfs data write fails ntfs records error code dzero corrupt file system ntfs performs strong sanity checking dsanity metadata blocks file system unmountable metadata blocks journal corrupted ntfs surprisingly perform sanity checking corrupted block pointer point important system structures corrupt block pointed updated cases ntfs propagates errors rpropagate ntfs aggressively retry rretry operations fail times read failures writes number retries varies times data blocks times mft blocks file system summary present qualitative summary file systems tested table presents summary techniques file system employs excluding ntfs ext simplicity ext implements simple reliable failure policy matching design philosophy found ext family file systems checks error codes modest level sanity checking recovers propagating errors aborting operations main problem ext failure handling write errors problems including file system corruption reiserfs harm reiserfs concerned disk failure concern evident write failures induce panic reiserfs takes action ensure file system corrupted reiserfs great deal sanity type checking behaviors combine form hippocratic failure policy harm jfs kitchen sink jfs consistent diverse failure detection recovery techniques detection jfs sanity checks error codes recovery jfs redundancy crashes system retries operations depending block type fails error detection api called level ext reiser jfs dzero derrorcode dsanity dredundancy rzero rpropagate rstop rguess rretry rrepair rremap rredundancy table iron techniques summary table depicts summary iron techniques file systems test check marks higher relative frequency usage technique ntfs persistence virtue compared linux file systems ntfs persistent retrying failed requests times giving propagate errors user reliably testing ntfs needed order broaden conclusions part ongoing work technique summary finally present broad analysis techniques applied file systems detect recover disk failures concentrate techniques underused overused inappropriate manner detection recovery illogical inconsistency common found high degree illogical inconsistency failure policy file systems observable patterns figure reiserfs performs great deal sanity checking important case journal replay result single corrupted block journal corrupt entire file system jfs illogically inconsistent employing techniques scenarios similar note inconsistency problematic logically inconsistent good idea file system provide higher level redundancy data structures deems important root directory criticizing inconsistencies undesirable unintentional jfs attempt read alternate superblock read failure occurs reading primary superblock attempt read alternate deems primary corrupted estimation root illogical inconsistency failure policy diffusion code implements failure policy spread kernel diffusion encouraged architectural features modern file systems split generic specific file systems observed cases developers implement portions code implement failure policies cases reiserfs panic write failure arises due inconsistency indicative lack attention paid failure policy detection recovery bugs common found numerous bugs file systems tested found sophisticated techniques generally indicative difficulty implementing correct failure policy hints effort put testing debugging code suggestion literature helpful periodically inject faults 
normal operation part fire drill method reveals testing broad cover code paths testing indirect-block handling reiserfs observe classes fault mishandling detection error codes amazingly error codes file system common jfs found occasionally file systems testing framework part file system developer toolkit tools class error easily discovered detection sanity checking limited utility file systems sanity checking ensure metadata meets expectations code modern disk failure modes misdirected phantom writes lead cases file system receive properly formatted incorrect block bad block passes sanity checks corrupt file system file systems tested exhibit behavior stronger tests checksums recovery stop correctly file systems employed form rstop order limit damage file system types errors arose reiserfs calls panic virtually write error prevent corruption structures careful techniques write failure ext abort transaction correctly squelch writes file system leading corruption fine-grained rebooting difficult apply practice recovery stop overused downside halting file system activity reaction failure inconvenience recovery takes time requires administrative involvement fix file systems form rstop innocuous read failure occurred simply returning error requesting process entire system stops draconian reactions possibly temporary failures avoided recovery retry underutilized file systems assume failures transient lower layers system handle failures retry requests time systems employ retry generally assume read retry write retry transient faults due device drivers transport issues equally occur reads writes retry applied uniformly ntfs lone file system embraces retry issue higher number requests block failure observed recovery automatic repair rare automatic repair rarely file systems rstop technique file systems require manual intervention attempt fix observed problem running fsck detection recovery redundancy finally importantly virtually file systems include machinery detect disk failures apply redundancy enable recovery failures lone exception minimal amount superblock redundancy found jfs redundancy inconsistently jfs places copies close proximity making vulnerable spatiallylocal errors explored potentially handling failures common drives today investigate inclusion forms redundancy failure policy file system read failure write failure corruption ixt detection j-dataj-commit j-descj-revoke j-superg-desc superdata indirecti-bitmap bitmapdir inode ixt recovery j-dataj-commit j-descj-revoke j-superg-desc superdata indirecti-bitmap bitmapdir inode figure ixt failure policy tables plot detection recovery policies ixt read write corruption faults injected block type range workloads workloads varied columns figure block types ixt file system varied rows workloads grouped manner figure key detection key recovery dzero rzero derrorcode rretry dsanity rpropagate dredundancy rredundancy rstop iron file system describe implementation evaluation iron ext ixt ixt implement family recovery techniques commodity file systems provide increase robustness ixt applies checksums metadata data blocks pure replication metadata employs parity-based redundancy protect user data section describe implementation demonstrate robust broad class partial disk failures investigate time space costs ixt showing time costs small modest space costs reasonable performance measurements activate deactivate iron features independently understand cost approach implementation briefly describe ixt implementation explain add checksumming metadata replication user parity performance enhancement transactional checksums existing ext file system framework checksumming implement checksumming ixt borrow techniques recent research checksumming file systems specifically place checksums journal checkpoint checksums final location distant blocks checksum checksums small cached read verification current implementation shato compute checksums incorporating checksumming existing transactional machinery ixt cleanly integrates ext framework metadata replication apply similar approach adding metadata replication ixt metadata blocks written separate replica log checkpointed fixed location block group distant original metadata transactions ensure copies reach disk consistently parity implement simple parity-based redundancy scheme data blocks parity block allocated file simple design enables recover data-block failure file modify inode structure ext associate file parity block data blocks parity blocks allocated files created file modified parity block read updated respect contents improve performance file creates preallocate parity blocks assign files created transactional checksums explore idea leveraging checksums journaling file system specifically checksums relax ordering constraints improve performance updating journal standard ext ensures previous journal data reaches disk commit block enforce ordering standard ext induces extra wait writing commit block incurs extra rotational delay avoid wait ixt implements call transactional checksum checksum contents transaction placing checksum journal commit block ixt safely issue blocks transaction concurrently crash occurs commit recovery procedure reliably detect crash replay transaction checksum journal data match checksum commit block note transactional checksum crash semantics original ext iron extensions cleaning overheads note cleaning overhead large problem pure log-structured file systems major performance issue journaling file systems ixt -style checksumming replication journaling file systems incorporate cleaning on-line maintenance costs ext writes metadata journal cleans journal checkpointing data final fixed location additional cleaning performed ixt increases total traffic small amount evaluation evaluate prototype implementation ixt focus major axes assessment robustness ixt modern disk failures time space overhead additional redundancy mechanisms employed ixt robustness test robustness ixt harness fault injection framework running partial-failure experiments ixt results shown figure ixt detects read failures ext error codes lower level derrorcode metadata block read fails ixt reads replica copy rredundancy replica read fails behaves ext propagating error rpropagate stopping file system activity rstop data block read fails parity block data blocks file read compute failed data block contents rredundancy ixt detects write failures error codes derrorcode aborts journal mounts file system read-only stop writes disk rstop data metadata block read checksum contents computed compared checksum block dredundancy checksums match read error generated rpropagate read errors contents failed block read replica computed parity block rredundancy process building ixt fixed numerous bugs ext avoided cases ext commit failed transactions disk potentially corrupt file system employing checksumming detect corruption replication parity recover lost blocks ixt robust file service spite partial disk failures quantitatively ixt detects recovers partial-error scenarios induced result logical well-defined failure policy time overhead assess performance overhead ixt isolate overhead iron mechanism enabling checksumming metadata data metadata replication parity user data transactional checksumming separately combinations standard file system benchmarks ssh-build unpacks compiles ssh source distribution web server benchmark responds set static http requests postmark emulates file system traffic server tpc-b runs series debit-credit transactions simple database run experiment times present average results benchmarks exhibit broad set behaviors specifically ssh-build good albeit simple model typical action developer administrator web server read intensive concurrency postmark metadata intensive file creations deletions tpc-b induces great deal synchronous update traffic file system table reports relative performance variants ixt 
workloads compared stock linux ext numbers draw main conclusions ssh-build web server workload time overhead iron techniques enabled ssh-build indicative typical activity checksumming replication parity incurs cost similarly web server benchmark conclude read-intensive workloads suffer addition iron techniques ssh web post tpcb baseline ext table overheads ixt file system variants results running variants ixt ssh-build ssh web server web postmark post tpc-b tpcb benchmarks presented ssh-build time measures time unpack configure build ssh source tree tar source size web server benchmark transfers data http requests postmark run transactions file sizes ranging subdirectories files tpc-b run randomly generated debitcredit transactions rows vary redundancy technique implemented combinations implies metadata checksumming enabled data checksumming enabled replication metadata turned parity data blocks enabled transactional checksums results normalized performance standard linux ext interested reader running times standard ext ssh-build web postmark tpc-b seconds slowdowns greater marked bold speedups relative base ext marked brackets testing linux kernel ghz intel memory western digital wdc bbdaa disk metadata intensive workloads postmark tpc-b overhead noticeable postmark tpc-b row workloads metadata intensive results represent worst-case performance expect observe implementation metadata replication row incurs substantial cost data checksumming row user parity metadata checksums contrast incur cost rows untuned implementation ixt results demonstrate worst case costs robustness prohibitive finally performance synchronous tpc-b workload demonstrates benefits transactional checksum base case technique improves standard ext performance row combination parity checksumming replication parity reduces overhead roughly row row additional robustness checksums applied improve performance journaling file systems space overhead evaluate space overhead measured number local file systems computed increase space required metadata replicated room checksums included extra block parity allocated found space overhead checksumming metadata replication small range found parityblock overhead user files bit substantial range depending volume analyzed summary investigated family redundancy techniques found ixt greatly increases robustness file system partial failures incurring modest time space overheads work left designs implementation techniques explored understand benefits costs iron approach related work effort builds related work bodies literature file system analysis related efforts inject faults test robustness systems failure prototype iron file system draws recent efforts building software robust hardware failure discuss turn fault injection robustness testing fault-tolerance community worked years techniques injecting faults system determine robustness fiat simulates occurrence hardware errors altering contents memory registers similarly fine inject software faults operating system major difference previous work approach focuses file systems handle broad class modern disk failure modes previous work approach assumes implicit knowledge file-system block types ensure test paths file system code previous work inserts faults blind fashion uncover problems found work similar brown patterson work raid failure analysis authors suggest hidden policies raid systems worth understanding demonstrate fault injection software raid systems qualitatively failure-handling recovery policies discover failure policy target file system raid requiring complex type-aware approach recent work yang model-checking find host file system bugs techniques well-suited finding classes bugs approach aimed discovery file system failure policy interestingly approach uncovers file system bugs yang reason testing scale model-checking limited small file systems reduce run-time approach applied large file systems work builds earlier work failure injection underneath file systems work developed approach test file systems handle write failures journal updates current work extends data types read write corruption failures iron file systems work iron file systems partially inspired work google acharya suggests cheap hardware paranoid assume fail unpredictable ways google good reason treats application-level problem builds checksumming top file system disk-level redundancy drives machines drive extend approach incorporating techniques file system applications benefit note techniques complimentary application-level approaches file system metadata block inaccessible user-level checksums replicas enable recovery now-corrupted volume related approach driver hardening effort linux stated hardened driver extends realm well-written include professional paranoia features detect hardware software problems page drivers generally improve system reliability faults handled file system end-to-end argument fail-partial failure model disks understood high-end storage high-availability systems communities network appliance introduced row-diagonal parity tolerate disk faults continue operate order ensure recovery presence latent sector errors virtually network appliance products checksumming detect block corruption similarly systems tandem nonstop kernel include end-to-end checksums handle problems misdirected writes interestingly redundancy single disk instances ffs internal replication limited fashion specifically making copies superblock platters drive noted earlier commodity file systems similar provisions suggest making replicas disk raid array reduce rotational latency primary intention copies recovery storage array difficult apply techniques selective manner metadata work replication improving performance fault-tolerance future investigation iron strategies checksumming commonplace improve system security patil stein suggest implement evaluate methods incorporating checksums file systems systems aim make corruption file system data attacker difficult finally dynamic file system sun good file system iron techniques dfs checksums detect block corruption employs redundancy multiple drives ensure recoverability contrast emphasize utility replication drive suggest evaluate techniques implementing redundancy show embellish existing commodity file system dfs written scratch limiting impact conclusions commodity operating systems grown assume presence reliable hardware result case file systems commodity file systems include requisite machinery handle types partial faults expect modern disk drives time reexamine file systems handle failure excellent model operating system kernel networking subsystem network hardware long considered unreliable hardware medium software stacks designed well-defined policies cope common failure modes disks viewed fully reliable mistrust woven storage system framework challenges remain failures disks expose layers file system software architecture redesigned enable consistent well-defined failure policy kind controls exposed applications users low-overhead detection recovery techniques iron file systems employ answers questions lead understanding effectively implement generation robust reliable iron file systems acknowledgments extend steve kleiman network appliance dave anderson jim dykes seagate insights disks work fail liuba shrira shepherd dave dewitt mark hill jiri schindler mike swift anonymous reviewers members adsl excellent suggestions comments himani apte meenali rungta invaluable work implementing parity ext finally computer systems lab csl providing terrific computing environment systems research work sponsored nsf ccrccr- ngsitr- ibm network appliance emc acharya reliability cheap learned stop worrying love cheap pcs easy workshop october altaparmakov linux-ntfs project http linuxntfs sourceforge net ntfs august alvarez burkhard cristian tolerating multiple failures raid architectures optimal storage uniform declustering proceedings annual international symposium computer architecture isca pages denver colorado anderson drive manufacturers typically don 
talk disk failures personal communication dave anderson seagate anderson dykes riedel interface scsi ata proceedings usenix symposium file storage technologies fast san francisco california april arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october arpaci-dusseau arpaci-dusseau fail-stutter fault tolerance eighth workshop hot topics operating systems hotos viii pages schloss elmau germany bairavasundaram sivathanu arpaci-dusseau arpaci-dusseau x-ray non-invasive exclusive caching mechanism raids proceedings annual international symposium computer architecture isca pages munich germany june bartlett spainhower commercial fault tolerance tale systems ieee transactions dependable secure computing january barton czeck segall siewiorek fault injection experiments fiat ieee transactions computers april jfs overview ibm developerworks library jfs html bitton gray disk shadowing proceedings international conference large data bases vldb pages los angeles california august brown patterson maintainability availability growth benchmarks case study software raid systems proceedings usenix annual technical conference usenix pages san diego california june candea kawamoto fujiki friedman fox microreboot technique cheap recovery proceedings symposium operating systems design implementation osdi pages san francisco california december chou yang chelf hallem engler empirical study operating system errors proceedings acm symposium operating systems principles sosp pages banff canada october corbett english goel grcanac kleiman leong sankar row-diagonal parity double disk failure correction proceedings usenix symposium file storage technologies fast pages san francisco california april devale koopman performance evaluation exception handling libraries proceedings international conference dependable systems networks dsngoteborg sweden june douceur bolosky large-scale study file-system contents proceedings acm sigmetrics conference measurement modeling computer systems sigmetrics pages atlanta georgia dykes modern disk roughly lines code personal communication james dykes seagate august emc emc centera content addressed storage system http emc emerson essays english traits self-reliance harvard classics edited charles eliot york collier son volume foolish consistency hobgoblin minds adored statesmen philosophers divines engler chen hallem chou chelf bugs deviant behavior general approach inferring errors systems code proceedings acm symposium operating systems principles sosp pages banff canada october ghemawat gobioff leung google file system proceedings acm symposium operating systems principles sosp pages bolton landing lake george york october gibson rochberg zelenka nagle amiri chang feinberg gobioff lee ozceri riedel file server scaling network-attached secure disks proceedings joint international conference measurement modeling computer systems sigmetrics performance pages seattle washington june gray census tandem system availability technical report tandem computers green eide controller flaws version http mindprod eideflaw html february kalbarczyk iyer yang characterization linux kernel behavior error proceedings international conference dependable systems networks dsnpages san francisco california june gunawi agrawal arpaci-dusseau arpacidusseau schindler deconstructing commodity storage clusters proceedings annual international symposium computer architecture isca pages madison wisconsin june henson history unix file systems http infohost nmt val slides pdf hitz lau malcolm file system design nfs file server appliance proceedings usenix winter technical conference usenix winter san francisco california january hughes murray reliability security raid storage systems archives sata disk drives acm transactions storage february intel corp ibm corp device driver hardening http hardeneddrivers sourceforge net kari latent sector faults reliability disk arrays phd thesis helsinki technology september kari saikkonen lombardi detection defective media disks ieee international workshop defect fault tolerance vlsi systems pages venice italy october katcher postmark file system benchmark technical report trnetwork appliance october kleiman vnodes architecture multiple file system types sun unix proceedings usenix summer technical conference usenix summer pages atlanta georgia june lewis smart filers dumb disks nsic osd working group meeting april luby mitzenmacher shokrollahi spielman stemann practical loss-resilient codes proceedings twenty-ninth annual acm symposium theory computing stoc pages paso texas lun kao iyer tang fine fault injection monitoring environment tracing unix system behavior faults ieee transactions software engineering pages mckusick joy leffler fabry fast file system unix acm transactions computer systems august mckusick joy leffler fabry fsck unix file system check program unix system manager manual bsd virtual vaxversion april park balasubramanian providing fault tolerance parallel secondary storage systems technical report cs-tr- department computer science princeton november patil kashyap sivathanu zadok in-kernel integrity checker intrusion detection file system proceedings annual large installation system administration conference lisa atlanta georgia november patterson brown broadwell candea chen cutler enriquez fox kiciman merzbacher oppenheimer sastry tetzlaff traupman treuhaft recovery oriented computing roc motivation definition techniques case studies technical report csd- berkeley march patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod conference management data sigmod pages chicago illinois june postel rfc transmission control protocol september ftp ftp rfc-editor in-notes rfc txt august prabhakaran arpaci-dusseau arpaci-dusseau model-based failure analysis journaling file systems proceedings international conference dependable systems networks dsnyokohama japan june redell dalal horsley lauer lynch mcjones murray purcell pilot operating system personal computer communications acm february reiser reiserfs namesys ridge field book scsi starch june rinard cadar dumitran roy leu william beebe enhancing server availability security failure-oblivious computing proceedings symposium operating systems design implementation osdi san francisco california december rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february saltzer reed clark end-to-end arguments system design acm transactions computer systems november schindler experienced severe performance degradation identified problem disk firmware disk drives reprogrammed fix problem personal communication schindler emc july schlosser ganger mems-based storage devices standard disk interfaces square peg round hole proceedings usenix symposium file storage technologies fast pages san francisco california april schneider implementing fault-tolerant services state machine approach tutorial acm computing surveys december schwarz xin miller long hospodor disk scrubbing large archival storage systems proceedings annual meeting ieee international symposium modeling analysis simulation computer telecommunication systems mascots volendam netherlands october seltzer bostic mckusick staelin implementation log-structured file system unix proceedings usenix winter technical conference usenix winter pages san diego california january siewiorek hudak suh segal development benchmark measure system robustness proceedings international symposium fault-tolerant computing ftcstoulouse france june sivathanu bairavasundaram arpaci-dusseau arpaci-dusseau life death block level proceedings symposium operating systems design implementation osdi pages san francisco california december sivathanu prabhakaran arpaci-dusseau arpaci-dusseau improving storage system availability graid proceedings usenix symposium file storage technologies fast pages san francisco california april sivathanu prabhakaran popovici denehy arpaci-dusseau arpaci-dusseau semantically-smart disk systems proceedings usenix symposium file storage technologies fast pages san francisco california 
april solomon inside windows microsoft programming series microsoft press edition stein howard seltzer unifying file system protection proceedings usenix annual technical conference usenix boston massachusetts june sweeney doucette anderson nishimoto peck scalability xfs file system proceedings usenix annual technical conference usenix san diego california january swift bershad levy improving reliability commodity operating systems proceedings acm symposium operating systems principles sosp bolton landing lake george york october talagala patterson analysis error behaviour large storage system ieee workshop fault tolerance parallel distributed systems san juan puerto rico april data clinic hard disk failure http dataclinic harddisk-failures htm transaction processing council tpc benchmark standard specification revision technical report tsai iyer measuring fault tolerance ftape fault injection tool international conference modeling techniques tools computer performance evaluation pages september tweedie journaling linux ext file system fourth annual linux expo durham north carolina wehman den haan enhanced ide fast-ata faq http thef-nym sci kun cgi-pieterh atazip atafq html weinberg solaris dynamic file system http members visi net thedave sun dynfs pdf wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february yang twohey engler musuvathi model checking find file system errors proceedings symposium operating systems design implementation osdi san francisco california december gum chen wang krishnamurthy anderson trading capacity performance disk array proceedings symposium operating systems design implementation osdi san diego california october 
deploying safe user-level network services ictcp haryadi gunawi andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison haryadi dusseau remzi wisc abstract present ictcp information control tcp implementation exposes key pieces internal tcp state tcp variables set safe fashion primary benefit ictcp enables variety tcp extensions implemented user-level ensuring extensions tcp-friendly demonstrate utility ictcp collection case studies show exposing information safe control tcp congestion window readily implement user-level versions tcp vegas tcp nice congestion manager show user-level libraries safely control duplicate acknowledgment threshold make tcp robust packet reordering wireless lans show retransmission timeout adjusted dynamically finally find converting stock tcp implementation ictcp straightforward prototype requires approximately lines kernel code introduction years networking research suggested vast number modifications standard tcp protocol stack proposals eventually adopted suggested modifications tcp stack widely deployed paper address problem deployment proposing small enabling change network stack found modern operating systems specifically introduce ictcp pronounced tcp slightly modified in-kernel tcp stack exports key pieces state information safe control user-level libraries exposing state safe control tcp connections ictcp enables broad range interesting important network services built user-level user-level services built ictcp deployable services implemented tcp stack services packaged libraries easily downloaded interested parties approach inherently flexible developers tailor exact applications finally extensions composable library services build powerful functionality lego-like fashion general ictcp facilitates development services reside key advantage ictcp compared approaches upgrading network protocols simplicity implementing ictcp framework platform simplicity virtue reasons ictcp leverages entire existing tcp stack simple convert traditional tcp implementation ictcp linux-based implementation requires approximately lines code small amount code change reduces chances introducing bugs protocol previous tcp modifications property advantage ictcp safe manner user-level control safety issue time users allowed modify behavior ictcp users allowed control set limited virtual tcp variables cwnd dupthresh rto users download arbitrary code safety concern remaining concern network safety applications implement tcp extensions friendly competing flows building top extant tcp reno stack restricting virtual variables safe range values ictcp ensures extensions aggressive tcp reno friendly addition providing simplicity safeness framework ictcp address additional questions overheads implementing variants tcp ictcp reasonable measurements show services built ictcp scale incur minimal cpu overhead ictcp waiting mechanisms wide range functionality implemented conservative approach demonstrate utility ictcp implementing extensions tcp set case studies focus modifications alter behavior transport appears sixth symposium operating systems design implementation osdi regard congestion tcp vegas tcp nice congestion manager set focus tcp modifications behave differently presence duplicate acknowledgments build reodering-robust extension misinterpret packet reordering packet loss extension efficient fast retransmit efr set explore tcp eifel adjusts retransmit timeout finally services developed easily framework show amount code required build extensions user-level services ictcp similar original native implementations rest paper structured section compare ictcp related work extensible network services section present design ictcp section describe methodology section evaluate important aspects ictcp simplicity implementing ictcp platform network safety ensured user-level extensions computational overheads range tcp extensions supported complexity developing extensions conclude section related work section compare ictcp approaches provide networking extensibility upgrading tcp recent projects proposed frameworks providing limited extensions transport protocols protocols tcp evolve improve ensuring safety tcp friendliness compare ictcp proposals mogul propose applications radically set tcp state terms tcp state ictcp similar proposal greater philosophical difference arises internal tcp state set mogul arbitrary state setting suggest safety provided cryptographic signature previously exported state restricting ability super-user ictcp conservative allowing applications alter parameters restricted fashion trade-off ictcp guarantee network services behaved mogul approach enable broader range services session migration web net projects developing management interface tcp similar information component ictcp web instruments tcp export variety per-connection statistics web propose exporting detailed information ictcp web export timestamps message acknowledgment tcp-tuning daemon net similar control component ictcp daemon observes tcp statistics responds setting tcp parameters key difference ictcp net propose allowing complete set variables controlled ensure network safety net appears suitable tuning parameters set frequently ictcp frequently adjust in-kernel variables per-message statistics ability block in-kernel events occur stp addresses problem tcp deployment stp enables communicating end hosts remotely upgrade protocol stack stp authors show broad range tcp extensions deployed emphasize major differences stp ictcp stp requires invasive kernel support safe downloading extension-specific code support in-kernel extensibility fraught difficulty contrast ictcp makes minimal kernel stp requires additional machinery ensure tcp friendliness ictcp guarantees friendliness design stp powerful framework tcp extensions ictcp provided easily safely finally information component ictcp derived infotcp proposed part infokernel previous work showed infotcp enables userlevel services indirectly control tcp congestion window cwnd ictcp improves infotcp main ways ictcp exposes information complete set tcp variables ictcp services directly set cwnd inside tcp applications perform extra buffering incur sleep wake events finally ictcp tcp variables cwnd controlled ictcp tcp extensions implemented efficient accurate user-level tcp researchers found move portions conventional network stack userlevel user-level tcp simplify protocol development ictcp userlevel tcp implementation typically struggles performance due extra buffering context switching assurance network safety application-specific networking large body research investigated provide extensibility network services projects network protocols specialized applications ictcp improve performance dramatically approaches tend require radical restructuring networking stack guarantee tcp friendliness protocol languages architectures network languages structured tcp implementations simplify development network protocols ability replace specialize modules appears sixth symposium operating systems design implementation osdi states snd nxt snd una information cwnd ssthresh msglist ack dsack seq rtt acklist timeout cwnd cwnd cnt ssthresh rcv wnd rcv nxt snd una snd nxt dupthresh rto retransmits control tcp clients ictcp vegas ictcp nice ictcp ictcp efr ictcp eifel ictcp ictcp figure ictcp architecture diagram shows ictcp architecture base stack ictcp slightly modified tcp stack exports information limited control top ictcp built number user-level libraries implement pieces functionality suggested literature libraries composed applicable enabling construction powerful services plug-and-play fashion applications sit top stack choose libraries match directly kernel transport generally easier extend existing tcp implementations ictcp design ictcp framework exposes information control key parameters tcp protocol implementation section give high-level overview user-level network services deployed ictcp describe classes information control exported ictcp system architecture figure presents schematic ictcp framework illustrated user-level libraries implementing variants tcp built top ictcp user-level libraries transparently applications 
standard interfaces tcp connections ictcp libraries design ictcp sending side ictcp deployed receivers running ictcp unmodified kernel stack simplify implementation ictcp bsd socket interface exporting information providing control socket options approach minimized implementation work imposes unnecessary run-time overhead obtaining state requires copy kernel user space evaluation shows user-level network services naively poll ictcp frequently state information incur significant increase cpu overhead minimize overhead ictcp polling interrupt-based interface tcp variables updated acknowledgment arrives end round roundtrip time elapsed applications receive interrupt condition case studies ictcp user-level libraries structured threads thread injects packets kernel performs sleep wait set operations information goal ictcp expose information traditionally internal tcp challenge determine information exposed information exposed build interesting extensions information exposed future kernel implementations tcp constrained undesirable expanded interface tcp implementations constrained adhere tcp specification internal variables required ictcp explicitly exports variables part tcp specification sequence number snd nxt oldest unacknowledged sequence number snd una congestion window cwnd slow start threshold ssthresh exposing information tcp implementation straightforward found interesting services access information needed libraries ictcp-nice ictcp-rr examine information message ictcp exposes standard information packet message list history recent packets reporting packet sequence number round-trip time time-out fast retransmit ack list history recent acknowledgments recording packet acknowledgment number type normal ack duplicate ack sack dsack exposing per-packet per-ack information trivial tcp implementations exist tcp reno track round-trip time packet add high resolution timer ictcp record information additional complexity recording per-message information requires additional memory ictcp creates lists enabled user-level services control goal ictcp variables internal tcp externally set safe manner challenge determine variables modified values ensuring resulting behavior tcp-friendly philosophy appears sixth symposium operating systems design implementation osdi variable description safe range usage cwnd congestion window limit number packets cwnd cnt linear cwnd increase increase cwnd aggressively ssthresh slow start threshold move rcv wnd receive window size reject packet limit sender rcv nxt expected seq num vrcv wnd reject packet limit sender snd nxt seq num send vsnd una reject ack enter snd una oldest unacked seq num vsnd nxt reject ack enter frfr dupthresh duplicate threshold vcwnd enter frfr rto retransmission timeout exp backoff srtt rttvar enter retransmits number consecutive timeouts threshold postpone killing connection table safe setting tcp variables table lists tcp variables set ictcp range variable safely set ensuring result aggressive baseline tcp implementation give usage intuition control variable notation refers tcp original copy variable refers virtual copy set slow start congestion avoidance frfr fast retransmit fast recovery finally srtt rttvar exp backoff represent smoothed round-trip time round-trip time variance rto exponential backoff ictcp conservative control allowed aggressive transmission basic idea variable interest ictcp adds limited virtual variable terminology tcp variable original foo introduce limited virtual variable vfoo meaning clear simply original restrict range values virtual variable allowed cover resulting tcp behavior friendly ensure tcp actions aggressive original tcp implementation acceptable range variable function fluctuating tcp variables check call time user valid reject invalid settings ictcp accepts settings coerces virtual variable valid range safe range virtual congestion window vcwnd vcwnd cwnd vcwnd rises cwnd cwnd converting variable virtual variable ictcp stack trivial simply replace instances original variable virtual ensure virtual change original variable simplest case statement cwnd cwnd replaced cwnd vcwnd complex cases control flow require careful manual inspection limit extent original variable replaced virtual variable foremost goal ictcp ensure ictcp create aggressive flows conservative virtual variables introduce interesting tcp variables set current implementation ictcp control ten variables convinced safely set analysis linux tcp implementation introduce virtual variables original variable set interfaces sysctl tcp retries user mss approximated ways set rto srtt mdev rttvar mrtt claim ten variables represent complete collection settable values form set ten variables safe ranges summarized table briefly discuss range values safe ictcp variable variables cwnd cwnd cnt ssthresh property safe strictly lower case sender directly transmits data congestion window smaller cwnd cwnd cnt slow-start entered congestion avoidance ssthresh set variables determine packets acknowledgments accepted constraints variables complex receiver packet accepted sequence number falls inside receive window rcv nxt rcv nxt rcv wnd increasing rcv nxt decreasing rcv wnd effect rejecting incoming packets forces sender reduce sending rate sender acknowledgment processed sequence number snd una snd nxt increasing snd una decreasing snd nxt sender discard acks reduce sending rate case modifying values effect dropping additional packets tcp backs-off appropriately final set variables dupthresh rto retransmits control thresholds timeouts variables set independently original values increasing decreasing dupthresh believed safe changing values increase amount traffic sender transmit packets increase congestion window appears sixth symposium operating systems design implementation osdi information loc control loc states cwnd message list dupthresh ack list rto high-resolution rtt ssthresh wakeup events cwnd cnt retransmits rcv nxt rcv wnd snd una snd nxt info total control total ictcp total table simplicity environment table reports number statements counted number semicolons needed implement current prototype ictcp linux methodology prototype ictcp implemented linux kernel experiments performed exclusively netbed network emulation environment single netbed machine mhz pentium cpu main memory intel etherexpress pro ethernet ports sending endpoints run ictcp receivers run stock linux experiments dumbbell topology senders routers interconnected potential bottleneck link receivers experiments modified nistnet router nodes emulate complex behaviors packet reordering experiments vary combination bottleneck bandwidth delay maximum queue size intermediate router nodes experiments run multiple times averages reported variance low cases shown evaluation evaluate ictcp reasonable framework deploying tcp extensions user-level answer questions easily existing tcp implementation converted provide information safe control ictcp ictcp ensure resulting network flows tcp friendly computation overheads deploying tcp extensions user-level processes ictcp scale fourth types tcp extensions built deployed ictcp finally difficult develop tcp extensions note spend bulk paper addressing fourth question range extensions implemented discussing limitations explicit approach control set internal batch-aware tcp distributed variables file tcp system setsockopt john option bent val douglas switch thain option andrea case tcp arpaci-dusseau vcwnd remzi vcwnd val arpaci-dusseau case tcp miron set livny vcwnd computer vcwnd sciences val department check data wisconsin put madison abstract wire tcp present snd design test implementation vcwnd evaluation min cwnd batch-aware min distributed vcwnd file system cwnd bad-fs min system designed cwnd orchestrate cwnd large o-intensive transmit batch workloads tcp remote computing clusters distributed wide area packets bad-fs consists flight min components cwnd storage layer exposes rules control return traditionally fixed policies return figure caching in-kernel consistency modification replication adding vcwnd scheduler exploits tcp control stack requires lines workloads code extracting ictcp control applications set virtual variables bsd setsockopt interface 
based congestion window tcp snd test checks data put wire show adding virtual cwnd decision-making process simple straightforward cwnd ictcp minimum vcwnd cwnd simplicity environment begin addressing question difficult convert tcp implementation ictcp initial version ictcp implemented linux experience implementing ictcp fairly straightforward requires adding lines code table shows added statements tcp create ictcp number statements added perfect indicator complexity non-intrusive modifications figure partial vcwnd variable added ictcp stack network safety investigate ictcp flows tcp friendly perform evaluation measure throughput default tcp flows competing ictcp flows measurements show ictcp tcp friendly desired storage default tcp flows layer obtain placing bandwidth external competing scheduler ictcp bad-fs manages storage computation coordinated gracefully dealing competing cache consistency default fault-tolerance space management issues workload-specific manner microbenchmarks real workloads demonstrate performance benefits explicit control delivering excellent end-to-end tcp performance wide-area introduction traditional distributed file systems nfs afs built solid foundation empirical measurement studying expected workload patterns researchers developers long make trade-offs system design building systems work workloads interest previous distributed file systems flows targeted show computing constraining environment values collection valid range interactively ictcp client illustrate machines past created work unconstrained ictcp demonstrated workloads virtual lead variables set designs filenet default tcp flows google compete file unconstrained system ictcp assumptions flows usage throughput patterns appears sharing sixth characteristics symposium operating aspects systems design workload change implementation reexamine design decisions osdi throughput embedded ratio cwnd distributed file cwnd systems cwnd area increasing interest cwnd batch cnt cwnd workloads cnt long cwnd popular cnt scientific community batch computing ssthresh increasingly ssthresh common ssthresh broad range important commercially viable application domains throughput including ratio genomics video flows set production snd una simulation snd document una processing mss data snd mining una electronic design automation mss financial services graphics rendering flows batch set workloads dupthresh minimally dupthresh present system dupthresh set jobs flows run set rto srtt ordering var srtt var environments figure approximate network run safety times ictcp graph requirements shows lines advance line scheduler default information default ictcp dispatch jobs enforces parameters values maximize safe range throughput batch line workloads unconstrained typically run ictcp controlled parameters localarea cluster set environments organizations dupthresh graph large workload unconstrained demands ictcp increasingly lines ways metric share ratio resources throughput achieved wide-area default tcp flows lower costs competing increase ictcp flows productivity versus approach competing accessing default resources tcp flows wide-area graphs vary simply run ictcp parameters localarea set batch system case set multiple variable clusters unsafe spread cwnd packets larger cwnd cnt wide-area times larger distributed ssthresh file system times larger snd backplane una data access packets lower dupthresh approach random fraught values difficulty largely due default rto remaining handled initial srtt primary rttvar problem packets traditional dropped distributed file topology system dumbbell approach control senders decisions receivers caching consistency experiments fault tolerance rto made experiments implicitly bottleneck file bandwidth system mbps decisions delay reasonable workloads file rto systems experiments designed bottleneck bandwidth ill-suited mbps wide-area percents batch drop computing rate system default tcp flows minimize data reduced movement measurements shown wide-area figure system graphs carefully evaluate cache ictcp space parameters remote explicitly clusters setting caching parameter decisions buried deep safe range distributed file x-axis systems graph preventing increase control number mitigate competing ictcp problems tcp flows enable graph utilization shows remote lines clusters o-intensive batch line workloads ictcp introduce flows matching batch-aware proposal distributed virtual file variables system limited badfs bad-fs safe differs range traditional line distributed file unconstrained ictcp systems flows metric approach ratio control bad-fs throughput exposes achieved decisions default commonly tcp hidden inside distributed file system external workload-savvy flows scheduler bad-fs competing leaves ictcp consistency flows caching versus replication competing decisions default tcp scheduler flows enabling explicit throughput ratio workload-specific control file system behavior ictcp main reason flows migrate control friendly file system ictcp flows scheduler unfriendly information cwnd cwnd scheduler cnt intimate ssthresh knowledge experiments show workload variables running set exploit safe knowledge range improve ensure performance friendliness streamline expected failure ictcp flows handling combination allowed workload increase information congestion explicit window control file default system tcp leads remain tcp distinct friendly benefits unconstrained ictcp traditional approaches flows larger congestion windows overly aggressive result competing tcp flows obtain fair share bandwidth appears evaluate variables usenix control symposium acknowledgments networked systems design packets implementation accepted nsdi behavior enhanced snd una performance shown carefully fourth managing graph remote snd cluster una disk variable caches represents cooperative highest unacknolwedged packet fashion virtual snd controlling una set needed safe data range transported actual wide-area unconstrained bad-fs ictcp minimizes over-estimates wide-area number traffic bytes acknowledged improves throughput increases workload congestion window knowledge bad-fs aggressively improves ictcp performance correctly constrains capacityaware snd scheduling una avoid flow remains thrashing friendly improved results failure handling variables detailed rcv workload wnd information rcv nxt scheduler snd nxt determine shown make cases replicas ictcp data flows based remain friendly cost desired generating unconstrained ictcp flows indiscriminately fail completely typical file increasing systems rcv wnd data loss treated uniformly variable performance safe range problem scheduler receive buffer ability overflow regenerate final lost file graphs rerunning explore application dupthresh generated rto thresholds replicates experiment cost regeneration retransmits high variable simplified implementation detailed workload decide information connection simpler implementation terminated expected bad-fs dupthresh cooperative cache decreasing increasing implement cache consistency default protocol exact knowledge unfriendliness data dupthresh dependencies scheduler constrained ensures proper access ordering case rto jobs previous graph work shows rto demonstrated set difficulties exp building backoff srtt general rttvar cooperative caching resulting flow scheme demonstrate aggressive benefits graphs represent explicit control small subset prototype implementation experiments bad-fs conducted investigate synthetic tcp workloads friendliness demonstrate experimented bad-fs setting ictcp reduce variables wide-area random traffic values order safe magnitude range avoid performance controlled faults ictcp capacity-aware parameters scheduling isolation proactively sets replicate data parameters obtain simultaneously high cases performance tcp spite reno flows remote competing failure ictcp real obtain workloads demonstrate appears practical sixth benefits symposium operating system systems o-intensive design batch workloads implementation run osdi remote cpu resources utilization number easily connections high scaling performance cpu per-ack finally intr bad-fs per-round achieves intr ends mstlist maintaining per-round site intr autonomy support unmodified reno legacy throughput applications number connections practical scaling constraints throughput reno important per-round intr acceptance per-round wide-area intr batch msglist computing per-ack environments intr figure rest cpu overhead paper throughput organized scaling ictcp connect section sender describe host assumptions receiver hosts expected environment network workload interfaces links section discuss mbps architecture delay links system aggregrate section sender present host send experimental data outward evaluation mbps section examine related work finally x-axis section increase conclude number background connections section describe setting sender bad-fs host connections spread present evenly expected workloads basing receivers assumptions figure recent work compares batch workload cpu utilization characterization reno describe ictcp computing environment per-ack per-round users interrupt workloads figure shows difficulty ictcp throughput encounter degradation executing sender workloads load high conventional bandwidth tools workloads competing illustrated figure tcp reno data-intensive flows workloads desired composed summary multiple results independent empirically demonstrate ictcp flows vertical sequences require safe variable settings tcp friendly experiments prove ictcp ensures network safety measurements combined analysis give confidence ictcp safely deployed cpu overhead evaluate overhead imposed ictcp framework ways explore scalability ictcp synthetic user-level libraries experiments explore ways user-level library reduce cpu job overhead job minimizing interactions kernel implement job job tcp job vegas user-level top ictcp job experiments job directly compare ictcp infotcp scaling ictcp evaluate job ictcp job scales number connections job increased job endpoint host batch batchendpoint user-level input input extensions built pipeline data ictcp pipeline data expected pipeline data set input output pieces job tcp width information depth figure rates typical factors batch-pipelined workload determine single pipeline amount represents overhead logical work user user process wishes requires complete per-ack per-round comprised interrupts series jobs users assemble user process pipelines batch ictcp message explore list variations ack input list parameters data input structures data show processes scaling communicate properties user ancestors libraries built relatives ictcp private data construct files workload synthetic generally libraries consists mimic large number behavior sequences case studies incidentally synchronized synthetic library beginning logically distinct correctly execute rate siblings refer vertical slice workload pipeline horizontal slice batch entire set batch-pipelined workload note per-ack pipeline interrupts generically representing processes ictcp-efr connected ictcp-eifel unix-style pipes library per-round communicate interrupts files iccm key final differences library single per-round application interrupts batch-pipelined workload file message sharing ack behavior list data structures instances ictcp-vegas pipeline ictcp-nice run ictcp-rr executable potentially graphs input figure files show ictcp characterize sharing tcp reno occurs scale batch-pipelined number workloads flows breaking increased activity host types shown figure figure reports endpoint cpu unique utilization input final output pipeline-shared figure shared reports write-then-read throughput data single figure pipeline shows batchshared ictcp input data per-ack shared multiple per-round interrupts pipelines environment reaches cpu wide-area utilization sharing untrusted arbitrary personal computers connections platform batch additional workloads cpu overhead platform ictcp types message throughput-intensive list workloads negligible clusters comparison tcp managed reno machines reaches spread roughly wide utilization area assume connections cluster machine slowly processing increases memory local roughly disk connections space remote figure users shows throughput cluster exports ictcp resources starts cpu degrade sharing system obvious bottleneck connections system depending wide-area connection per-ack managed per-round carefully appears interrupts usenix symposium flows networked systems ictcp design throughput implementation per-ack nsdi per-round ensure interrupts high performance lower simplicity tcp focus reno efforts case single cluster ictcp cpu accessed overhead remote noticeable user prohibitive section measure present preliminary extent results multi-cluster environment refer organized hostile managed collection clusters cluster-to-cluster user-level system library contrast accurately popular peer-to-peer systems implement tcp functionality environment measure interrupt miss rate defined organized frequently effort share user computing misses resources interrupt corporations ack end organizations round assume scaling environments experiments connections observed worst-case miss rate per-ack interrupts per-round interrupts low miss rates imply functionality userlevel stable responsive powerful current network trustworthy conditions ictcp-vegas technologies evaluate ictcp designs implement tcp vegas directly congestion applicable avoidance user-level domain library tcp make vegas practical reduces latency important increases assumption throughput site relative tcp local reno autonomy carefully matching resources sending autonomy rate primary rate implications packets design drained bad-fs workload network avoiding remote resources time resources arbitrarily packet loss revoked specifically system sender sees built measured exploit throughput remote differs resources expected throughput tolerate unexpected resource fixed failures threshold increases due appears physical sixth breakdowns symposium software operating failures systems deliberate design preemptions autonomy implementation prohibits deployment arbitrary software osdi cpu remote utilization cluster bandwidth designing delay ictcp-vegas bad-fs cpu overhead assume infovegas remote ictcp-vegas cluster per-ack intr ictcp-vegas polling ability ictcp-vegas per-round dispatch intr well-defined reno job figure ictcp-vegas ordinary cpu unprivileged overhead user figure mandating compares single cpu distributed utilization file reno system infovegas versions viable solution finally assume jobs run systems modified experience scientific workloads ictcp-vegas product vary years bottleneck-link bandwidth fine-tuning x-axis decreases complete congestion control viewed window untouchable cwnd ease implementation important implementation work vegas user congestion control algorithm current ictcp-vegas solutions user wishes run batchpipelined workload environment user developed debugged workload home system ready run batches hundreds structured thousands operation computing vegas resources remote user-level batch library execution systems library simply condor passes lsf messages pbs directly grid engine pipeline workload expected input data varying ictcp parameters buffering small inputs layer implement input data begins versions user vary home point storage server poll ictcp ftp server information output time data send generated packet eventually time committed acknowledgment home received server conventional batch round ends computing systems library present 
user options running relevant workload tcp state option calculates remote target simply congestion submit window vcwnd workload vcwnd remote batch ictcp-vegas system sets option explicitly inside input output occur demand back ictcp home storage device note approach implementation simple ictcp-vegas throughput similar data-intensive infovegas workload part drastically reduced factors wide-area network bandwidth sufficient infokernel handle simultaneous primary batch difference reads data-intensive infotcp pipelines running manage parallel vcwnd pipeline output provide directed control back tcp home variables site including infovegas 
temporary calculates data vcwnd needed computation actual cwnd completes infovegas option buffer pre-staging packets user transfer manually configure system replicate batch data tcp sets layer remote infovegas environment blocks approach requires acknowledgment user arrives obtain point account recalculates vcwnd remote environment send identify messages input data evaluation transfer data verified remote site log ictcp-vegas remote behaves system unpack in-kernel data implementation vegas location due configure space workload constraints recognize show correct results directories possibly focus tmp evaluation temporary pipeline cpu data overhead submit figure shows workload total user system cpu utilization manually deal function network failures bandwidth tcp reno entire versions ictcp-vegas infovegas network bandwidth increases cpu utilization increases implementation cpu utilization system utilization increases significantly infovegas due frequent user-kernel crossings extra overhead reduced process ictcp-vegas polls ictcp message send repeated wakes arrival acknowledgment data document processed latency bottleneck link batch bandwidth mbps systems link capacity latency reno tcp nice existing ictcp-nice figure systems ictcp-nice link capacity longer latency foreground flow competes capacity background flows offer line corresponds run user experiment protocol background flows obvious ictcp tcp nice reno vegas y-axis shows description average configuration document process transfer latency foreground laborintensive traffic foreground traffic error-prone consists -minute section additionally tmp challenging availability guaranteed limitation user made configurations independently scheduling system scheduling system correctly checkpoint pipelines workload users lengths simply run workloads traditional distributed file systems solution typically due administrative desire squid preserve autonomy domain proxy trace boundaries logged berkeley systems background traffic fixed consists policies prevent long-running flows topology viable batch-pipelined dumbbell workloads sending nodes blast receiving nodes commonly foreground genomic search flow program consisting sender receiver single pairs stage pipeline background searches flows distributed large shared dataset remaining protein sender string receiver matches pairs assume bottleneck user link bandwidth run blast varied compute x-axis cluster nodes noticeable equipped ictcp conventional information distributed file system getsockopt interface afs incurs nfs significant cold overhead caches ictcp-vegas nodes greatly reduce individually overhead simultaneously access information home server frequently vegas large adjusts demands cwnd resulting end round ictcp-vegas behave accurately waking round optimization results cpu utilization higher ictcp-vegas in-kernel poor performance dataset redundantly transferred wide area network caches loaded node run local disk speeds dataset fit cache node thrash generate enormous amount repetitive traffic back home server lacking workload information node employ mechanism protect consistency availability cached data contrast reno tcp batch-aware system extensions bad-fs fourth axis global view evaluating ictcp hardware concerns configuration range workflow structure tcp extensions execute workloads efficiently importance copying issue dataset single spend time wide remaining appears paper usenix topic symposium networked systems design implementation nsdi queries catalogscheduler home address question demonstrating tcp variants built top ictcp case studies explicitly meant exhaustive illustrate flexibility simplicity ictcp briefly discuss storage ssss cccccccc ictcp movementdata remote cluster remote implement cluster wider set statusupdatesjob tcp extensions data ictcp-nice placements complete case job study notices show figure tcp system nice architecture circles implemented compute user-level servers ictcp execute batch study jobs squares demonstrates storage algorithm servers differs hold cached radically inputs temporary base ictcp outputs reno types servers report catalog server records state system algorithm implemented pipeline batch sharing grid workloads douglas thain john bent andrea arpaci-dusseau remzi arpaci-dusseau miron livny computer sciences department wisconsin madison abstract present study batch-pipelined scientific workloads candidates execution computational grids studies focus behavior single applications study characterizes workloads composed pipelines sequential processes file storage communication share significant data batch study includes measurements memory cpu requirements individual components analyses sharing complete batches conclude discussion ramifications workloads end-to-end scalability system design introduction years researchers understood importance studying workload characteristics order evaluate impact current future systems architecture previous application studies focused detailed behavior single applications sequential parallel caching behavior spec workloads long topic intense scrutiny communication characteristics parallel applications similarly documented applications isolation production settings computational science desired end-result product group applications run hundreds thousands times varied inputs applications executed high throughput computing system condor managed high-level workflow software chimera refer workloads batch-pipelined illustrated figure batch-pipelined workload composed independent pipelines pipeline sequential processes communicate preceding succeeding processes private data files shared input files pipelines process pipeline sharing pipeline sharing batch batch width figure batch-pipelined workload stages figure suggests workload generally submitted large batches pipelines incidentally synchronized beginning pipeline logically distinct correctly execute faster slower siblings key difference studying behavior single application batch-pipelined workload sharing behavior batch-pipelined workload understood instances application run executable potentially input files realistically capture full diversity production workloads study behavior entire pipeline account effects sharing paper present study production scientific workloads collected application pipelines diverse fields computational science including astronomy biology geology physics applications representative broad class important workloads present basic characterization computational memory demands workloads find individually single pipeline place tremendous load system resources combination loads overwhelming focus behavior workloads primary source sharing characterize sharing occurs workloads breaking activity categories endpoint represents input final output pipeline-shared shared write-then-read fashion single pipeline batch-shared comprised input shared pipelines characterization show shared dominant component traffic importantly study implications systems design find wide-area network bandwidth scalability problem applications attempts made eliminate shared successful systems workloads segregate types traffic order scale successfully submit pipeline-shared data significant problem batch-shared data elucidate traditional file systems workloads rest paper organized section describe general characteristics batchpipelined workloads specific application pipelines section describe experimental method sections analyze data discuss implications discuss related work section conclude section applications applications characterize chosen range scientific disciplines selection criteria applications attacking major scientific objective composed sequential applications require scalable computing environment accomplish high throughput focus applications measurements include seti home point guidance users chose workloads input parameters correspond production descriptions applications found figure applications variable granularity cms amanda process variable number small independently generated events applications chose pipeline sizes events cms showers amanda typical production cases cpu resources consumed pipeline scale linearly number events ibis multiple datasets differing resolutions granularity resolution reflects size dataset experiments medium sized dataset ibis nautilus perform single simulations variable length seti blast operate work unit fixed size applications observed characteristic behaviors diamond-shaped storage profile small initial inputs generally created humans initialization tools expanded early stages large intermediate results intermediates reduced stages small results interpreted humans incorporated database intermediate data serves checkpoint cached values ephemeral nature multi-level working sets users easily identify large logical collections data needed application calibration tables physical constants execution applications tend select small working set users aware significant consequences data replication caching techniques significant data sharing application large configuration space users submit large numbers similar jobs access similar working sets analysis condor logs shows usual batch size thousand amanda cms blast property exploited efficient widearea distribution modest communication links method application capture cpu memory behavior cpu memory behavior tracked hardware counters statistics instrument behavior make shared-library interposition agent replaces routines standard library explicit event requested application library records event marking start end operation instruction count details request technique applied application dynamically linked care avoid additional overheads due tracing access memory-mapped files traced userlevel paging technique posix mprotect feature access memory-mapped regions generates user-level page fault sigsegv handled traced shared library application blast memory-mapped analysis page faults considered equivalent explicit read operations page size non-sequential access memorymapped pages recorded explicit seek operation workload analysis overview resources consumed application figure applications wide variance run times current hardware ranging minute blast day ibis considered individually applications spend majority time consuming cpu memory requirements program sizes modest comparison total volume matches search string database mbmips blastp blast inputs climate data climate forecast analyze mips ibis triggered events raw events geometry configuration configuration cmkin mips mips cmsim cms problem solution initial state integral mips scf mips argos mips setup initial state intermediate states initial state coordinate files visualization physics mips nautilus bin coord mips mips rasmol nautilus inputs ice tables raw events standard events noisy events triggered events geometry physics corsika corama amasim kbmips mips mips mmc mips amanda figure application schematics schematics summarize structure application pipeline circles individual processes labeled instruction counts rounded boxes data private pipeline double boxes data shared pipelines batch arrows data flow blast searches genomic databases matching proteins nucleotides queries archived data include errors gaps acceptable match similarity parameterized exhaustive search single executable blastp reads query sequence searches shared database outputs matches ibis global-scale simulation earth systems ibis simulates effects human activity global environment global warming ibis performs simulation emits series snapshots global state cms high-energy physics experiment begin operation cms testing software two-stage pipeline stage cmkin random seed generates models behavior particles accelerated ring output set events fed cmsim simulates response detector final output represents events exceed triggering threshold detector messkit hartree-fock simulation non-relativistic interactions atomic nuclei electrons allowing computation properties bond strengths reaction energies distinct executables comprise calculation setup initializes data files input parameters argos computes writes integrals atomic configuration scf iteratively solves self-consistent field equations nautilus simulation molecular dynamics input configuration describes molecules threedimensional space newton equation solved particle incremental snapshots periodically capture particle coordinates final snapshot passed back program initial configuration simulation eventually snapshots converted standard format bin coord consolidated images rasmol amanda astrophysics experiment designed observe cosmic events gamma-ray bursts collecting resulting neutrinos interaction earth mass stage calibration software corsika simulates production neutrinos primary interaction creates showers muons corama translates 
output standard high-energy physics format mmc propagates muons earth ice introducing noise atmospheric sources finally amasim simulates response detector incident muons real millions instructions memory traffic application time integer float burst text data share ops seti seti blast blastp ibis ibis cms cmkin cmsim total setup argos scf total nautilus nautilus bin coord rasmol total amanda corsika corama mmc amasim total figure resources consumed shown total amounts resources consumed subsequent tables shading differentiate application pipelines real time refers total wall-clock time applications run instrumentation overhead burst average number instructions executed operations instruction counts obtained performance monitoring counters pmcs -class processors notice exception application pipelines modest bandwidth requirements total reads writes application files traffic unique static files traffic unique static files traffic unique static seti seti blast blastp ibis ibis cms cmkin cmsim total setup argos scf total nautilus nautilus bin coord rasmol total amanda corsika corama mmc amasim total figure volume shown total amounts performed traffic number bytes flow process unique considers unique byte ranges total traffic notice cms perform large proportions reread traffic indicating caching important static refers total size files accessed unique applications read portions files notice blast reads total data files accesses suggests systems prestage data sets performing unnecessary work appl open dup close read write seek stat seti blastp ibis cmkin cmsim total setup argos scf total nautilus bin coord rasmol total corsika corama mmc amasim total figure instruction mix shown total number type instructions executed applications seek column includes non-sequential access memory-mapped pages ignores lseek operations change file offset column sums number generally uncommon operations ioctl access high numbers column reflect fact bin coord rasmol driven shell scripts perform readdir operations notice applications high degrees random access shown ratio seeks reads writes contradicts previous file system studies dominance sequential endpoint pipeline batch appl files traffic unique static files traffic unique static files traffic unique static seti blastp ibis cmkin cmsim total setup argos scf total nautilus bin coord rasmol total corsika corama mmc amasim total figure roles shown total amounts type performed endpoint traffic consists initial inputs final outputs unique application pipeline traffic intermediate data passed pipeline stages intermediate data passed phases single stage batch traffic input data shared instances pipeline traffic number bytes flow process unique considers unique byte ranges total traffic static refers total size files accessed unique applications read portions files notice applications exception ibis endpoint traffic relative total traffic scalability systems run applications depend ability differentiate types hit rate blast ibis cms hit rate cache size cache size nautilus cache size amanda figure batch cache simulation hit rate blast ibis cms hit rate cache size cache size nautilus cache size amanda figure pipeline cache simulation figure details volume produced pipeline stage applications conceived pipeline multiple stages connected simple data streams makes complex read write file system number files accesses seti cms lesser degree blast read input data multiples times overwriting output data found pipelines exception amanda output over-writing update application-level checkpoints place alarmed observe checkpoints unsafely written directly existing data written file atomically replaced renaming pipelines distributed large collections data runs typical run accesses small portion common similar runs static size blast dataset exceeds unique amount read application distribution operations figure notice applications high degree random access shown ratio seeks reads writes results nature data files accessed programs generally complex self-referencing internal structure contradicts file system studies dominance sequential characterize types sharing batchpipelined workloads divided traffic roles endpoint traffic consists initial inputs final outputs unique pipeline read written central site system design pipeline traffic consists intermediate data passed pipeline stages intermediate data passed phases single stage batch traffic input data identical pipelines understanding application identified file accessed endpoint pipeline batch computed traffic performed category shown figure immediately comparatively traffic needed endpoints bulk pipeline batch depending application examining figures note large number opens issued relative number files accessed typically designed standalone workstations applications optimized realities distributed computing opening file access times expensive issuing read write figures show working set sizes batchshared pipeline-shared data workload values computed simulations performed trace data batch width varying lru cache size blocks executable files implicitly included batch-shared data general types sharing cache sizes small respect volume sizes typical main memories today outliers amanda large amount batch shared data half read cache effective large sizes amanda high pipeline hit rate ictcp-nice small requires cache access sizes due large internal number state ictcp singlebyte complete requests message due list high overview degree tcp nice re-reading output zero-cost overwriting background cms transfer small tcp cache nice sizes background flow effectively interferes maximize hit foreground rates flows blast reaps large pipeline fraction data spare ibis network bandwidth tcp stage nice pipeline appears data sixth form symposium checkpoints operating written systems design read multiple implementation times osdi figure similar shows tcp vegas applications additional relate components amdahl multiplicative window long reduction standing system response balance increasing ratios round-trip times recently amended ability reduce gray congestion window workloads cpu-io discuss ratios measured components mips mbps turn tcp exceeding nice amdahl halves ideal current congestion indicating window reliance long computation round-trip times measured ratio unlike memory vegas cpu speed reduces alpha window halves amdahl window packets lost determine window size halved tcp nice algorithm monitors round-trip delays estimates total queue size bottleneck router signals congestion estimated queue exception size exceeds component fraction amanda estimated maximum queue close capacity gray specifically tcp nice counts number reliance packets computation delay memory exceeds finally minrtt ratio maxrtt cpu minrtt instructions instructions fraction orders delayed magnitude packets larger round respect exceeds single instance pipeline tcp commodity nice computing signals node congestion engineered decreases amdahl metrics considerably window overprovisioned multiplicatively tcp bandwidth nice memory capacity window cpu mem cpu cpu effect appl mips mbps congestion mips window instr seti blastp ibis cmkin cmsim total setup argos scf total nautilus bin coord rasmol total tcp corsika nice adds corama timer waits mmc amasim number rtts total sending amdahl packets gray implementation implementation figure amdahl ictcp-nice ratios system similar implications ictcp-vegas workloads slightly potentially infinite complex problem ictcp-nice domains requires ability information harness packet computing power enables summary higher statistics resolution parameters x-ray ictcp-nice lower non-invasive obtains statistical exclusive full caching uncertainties message mechanism current list users raids sequence lakshmi applications number bairavasundaram seqno scale muthian round throughput sivathanu trip andrea time running usrtt hundreds arpaci-dusseau packet thousands remzi simultaneously arpaci-dusseau implementation computer windows scale sciences department applications tricky considered wisconsin-madison cpu-bound abstract raid vcwnd storage bound mechanism arrays considered case possess gigabytes aggregate window ram give idea ictcp-nice growing sets envelope vcwnd current scientific single computing rtt period spring cms periods pipeline evaluation demonstrate simulate million effectiveness events divided ictcp pipelined approach jobs replicate consuming cpu-years experiments producing terabyte original tcp output nice batch paper figures small fraction attempted results test show run ictcp-nice full performs production begins identically successive in-kernel yearly tcp workloads nice planned desired grow figure shows latency code foreground data connections published competes authoritative form background experiment connections central spare site capacity likewise network simulation varied outputs results eventually moved back ictcp-nice archival tcp nice storage section background connections explore latency general properties foreground computing connections storage systems order magnitude faster built satisfy tcp reno workloads background explore connections detailed algorithms desired ictcp-nice data tcp management nice perform similarly provisioning graphs figure show resources latency endpoint scalability foreground connections capacity throughput individual background computing connections nodes number ultimate background scalability connections workloads increases graph limited top competition shows shared resources background assume flows added workload document relies latency remains central site essentially constant authenticity ictcp-nice archival tcp input nice output data background flows demonstrated graph actual endpoint bottom shows traffic ictcp-nice small tcp fraction nice obtain total applications document latency eliminate sec number non-endpoint traffic background latency reno endpoint tcp server nice techniques caching ictcp-nice replication throughput number background significant throughput gains reno tcp scalability nice ictcp-nice traffic figure elimination ictcp-nice impact carried background flows carefully pipeline-shared graphs traffic correspond eliminated experiment graph shows end average user document latency intermediate data foreground traffic return graph shows debugging 
archival ability reproduce questionable batchshared eliminated constraints maintaining consistency authenticity potentially changing input data traffic elimination blindly consideration data computing system limits system executing workloads based ability eliminate shared traffic figure shows selected applications scale systems eliminating category traffic assume presence buffering structure sufficient completely overlap cpu figures assume mips cpu show cpu time horizontal lines show milestones bandwidth lower represents capable commodity hard disk upper represents aggressive storage server network leftmost graph shows scalability system carries traffic endpoint server discipline high end storage device needed systems modest size overwhelmed applications ibis seti scale batch-shared traffic eliminated make significant improvements cms nautilus shown graph hand pipelineshared traffic eliminated observe significant gains seti nautilus shown endpoint performed reach limit shown rightmost graph applications shown scale workers modest storage high-end storage seti potentially scale million cpus indicator specialized design wide-area deployment valuable caching number disk bytes blocks background flows manage raid systems transfer lru lru-like policies manage caches array caches recognize presence system buffer minutes caches period redundantly line retain corresponds limits blocks protocol workload background cached scalability flows cpu system tcp hardware reno wasting improve precious ictcp-nice performance cache tcp space nice time number limits paper space background prevent flows introduce x-ray varied exclusive x-axis raid detailed array bottleneck discussion caching link mechanism found x-ray bandwidth achieves technical set high kbps degree report delay perfect exclusivity experimental setup gray-box identical methods figure observing throughput les number accessed flows rate increases batch updates desired width system ictcp-nice meta-data x-ray tcp batch nice constructs width achieve approximate similar image batch results contents width iccm storage center show system cache commodity important disk components information determine congestion manager exclusive set blocks built ictcp cached main contribution array study microbenchmarks rate show batch demonstrate width information blast x-ray cms prediction shared amanda nautilus system ictcp ibis buffer setiathome cache contents data highly endpoint accurate pipeline trace-based endpoint simulation batch show endpoint x-ray figure considerably scalability outperforms lru roles performs graphs show invasive approaches scalability main strength applications x-ray improved approach easy orders deploy magnitude performance batch-shared gains pipeline-shared achieved flows scsi multiple protocol ictcp flows system sender introduction cooperate modern systems overview comprised congestion manager multiple levels architecture caching motivated processor types level problematic behavior rest exhibited emerging storage applications hierarchy applications hierarchy employ performance multiple concurrent flows secondlevel caches sender receiver important flows important compete data sets performed resources prove rst-level endpoint overly server aggressive caches increase horizontal share lines effectiveness show network milestones information second-level caches bandwidth previous work upper applications processor caching represents udp-based introduced high-end flows storage concept sound center congestion exclusive control lower caching adapt avoiding represents changing duplication current network commodity data conditions disk addresses software levels architecture problems memory order inserting hierarchy scale module large effective sizes amount software architectures sender cache real estate workloads receiver increased strive layer potentially eliminate improving batch-shared appears pipeline-shared sixth data symposium endpoint operating interactions systems design performance exclusivity implementation constraints osdi security studied maintains persistence network levels statistics performance traditional flows storage file orchestrates hierarchy systems data transmissions serve including distributed applications hybrid congestion naming systems control algorithm consistency storage arrays obtains requirements feedback raids targeted problem interactive receiver inclusion cooperating implementation users primary applications importance difference require modern iccm data storage management systems system location iccm specialized built built requirements two-level top workload hierarchy analysis ictcp failure layer system recovery top resource rst top management level iccm issue storage leverages array batch input congestion multiple sharing control disks algorithm beneath received significant statistics rst-level attention cache present grid managed tcp computing iccm operating community system considerably deployed simpler systems implement implements srb lru-based gdmp iccm replacement guarantees policy manage widely-distributed storage array congestion well-known control batch hardware algorithm shared manages data stable memory techniques friendly existing discovering memory tcp serves traffic replicating second-level batchshared iccm cache data approach managed lru drawback proposed fashion non-cooperative diminishing worsening applications importance problem bypass batch iccm fact sharing submit hosts tcp disk directly issue arrays pipeline iccm sharing caches guarantee similar fairness size problem high-end disk flows arrays neglected gigabytes aware memory figure iccm shows run architecture localization running similarly con types sending gured endpoint hosts cache achieve components high iccm exclusion scalability clients cache treatment space individual pipelineshared storage flow data arrays necessarily iccm wasted server previous storage research batch component shared addressed data receiving problem endpoint iccm writer ways server approach roles reader change identify macroflows discarded second-level pipeline-shared flows policy outputs incorporate require endpoint access facility characteristics discovery destination frequency reader track make data replacement aggregate statistics decisions advertised approach avoids macroflow degree cache inclusion batch-shared identify data policies macroflows loss client carefully pipeline-shared flow tailored output registers work require beneath process re-execution lru cache previous destination speci computation address stage workloads iccm solutions server pipeline track workloads statistics batch sharing highly-specialized client problems schemes flow require periodically function obtains application desired network classified state approach ictcp change roles number interface degree outstanding systems accuracy bytes custom snd storage nxt applications snd wong una seti shares wilkes succeeded propose state wide scalability scsi iccm command virtue server demote manual iccm moves server division block periodically endpoint updates cache directly statistics explicit network raid macroflow communication sums expect outstanding bytes valuable flow applications macroflow re-written client flow distributed environment obtain ideally aggregate statistics roles macroflow detected time automatically intervals implement approach bandwidth sharing clients trec system macroflow deduces client program calculates dependencies window cache limit enabling number outstanding manage bytes array specifically cache explicitly iccm client lru obtains discipline server number approach flows readily macroflow deployed total number inducing outstanding instruction-set bytes change flow processor level statistics dif cult client calculates leads number researchers behavior bytes focus send micro-architectural obtain innovations user fair provide share hints changing systems roles bandwidth system client interface modifying tcp systems applications transport storage directly number simply scsi file sets systems result vcwnd account ictcp storage vendors number conventional wisdom iccm implement quickly-deleted clients data mechanism macroflow significant source traffic general-purpose workload recognition limited application due requirements reliability consistency interactive systems nfs permits delay application writes data movement server delay made minutes hours order accommodate pipeline sharing reduction unnecessary writes accompanied increased danger data loss crash unusual consistency semantics session semantics afs worse closing file blocking operation forces write-back dirty data vertically shared data written back numerous close operations cpu held idle pipelines offering possibility cpu-i overlap general-purpose file systems operate assumption data eventually flow back archival site workloads require opposite assumption created data remain created explicit operation writer system user forces archival storage improves overlap eliminates unnecessary writes increases danger operations waiting written back fail due permissions disconnection sources error distributed file system acceptable batch system long failed detected matched process issued force re-execution job suggest problem attacked coupling workflow manager condor dagman globus chimera tracks dependencies general graphs jobs systems activity presumed reliable centralized side effect execution creation positioning pipeline-shared data integrated workflow data efficiently shared maintaining possibility error recovery related work cpu memory communication characteristics applications studied years research community roughly categorized type workloads generalpurpose workloads applications sequential applications examined isolation parallel applications isolation summarize work categories focusing examined file system activity file system activity examined range general-purpose workloads studies greatly influenced file system design years focused academic research workloads studies found files short lifetimes access patterns exhibit high degree locality read-write sharing rare missing broad studies traffic linkage applications generate traffic similar work studies focused behavior individual applications commercial workloads domain interaction pipeline behavior sequential applications examined interesting study detailed memory-system behavior applications opportunities sharing fundamentally studies parallel applications ways similar pipelined batch applications cpu memory communication behavior parallel vector applications quantified number studies impact explicit compete study complements works scheduler share bandwidth evenly evaluation demonstrate effectiveness ictcp build congestion manager replicating experiments performed figure experiments shown figure place flows macroflow shown graph tcp reno flows macroflow share bandwidth fairly performance connections varies standard deviation contrast shown graph iccm flows macroflow connections progress similar consistent rates iccm flows achieve throughputs sequence number time seconds reno sequence number time seconds iccm figure iccm fairness graphs compare performance concurrent transfers sender receiver bottleneck link set delay graph stock reno graph iccm manages tcp flows roughly standard deviation ictcp-rr tcp fast retransmit optimization fairly sensitive presence duplicate acknowledgments specifically tcp detects duplicate acks arrived assumes loss occurred triggers retransmission recent research packet reordering common internet earlier designers suspected frequent reordering occurs tcp sender receives rash duplicate acks wrongly concludes loss occurred result segments unnecessarily retransmitted wasting bandwidth congestion window needlessly reduced lowering client performance overview 
number solutions handling duplicate acknowledgments suggested literature high level algorithms detect presence reordering dsack increase duplicate threshold dupthresh avoid triggering fast retransmit base implementation blanton allman work limits maximum dupthresh window appears sixth symposium operating systems design implementation osdi false fast retransmits packet delay rate false fast retransmits linux linux dsack ictcp-rr throughput packet delay rate throughput linux dsack ictcp-rr linux figure avoiding false retransmissions ictcp-rr top number false retransmissions bottom throughput vary fraction packets delayed reordered modified nistnet router compare implementations text experimental setup includes single sender receiver bottleneck link set delay nistnet router runs router introducing distributed packet delay standard deviation size timeout occurs sets dupthresh back original implementation user-level library implementation ictcp-rr straight-forward library history acks received list larger kernel exported ack list kernel aggressive pruning size losing potentially valuable information dsack arrives ictcp places sequence number falsely retransmitted packet ack list library consults ack history frequently occurrences found library searches past history measure reordering length sets dupthresh evaluation figure shows effects packet reordering compare implementations stock linux dsack enhancement linux dsack reordering avoidance built kernel user-level ictcp-rr implementation graph show number false fast retransmisretransmitted packets loss rate retransmissions ictcp-efr reno reno ictcp-efr throughput loss rate throughput ictcp-efr reno figure aggressive fast retransmits ictcp-efr top number retransmitted packets reno ictcp-efr due retransmission timeouts fast retransmits bottom achieved bandwidth x-axis vary loss rate mimic wireless lan single sender single receiver bottleneck link set delay sions occur false retransmission caused reordering stock kernel issues false retransmits incorrectly believes reordering actual packet loss graph observe resulting bandwidth dsack in-kernel ictcp-rr versions perform essentially ignoring duplicate acks achieving higher bandwidth ictcp-efr previous case study showed increasing dupthresh contrast environments wireless lans loss common duplicate acks strong signal packet loss window size small case opposite solution desired dupthresh lowered invoking fast retransmit aggressively avoid costly retransmission timeouts overview discuss ictcp-efr user-level library implementation efr efficient fast retransmit observation underlying efr simple appears sixth symposium operating systems design implementation osdi rto sec time eifel rto ictcp user-level karn-patridge ul-kp ul-kp lines spike fixed ictcp-eifel measured rtt rto time self-trained eifel rto rto measured rtt figure adjusting rto ictcp-eifel graph top shows versions ictcp-eifel experiment measured round-trip time identical calculated rto differs line shows karn-partridge rto algorithm disabled kernel implemented user-level ictcp experiment remove lines tcp code added fix rto spike show fix easily provided user-level experiment implement full eifel rto algorithm user-level experiments emulate bandwidth kbps delay queue size graph bottom shows full adaptive eifel rto algorithm bandwidth kbps delay queue size sender adjust dupthresh match number duplicate acks receive implementation ictcp-efr implementation straightforward simplicity modify dupthresh window small efr scheme relevant window small library frequently checks message list duplicate acks sees computes sets dupthresh evaluation figure shows behavior ictcpefr versus in-kernel reno function loss rate emulated wireless network ictcp-efr interprets duplicate acknowledgments signs loss number fast retransmits increases shown graph top importantly number costly retransmission timeouts reduced graph bottom shows bandwidth increases result ictcp-eifel retransmission timeout rto determines time elapse packet sender considers lost retransmits rto prediction upper limit measured round-trip time mrtt correctly setting rto greatly influence performance overly aggressive rto remaining expire challenge prematurely forcing storage unnecessary array spurious cache design retransmission derive overly-conservative second-level rto caching scheme long idle lru-based times lost work packets retransmitted workloads overview eifel rto corrects require problems change interface traditional karn-partridge systems rto storage immediately broadly mrtt deployable decreases rto paper incorrectly introduce increased x-ray exclusive array period cache time array caching scheme rto designed decay meet correct goals primary magic dif culty numbers building rto calculation exclusive assume lru-based low raid cache mrtt sampling changing rate interface sender load storage assumptions incorrect system rto activity incorrectly collapses observed mrtt raid implementation reads implemented eifel cached rto algorithm pages user-level raid library ictcp-eifel fuzzy picture library contents access ictcp cache appropriately adjust contents information catalog direct system configuring storage devices variables mrtt ssthresh cwnd submitting batch mrtt jobs calculates gray shapes values elements srtt smoothed round-trip design rttvar white round-trip variance standard components ictcp-eifel found library operates batch systems wakes area sharing acknowledgment arrives duplicating polls ictcp data remote mrtt mrtt cluster changed explicit calculates knowledge rto sharing sets characteristics ictcp permits library system requires safe dispense control rto expense evaluation complexity consistency graph checks figure allowing shows nodes continue progression executing improvements disconnected architecture ictcp-eifel section experiments present approximately architecture match implementation bad-fs recall eifel main rto goal paper design bad-fs figure export sufficient control remote implementation scheduler disable deliver karn-partridge improved rto performance algorithm fault-handling kernel o-intensive batch implement workloads run ictcp-eifel expected version incorrectly increases rto mrtt remote decreases clusters figure implementation summarizes corrects problem architecture bad-fs additional lines code elements user-level shaded gray rto bad-fs eventually structured collapses mrtt finally types server version processes manage ictcp-eifel local adjusts resources rto compute server exports conservative ability transfer avoids execute spurious retransmissions graph figure similar figure ordinary eifel user paper program shows remote cpu implemented storage server full eifel rto algorithm exports user-level access disk algorithm memory rto resources increasingly remote aggressive procedure calls spurious resemble timeout standard occurs file system point operations backs permits remote conservative users allocate space summary case abstraction studies called volumes number interposition strengths agents bind ictcp unmodified approach workloads running ictcp easily compute enables servers tcp variants storage servers aggressive types reno servers periodically implemented report simply efficiently catalog user-level server tcp summarizes vegas tcp current nice state system scheduler push periodically examines kernel state ictcp catalog ideally considers appears work sixth symposium operating assigns systems jobs design compute implementation servers osdi data suited storage servers scheduler obtain tuning data parameters executables optimal values inputs depend number environment external storage workload sites simplicity dupthresh assume ictcp user correcting data errors stored parameter values single home storage behavior server rto case standard studies ftp illustrated server limitations ictcp iccm assemble framework shares information flows information shared flows voluntarily perspective congestion state learned scheduler compute previous flows storage servers directly inherited logically independent flows specialized limitation device arises run ictcp reliance type inkernel server tcp process stack diskless forcibly workstation runs compute server storage appliance runs storage server typical workstation cluster node computing disk resources runs bad-fs run environment multiple owners high failure rate addition usual network system errors bad-fs prepared eviction failures shared resources revoked warning rapid rate change systems creates possibly stale information catalog bad-fs prepared discover servers attempts harness longer bad-fs makes standard components compute servers condor startd processes storage servers modified nest storage appliances interposition agents parrot agents catalog condor matchmaker servers advertise catalog classad resource description language storage servers storage servers responsible exporting raw storage remote sites manner efficient management remote schedulers storage server fixed policy managing space makes policies accessible external users carve space caching buffering tasks fit abstraction called volumes storage servers users allocate space lifetime type specifies policy internally manage space bad-fs storage server exports distinct volume types scratch volumes cache volumes scratch volume self-contained read-write file system typically localize access temporary data scheduler scratch volumes pipeline data passed jobs buffer endpoint output scratch volumes scheduler minimizes home server traffic localizing pipeline writing endpoint data pipeline successfully completes cache volume read-only view home server created home server path caching policy lru mru maximum storage size multiple cache volumes bound cooperative cache volume catalog server storage servers query discover peers number algorithms exist managing cooperative cache intent explore range algorithms describe reasonable algorithm system explain scheduler cooperative cache built distributed hash table keys table block addresses values server primarily responsiappears usenix symposium networked systems design implementation nsdi ble block avoid wide-area traffic primary server fetch block home server servers create secondary copies primary space needed secondary data evicted primary approximate locality initial implementation forms cooperative caches peers subnetwork initial analysis suggests sufficient future plan investigating complicated grouping algorithms failures cooperative cache including partitions easily managed slowdown cooperative cache internally partitioned primary blocks assigned missing peers reassigned long home server accessible partitioned cooperative caches refetch lost data continue noticeable disturbance running jobs approach cooperative caching important differences previous work data dependencies completely scheduler implement cache consistency scheme read data considered current scheduler invalidates volume design decision greatly simplifies implementation previous work demonstrated difficulties building general cooperative caching scheme unlike previous cooperative caching schemes manage cluster memory cooperative cache stores data local disks managing memory caches cooperatively advantageous important optimization make environment avoid data movement wide-area managing remote disk caches simplest effective local global control note volumes export degree control scheduler creating deleting volumes scheduler controls data sets reside remote cluster storage servers retain control per-block decisions important decisions made locally storage servers assignment primary blocks cooperative cache cache victim selection scheduler careful space allocation cache victimize blocks longer needed general found separation global local control suitable workloads work precisely identify balance point clear trade-off extreme complete local control current approach suffers policies embedded distributed file systems inappropriate batch workloads extreme complete global control scheduler makes decisions block data require exorbitant complexity scheduler incur excessive network traffic exert fine-grained control interposition agents order permit ordinary workloads make storage servers interposition agent transforms posix operations storage server calls 
agent mapping logical path names physical storage volumes provided scheduler runtime agent volume abstraction hide large number errors job end user volume longer exists due accidental failure deliberate preemption storage server returns unique volume lost error agent discovering agent forcibly terminates job indicating run correctly environment scheduler clear indication failures transparent recovery actions scheduler bad-fs scheduler directs execution workload compute storage servers combining static workload description dynamic knowledge system state specifically scheduler minimizes traffic wide-area differentiating types treating appropriately carefully managing remote storage avoid thrashing replicating output data proactively data expensive regenerate workflow language shown figure declarative workflow language describes batch-pipelined workload shows scheduler converts description execution plan keyword job names job binds description file specifies information needed execute job parent ordering jobs volume keyword names data sources required workload volume ftp server volumes empty scratch volumes volume sizes provided scheduler allocate space appropriately themountkeyword binds volume job namespace jobs access volume mydata jobs share volume path tmp extract command files interest committed home server case pipeline produces file retrieved uniquely renamed readers accustomed working interactive environment language unusual burden point user intending execute batch-pipelined workloads exceptionally organized batch users provide information scattered shell scripts make files batch submission files addition imparting needed information bad-fs scheduler workflow language reduces user burden collecting dispersed information coherent appears usenix symposium networked systems design implementation nsdi job condor job condor set starting congestion state implementing extensions evaluate ability ictcp implement wider range tcp extensions list discussed stp job extensions standardized condor job linux condor parent sack child dsack fack tcp parent child high performance ecn volume ftp home reno syn cookies data implemented volume ictcp scratch rr-tcp volume vegas scratch nice discuss mount challenges mydata mount implementing mydata remaining mount extensions place tmp mount extensions tmp categories mount introduce tmp mount algorithms existing tmp variables extract ftp modify home packet extract format modify ftp tcp algorithm home structure joba jobb mechanisms mount existing extract extract mount mount volume variables volume classify mount mount jobc extensions mount changing volume behavior job home existing storage variables data byte counting agent abc job tcp scheduler catalog westwood home equation-based storage tcp execute tfrc cleanup submit recently compute proposed server tcp query extensions extract fall configure storage category server include fast tcp figure limited workflow slow-start scheduler examples highspeed tcp simple workflow extensions script directed graph natural jobs match constructed ictcp job implemented parent extent file system namespace aggressive presented tcp jobs reno configured equationbased volume tcp specifies mount congestion extract window keyword increase decrease files gradually committed reno ictcpeqn home storage cwnd server increase pipeline gradually completion desired graphical forces representation cwnd decrease workflow usual scheduler reno plan rate job conservative scheduler implementations queries catalog extensions current beneficial system state abc decides implemented place ictcp job aggressively increase data cwnd scheduler creates receiver volumes delays ack storage ictcp-abc server job correct ack dispatched division compute case server job highspeed tcp executes accessing extension volumes supported agent jobs manner complete strictly scheduler aggressive extracts cwnd scheduler frees decreased volumes smaller amount scoping tcp unlike reno file systems badfs issue aware arises flow data extensions workflow language ictcp enforces scheduler tcp data friendliness originates ictcp constrains needed tcp virtual variable safe range overly conservative ictcp small increases tcp initial congestion window long time period flows generally considered tcp friendly alternatively create stp customized separate environment module enforce job tcp minimize friendliness traffic module home monitors server sending refer scoping scoping minimizes traffic ways cooperative cache rate volumes verifies hold read-only batch data upper-bound determined figure state volumes connection reused packet modification size large loss number event jobs rate round-trip scratch time volumes retransmission timeout figure ictcp localize similar pipeline modular data approach job executes accesses equation-based enforcer volumes important explicitly drawback created non-conforming flows home server terminated accessed packets batch buffered data bounded size pipeline consistency tcp-friendly management rate workload terminate information flows expressed ictcp naturally workflow modulates language agressive scheduler flows neatly addresses manner issue efficient consistency space management time packet required format dependencies classify jobs data extensions changing 
directly scheduler format runs jobs contents packets meet constraints extensions put implement bits cache consistency tcp protocol reserved field bad-fs storage eifel servers algorithm user robust make congestion mistakes signaling workflow extensions description implemented affect easily cache ictcp consistency current correct form failure recovery compelling understanding expand ictcp expected workload behavior variables packet user header scheduler set easily detect difficult mistakes ensure warn safely approximate behavior encapsulating user results workload compromised implemented detection features architecture readily admits extra capacity-aware information scheduling application scheduler data responsible requiring throttling running sender workload receiver avoid performance ictcp-enabled faults kernel maximize throughput library carefully technique allocating volumes extra information scheduler avoids passed overflowing protocol storage stacks thrashing caches remaining transparent disk capacity applications rapidly increasing technique size implemented data functionality sets similar growing space dccp management remains important implementation scheduler user-level manages library space retrieving transmits packets list udp obtains storage network information ictcp flow sender receiver investigating approach detail structure mechanism approximately extensions modify fundamental aspects tcp algorithm extensions follow existing tcp states tcp limited transmit define mechanisms sctp checksum extensions deviate substantially base tcp reno algorithm ictcp implement catalog server behavior selecting approach ready job addressing limitation unfulfilled storage modifying packet pipe headers batch ictcp scheduler provide allocate control underneath job kernel stack volumes packet allocates configures filter volumes users schedules exert job control packets jobs execute changing timing ordering space altogether scheduler suppressing waits duplicating job subset complete packets resources pass arrive filter failure occur control note due meted lack caution complete global ensuring control remain scheduler tcp friendly slightly central overprovision challenge summary needed ictcp volume size approaches powerful storage stp capacity scheduling implement domains smaller selecting range smallest tcp job extensions appears result starvation sixth symposium domain operating starvation systems design avoided implementation workflow static entity executed osdi scheduler throughput smaller kbps jobs packet delay run rate composing jobs ictcp-rr eventually ictcp-vegas run ictcp-rr failure ictcp-vegas handling ictcp-rr finally ictcp-vegas scheduler reno makes figure bad-fs composing robust ictcp-vegas failures handling ictcp-rr failures figure jobs shows storage servers strength catalog composing multiple ictcp aspect libraries batch workloads environment reordering leverage occurs job idempotency job space simply rerun bottleneck order queue regenerate low output libraries scheduler log time allocations persistent storage environment throughput transactional higher interface compared compute storage servers libraries scheduler fails experimental setup allocated includes volumes single sender running jobs receiver continue bottleneck operate queue size unappears set usenix link symposium set networked systems design delay implementation nistnet nsdi router aided runs scheduler recovers router simply introducing re-reads log discover distributed packet resources delay allocated resumes normal operations standard recording deviation allocations persistently x-axis vary re-discovered percentage released delayed timely manner packets log irretrievably lost simplicity providing workflow ictcp resumed layer real beginning system previously outweigh acquired leases drawback ease eventually expire development contrast catalog final server question soft address state complexity catalog ictcp discover framework resources develop tcp extensions recover answer state question crash showing catalog ease unavailable user-level scheduler libraries continue ictcp operate combined resources perform functionality discover directly compare catalog server complexity recovers building rebuilds tcp extensions knowledge user-level compute storage servers send periodic updates scheduler waits passive indications failure compute storage servers conducts active probes verify job exits abnormally error indicating failure detected building directly kernel ictcp framework enables functional composition user-level library exports interface ictcp library services stacked build powerful functionality interposition simplest agent case stacked scheduler libraries suspects control disjoint storage sets servers ictcp housing variables volumes assigned ictcp-vegas job ictcp-rr libaries faulty scheduler stacked probes combination servers controls volumes values healthy cwnd assumes dupthresh job figure encountered shows transient advantage communication problems stacking simply reruns libraries flows running volumes environment failed packet unreachable reordering period small time bottleneck queues assumed exhibit lost higher throughput failure volume libraries affects jobs libary alternatively design simplification stacked libaries scheduler considers control partial overlapping volume sets failure ictcp variables failure case entire volume layer future constrains plan range investigate safe trade-offs values involved virtual choice variable quantify failure complexity granularities running building jobs functionality rely failed top volume ictcp stopped addition kernel failures count cascade completed number processes wrote statements volume implementation rolled back number re-run order semicolons avoid removing expensive restarts pipeline printing scheduler debugging checkpoint scratch table volumes shows pipeline stages number complete case study determining ictcp native ictcp-vegas optimal ictcp-nice checkpoint interval iccm ictcp-rr problem table solution ease depends development likelihood ictcp failure table reports number checkpoint statements cost counted create unlike number systems semicolons bad-fs needed solve implement problem case automatically studies ictcp scheduler compared unique native position measure implementation native vegas controlling implementation variables count scheduler performs entire patch simple cost-benefit analysis linux runtime tcp determine nice count checkpoint statements worthwhile changing algorithm works core transport layer scheduler algorithm tracks average time quantifying replicate number needed scratch statements volume complicated cost fact initially assumed authors provide complete order linux kernel trigger modifications distributed replication count measurement determine transport layer benefit replication comparison scheduler tracks fair number job storage failures computes functionality mean-time-to-failure iccm count number lines devices linux system calculate benefit amount replicating reordering volume in-kernel sum sack run dsack times jobs ictcp-rr completed traverses ack applicable list pipeline multiplied statements required probability case failure studies benefit exceeds implementations vegas cost nice scheduler comparing replicates ictcp user-level volume libraries native implementations number statements storage server insurance comparable conclude failure developing original services fails ictcp scheduler restarts complex pipeline building saved natively copy due advantage robust failure debugging semantics analysis scheduler performed handle user-level network partitions conclusions differently presented design failures implementation partitions ictcp slightly formed modified version scheduler linux tcp compute servers exposes information scheduler control choose applications reschedule jobs userlevel libraries running evaluated side ictcp partition axes situation findings partition converting tcp resolved stack ictcp point requires small amount additional code scheduler determining find precisely multiple limited servers virtual parameters executing place jobs note original tcp parameters introduce nontrivial errors exercise ictcp ten internal tcp variables safely set user-level processes values chosen user resulting flow tcp friendly ictcp incurs minimal additional job cpu overhead writes relative distinct in-kernel scratch implementations volumes long scheduler ictcp choose polled output excessively extract information discard reduce overhead practical ictcp issues processes primary block obstacles deploying acknowledgment arrives distributed end system round fourth friendly ictcp enables administrator range deploying tcp operating extensions system file implemented system user-level batch system found vast ictcp majority framework software suited requires extensions implement congestion control algorithms aggressive reno adjusting parameters match privileged workload user environment install conditions oversee support software radical tcp requirements extensions make ictcp forms distributed computing developed practical impossibility allowing larger tcp headers powerful safely set facility packets difficult acknowledgments ordinary reordered user delayed obtain administrative finally privileges developing tcp end extensions bad-fs appears packaged sixth virtual symposium batch system operating systems design deployed implementation existing batch osdi system top special ictcp privileges complex technique patterned implementing directly glide-in job kernel frey easier debug similar spirit exposing information recursive virtual control machines layers run bad-fs 
network ordinary user submit jobs existing batch system bad-fs bootstraps systems relying basic ability queue run self-extracting executable program storage compute servers interposition agent deployed servers report catalog server scheduler harness resources note scheduling virtual batch jobs discretion host system jobs interleaved time space jobs submitted users technique deploy badfs existing condor pbs batch systems practical issue security bad-fs grid security infrastructure gsi public key system delegates authority remote processes time-limited proxy certificates bootstrap system submitting user enter password unlock private key home node generate proxy certificate user-settable timeout proxy certificate delegated remote system storage servers authenticate back home storage server requires users trust host system steal secrets reasonable environment appears usenix symposium networked systems design implementation nsdi pipebatch mixed home traffic traffic remote pipe-local caching bad-fs pipebatch mixed runtime runtime figure scoping traffic reduction run times graphs show total amount network traffic generated runtimes number workloads optimizations enabled experiment run synthetic pipelines depth generates total x-axis vary relative amounts batch pipeline batch workload generates batch pipeline common types workloads amount endpoint small leftmost graph shows total amount home server traffic shows total runtimes home server accessed emulated wide-area network set stack experimental evaluation section present experimental evaluation similarity bad-fs tcp variety workloads sctp present sctp methodology extended focus straight-forward manner scoping capacity-aware icsctp scheduling icsctp failure framework handling user-level synthetic libraries workloads understand deal system behavior problems spurious present retransmission experience running implement real functionality workloads network system failure detection controlled environment recovery finally discuss conclusion initial experience ictcp bad-fs run powerful real workloads proposals multiple extending clusters tcp wild networking methodology protocols initial experiments advantage section ictcp build simplicity environment similar pragmatism easy section implement assume ictcp user flows input built data ictcp stored remain tcp home friendly server computational pipelines overheads run reasonable output data safely stored systems back ictcp home server practice workload considered theory complete reap assume benefits workload userlevel run tcp remote extensions cluster acknowledgments machines experiments accessible paper user performed home server exclusively wide-area netbed link network emulate emulation environment scenario limit utah bandwidth greatly home indebted server robert ticci tim simple stack network leigh delay stoller engine kirk similar webb dummynet jay lepreau providing remotely run jobs superb environment home server traverse slow link cluster dedicated compute pool condor nodes wisconsin connected mbit ethernet switch node pentiumprocessors physical memory ibm scsi drive partition networking made research condor jobs nitin partitions typically agrawal lakshmi half bairavasundaram nathan burnett time vijayan rest prabhakaran awaits lazy muthian garbage sivathanu collection explore helpful performance discussions bad-fs comments range workload paper scenarios utilize parameterized jeffrey synthetic mogul batch-pipelined workload excellent synthetic shepherding workload substantially configured improved perform varying content amounts presentation endpoint batch pipeline paper finally compute lengths anonymous reviewers time exhibit helpful amounts suggestions work batch sponsored pipeline nsf parallelism experiment ccrccr- requires parameters ccrngs- leave itritr- descriptions ibm emc individual figure captions wisconsin alumni research previous foundation results workload abbott analysis focus peterson batch-intensive language-based workloads approach exhibit protocol high degree implementation ieee batch acm sharing transactions pipeline endpoint networking feb pipeintensive allman perform tcp large congestion amounts control pipeline byte generate counting batch rfc endpoint feb allman scoping results balakrishnan floyd experiment enhancing shown tcp loss figure recovery demonstrate limited bad-fs transmit scoping jan minimize traffic rfc wide allman area floyd localizing pipeline patridge scratch volumes increasing reusing tcp batch initial data window cooperative rfc cache volumes internet engineering optimizations task straightforward force allman ability paxson increase throughput significant stevens tcp congestion experiment control repeatedly rfc run internet engineering synthetic task workload force vary apr relative amount armando batch caro pipeline iyengar compare amer number ladha system gerard configurations heinz remote shah configuration sctp proposed standard home robust node internet data baseline transport compare ieee pipeline computer localization november caching optimizations arpaci-dusseau finally optimizations arpaci-dusseau combined bad-fs burnett configuration note denehy engle experiments assume gunawi copious cache nugent space controlled popovici environment transforming capacity-aware scheduling failure recovery policies needed left-hand mechanisms graph shows total infokernel transferred sosp wide-area balakrishnan network rahul surprisingly cooperative seshan cache greatly integrated reduces congestion batch traffic management architecture home node internet ensuring hosts sigcomm batch data pages set bellardo retrieved savage cache measuring packet reordering pipeline proceedings localization optimizations acm work usenix expected internet removing measurement pipeline workshop marseille france home server nov finally biagioni structured tcp optimization standard isolation proceedings sufficient sigcomm bad-fs pages configuration london united combines kingdom aug minimize network blanton traffic allman entire making workload tcp range robust right-hand packet graph reordering figure acm shows computer runtimes communication workloads review emulated remote jan cluster blanton graph direct impact wide-area traffic allman runtime tcp capacity-aware dsacks scheduling sctp duplicate examine tsns benefits detect spurious explicit storage retransmissions management rfc internet previous engineering experiments task force run february environment braden storage tcp tcp extensions transactions capacity rfc internet increasing engineering size task batch data force sets brakmo storage sharing malley jobs users peterson tcp scheduler vegas carefully techniques manage remote congestion space detection avoid avoidance wide-area thrashing proceedings experiments sigcomm compare pages capacity-aware london bad-fs scheduler united kingdom simple variants aug depth-first scheduler cardwell breadth-first bak scheduler tcp algorithms vegas aware implementation data linux http workload flophouse appears neal usenix linux-vegas symposium carson networked systems santay design nist network implementation emulation nsdi runtime tool hours snad batch ncsl intensive nist dfs gov bfs nistnet january bad-fs cheng normalized jin home traffic batch low fast data tcp total coop motivation cache architecture dfs bfs algorithms bad-fs performance figure batch-intensive explicit infocom storage management dunigan graphs mathis show benefits tierney explicit tcp storage tuning management daemon batchintensive workload nov workload edwards consists -stage muir pipelines experiences implementing stage high-performance process tcp streams user-space shared batch sigcomm file pages cambridge batch massachusetts files total aug batch file ely size varied savage percentage wetherall total alpine amount user-level cooperative cache infrastructure space network protocol nodes development experiment proceedings amounts usenix symposium negligible internet nodes local technologies storage systems usits portion pages cache total cache size set x-axis san reflects francisco observations california storage mar condor ely pool spring base decisions wetherall solely job savage robust congestion signaling icnp nov fiuczynski bershad extensible protocol architecture application-specific networking proceedings usenix annual technical conference usenix san diego california jan floyd reno modification tcp fast 
recovery algorithm rfc internet engineering task force floyd highspeed tcp large congestion windows rfc internet engineering task force floyd limited slow-start tcp large congestion windows rfc internet engineering task force floyd handley padhye widmer equationbased congestion control unicast applications proceedings sigcomm pages stockholm sweden aug floyd mahdavi mathis podolsky extension selective acknowledgment sack option tcp rfc internet engineering task force ganger engler kaashoek briceno hunt pinckney fast flexible application-level networking exokernel systems acm tocs feb appears sixth symposium operating systems design implementation osdi isi usc transmission control protocol rfc sept jacobson studying sharing behavior important class workload studies demonstrate drastic differences behavior parallel applications compared general-purpose workloads parallel scientific workloads high bursty rates constant behavior runs input parameters parallel workloads tend dominated storage retrieval costs large files check-point files finally quick deletion uncommon conclusions applications run isolation production settings scripting workflow tools glue series applications pipelines pipeline run thousands times varied inputs achieve goals users term workloads batch-pipelined batches pipelines run instant paper characterize collection scientific batch-pipelined workloads typical characterizations processing memory demands bring sharing characteristics workloads demonstrate importance scalability key managing workloads classification segregating traffic type aggressively exploiting sharing characteristics scalability improved orders magnitude acknowledgements gratefully acknowledge people helped install operate understand applications behavior including paolo desiati zach miller amadeu sum juan pablo jon foley dierk polzin daniel reed alan smet brian forney muthian sivathanu florentina popovici timothy denehy helpful discussion comments paper work sponsored nsf ccrccr- ccrngs- itran ibm faculty award wisconsin alumni research foundation douglas thain supported lawrence landweber ncr fellowship distributed systems acharya uysal bennett mendelson beynon hollingsworth saltz sussman tuning performance intensive parallel applications proceedings fourth workshop input output parallel distributed systems iopads pages philadelphia pennsylvania altschul madden schaffer zhang zhang miller lipman gapped blast psi-blast generation protein database search programs nucleic acids research pages amdahl storage parameters system potential ieee computer group conference pages june baker hartmann kupfer shirriff ousterhout measurements distributed file system proceedings acm symposium operating systems principles sosp july barroso gharachorloo bugnion memory system characterization commercial workloads proceedings international symposium computer architecture isca pages cantin hill cache performance selected spec cpu benchmarks computer architecture news september crandall aydt chien reed input output characteristics scalable parallel applications proceedings ieee acm conference supercomputing san diego california cypher konstantinidou messina architectural requirements parallel scientific applications explicit communication proceedings annual international symposium computer architecture pages san diego california acm sigarch ieee computer society tcca computer architecture news foley integrated structure biosphere model land workflow surface depth-first processes simply terrestrial assigns carbon single balance pipeline cpu runs jobs pipeline completion starting conversely breadth-first attempts execute jobs batch completion descending horizontal batch slice correct types workloads lead poor storage allocations depth-first vegetation scheduling dynamics global batch-intensive biogeochemical workload thrashing cycles foster attempts voeckler 
simultaneously wilde zhou chimera virtual data system representing querying cache automating data derivation proceedings batch datasets similarly conference breadth-first scientific scheduling statistical pipe-intensive database workload management edinburgh over-allocate storage scotland creates july gray allocations shenoy pipelines rules completing thumb data batch-intensive engineering capacity-aware proceedings scheduling figure sixteenth illustrates ieee importance international capacity-aware conference scheduling data engineering measurements icde batch-intensive workloads pages scheduled holtman cms algorithms data grid workload system overview depth requirements cms large batch note data cern sets july takes hulith sizable amanda fraction experiment proceedings cooperative xvii international cache conference remote neutrino cluster physics varied astrophysics x-axis helsinki finland upper graph shows june runtime kuo lower winslett presents cho amount lee wide-area traffic chen generated efficient normalized input size output batch scientific data simulations make proceedings number observations parallel graphs distributed systems similarity iopads graphs validates pages wide-area lee network link crowley bottleneck bear resource anderson expected bershad policies achieve execution similar characteristics results desktop long applications windows proceedings entirety batch international data symposium sets fits computer architecture caches isca pages size litzkow livny mutka runtime condor hours pipe hunter intensive bfs idle dfs workstations proceedings bad-fs failures international hundreds conference pipe distributed size computing shared systems disk bfs dfs june bad-fs figure miller pipe-intensive explicit katz storage input management output behavior graphs depict supercomputing benefits applications explicit storage proceedings management acm pipeintensive ieee workload conference workload supercomputing consists -stage pages pipelines pipe data ousterhout size varied costa percent harrison total storage kunze kupfer amounts negligible thompson compute trace-driven servers analysis storage server unix experiment bsd representing file set system diskless procedings clients single server x-ray sharpens picture gray-box methods observing updates storage space access server time constrained eld batch inode data x-ray approaches infer total capacity blocks accessed cooperative cache build runtime approximate view wide-area traffic contents increase cache depth-first scheduling x-ray combines total batch knowledge data traditional longer monitoring fits data cache accesses depth-first scheduling refetch relevant batch data data cache pipeline approaching case performance results globally-managed lru extra cache fetches study x-ray pipelines series simulations compute servers x-ray server accurately executes predict contents pipelines system note appears runtime proceedings begins international increase symposium slightly computer architecture reason isca cache accurate inefficiency prediction lack enables highly exclusive cache delivering noticeably higher hit rates simple lru cache policy real workloads x-ray improves hit rates factor compared lru approaching performance perfect exclusive cache complete global requiring control allowed system current volume interface interface storage case rest local cooperative paper cache structured hash function section perfectly distributing overview data system peers operation explains cache nears problem full cache utilization inclusion skew overloads storage hierarchy nodes section results discusses extra traffic semantic information home obtained server disk implications section describes x-ray trade-off cache local section evaluates global control caching mechanism correct section discusses implication related work section scheduler summarizes aware work outlines future research utilization directions cooperative background cache section outlines utilization operation peer system finally breadth-first viewpoint bad-fs caching scheduling explains problem retain cache linear inclusion performance storage regime hierarchy proposes ensure solution total based amount utilizing batch semantic data accessed information disk time acm exceed symposium array capacity operating file systems system principles cooperative assumptions cache sosp begin pages presenting individual december assumptions batch dataset pasquale exceeds system capacity polyzos information static cooperative analysis cache present performance characteristics inode scientific breadth-first applications bad-fs scheduling found production workload converges xed location proceedings depth-first disk acm note included ieee inode conference pointers inefficiency supercomputing data caused pages blocks depth-first november deviate pointers slightly rajasekar direct wan inode moore happen indirect mysrb slightly block srb pointed components pipe-intensive inode capacity-aware data levels grid scheduling indirection proceedings set larger cache eleventh les ieee management inode symposium experiments tracks high focus information performance distributed pipeline-intensive activity workload computing hpdc creation edinburgh time scotland batchappears access july time usenix ranganathan symposium system networked foster maintains systems decoupling buffer design computation cache data implementation variable scheduling size distributed caches nsdi data-intensive disk mtbf applications blocks secsno failure proceedings cache largesmalllargesmall eleventh managed ieee throughput symposium jobs lrulike minute high caching always-copy policies performance never-copy distributed addition bad-fs computing cache figure hpdc failure data edinburgh handling blocks scotland graph operating shows july systems behavior roselli separate lorch inode cost-benefit cache strategy anderson comparison failure inodes file scenarios system shown open workloads recently usenix workloads accessed annual les technical width depth size conference minute system cpu rosti cache time varies serazzi due performs smirni pressure small squillante virtual impact memory system program behavior pages parallel required scheduling address proceedings spaces fewer joint pages international conference measurement caching modelling computer systems opened sigmetrics system rst pages identi samar inode stockinger number grid data management pilot pathname traversal proceedings iasted international checks conference applied informatics february satyanarayanan inode study present file sizes inode functional cache lifetimes present proceedings disk symposium block operating systems inode principles sosp read disk pages sullivan application werthimer reads bowyer cobb gedye system anderson calculates major block seti numbers project based project serendip data desired bytes personal computers proceedings inode amount indirect pipeline international blocks conference buffer large cache bioastronomy amount read sum run disk locate periods pablo nautilus disk high block molecular low numbers rates simulations code correspond failure technical failures report requested induced blocks wisconsin buffer artificial madison cache failure dept 
generator formatted disks random time failures seconds total runtime single pipe intensive case expect capacity-aware approach follow depth-first strategy closely results presented figure lower graph plot number failed jobs strategy induces job failure arise workload shortage space pipeline output scenario job runs space pipeline data aborts rerun time number job failures due lack space good indicator scheduler success scheduling pipeline-intensive jobs space constraints graph observe breadth-first scheduling unable prevent thrashing contrast capacity-aware bad-fs scheduler exceed space pipelines observes aborted job careful allocation results drastically reduced runtime shown upper graph stair-step pattern runtime bad-fs results careful allocation size data pipeline total storage bad-fs schedules workload jobs cpus data exceeds bad-fs allocates single cpu time notice bad-fs achieves runtimes comparable depth-first scheduling wasted resource consumption failure handling show behavior bad-fs varying failure conditions recall unlike traditional distributed systems bad-fs scheduler re-create lost output file make replica file remote cluster depend cost generating data versus cost replicating choice varies workload system conditions figure shows bad-fs cost-benefit analysis adapts variety workloads conditions compare naive algorithms always-copy replicates pipeline volume stages completes never-copy replicate draw conclusions graph environment failure replication leads excessive overhead increases amount data case bad-fs outperforms always-copy match never-copy initial replication seed analysis environment frequent failure surprising bad-fs outperforms never-copy intuitively bad-fs outperforms always-copy case particulars workload failure rate replicating worthwhile stage bad-fs correctly avoids replicating stage always-copy naively replicates stages workload experience conclude demonstrations system running real workloads demonstration presented figure compare runtime performance badfs methods utilizing local storage resources remote configuration local storage utilized executed directly home node standalone emulates afs caching data execute nodes cooperative caching storage servers leftmost graph shows results remote workload execution bandwidth home server constrained rightmost shows local workload execution home server situated local area network execute nodes graphs draw conclusions bad-fs equals exceeds performance remote standalone caching workloads configurations workloads discussed great detail earlier profiling work large degrees batch pipeline data sharing note workloads consists endpoint data gain benefit system benefit chemical engineering thain caching bent cooperatively arpaci-dusseau standalone arpaci-dusseau mode greater livny batch-intensive architectural workloads implications pipeline blast batch sharing scientific pipe-intensive workloads technical report pipe-intensive cstr- workloads wisconsin important computer optimization sciences pipeline department localization january performed thain bad-fs livny standalone multiple bypass cooperative interposition caching agents bad-fs distributed outperform computing standalone journal cluster cold warm phases computing execution vahdat entire anderson batch data transparent set result fits caching technical storage report server csd- cooperative computer caching science division improvement data california-berkeley initially paged vazhkudai tuecke data foster exceed replica capacity selection globus data caches grid ieee cooperative international caching symposium unlike standalone cluster computing grid ccgrid wong searched block disk reads issued martin blocks present arpaci-dusseau cache priority culler blocks architectural buffer requirements cache scalability updated nas cache parallel policy benchmarks lru supercomputing mostrecently read portland block oregon highest nov priority finally woo ohara access time torrie eld shingh in-memory inode gupta updated splashprograms inode characterization marked dirty methodological writing considerations proceedings similar annual main international differences symposium read computer architecture application-generated blocks pages santa cache margherita marked ligure dirty italy modi june cation acm time eld sigarch inode ieee updated computer society system tcca periodically computer ush modi architecture dirty news blocks disk 
modi meta-data blocks superblocks bitmap blocks inode blocks generally ushed sooner modied data blocks typical setting meta-data blocks linux ext system seconds data ushed seconds access time information periodically written observed disk problem disk arrays lru-like policies manage cache block array cache miss block potentially replacing recently accessed block policies recognize fact array cache second-level cache services accesses miss system buffer cache block read system system buffer cache subsequent requests block handled cache disk reads block evicted block recently read block array cache stay array cache signi period time wasting cache space array caches greatly affected cache inclusion size comparable size host memory ideal disk block array cache evicted system buffer cache array cache acting victim cache disk array observe disk block requests hit system cache information decide block evicted complicate situation system buffer cache xed size due varying degrees memory pressure solution question addressing storage system learn contents system cache make decisions blocks array cache system interface storage key building system semantic knowledge storage array semantically-smart storage array knowledge system structures embedded sense storage typical array semantically-smart storage system observe inode updated access time eld inode changed array infer read valuable information intelligent caching scheme section explore information obtained disk array semantic awareness inferences made information semantic information semantically-smart storage array knowledge higher level system data structures instance block identify inode data block inode block block identify individual elds inode semantic information embedded appears proceedings international symposium computer architecture isca information inferences requirements disk read request data block block system cache mru block identify data blocks disk read request previously read block block victim system cache past identify data blocks remember previously read blocks access time inode disk read observed blocks present system cache identify inode blocks note 
inode elds cache inode blocks remember disk reads table semantic inferences table presents inferences made disk array piece information capabilities required make inference disk array learned array careful observation system traf note embedding knowledge disk array reasonable on-disk system structures change modern systems great lengths preserve on-disk layout revisions order ensure backward compatibility existing systems semantic knowledge disk array observe elds inode time accessed modi information facilitate prediction ordering blocks system cache size system cache describe speci inferences disk array make based extra semantic information table summarizes inferences speci mechanisms required enable inferences disk array identify data blocks infer data block read system recently mru block system cache assumed system cache lru-based disk array infer block read replaced system disk array make stronger inference disk read observes previously read block block system cache earlier present block victim point time disk reads block make inference disk array remember block numbers previously read blocks finally updates access timestamp eld inode enable inference disk array identify inode blocks compare contents inode block written previous on-disk state identifying inodes change access time semantic knowledge enables disk array associate inode data blocks represented inode information disk array infer changed access time inode implies blocks accessed system blocks read disk access time disk array infer accessed blocks present system cache assuming time loosely synchronized host array order make inference disk array remember past disk accesses assume change access time implies accessed opposed block studies system activity reasonable explore rami cations assumption set inferences aids constructing access information blocks information block victim required system cache information derived late scheme access information block information blocks assumed system cache lru replacement policy systems conform assumption information gleaned disk array maintain list block numbers data blocks read system ordered access times blocks obtained inode writes actual disk reads list reects recency access perceived system attempts mirror ordering system cache block lru end list earliest access time mru end latest access time maintaining ordered list extend inferences disk read previously read block ordered list implies block evicted blocks block lru end list evicted system cache blocks earlier access times block read similarly system level access block generate disk read implies block blocks block mru end ordered list present system cache basic inferences driven semantic information approximating contents system cache section describe details transforming base idea working cache mechanism preserve exclusivity x-ray cache section rst describe build approximate image system cache contents semantic information discuss limitations approach finally describe cache content prediction build exclusive array cache mechanism tracking file system cache track contents system cache maintain ordered list block numbers accessed system call list recency list r-list entry r-list access time block inferred array identi denotes block belongs moving pointer called cache begin pointer appears proceedings international symposium computer architecture isca actions disk read block actions inode write lruend mru disk read block time lru end block belongsinode write file end access time lru end end inclusive region inclusive region inclusive region exclusive region exclusive region exclusive region end mru mru lru end end inclusive regionexclusive region mru block timestamp figure r-list pointer operation contents system cache tracked disk array r-list pointer gures show status r-list pointer disk read inode write block r-list disk block number access time pointer slides list demarcates set blocks presumed resident cache blocks r-list outline r-list pointer managed r-list maintained basic rules block read added moved mru end r-list access time change observed result inode write blocks belonging removed list re-inserted list ecting access time pointer called ideal point array cache placement occur number blocks pointer mru end r-list estimate size system cache set blocks range approximation contents system cache label region pointer mru end r-list inclusive region region pointer lru end list exclusive region pointer maintained read observed block r-list indicating victim block inclusive region implies system cache size overestimated pointer moved position block read shrinking inclusive region victim block present exclusive region pointer moved block mru end action required account possibility reading block result eviction lru block system cache case conservative estimate cache size system level access blocks inferred inode write set blocks r-list belong examined block earliest access time chosen block lies exclusive region implies size system cache underestimated pointer moved position accessed block expanding inclusive region accessed block present inclusive region action required figure illustrates operation system cache tracking mechanism rst disk read block time initially pointer positioned blocks indicating blocks expected present system cache blocks expected victims system cache read block implies blocks system cache victims past block read longer victim recently block moved mru end r-list timestamp updated pointer repositioned blocks ect fact block expected victim illustrates inode write initially pointer positioned blocks indicating block expected system cache inode write block observed access timestamp noted assume timestamp changed assuming disk reads observed infer block present system cache pointer moved past block ect information entry block repositioned r-list timestamp handling partial file access techniques assume les accessed entirety access time update inode infer information blocks accesses typical system workloads involve les require mechanisms robust occasional partial accesses read time block accessed initially victim moved exclusive region r-list nally block accessed receiving access time update due accessed mechanism appears proceedings international symposium computer architecture isca wrongly increase cache size position assumes fullle access handle situation adopt simple heuristic long block belonging inclusive region blocks exclusive region disregarded access time updates received improve robustness techniques occasional skews access pattern updates pointer congestion avoidance control proceedings sigcomm performed suf cient evidence observed speci cally update performed threshold number accesses suggest update accesses pertaining blocks les limits accuracy mechanisms track contents system cache reasonable level accuracy fundamental limitations interval typically seconds inode writes creates window uncertainty accesses evictions blocks system interval potentially unknown x-ray mismatch actual ordering blocks system maintained x-ray blocks moved exclusive region recently blocks system access information pages stanford blocks observed california aug jacobson time braden pointer borman tcp moved extensions high exclusive performance region rfc ect internet access engineering task information force pointer update account iyengar access amer blocks heinz two-level account threshold recovery blocks mechanism evicted sctp system sci karn time partridge interval improving round-trip cache time size estimates estimate reliable ated transport protocols x-ray observes proceedings victim read sigcomm shrinks aug inclusive kohler region handley inode floyd timestamps designing dccp granularity congestion control multiple les reliability icir accessed kohler dcp access dccp-icnp time ordering pdf 
relevant blocks unknown x-ray lead error predicted cache size future read evicted block change access time limitation hold systems netbsd ffs maintains timestamps microsecond granularity assume worst -second granularity found linux ext system block accessed evicted system cache inode write interval case x-ray wrongly blocks accessed blocks mru end r-list present system cache error occur block system cache accessed single inode write interval show potential limitations prediction mechanism achieves high level accuracy enabling cache mechanism ideal exclusivity ray cache mechanism section describes x-ray cache built top system cache tracking mechanism size array cache blocks ideally x-ray cache rst blocks past pointer exclusive region r-list unlike simple policies lru place block cache block read system x-ray block ready system issues read block x-ray explicitly fetch block place exclusive cache decide blocks fetch cache x-ray periodically examines r-list blocks added n-block window past pointer r-list blocks removed blocks newly added window replace removed blocks one-by-one x-ray cache fetched kohler kaashoek montgomery readable tcp prolac protocol language proceedings sigcomm pages cambridge massachusetts aug ludwig sklower eifel retransmission timer acm computer communications review july maeda bershad protocol service decomposition high-performance networking proceedings acm symposium operating systems principles sosp pages asheville north carolina dec mahdavi floyd tcp-friendly unicast ratebased flow control end end-interest mailing list http psc networking papers tcp friendly html jan mathis heffner reddy web extended tcp instrumentation acm computer communications review july mathis mahdavi floyd romanow tcp selective acknowledgment options rfc internet engineering task force mogul brakmo lowell subhraveti moore unveiling transport hotnets mogul rashid accetta packet filter efficient mechanism user-level networkcode proceedings acm symposium operating systems principles sosp austin texas november padhye floyd inferring tcp behavior sigcomm pages august patel whitaker wetherall lepreau stack upgrading transport protocols untrusted mobile code sosp paxson allman dawson fenner griner heavens lahey semke volz tcp implementation problems rfc internet engineering task force mar pradhan kandula shaikh nahum daytona user-level tcp stack http nms lcs mit kandula data daytona pdf ramakrishnan floyd black addition explicit congestion notification ecn rfc internet engineering task force seltzer endo small smith dealing disaster surviving misbehaved kernel extensions proceedings symposium operating systems design implementation osdi pages seattle washington oct stone stewart otis stream control transmission protocol rfc sept tamura tobe tokuda efr retransmit scheme tcp wireless lans ieee conference local area networks pages thekkath nguyen moy lazowska implementing network protocols user level ieee acm transactions networking venkataramani kokku dahlin tcp-nice mechanism background transfers proceedings symposium operating systems design implementation osdi pages boston massachusetts dec von eicken basu buch vogels u-net user-level network interface parallel distributedcomputing proceedings acm symposium operating systems principles sosp pages copper mountain resort colorado dec wallach engler kaashoek ashs application-specific handlers high-performance messaging ieee acm transactions networking aug wang valla sanadidi gerla adaptive bandwidth share estimation tcp westwood ieeeglobecom white lepreau stoller ricci guruprasad newbold hibler barb joglekar integrated experimental environment distributed systems networks proceedings symposium operating systems design implementation osdi pages boston massachusetts dec zhang karp floyd peterson rr-tcp reordering-robust tcp dsack international conference network protocols icnp june 
aggregate cache space fit working set benefit cooperative caching warm caches illustrated blast measurements graph left figure logfile analysis showed appears usenix symposium networked systems design implementation nsdi ibis cms blast amanda runtime wide-area execution remote standalone bad-fs ibis cms blast amanda runtime local-area execution remote standalone bad-fs figure workload experience graphs show runtime measurements real workloads workload submit pipelines dedicated condor pool cpus condor pool accesses local storage resources configurations remote redirected back home node standalone emulates afs-like caching home server bad-fs measurement present average runtime jobs run storage server storage cache cold subsequent jobs run cache warm graph left shows runtimes workload executed cluster separated home node emulated wide-area link set home node located local area network note y-axis shown log scale accentuate points interest detailed information workloads found profiling study storage servers slightly cache space needed total blast batch data subsequent jobs accessed servers forced refetch data refetching wide-area home server standalone case expensive refetching cooperative cache bad-fs local-area home server performance advantage disappears behavior servers explains increased variability shown measurements fourth penalty performing remote home node severe significant home node local-area network execute cluster result illustrates bad-fs improve performance bandwidth home server limiting resource finally comparing graphs make observation bad-fs performance independent connection home server caches cold independent warm scoping bad-fs achieve local performance remote environments wild evaluations conducted controlled environments conclude experimental presentation demonstration bad-fs capable operating uncontrolled real world environment created wide-area bad-fs system existing batch systems wisconsin large condor system thousand cpus including workstations clusters classroom machines shared large number users mexico unm pbs system manages cluster dedicated machines established personal scheduler catalog home storage server wisconsin submitted large number bad-fs bootstrap jobs batch systems installing special software locations directed scheduler execute large workload consisting cms pipelines resources figure timeline execution workload expected number cpus varied widely due competition users availability idle workstations vagaries batch scheduler unm consistently provided twenty cpus jumping forty hours spikes cpus hours due crash recovery catalog server resulted loss monitoring data running jobs benefits cooperative caching underscored dynamic environment bottom graph cumulative read traffic home node shown hills plateaus hills correspond large spikes number cpus cpus subnet begin executing fetch batch data home node smaller hills number cpus effect amount home read traffic server entering established cooperative cache fetch batch data peers finally figure illustrates design implementation bad-fs suitable running intensive batch-pipelined workloads multiple uncontrolled real world clusters failures disconnections bad-fs continues making steady progress removing burden user scheduling monitoring resubmitting jobs appears usenix symposium networked systems design implementation nsdi cpus total cpus cpus unm jobs running tens jobs complete writes server reads server figure wild graphs present timeline behavior large cms workload run bad-fs workload consisted cms pipelines run resources scavenged collection cpus mexico running pbs cpus wisconsin running condor topmost timeline presents total number cpus middle shows number jobs running cumulative jobs completed bottom shows cumulative traffic incurred home server related work designing bad-fs drew related work number distinct areas workflow management historically concern high-level business management problems involving multiple authorities computer systems large organizations approval loans bank customer service actions company scheduler works lower semantic level systems borrow lessons integration procedural data elements automatic management dependencies performance fault tolerance found variety tools systems managed dependencies jobs basic found unix tool make elaborate dependency tracking explored vahdat anderson work transparent result caching work authors build tool tracks process lineage file dependency automatically workflow description static encoding knowledge manner scheduler constructs private namespaces running workloads reminiscent database views private namespace simpler construct maintain views contrast present systems implementation challenges handling updates base tables propagation extant materialized views bad-fs improved prefetching batch datasets work noted difficulty correctly predicting future access patterns bad-fs explicitly supplied user declarative workflow description recent work peer-to-peer storage systems 
systems interesting solutions problem domain intended falls short applied context batch workloads reasons distributed file systems good match overlays developed environments communication clusters plan investigate future work similar work grid computing techniques designed bad-fs environments cluster-on-demand offers sophisticated resource clustering techniques badfs form cooperative cache groupings extensible systems share approach allowing application control recent work recently revisited approach extensible systems commercially successful specialized policies great greater batch workloads running systems designed interactive research mobile computing bears similarity flinn discuss process data staging untrusted surrogates ways surrogate similar bad-fs storage server major difference surrogate primarily concerned trust servers primarily concerned exposing control zap vmware checkpointing migration processes operating systems create remote virtual environment higher level batch system systems secure interposition janus complement badfs make resource owners donate resources shared pools finally bad-fs similar distributed file systems google file system motivated workloads deviate earlier file system assumptions additional similarity simplified consistency implementation gfs relax consistency semantics enable bad-fs explicit control earlier work coda afs applicable systems caching availability disconnected operation bad-fs storage servers enact similar role appears usenix symposium networked systems design implementation nsdi conclusions big bad wolf neighborhood bad meaning bad bad meaning good run dmc peter piper allowing external control long recognized powerful technique improve aspects system performance moving control external user system system user dictate policy individual nature work systems lacking mechanisms external control speculate systems proven adept speculation work majority workloads paper argued distinct nature batch workloads matched design traditional distributed file systems external control greater bad-fs distributed file system exposes internal control decisions external scheduler detailed knowledge workload characteristics scheduler carefully manages remote resources facilitates execution intensive batch jobs wide-area local-area clusters synthetic real workload measurements controlled uncontrolled environments demonstrated ability bad-fs workload specific knowledge improve throughput selecting storage policies scoping space allocation cost-benefit replication acknowledgments nate burnett nicholas coleman tim denehy barry henrichs florentina popovici muthian sivathanu vijayan prabhakaran department helpful discussions comments paper grateful excellent support provided members csl state appreciation jeff chase thoughtful analysis work development project finally anonymous reviewers helpful suggestions eric brewer excellent insightful shepherding substantially improved content presentation paper work sponsored part nsf ccrnsf ngsccr- ccritr- itrdoe de-fc wisconsin alumni research foundation emc ibm adya bolosky castro cermak chaiken douceur howell lorch theimer wattenhofer farsite federated reliable storage incompletely trusted environment proceedings symposium operating systems design implementation osdi boston dec agrawal imielinski swami database mining performance perspective ieee transactions knowledge data engineering dec altschul madden schaffer zhang zhang miller lipman gapped blast psi-blast generation protein database search programs nucleic acids research pages anderson dahlin neefe patterson wang serverless network file systems proceedings acm symposium operating systems principles sosp pages copper mountain dec arpaci-dusseau arpaci-dusseau burnett denehy engle gunawi nugent popovici transforming policies abstract run-time adaptation river acm tocs remzi arpaci-dusseau present design implementation evaluation run-time adaptation river dataflow programming environment goal river system provide adaptive mechanisms database query-processing applications cope performance variations common cluster platforms describe system basic mechanisms carefully evaluate mechanisms effectiveness analysis answer previously unanswered important questions core run-time adaptive mechanisms effective compared ideal keys making work applications easily primitives finally situations run-time adaptation sufficient performing study utilize three-pronged approach comparing results idealized models system behavior targeted simulations prototype implementation providing insight positives negatives run-time adaptation specifically river broader context comment interplay modeling simulation implementation system design full paper pdf bibtex 
mechanisms infokernel proceedings acm symposium operating systems principles sosp bolton landing lake george oct avery cms virtual data requirements kholtman home cern kholtman tmp cmsreqsv baker hartman kupfer shirriff ousterhout measurements distributed file system proceedings acm symposium operating systems principles sosp pages pacific grove oct bent venkataramani leroy roy stanley arpaci-dusseau arpaci-dusseau livny flexibility manageability performance grid storage appliance proceedings high-performance distributed computing hpdcpages edinburgh scotland jul bershad savage pardyak sirer fiuczynski becker chambers eggers extensibility safety performance spin operating system proceedings acm symposium operating systems principles sosp pages copper mountain dec breitbart deacon schek sheth weikum merging application-centric data-centric approaches support transaction-oriented multi-system workflows sigmod record cantin hill cache performance selected spec cpu benchmarks computer architecture news sep chandra dahlin richards wang anderson larus experience language writing coherence protocols proceedings usenix conference domain-specific languages santa barbara oct chang gibson automatic hint generation speculative execution proceedings symposium operating systems design implementation osdi pages orleans louisiana feb chase grit irwin moore sprenkle dynamic virtual clusters grid site manager proceedings ieee international symposium high performance distributed computing hpdc seattle june dabek kaashoek karger morris stoica wide-area cooperative storage cfs proceedings acm symposium operating systems principles sosp banff canada oct dahlin wang anderson patterson cooperative caching remote client memory improve file system performance proceedings symposium operating systems design implementation osdi monterey nov eda industry working group eda resource http eda edwards mckendry exploiting read-mostly workloads filenet file system proceedings acm symposium operating systems principles sosp pages litchfield park arizona dec engler kaashoek toole exokernel operating system architecture application-level resource management proceedings acm symposium operating systems principles sosp pages copper mountain dec appears usenix symposium networked systems design implementation nsdi feeley morgan pighin karlin levy implementing global memory management workstation cluster proceedings acm symposium operating systems principles sosp pages copper mountain dec flinn sinnamohideen tolia satyanarayanan data staging untrusted surrogates proceedings usenix symposium file storage technologies fast san francisco apr ford hibler lepreau tullman back clawson microkernels meet recursive virtual machines proceed-ings symposium operating systems design implementation osdi seattle oct foster avery petascale virtual data grids data intensive science griphyn white paper foster kesselman tsudik tuecke security architecture computational grids proceedings acm conference computer communications security conference pages foster kesselman tuecke anatomy grid enabling scalable virtual organizations international journal supercomputer applications frey tannenbaum foster livny tuecke condor-g computation management agent multiinstitu- tional grids proceedings ieee international symposium high performance distributed computing hpdc san francisco aug gelenbe optimal checkpoint interval journal acm apr georgakopoulos hornick sheth overview workflow management process modeling workflow automation infrastructure distributed parallel databases ghemawat gobioff leung google file system proceedings acm symposium operating systems principles sosp bolton landing lake george oct goldberg wagner thomas brewer secure environment untrusted helper applications proceedings sixth usenix security symposium july gribble brewer hellerstein culler scalable distributed data structures internet service construction proceedings symposium operating systems design implementation osdi san diego oct gupta mumick maintenance materialized views problems techniques applications ieee quarterly bulletin data engineering special issue materialized views data warehousing jones interposition agents transparently interposing user code system interface proceedings acm symposium operating systems principles sosp pages asheville north carolina dec kistler satyanarayanan disconnected operation coda file system acm transactions computer systems feb kubiatowicz bindel eaton chen geels gummadi rhea weimer wells weatherspoon zhao oceanstore architecture global-scale persis-tent storage proceedings international conference architectural support 
programming languages operating systems asplos pages cambridge nov lancaster renderman web site http renderman litwin neimat schneider family order preserving scalable distributed data structures proceedings international conference large databases vldb pages santiago chile sep litzkow livny mutka condor hunter idle workstations proceedings acm computer network performance symposium pages june muthitacharoen morris gil chen ivy read write peer-to-peer file system proceedings symposium operating systems design implementation osdi boston dec osman subhraveti nieh design implementation zap system migrating computing environments proceedings symposium operating systems design implementation osdi boston dec ousterhout costa harrison kunze kupfer thompson trace-driven analysis unix bsd file system proceedings acm symposium operating system principles sosp pages orcas island dec platform computing improving business capacity distributed computing platform industry financial raman matchmaking frameworks distributed resource management phd thesis recently blocks removed blocks cache replaced rst blocks present system cache x-ray avoid inclusion order x-ray cache organized access time ordered list blocks blocks required placement obtained source unlike mechanisms demote change interface accommodate special cache place command system supply evicted block change interface system disk blocks read disk schedule cache placement reads x-ray requires additional disk bandwidth additional bandwidth forms workload suf cient idle time requests x-ray idle time schedule disk reads placement section explore idle time required purpose workload idle time x-ray perform timely placement internal bandwidth disk array higher external bandwidth limited bandwidth single scsi bus large storage arrays internal buses substantial extra internal bandwidth perform replication migration data storage array scenarios x-ray leverage small amount extra bandwidth schedule placement reads freeblock scheduling shown capable extracting signi amount free bandwidth busy disks negligible impact foreground workload x-ray potentially freeblock scheduling cases internal bandwidth scarce evaluation section trace-based simulation evaluate x-ray rst describe simulation environment section evaluate x-ray system cache tracking mechanism terms accurately predict cache contents finally section evaluate performance improvements x-ray caching mechanism synthetic real workloads simulator built trace-driven simulator system disk system underneath simulator takes trace system requests open read write models system behaviorally similar linux ext system appears proceedings international symposium computer architecture isca simpli system model consists inode data blocks meta-data blocks including superblock bitmap blocks indirect pointer blocks modeled traf blocks minimal system cache lru replacement default investigate cache replacement policies section size cache dynamically changed model virtual memory pressure system block size writes blocks marked dirty buffer cache dirty blocks written periodically dirty inode blocks written disk seconds speci dirty data blocks written seconds inode timestamps granularity disk array simulator models simple disk constant access time model single disk simplicity results hold interesting disk arrays evaluation concentrates hit rates disk-speed insensitive access times levels hierarchy hits system cache hits array cache cost disk accesses cost prediction accuracy section quantify degree accuracy x-ray track size contents system cache explore sensitivity mechanism system workload parameters metrics error cache size prediction predicted system cache size number blocks inclusive region r-list difference predicted cache size actual system cache size measured regular intervals average error computed fraction false positives effective x-ray cache blocks recent victims system cache due prediction inaccuracy x-ray wrongly conclude blocks system cache victims measure ratio number false positives predicted cache size fraction false negatives maintain exclusion x-ray avoid wrongly identifying blocks system cache victims metric ratio number false negatives actual cache size synthetic workloads random zipf similar wong wilkes evaluate exclusive caching experiments subsection workloads warmup phase set les read fully sequentially les selected order set read fully random benchmark selection les uniform random zipf benchmark selects les based zipf distribution selection highly biased small number popular les prediction file system cache size run random benchmark system cache size initially set blocks record cache size predicted x-ray execution benchmark order evaluate reactivity x-ray cache size change cache size blocks time seconds predicted size actual size figure cache size prediction cache size prediction compared actual cache size execution random benchmark shown benchmark les blocks size performs fullle reads warmup phase actual cache size changed blocks blocks read warmup size prediction error file system cache size blocks size prediction error random file size block file size blocks file size blocks file size blocks file size blocks size prediction error file system cache size blocks size prediction error zipf file size block file size blocks file size blocks file size blocks file size blocks figure estimating cache size average percentage error cache size prediction function system cache size plotted sizes random zipf benchmarks working set size constant blocks benchmarks executed sizes total number blocks accessed benchmark constant warmup period measurements actual cache size system multiple times execution benchmark figure compares cache size prediction x-ray actual system cache size warmup phase rst seconds benchmark scans blocks working set x-ray receives information contents system cache random selection phase starts x-ray predict size system cache high degree accuracy x-ray highly responsive system cache size inaccuracies due reasons cited earlier responsible slight overestimate cache size observe obtained similar results zipf benchmark shown explore average percentage error cache size prediction random zipf benchmarks mechanism evaluated sizes system cache sizes figure shows sensitivity size prediction error sizes system cache sizes file size factor mechanism performs access time information obtained granularity appears proceedings international symposium computer architecture isca fraction false positives file system cache size blocks false positives random file size block file size blocks file size blocks file size blocks file size blocks fraction false positives file system cache size blocks false positives zipf file size block file size blocks file size blocks file size blocks file size blocks fraction false negatives file system cache size blocks false negatives random file size block file size blocks file size blocks file size blocks file size blocks fraction false negatives file system cache size blocks false negatives zipf file size block file size blocks file size blocks file size blocks file size blocks figure false positives false negatives fraction false positives fraction false negatives function system cache 
size plotted sizes random zipf benchmarks working set size constant blocks benchmarks executed sizes total wisconsin-madison oct rizzo dummynet simple approach evaluation network protocols acm computer communication review roselli lorch anderson comparison file system workloads proceedings usenix annual technical conference usenix pages san diego june rowstron druschel storage management caching past large-scale persistent peer-to-peer storage utility proceedings acm symposium operating systems principles sosp banff canada oct rusinkiewicz sheth specification execution transactional workflows modern database systems object model interoperability pages saito karamanolis karlsson mahalingam taming aggressive replication pangaea wide-area file system proceedings symposium operating systems design implementation osdi boston dec sapuntzakis chandra pfaff chow lam rosenblum optimizing migration virtual computers proceedings symposium operating systems design implementation osdi boston dec satyanarayanan study file sizes functional lifetimes proceedings acm symposium operating systems principles sosp pages pacific grove dec seltzer endo small smith dealing disaster surviving misbehaved kernel extensions proceedings symposium operating systems design implementation osdi pages seattle oct soderbergh mac lies videotape apple hotnews articles fullfrontal sullivan werthimer bowyer cobb gedye anderson major seti project based project serendip data personal computers proceedings international conference bioastronomy thain bent arpaci-dusseau arpaci-dusseau livny pipeline batch sharing grid workloads proceedings high-performance distributed computing hpdcpages seattle june thain livny parrot transparent user-level middleware data-intensive computing workshop adaptive grid middleware orleans louisiana sep vahdat anderson transparent result caching proceedings usenix annual technical conference usenix orleans louisiana june vogels file system usage windows proceedings acm symposium operating systems principles sosp pages kiawah island resort south carolina dec 
number blocks accessed benchmark constant warmup period seconds measurements size prediction error percentage files accessed partially size prediction random zipf fraction false positives percentage files accessed partially false positives random zipf fraction false negatives percentage files accessed partially false negatives random zipf figure partial file access performance system cache tracking evaluated percentage partially accessed les increases working set consists les blocks size system cache size blocks random performs reads zipf performs reads varying percentages les read partially gure shows average size prediction error false positives fraction false negatives graphs observe system cache size increases percentage error decreases larger cache size fewer blocks evicted cache inode writes leading lower misclassi cation errors size prediction error depends extent size error increases size increases considerably signi fraction system cache size prediction file system cache contents cacy x-ray predicting contents cache terms metrics outlined fraction false positives false negatives important fractions low high number false positives imply x-ray ignore signi number recently accessed blocks cached system cache high number false negatives lead x-ray redundantly caching blocks present system cache figure plots fraction false positives fraction false negatives predicted x-ray system cache sizes sizes random zipf workloads graphs show fraction false positives low range parameters fraction false positives decreases increase cache size similar trend observed size prediction error cache tracking mechanism effective identifying recent victims cache quickly respect false negatives trends similar earlier graphs average fraction low x-ray cache high degree exclusivity sensitivity partial file access evaluate robust x-ray prediction mechanism partial access modi random zipf benchmarks access random number blocks percentage les rest les read fully figure shows prediction error x-ray error metrics percentage les accessed partially increased graphs x-ray tolerates partial reads studies shown accesses typical system workloads reads speci cally baker found read-only accesses read bytes sequential transfers maximum reads non-full size content predictions accurate sensitivity inode write interval x-ray obtains access information inode writes performance x-ray sensitive long inode blocks dirty written figure graphs performance x-ray inode write delay increased gures show small write delays seconds prediction error tolerable excessively long write delays size prediction error fraction false negatives increase considerably inode access time update fundamental sources information x-ray surprising reasonable inode write frequency required prediction typical systems linux ext system small write delays inode blocks appears proceedings international symposium computer architecture isca size prediction error inode write interval seconds size prediction zipf random fraction false positives inode write interval seconds false positives zipf random fraction false negatives inode write interval seconds false negatives zipf random figure inode write interval performance system cache tracking evaluated inode write interval increases working set les blocks size random performs fullle reads zipf performs fullle reads gure shows average size prediction error false positives fraction false negatives fraction inode write intervals cache workload size false false size size prediction positives negatives blocks blocks error fraction fraction table scaling behavior quality system cache tracking evaluated system cache size workload size scaled random benchmark executed size set blocks number les increases working set increases scaling behavior table shows scaling x-ray terms error metrics workload size system cache size increased random benchmark observe effect errors decreases benchmark system cache size workload scaled error article sources arpaci-dusseau independent -tocs system cache title size run-time percentage adaptation error reduces river author system cache remzi size arpaci-dusseau scaled journal acm transactions cache computer systems tocs pages performance month february volume number year 
section performance x-ray cache mechanism evaluated synthetic workloads real traces compare hit rates array cache approaches examine resulting response time read average read latency compare performance x-ray alternative approaches compare array cache managed simple lru fashion represents array caches managed today multi-queue cache policy speci cally designed second-level caches utilizes frequency access prioritize blocks compare approach demote cache mechanism achieves exclusivity modifying system explicitly supply victim blocks array cache finally compare ideal case scenario array cache added system cache upper bound array cache achieve perfect exclusivity note case relevant read latency measurements hit rate measurements separate array cache experiments section assume x-ray suf cient extra bandwidth schedule cache placement disk reads constrained scenario extra bandwidth quantify idle time needed x-ray work effectively finally compare performance x-ray approaches system cache policy lru synthetic workloads set experiments random zipf workloads section figure figure show array cache hit rates x-ray lru multi-queue demote array cache sizes random zipf workloads measurements warmup phase benchmarks gures x-ray outperforms lru multi-queue signi cantly random workload x-ray compares indistinguishably demote implying x-ray effective enforcing exclusivity explicit accurate information demote zipf workload hit rate x-ray close demote reason x-ray performs slightly worse case compared random workload impact false positives higher zipf workload important capture recent victims system cache workloads multi-queue policy performs lru due consideration frequency access figure figure compare average read latency workloads x-ray mechanisms compare x-ray ideal scenario array cache space added host system surprisingly demote performs close ideal scenario perfect information enforce exclusivity latency x-ray lru multi-queue policies close ideal scenarios higher hit rates achieved x-ray lead signi improvements read latency benchmarks real workloads evaluate performance x-ray real workloads set experiments http traces web servers evaluate x-ray convert trace requests appears proceedings international symposium computer architecture isca hit rate array cache size blocks random hit rate demote x-ray multi-queue lru read latency milliseconds array cache size blocks random read latency lru multi-queue x-ray demote extra figure random workload array cache hit rate average read latency x-ray lru multi-queue demote random benchmark presented read latency graph plots line pertaining adding extra space system cache system cache size set blocks benchmark les blocks size reads performed hit rate array cache size blocks zipf hit rate demote x-ray multi-queue lru read latency milliseconds array cache size blocks zipf read latency lru multi-queue x-ray demote extra figure zipf workload array cache hit rate average read latency x-ray lru multi-queue demote zipf benchmark presented read latency graph plots line pertaining adding extra space system cache system cache size set blocks benchmark les blocks size reads performed web servers system read operations assume objects referred trace static les generated dynamically traces requests image les requests html les 
assume bytes data returned client rst bytes issue requests times speci trace preserving idle time requests traces section -minute section http trace heavily accessed soccer world cup website section http trace nasa web server recorded august figure shows hit rate array cache average read latency worldcup workload gure shows hit rate achieved x-ray lru multi-queue entire range array cache sizes hit rate comparable demote hit rate improvements translate improvements response time x-ray improves read latency times compared lru times compared multi-queue performs similar demote maximum slowdown figure shows hit rate array cache average read latency nasa trace system cache size set blocks x-ray performs demote signi cantly lru multi-queue performance gain x-ray signi array cache small compared system cache approximate information system cache contents x-ray perform invasive methods demote require storage interface sensitivity idle time section explore idle time required x-ray timely fetch exclusive cache blocks placeappears proceedings international symposium computer architecture isca hit rate array cache size blocks worldcup trace hit rate demote x-ray multi-queue lru read latency milliseconds array cache size blocks worldcup trace read latency lru multi-queue x-ray demote extra figure worldcup trace hit rate read latency array cache hit rate average read latency x-ray lru multiqueue demote worldcup trace presented read latency graph plots line pertaining adding extra space system cache system cache size set blocks hit rate array cache size blocks nasa trace hit rate demote x-ray multi-queue lru read latency milliseconds array cache size blocks nasa trace read latency lru multi-queue x-ray demote extra figure nasa trace hit rate read latency array cache hit rate average read latency x-ray lru multi-queue demote nasa trace presented read latency graph plots line pertaining adding extra space system cache system cache size set blocks ment estimate idle time requirements x-ray implementation issues disk read time idle time assume free internal bandwidth run worldcup benchmark varying degrees idle time purpose scale inter-request times recorded trace broad range scaling factors system cache size array cache size set blocks figure shows hit rate array cache amounts idle time observe graph hit rates multi-queue lru demote independent idle time hit rate x-ray decreases idle time decreases foreground requests greater portion disk bandwidth nasa benchmark signi cantly idle time worldcup benchmark observed hit rate affected factor reductions idle time results shown suf cient idle time present workload x-ray schedule cache placement reads requiring extra internal bandwidth workloads idle time spare internal disk array bandwidth freeblock scheduling schedule reads file system cache policies x-ray designed assumption system cache managed lru fashion systems lru section evaluate performance x-ray system cache managed replacement policies clock clock widely approximation lru cache policy linux variation manage page cache figure presents array cache hit rates worldcup trace study cases ordering demote x-ray multi-queue lru remains slightly larger difference demote x-ray hinting array tuned speci caching algorithm host subject leave future investigation appears proceedings international symposium computer architecture isca hit rate idle time reduction factor x-ray demote multi-queue lru lru multi-queue demote x-ray idle time idle time figure hit rate idle time hit rate array cache worldcup benchmark factor reductions idle time shown x-ray implementation extra internal disk array bandwidth study fractional factor reduction idle time reciprocal factor increase idle time factor reduction retaining original idle time trace hit rate array cache size blocks clock demote x-ray multi-queue lru hit rate array cache size blocks demote x-ray multi-queue lru figure file system cache policy array cache hit rate x-ray lru multi-queue demote worldcup benchmark presented cases system cache managed clock system cache size set blocks related work cache replacement algorithms explored good detail years algorithms proposed single level cache mind include lru lfu fifo mru lee explored spectrum policies subsume lru lfu number earlier works distributed systems demonstrated multi-level cache hierarchy rethinking efforts investigated policies method avoid inclusion focus frequency-based policies recently zhou proposed multiqueue algorithm level caches put minimal lifetime frequency-based priority temporal frequency desirable qualities cache replacement algorithm multiqueue algorithm satis requirements multiple lru queues second-level cache recent block queue minimum frequency threshold selected replacement multi-queue eliminate cache inclusion cache placement occurs disk read block system demote array cache management mechanism considers cache exclusion central managing array cache demote system informs disk array blocks discards block present array cache system supplies block requires changing system-disk interface hinders deployment demote increases interconnect bandwidth requirement moving blocks system cache back array cache problem interconnect-constrained environments finally recent work eviction-based cache placement cache exclusion manage array cache similar work unlike demote mechanism attempts retain current interfaces requires software installed host machine change interface storage specifically eviction-based cache placement virtual memory addresses supplied system modi device driver track contents system mechanism relies idle time extra bandwidth disks read blocks array cache mechanism change interface device driver requires interface disk order communicate needed information storage server mechanism provisions detect system cache size introducing possibility misjudging contents work correctly moves cache pages original location system page migration conclusions technology trends point availability smarter disk array systems future semantic intelligence disk arrays manage large caches present systems semantic information avoids system-disk interface providing information infer contents system cache paper shown create image system cache information inferred disk traf introduced metrics evaluate tracking system cache contents viewpoint information exclusive caching image system cache helps identify set exclusive blocks array cache x-ray array cache based semantic information good cache hit rates improves execution time considerably x-ray achieves ends modi cations system storage interface readily deployed future plan explore number extensions x-ray infer occurrence deletions information remove invalid data cache x-ray possibly detect caching algorithm system assuming lru-like finally explore utility x-ray underneath classes systems windows ntfs underneath database management systems extensions lead robust deployable exclusive caching mechanism storage arrays appears proceedings international symposium computer architecture isca acknowledgments anuradha vaidyanathan involvement input early stages project saisanthosh balakrishnan nathan burnett timothy denehy florentina popovici vijayan prabhakaran insightful comments earlier drafts paper anonymous reviewers comments suggestions helped signi cantly improve paper work sponsored nsf ccrccr- ccrngs- itritr- ibm emc wisconsin alumni research foundation arlitt williamson web server workload characterization 
search invariants proceedings acm sigmetrics conference measurement modeling computer systems sigmetrics martin arlitt tai jin world cup web site access logs http acm sigcomm ita august martin arlitt tai jin workload characterization world cup web site technical report hpl- hewlett packard labs andrea arpaci-dusseau remzi arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october mary baker john hartman martin kupfer ken shirriff john ousterhout measurements distributed file system proceedings acm symposium operating systems principles sosp pages paci grove california october rohit chandra scott devine ben verghese anoop gupta mendel rosenblum scheduling page migration multiprocessor compute servers proceedings international conference architectural support programming languages operating systems asplos pages san jose california october zhifeng chen yuanyuan zhou kai eviction-based placement storage caches proceedings usenix annual technical conference usenix pages san antonio texas june zarka cvetanovic dileep bhandarkar characterization alpha axp performance spec workloads proceedings international symposium computer architecture pages ian dowse david malone recent filesystem optimisations freebsd proceedings usenix annual technical conference freenix track emc corporation symmetrix enterprise information storage systems http emc theodore johnson dennis shasha low-overhead high performance buffer management replacement algorithm proceedings international conference large databases vldb pages santiago chile september norman jouppi improving direct-mapped cache performance addition small fully-associative cache prefetch buffers proceedings annual international symposium computer architecture isca pages seattle washington norman jouppi steven wilton tradeoffs two-level on-chip caching proceedings international symposium computer architecture pages kimberly keeton david patterson yong qiang roger raphael walter baker performance characterization quad pentium pro smp oltp workloads proceedings annual international symposium computer architecture isca pages june donghee lee jongmoo choi jun-hum kim sam noh sang lyul min yookum cho chong sang kim existence spectrum policies subsumes recently lru frequently lfu policies proceedings acm sigmetrics conference measurement modeling computer systems sigmetrics atlanta georgia lumb schindler ganger nagle riedel higher disk head utilization extracting free bandwidth busy disk drives proceedings symposium operating systems design implementation osdi pages san diego california october makaroff derek eager disk cache performance distributed systems international conference distributed computing systems icdcs pages paris france muntz honeyman multi-level caching distributed file systems cache ain nuthin trash proceedings usenix winter technical conference usenix winter pages san francisco california january drew roselli jacob lorch thomas anderson comparison file system workloads proceedings usenix annual technical conference usenix pages san diego california june muthian sivathanu vijayan prabhakaran florentina popovici timothy denehy andrea arpaci-dusseau remzi arpaci-dusseau semantically-smart disk systems proceedings usenix symposium file storage technologies fast pages san francisco california march theodore stephen tweedie future directions ext filesystem proceedings usenix annual technical conference freenix track john wilkes richard golding carl staelin tim sullivan autoraid hierarchical storage system acm transactions computer systems february darryl willick derek eager richard bunt disk cache replacement policies network fileservers international conference distributed computing systems icdcs pages pittsburgh pennsylvania theodore wong john wilkes cache making storage exclusive proceedings usenix annual technical conference usenix monterey california june yuanyuan zhou james philbin kai multi-queue replacement algorithm level buffer caches proceedings usenix annual technical conference usenix pages boston massachusetts june 
transforming policies mechanisms infokernel andrea arpaci dusseau remzi arpaci dusseau nathan burnett timothy denehy thomas engle haryadi gunawi james nugent florentina popovici department computer sciences wisconsin madison fdusseau remzi ncb tedenehy englet haryadi damion popovicig wisc abstract describe evolutionary path operating systems exible manner higher-level services infokernel exposes key pieces information algorithms internal state default policies mechanisms controlled user-level implemented prototype infokernels based linux netbsd kernels called infolinux infobsd infokernels export key abstractions basic information primitives infolinux implemented case studies showing policies linux manipulated kernel speci cally show default cache replacement algorithm layout policy disk scheduling algorithm tcp congestion control algorithm turned base mechanisms case study found infokernel abstractions implemented code overhead accuracy synthesizing policies user-level acceptable categories subject descriptors operating systems organization design general terms design experimentation performance keywords policy mechanism information introduction separating policy mechanism long goal operating system design informal nition view policy scheme deciding mechanism tool implementing set policies conceptually design simpler view distinct minimum separating policy mechanism build modular managing processes cpu traditional view dispatcher performs low-level context-switch mechanism scheduler decides process run policy conceptual division ectively isolates code change permission make digital hard copies part work personal classroom granted fee provided copies made distributed pro commercial advantage copies bear notice full citation rst page copy republish post servers redistribute lists requires prior speci permission fee sosp october bolton landing york usa copyright acm ported dispatcher change handle erent workloads scheduler ambitious goals separation enables extensible systems kernel implements mechanisms processes implement policies user-level suit alternatively design kernel processes download ideal policies directly practice cleanly separate policies mechanisms simplest mechanisms decisions embedded placing waiting process queue makes policy decision process inserted queue presence speci mechanisms dictates policies ciently pragmatically implemented words levin decision exclude policies lower-level kernel policy research explicitly strives push nition mechanism extreme safe protected image hardware operation implement policies ensure fairness competitors result mechanism policy viewed continuum policies implemented component act mechanisms layer system words features policy mechanisms depends perspective important challenge next-generation systems determine policies implemented traditional converted mechanisms higher-level services large amount functionality hundreds millions dollars invested thousands developer years spent commodity operating systems view existing policies mechanisms higher-level services built top radical restructuring operating system advocate evolutionary approach thesis paper key transforming policies implemented mechanisms export information internals operating system enhanced expose internal information infokernel work show functionality system signi cantly enhanced existing modi provide key pieces information internal state algorithms infokernel higher-level services require policies implement functionality services leverage default policies demonstrate feasibility approach modify linux kernel create infolinux implementation infolinux exposes values key data structures simple descriptions algorithms employs illustrate power information investigate case studies user-level services convert default linux policies controllable mechanisms illustrate succinctness approach show tens hundreds lines code required export information linux case studies focus major components cache management placement disk scheduling networking rst case study show user-level service convert linux q-based page replacement algorithm building block replacement algorithms mru lru lfu fifo show applications turn range system allocation policies controllable placement mechanism applications les directories disk show linux c-look disk scheduling policy transformed building block algorithms idle queue free-bandwidth scheduler finally demonstrate exporting information tcp reno altered controllable transport mechanism enabling user-level policies tcp vegas experience reveals fundamental abstractions infokernel support exporting comprehensive information infokernel retains level secrecy implementation enable innovation infokernel interface provide portability applications infokernel strives export fundamental abstractions expected hold policies represent page replacement algorithm infokernel report direct state page bits frequency bits dirty bits relevant state depends exact algorithm generalized abstraction desired list pages ordered expected evicted level detail export fundamental tension infokernel design case studies describe abstraction prioritized lists provide ective means exporting requisite information prototype infobsd derived netbsd veri abstractions easily implemented erent systems case studies uncover limitations infokernel approach relevant kernel state expressed ordered list user-level service directly manipulate ordering touching page increase priority primitives types services implemented limited disk scheduling networking case studies target policy substantially ers underlying kernel policy cult accurately mimic target policy behavior arises emulating mru top default linux algorithm finally list-reordering operations expensive involve disk accesses achieving control user-level prohibitively costly controlled placement case study exhibits property suggesting additional policy-manipulation machinery bene cial implementing infolinux discovered number information primitives streamline interactions user-level services infokernel application obtain information memorymapped read-only pages system calls interface depends frequency information needed internal structure application obtain information polling blocking kernel informs information changed case studies illustrate primitives structure remainder paper begin section addressing primary issues building infokernel section compare infokernels previous work section describe details primary implementation infolinux section describe case studies section discuss preliminary experience infobsd conclude section infokernel issues section discuss general issues infokernel begin presenting bene exposing information policies state higher-level services applications discuss fundamental infokernel tensions information exposed bene information transform policy implemented mechanism user-level process understand behavior policy erent conditions behavior policy function algorithms current state export information captures aspects providing information user-level processes manipulate underlying policy adapt behavior manipulate policy exposing algorithms internal state higher-level services running implement policies tailored knowledge services predict decisions make set inputs current state change decisions speci cally service implemented user-level library probes normal inputs reacts controlled manner application system performs prefetching observing sequential access pattern application blocks squelch prefetching intervening read random block policy limits preferences limits ensure measure fairness competing processes preferences workload behavior improve system performance converting source infokernel policy target user-level policy implies limits imposed source policy circumvented preferences biased general service bias preferences source policy overhead incurs disincentive obtaining control system-wide goals system allocation policy takes advantage higher bandwidth outer tracks multi-zone disk giving preference large les outer zone fairness system limits space allocated user zone process wishes allocate small outer tracks exceeded user per-zone quota process bias behavior system padding larger size case process pays time space overhead create large actions match default preferences system enable adaptation secondary bene providing information applications adapt behavior improved performance memory-intensive application amount physical memory process data multiple passes limiting working set avoid thrashing extreme process amount time remaining time slice decide acquire 
contentious lock expects preempted nishing critical section straightforward services directly adapt behavior indirectly manipulate behavior focus challenging issue controlling policy paper tensions design infokernel number design decisions made discuss issues pertaining amount information exposed exposing information process boundaries exposing information adding mechanisms amount information tension designing infokernel decide information exported hand exporting information bene cial priori information higher-level services hand exposing information greatly expands api presented applications destroys encapsulation put simply knowledge power ignorance bliss unfortunate implications application api expanded user-level service control page replacement algorithm page evicted service developed infokernel clock replacement application examines clock hand position bits service moved infokernel pure lru replacement service examine position page lru list perspective user-level service api implies service longer operates correctly signi cantly rewritten perspective xed api discourages developers implementing algorithms constrains evolution application portability infokernel information hidden provide abstractions sake innovation abstractions ciently high level operating system easily convert internal representations abstractions precisely determining correct infokernel abstractions requires experience large number case studies operating systems paper important rst step ning abstractions examining major components operating system cache management placement disk scheduling networking case studies describe abstraction infokernel export represent cache replacement algorithm prioritized list resident pages user-level services ciently determine pages evicted implementation illustrates implementing abstractions existing simple involves lines code process boundaries tension designing infokernel determine information competing processes exposed hand information processes exposed process optimize behavior relative entire system hand information processes process learn secrets harm performance process information processes hidden security privacy data read written contents memory pages information resource usage processes increase prevalence covert channels information higher cost resident page list curious process infer process accessing speci timing open system call curious process infer fast time inode cache infokernel hide information process boundaries performing work resident page list block number removed pages belong calling process issue addresses suitability competing applications running infokernel concern infokernel services encouraged game control harm processes acquire locks performing control potentially competes processes greedy process avoid advisory lock information greedy process acquire fair share resources greedy service pages memory touching evicted steal frames processes infokernel provide mechanisms behavior original albeit costly achieve infokernel support greedy process continually touch pages blindly imposing additional overhead entire system summary infokernel stresses role arbitrate resources competing applications limits existing policies impart responsibilities infokernel adequate policy limits suited non-competitive server workloads adding mechanisms nal issue determine kernel add mechanisms control simply exposing information question cult answer general requires side-by-side comparison desired piece functionality leave future work adding mechanism complex exposing information reasons consistent existing policy mechanism preferences policy violate limits policy mechanism explicitly check current invocation violate policy limits system user-level policy implemented infokernel performs check automatically complexity arises notifying user reasons mechanism failure cient level detail user submit request cient information request succeed future exposing details mechanism invocation violated policy similar exposing basic policy information task infokernel related philosophies infokernel extensible systems goal tailoring operating system workloads services user-speci policies primary erence infokernel strives evolutionary design realistic discard great body code contained current operating systems infokernel transforms existing operating system suitable building block infokernel approach erence extensible systems application-speci code run protected environment disadvantages advantages disadvantages infokernel exible range policies provide higher overhead indirectly controlling policies userlevel policies voluntarily processes advantage approach infokernel require advanced techniques dealing safety downloaded code software-fault isolation type-safe languages in-kernel transactions open question address simple control provided infokernel cient implement range policies idea exposing information explored speci components instance bene knowing cost accessing erent pages state network connections demonstrated infokernel generalizes concepts compare infokernel philosophy related philosophies detail exokernel open implementation gray-box systems goal exposing information stated exokernels exokernel takes strong position xed high-level abstractions avoided information page numbers free lists cached tlb entries exposed directly exokernel sacri ces portability applications erent exokernels information standard interfaces supplied library operating systems alternately infokernel emphasizes importance allowing operating systems evolve maintaining application portability exposes internal state abstractions systems map data structures philosophy open implementation project similar infokernel philosophy states part implementation details hidden interface mere details details bias performance resulting implementation authors propose ways changing interface clients modules allowing clients anticipated usage outline requirements download code module clients choose module implementation btree linkedlist hashtable approach exposes algorithm employed infokernel address importance exposing state finally relationship infokernels authors work gray-box systems philosophy gray-box systems acknowledges information applications existing operating systems leveraged graybox approach takes extreme position modi applications assume infer information number limitations implementing user-level services gray-box system removed infokernel gray-box system user-level services make key assumptions incorrect ignore important parameters operations performed service infer internal state impose signi overhead web server simulate cache replacement algorithm on-line infer current contents memory finally make correct inference circumstances service observe inputs outputs infokernel retains advantages leveraging commodity operating system user-level services built infokernel robust powerful gray-box system implementation infolinux section describe experience building prototype infokernel based linux infolinux strict superset linux interfaces added expose information control mechanisms policies modi point exercise demonstrate traditional operating system easily converted infokernel result prototype infolinux cient functionality demonstrate higher-level services extend existing linux policies abstractions policy information structure initial version infolinux abstractions key policies linux abstraction composed data structures algorithms enable portability user-level services erent infokernels data structures standardized data structures exported infolinux system calls user-level libraries user-level library accesses kernel memory directly key pages case study abstraction description inforeplace pagelist prioritized list in-memory pages victimlist list pending victim pages infoplace fsregionlist prioritized list disk groups dir allocation infosched diskrequestlist queue disk requests fileblocks list blk numbers inode data infovegas msglist list message segments table case studies infolinux abstractions case study paper present names abstractions employs short description mapped read-only address space memory-mapped interface processes avoid overhead system call rarely interesting data structures scattered kernel memory disk scheduling queue signi restructuring kernel place related information page case studies ned number fundamental infokernel abstractions summarized table detail section found commonality exists abstractions needed disparate policies case essential state information expressed terms prioritized list cases version list exists kernel cases infokernel construct list varied sources information abstract list disk scheduling policy simply 
existing scheduling queue separated device abstract list allocation policy cylinder groups group selected allocation head list constructed combining knowledge cylinder groups picked current state group represent algorithm infolinux prototype exports logical disk scheduling algorithm represented c-look sstf sptf naming method primitive sufcient initial demonstration existing policies infolinux controlled investigating general representation key aspects policy infokernel exports rules determine items list abstraction moved priority user processes predict item inserted list information primitives converting internal format data structures linux general representation required infokernel interface requires careful implementation choices found number information primitives making conversion simpler developer cient run time ers application periodically poll state infokernel polling performed frequently application miss important state infolinux mechanism recording data structure circular ers amortizing overhead system call values noti ers poll state service noti key data structure infolinux mechanism process block speci abstraction changed timers amount time operation takes reveal information infokernel time valuable inferring properties resource autonomy network disk infolinux mechanism add timers kernel return results user processes procedure counters infokernel export estimate state kernel count number times procedure called piece code executed infolinux mechanism add counters speci locations code primitives implemented dynamic kernel instrumentation tool dynamic instrumentation infokernel developer easily trace variables incur overhead tracing activated user process preliminary experience tool overhead enabling information primitives low ering variable typical system operations infolinux routine ext getblk incurs negligible overhead case studies demonstrate power infokernel approach implemented number case studies show policies infolinux converted controllable mechanisms examples focus major policies linux cache management placement disk scheduling networking case studies emphasize erent aspects infokernel exibility control provided range internal policies mapped general abstraction rate state information converting cache replacement policy mechanism show wide range target policies fifo lru mru lfu implemented user-level transforming system placement policy mechanism show infokernel abstraction ciently general capture important details variety policies directory allocation ext ffs temporal locality manipulations disk scheduling tcp congestion control algorithms show user-level policies frequent noti cation state implemented case study present infokernel abstraction suitably represents underlying policy describe export abstraction ciently infolinux present user-level library code implements policy top infokernel abstraction quantify accuracy overhead controlling policies comparing infolinux result modeled expectations in-kernel implementation cases approach perfect accuracy incur additional overhead common theme case studies overhead controlling policies user-level directly depends user desired control meshes preferences biases policy finally case study demonstrate usefulness user-level policy showing performance improvement workload compared default linux policy experimental environment experiments section employ number erent machine con gurations machine ghz pentium processor main memory -gb -rpm western digital ata ide hard drives machine mhz pentium processor main memory -gb -rpm ibm lzx scsi hard drives machine mhz pentium main memory -gb -rpm ibm gxp ata ide hard drive intel etherexpress pro ethernet ports netbed emulation environment multi-disk machines disk noted stress erent components system machines booted memory experiments run multiple times averages reported variance low cases shown file cache replacement erent applications bene erent cache replacement algorithms modifying replacement policy demonstrate exibility extensible systems functionality approximated infokernel environment rst case study user-level library inforeplace demonstrates variety replacement algorithms fifo lru mru lfu implemented top unmodi linux replacement algorithm begin describing intuition cache replacement policy treated mechanism giving replacement control applications case application wishes hot list pages resident memory target policy supports simple lru-replacement policy source policy ensure hot list remains resident user process pages evicted user process accesses page number times source replacement policy increase priority page generally replacement policy converted accessing pages evicted source policy evicted target policy infokernel abstractions support inforeplace user-level library infolinux export information applications determine victim pages operations move pages priority state linux converted form low overhead linux uni page cache q-like replacement policy rst referenced page active queue managed two-handed clock evicted page inactive queue managed fifo provide general representation prioritized list kernel task statements memory-map counter setup track page movement reset counter export victimlist total victimlist abstraction user-level task statements setup simulation framework target policies fifo lru mru lfu check victimlist refresh total inforeplace library table code size cache replacement case study number statements counted number semicolons needed implement victimlist abstraction infolinux inforeplace library user-level shown physical pages pagelist infolinux exports concatenation queues system call information inforeplace examine end queue pages interest drawback pagelist abstraction large number elements imposes signi overhead copying queue user space call made infrequently queue checked infrequently pages evicted user-level library notices infolinux victimlist abstraction pages full queue mechanism quickly determine pages added list infolinux exports estimate rapidly queues changing reporting times items moved inactive queue ciently counting number times key procedures called counter activated service registers interest fast access user-space mapped address space user process counter approximately equal process performs expensive call state pages inactive queue shown top half table victimlist abstraction implemented statements fact half code needed setup memory-mapped counter user-level policies victimlist abstraction user-level inforeplace library frequently poll pages eviction obtain list pages pages evicted target policy inforeplace accesses move active list roles inforeplace track pages resident target policy simplicity inforeplace library exports set wrappers applications call open read write lseek linux procedures shrink cache macro del page inactive list lfumrulrufifo percent missing pages target replacement algorithm inforeplace inaccuracy lfumrulrufifo time read target replacement algorithm inforeplace overheads misc sim refresh check figure accuracy overhead inforeplace fifo lru mru lfu implemented top q-based replacement algorithm linux bar graph left shows inaccuracy inforeplace inaccuracy percentage pages memory workload ends bar graph shows average overhead incurred read write time divided time check victimlist abstraction refresh pages evicted simulate target replacement algorithm perform miscellaneous setup experiments run machine close system calls library tracks pages accessed explicit calls infolinux expanded return access information page process address space read write inforeplace library rst performs simulation target replacement algorithm determine speci page belongs page queue inforeplace victimlist pages high priority eviction accesses nally library wrapper performs requested read write returns basic steps implemented fifo lru mru lfu top linux q-based replacement algorithm bottom half table shows amount code needed implement inforeplace thousand statements required code straightforward bulk simulation erent replacement policies overhead accuracy evaluate overhead accuracy 
infokernel approach run synthetic workload speci cally crafted stress choices made replacement algorithms workload accesses large times size memory touching blocks initial access order recency frequency attributes block blocks evicted depends attributes replacement policy considers measure accuracy target policy end run comparing actual contents memory expected contents figure shows accuracy overhead implementing algorithms infolinux graph run time workload run time pinrange hit rate level index hit rate level index pinrange figure workload bene inforeplace graph left depicts run-time synthetic database index lookup workloads systems bars labeled show run time index lookups stock linux kernel bars labeled pinrange show run time specialized pinrange policy infolinux x-axis varies workload speci cally depth fan-out index implies index depth fan-out graph shows details pinrange speeds performance workload showing hit rate erent levels -level index experiments run machine left shows inaccuracy inforeplace ned percentage pages resident memory target replacement algorithm metric pages memory target policy pages resident inaccuracy general inaccuracy inforeplace low inaccuracy mru highest roughly resident pages preferences mru highly con ict emulating mru inforeplace constantly probe pages memory graph figure shows overhead implementing policy terms increase time read write operation time broken time check victimlist abstraction probe pages evicted simulate target replacement algorithm perform miscellaneous setup overhead inforeplace generally low read write call exception pure lfu incurs high simulation overhead roughly call due logarithmic number operations required read write order pages frequency assuming cost missing cache high overhead emulating lfu pays miss rate reduced workload bene database researchers observed policies provided general-purpose operating systems deliver suboptimal performance database management systems demonstrate utility inforeplace provide cache replacement policy inspired dbmin suited database index lookups indices dbms systems typically organized trees replacement policy nodes root tree memory pages higher probability accessed simplicity policy pinrange assumes index allocated root head leaves end pinrange pages preference based set pages rst bytes large lru queue remaining pages smaller queue pinrange simple implement requiring roughly statements inforeplace library demonstrate bene inforeplace repeated index lookups compare workload run-time pinrange versus default linux replacement policy note fairly sophisticated policy introduced database community speci cally handle types access patterns result preference pages top tree experiments run synthetic workloads emulating lookups index trees levels fan-out machine memory pinrange con gured prefer rst main memory graph left figure shows pinrange improves run-time erent trees illustrate pinrange improves performance graph figure plots hit rate function index level tree levels fan-out graph shows pinrange noticeably improves hit rate sixth level tree slightly reducing hit rate lowest seventh level tree improvement total hit rate results decrease run-time includes approximately seconds overhead inforeplace library summary case study shows replacement policies implemented information exposed victimlist abstraction ciently exible build variety classic replacement algorithms compares favorably direct in-kernel implementations cao work applications easily invoke policies combination lru mru strategies system difculty emulating behavior wider range policies lfu case study illustrates care ciently perform conversion internal state general victimlist abstraction inforeplace demonstrates target replacement algorithms similar source algorithm implemented accuracy overhead file directory placement o-intensive applications database systems web servers bene controlling layout data disk systems provide type control applications placement les demonstrate power extensible systems gray-box systems ability group related objects nextgeneration storage systems describe infoplace placement service case study demonstrate points placement functionality implemented lower kernel task statements collect region stats convert stats fsregionlist ext temporal data ffs export fsregionlist total fsregionlist abstraction user-level task statements framework setup directory allocation file allocation fill regions cache directories total infoplace library table code size placement case study number statements counted number semicolons needed implement fsregionlist abstraction infolinux shown kernel layout policies ext temporal data block ffs infoplace library overhead infokernel gray-box techniques erent kernel policies mapped common infokernel representation enabling innovation infokernel abstractions describe placement policy abstraction prioritized list regions disk fsregionlist list ordered beginning region allocation data operations performed reduce priority region infokernels freedom disk regions erently demonstrate generality abstraction explore erent kernel placement policies map representation begin default placement policy ext linux ffs-based systems maintain locality disk allocation cylinder group block group natural mapping region cylinder group abbreviated simply group placement policy ext les group parent directory directory group free data blocks average number free inodes simplicity focus abstracting directory placement policy placement exporting directory fsregionlist straightforward previous case study case priority group derived directory placement algorithm current state group speci cally free inodes free data block count map parameters precise ordering infolinux rst places cylinder groups categories average number free inodes average infolinux sorts category number free data blocks concatenates nal ordered list step infolinux describe erent system operations decrease priority group fsregionlist altering free inode data block counts ext placement algorithm decrease priority group future allocations infolinux considers cases groups average number free inodes infolinux reports creations zero-length les performed number free inodes average average infolinux reports creation block created number additional free data blocks group compared list understand challenges controlling directory placement top erent placement policies implemented variety policies linux kernel original ffs algorithm group fewest directories average number free inodes chosen case mapping prioritized list identical ext number directories data blocks simple placement algorithm selects group free data blocks case prioritized list simply orders groups number free data blocks finally temporal allocation cylinder group chosen previous group full algorithm prioritized list simply distance group hot group temporal allocation operation lowers group priority create empty les block number free inodes number free data blocks group choice made infolinux min amount code required implement fsregionlist abstraction shown top half table exporting system abstraction involves non-trivial amount code list explicitly exist linux expected creating fsregionlist complex directory placement policies ext ffs requires code straightforward policies temporal data user-level policies steps performed infoplace similar gray-box version place brie describe place place assumes running ext system group parent directory simple trick allocate named group place creates directory previously allocated group place renames speci user infoplace steps les controlling placement directories complicated place infoplace operation place repeatedly creates directory checks inode number directory allocated directory correct group steps move groups closer state target group chosen eventually place succeeds comparison infoplace begins 
obtaining fsregionlist priority list target group rst infoplace allocates directory veri infolinux directory created desired group race occur activity system target list infoplace performs designated time imbalance thousands inodes controlling ext place infoplace time percentage imbalance comparing allocation algorithms data ext ffs temporal figure overhead placement infoplace graph left compares overhead controlling allocation infoplace versus place information current state system time perform allocation target group shown y-axis target group fewest free inodes inode imbalance ned number inodes allocated groups identical number inodes graph compares overhead erent directory allocation policies linux data chooses group free data blocks ext default ext policy ffs original ffs policy temporal allocates directories hot group group completely lled nition imbalance varies allocation policies x-axis scenarios percentage maximum imbalance cylinder groups algorithm experiments run machine number type operations creating zero-length dummy les groups preceding re-obtains list groups repeating process target head successfully complete infoplace cleans removing zero-length dummy les place infoplace expensive directory allocation algorithm time user speci location directory common operation retain cache directories erent groups user speci target group libraries simply rename existing directories group target group cache empty explicit control needed analysis server traces typical day directories created upper bound entries added directory cache nighttime cron job amount code required implement infoplace library shown bottom half table overhead accuracy rst experiment shows information state system helps infoplace perform controlled placement ciently gray-box version place rst graph figure show time overhead place directory target group function imbalance imbalance ned number items inodes data blocks lled non-target groups target group move front list show accuracy versions provide complete accuracy expected versions overhead control increases inode imbalance increases representing amount ght placement preferences ext policy graph dramatically shows bene information overhead place times higher infoplace experiments shown graph figure illustrate cost infoplace depends directory placement algorithm key predicting cost correctly imbalance terms inodes data blocks overhead function imbalance cost creating needed items placement policies non-target groups primarily inodes ext ffs temporal cost policies data blocks data block algorithm cost graph show imbalance expected occur workload running placement policy expect imbalance ext ffs data block policies tend low algorithms balance usage disk imbalance temporal allocation tend high allocations group overhead controlling layout constant imbalance policies typical imbalance vary polices workload bene demonstrate utility infoplace library show bene results les accessed time reorganized disk shown bene general block-level le-level reorganization show simply standard tool modi advantage placement control provided infoplace speci cally modify tar program place les directories unpacked single localized portion disk demonstrate bene optimization unpack large archive case entire tree linux documentation project size unpacked directory tree roughly les directories run experiment machine memory infoplace initialized pre-built cache directories unmodi tar utility running linux takes seconds complete average enhanced tar completes unpacking roughly faster seconds bene achieved slightest modi cations tar statements added call infoplace library summary case study demonstrates erent directory placement policies implemented mapped infokernel abstraction infoplace takes initial steps showing abstract algorithm expressing operations lower priority group prioritized list case study shows overhead control strict function target end state ers desired native system placement policy finally study demonstrates standard utilities bene control provided infoplace library kernel task statements setup export diskrequestlist wait diskrequestlist change total diskrequestlist user-level task statements setup misc diskrequestlist issue request total infoidlesched library setup misc disk model pick background request total infofreesched library table code size disk scheduling case study number statements counted number semicolons needed implement diskrequestlist abstraction infolinux shown counts user-level libraries infoidlesched infofreesched disk scheduling researchers demonstrated applications bene advanced disk scheduling algorithms traditional sstf c-look algorithms case study demonstrate exposing information disk scheduler implement scheduling policies top infolinux speci cally show idle disk scheduler infoidlesched limited freeblock disk scheduler infofreesched implemented user-level libraries top infolinux infokernel abstractions describe disk scheduling policy infokernel exports requests disk scheduling queue cient detail disk scheduling algorithm predict queue request infolinux system calls obtain diskrequestlist processes block diskrequestlist exports scheduling algorithm c-look amount code needed export diskrequestlist reported table addition infofreesched detailed information overheads erent disk operations infofreesched timing primitives infolinux obtain coarse disk model times successive requests disk observed recorded linear block distance requests key index model shown capture seek head switch costs probabilistically capture rotational latency small enhancements needed capture aspects modern disks zoning user-level policies amount code scheduling policies shown table infoidlesched simple disk scheduling algorithm process schedule requests disk idle infoidlesched simply checks diskrequestlist scheduling queue remains empty threshold amount time infoidlesched issues single request queue empty infoidlesched waits state queue change waking items removed recheck queue infofreesched complex freeblock scheduler freeblock scheduling periods rotational latency disk lled data transfers words background tra serviced disk head moving requests impacting foreground tra lumb implement freeblock scheduling disk rmware simpli service time prediction subsequent work freeblock scheduling implemented freebsd kernel user-level scheduling testbed implementing freeblock scheduling top infolinux presents challenges user speci set infofreesched convert disk addresses conversion performed fileblocks infokernel interface predicting newly written blocks allocated disk complex infofreesched schedules read trafc limited setup tasks raid scrubbing virus detection backup infofreesched complete control requests disk scheduling queue requests ordered infofreesched choose background request inserted describe step detail list background requests infofreesched knowledge scheduling algorithm c-look predict background request inserted scheduling queue infofreesched determined request inserted requests infofreesched calculates background request harm harm determined indexing disk timing table linear block distance requests background request impact time foreground request allowed proceed optimization infofreesched schedules background request impact foreground tra infofreesched blocks waiting noti infolinux state disk queue changed infofreesched wakes rechecks background requests serviced overhead accuracy evaluate overhead placing disk scheduling policy user-level complicated infofreesched policy stress infofreesched random-i workload disk idle foreground tra consists processes continuously reading small les chosen uniformly random single background process reads random blocks disk keeping requests outstanding read performed infofreesched incurs overheads roughly obtain diskrequestlist infolinux approximately background request examined determine issued disk infofreesched examines requests background queue overhead induced negligible sum compared multi-millisecond disk latencies workload bene demonstrate utility infoidlesched show ability expose idle queue system activity traces labs foreground tra run minutes 
trace starting december rst created directory structure les trace run issue background tra stream blocks disk sequentially shown figure infoidlesched support background requests idlesched bandwidth infoidlesched background foreground freesched bandwidth infofreesched background foreground figure workload bene infoidlesched infofreesched graph left shows performance foreground background tra infoidlesched leftmost bar shows foreground tra competing background tra middle bar competing tra standard linux rightmost bar infoidlesched graph shows similar graph infofreesched workloads erent graphs text experiments run machine signi cantly degrade foreground performance read requests trace achieve background tra grabs infoidlesched support background tra limited desired foreground read requests achieve bandwidth background tra obtains background request stream induce small decrease foreground performance infoidlesched library aggressive idle scheduler reduce overhead reduce background bandwidth achieved demonstrate ability infofreesched free bandwidth random-i workload overhead experiment figure random foreground tra isolation achieves background requests added support infofreesched foreground tra harmed proportionately achieving background tra achieves background requests infofreesched foreground tra receives background tra obtains free bandwidth summary case studies stress infokernel approach infolinux user-level processes uence decisions disk scheduler ordering requests disk queue result user-level policies decide perform disk request time cult implement freeblock scheduler top system due culty predicting write tra system investigate future work case study shows importance infolinux primitives blocking state abstraction timing duration operations kernel task statements rtt timers wait wake export msglist total msglist abstraction user-level task statements setup main algorithm error handling total infovegas library table code size networking case study number statements counted number semicolons needed implement tcp msglist abstraction infolinux shown upper table lower table presents code size implementing congestion-control policy infovegas user-level networking networking research shown variations tcp algorithm superior erent circumstances erent workloads implemented small variations sending algorithm case study show tcp congestion control algorithm exported user-level processes manipulate behavior speci cally infovegas show tcp vegas implemented top tcp reno algorithm linux similar research network protocols userlevel infokernel infrastructure enables bene shortened development cycle easier debugging improved stability infokernel abstractions manipulate congestion control algorithm main abstraction infokernel msglist list packet packet infolinux exports state waiting acknowledged dropped round-trip time acknowledged variables snd una snd nxt speci tcp rfc exported derived message list tcp reno record round-trip time message high resolution timer times gathered infolinux timing primitives user-level policies basic intuition infovegas calculates target congestion window vcwnd msglist important parameters tcp vegas minrtt basertt derived information infovegas ensures forwards target vcwnd message segments time underlying infokernel finally infovegas blocks state message queue message acknowledged point infovegas send segment adjust calculation target vcwnd amount code implement functionality shown table overhead accuracy experiments verify infovegas behaves similarly in-kernel implementabandwidth queue size packets macroscopic behavior vegasinfovegas reno figure accuracy infovegas macroscopic behavior emulation environment figure experiments emulate network bandwidth delay vary router queue size x-axis y-axis reports bandwidth achieved linux vegas infovegas reno tion vegas linux macroscopic microscopic levels figure shows infovegas achieves bandwidth similar vegas variety network con gurations router queue size changed numbers illustrate space queue decreases reno unable obtain full bandwidth due packet loss infovegas vegas achieve full bandwidth queue space desired figure illustrates behavior infovegas time compared reno in-kernel vegas desired cwnd derived infovegas time closely matches vegas ering signi cantly reno finally infovegas accurately implements vegas functionality user-level low overhead measurements show cpu utilization increases infovegas compared approximately in-kernel vegas workload bene illustrate bene infovegas prototype clustered server specifically nfs storage server con gured front-end node handles client requests backend storage units machines connected switch runs infolinux back-end storage units continuously perform work background replicating important les disks performing checksums data reorganizing les disk ideally background tasks interfere foreground requests front-end workload stresses network front-end handles nfs requests les cached memory back-end node background replicator process replicates les back-end node back-end node results figure show contention network controlled infovegas streams contend network link bandwidth shared approximately equally foreground tra achieves replication process infovegas background tra interferes minimally foreground tra background tra obtains packets time reno cwnd time infovegas vcwnd cwnd diff time vegas cwnd diff figure accuracy infovegas microscopic behavior behavior reno infovegas in-kernel vegas compared time network con guration sender running infolinux receiver running stock linux machines acting routers single network exists source destination machine passes emulated bottleneck delay maximum queue size packets rst graph shows cwnd calculated reno graph shows infovegas cwnd exported reno derived target vcwnd derived parameter graph shows cwnd calculated linux native vegas implementation experiments run machines netbed testbed foreground tra achieves full line rate gure shows cpu utilization machines experiments revealing small additional cost infovegas service summary infovegas stresses limits infokernel control service react quickly frequent events occur inside kernel receiving acknowledgment overhead handling event circumstances infovegas pays overhead reduces bandwidth generally congestion control algorithm implemented infokernel viewed base sending mechanism aggressive policy allowed algorithm speci limit preference network resource congestion control policies built top infolinux send lower rate exposed primitive tcp friendly discussion brie compare user-level policies explored case studies discussion centers fact case study categories depending user-level process reorder relevant items infokernel prioritized list rst category libraries control policy changing order items related infokernel list inforeplace touches page increase priority infoplace allocates inodes data blocks group decrease priority libraries uence current future requests handled relative existing items list category overhead implementing policy user-level direct function overhead reorganizing list case studies shown infoplace inforeplace provide performance bene applications extreme circumstances overhead performing probes high inforeplace category libraries reorder items related lists libraries exert preferences limiting requests inserted related lists infoidlesched infofreesched infovegas libraries maintain order queue requests issue requests well-controlled times process retract decision insert item policies conservative initiating requests adapt quickly changing conditions infoidlesched send background requests disk queue increasing chances background request interfere foreground request arrives likewise infovegas react immediately network conditions change group messages issued experience infobsd section describe initial experience building prototype infobsd netbsd discussion focus main erences infobsd infolinux implementations date implemented memory management disk scheduling networking abstractions leave placement future work pagelist abstraction infobsd similar infolinux netbsd xed-sized cache primary erence infokernels infolinux pagelist page memory infobsd pages cache netbsd cache managed pure 
lru replacement infobsd simply exports lru list pagelist elements victimlist enable processes quickly determine elements moving lists infobsd tracks number evictions occurred lru list statements needed export abstractions infobsd primary savings compared infolinux requires statements infobsd provide memory-mapped interface eviction count diskrequestlist abstraction straightforward export infobsd chief erence infolinux infobsd relates layer system responsible maintaining device scheduling bgfg throughput cluster throughput background foreground bgfg cpu utilization bandwidth normalized cpu utilization figure workload bene infovegas graph left shows impact contention network infovegas background replication stream y-axis plots bandwidth delivered bar represents experiment combination foreground background tra infovegas graph depicts normalized cpu utilizations experiments cpu utilization bandwidth observe additional cpu overhead running infovegas experiments run machines type queues linux generic level maintains queues block devices infolinux generic level exports diskrequestlist abstraction netbsd generic level exists device type scsi ide export diskrequestlist abstraction independently lines code needed provide information infobsd infobsd requires statements infolinux linux code required access queue check finally infobsd implementation msglist requires relative infolinux version primary erence tcp linux skb ers network packet tcp netbsd mbuf ers multiple packets data structure netbsd cult add time-stamp packet needed msglist infobsd creates maintains queue packets time unacknowledged packet result infolinux statements msglist infobsd requires statements signi increase nal amount code small exercise shown abstractions exported infolinux straight-forward implement infobsd hopeful list-based abstractions ciently general capture behavior unix-based operating systems creating infokernels cult note infokernels export interfaces directly leverage user-level libraries created case studies majority code resides conclusions layering technique long building computer systems breaking larger system constituent components layering makes process building system manageable resultant separation modules increases maintainability facilitating testing debugging layering negative side-e ects traditional arguments layering implementationoriented observation layers network protocol stacks induce extra data copies insidious impact design architects layer encouraged hide details information layer system concealed layers paper argued operating systems avoid pitfall design export general abstractions describe internal state abstractions list memory pages eviction disk requests scheduled user-level services control policies implemented surprising ways information policies implemented transformed mechanisms usable services case studies stressing erent components cache management placement disk scheduling networking explored issues infokernel design ned abstractions infokernel export experience shown abstractions represented prioritized lists found number information primitives implementing abstractions procedure counters timers ability block infokernel state general found power infokernel approach depends closely desired control matches policy kernel infokernel user-level policies operate limits underlying kernel policy user-level policies bias preferences policy result target policies mesh inherent preferences policy implemented high accuracy low overhead found ability user-level processes ciently manipulate internal lists touching page increase priority enables powerful services built top infokernel knowledge serve guide developing future infokernels infokernels export operations ciently reorder retract items in-kernel prioritized lists exible building blocks implementing user-level policies acknowledgments john bent brian forney muthian sivathanu vijayan prabhakaran doug thain helpful discussions comments paper john bent storage server implementation brian forney trace analysis michael marty jacob kretz initial gray-box implementation inforeplace kirk webb netbed team con guring linux netbed computer systems lab providing superb research environment john wilkes excellent demanding shepherding substantially improved content presentation numerous aspects paper anonymous reviewers helpful suggestions finally give special grandparents arpaci niara vedat grandparents dusseau anita richard traveling madison taking care anna weeks submission due authors worked requisite long nights nal weeks work sponsored part nsf ccrngs- ccrccr- itrthe wisconsin alumni research foundation ibm faculty award ndseg fellowship department defense akyurek salem adaptive block rearrangement acm transactions computer systems allman balakrishnan floyd rfc enhancing tcp loss recovery limited transmit august ftp ftp rfc-editor in-notes rfc txt august arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages ban canada october bershad savage pardyak sirer fiuczynski becker chambers eggers extensibility safety performance spin operating system proceedings acm symposium operating systems principles sosp pages copper mountain resort colorado december brakmo malley peterson tcp vegas techniques congestion detection avoidance proceedings sigcomm pages london united kingdom august burnett bent arpaci-dusseau arpaci-dusseau exploiting gray-box knowledge ercache contents proceedings usenix annual technical conference usenix pages monterey california june cao felten implementation performance application-controlled file caching proceedings symposium operating systems design implementation osdi pages monterey california november cardwell bak tcp vegas implementation linux http flophouse neal linux-vegas august cheriton zwaenepoel distributed kernel performance diskless workstations proceedings acm symposium operating system principles sosp pages bretton woods hampshire october chou dewitt evaluation management strategies relational database systems proceedings international conference large data bases vldb pages stockholm sweden august dijkstra structure multiprogramming system communications acm druschel pai zwaenepoel extensible kernels leading research astray proceedings workshop workstation operating systems wwos-vi pages cape codd massachusetts ely savage wetherall alpine user-level infrastructure network protocol development proceedings usenix symposium internet technologies systems usits pages san francisco california march engler kaashoek toole exokernel operating system architecture applicationlevel resource management proceedings acm symposium operating systems principles sosp pages copper mountain resort colorado december gibson nagle amiri chang gobio riedel rochberg zelenka filesystems network-attached secure disks technical report cmu-cs- carnegie mellon hoe improving start-up behavior congestion control sheme tcp proceedings sigcomm pages stanford california august iyer druschel anticipatory scheduling disk scheduling framework overcome deceptive idleness synchronous proceedings acm symposium operating systems principles sosp pages ban canada october jacobson wilkes disk scheduling algorithms based rotational position technical report hpl-csp- hewlett packard laboratories jacobson congestion avoidance control proceedings sigcomm pages stanford california august johnson shasha low-overhead high performance management replacement algorithm proceedings international conference large databases vldb pages santiago chile september kaashoek engler ganger brice hunt mazi eres pinckney grimm jannotti mackenzie application performance flexibility exokernel systems proceedings acm symposium operating systems principles sosp pages saint-malo france october kiczales lamping lopes maeda mendhekar murphy open implementation design guidelines international conference software engineering icse pages boston massachusetts kiczales lamping maeda keppel mcnamee customizable operating systems proceedings workshop workstation operating systems wwos-iv pages napa california october lampson hints computer system design proceedings acm symposium operating system principles sosp pages bretton woods hampshire october levin cohen corwin pollack wulf policy mechanism separation hydra proceedings acm symposium operating systems principles sosp pages texas austin november liedtke micro-kernel construction proceedings acm symposium operating 
systems principles sosp pages copper mountain resort colorado december lumb schindler ganger nagle riedel higher disk head utilization extracting free bandwidth busy disk drives proceedings symposium operating systems design implementation osdi pages san diego california october lumb schindler ganger freeblock scheduling disk firmware proceedings usenix symposium file storage technologies fast pages monterey california january matthews roselli costello wang anderson improving performance logstructured file systems adaptive methods proceedings acm symposium operating systems principles sosp pages saint-malo france october mckusick joy fabry fast file system unix acm transactions computer systems august nugent arpaci-dusseau arpaci-dusseau controlling place file system gray-box techniques proceedings usenix annual technical conference usenix pages san antonio texas june neil neil weikum lru-k page replacement algorithm database disk ering proceedings acm sigmod international conference management data sigmod pages washington peacock kamaraju agrawal fast consistency checking solaris file system proceedings usenix annual technical conference usenix pages orleans louisiana june pearce kelly harder field gilk dynamic instrumentation tool linux kernel proceedings international conference modeling tools techniques computer communication system performance evaluation tools pages london united kingdom april popovici arpaci-dusseau arpacidusseau robust portable scheduling disk mimic proceedings usenix annual technical conference usenix pages san antonio texas june postel rfc transmission control protocol september ftp ftp rfc-editor in-notes rfc txt august riedel kallahalla swaminathan framework evaluating storage system security proceedings usenix symposium file storage technologies fast pages monterey california january rosu rosu kernel support faster web proxies proceedings usenix annual technical conference usenix pages san antonio texas june ruemmler wilkes disk shu ing technical report hpl- hewlett packard laboratories schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon november seltzer chen ousterhout disk scheduling revisited proceedings usenix winter technical conference usenix winter pages washington january seltzer endo small smith dealing disaster surviving misbehaved kernel extensions proceedings symposium operating systems design implementation osdi pages seattle washington october shenoy vin cello disk scheduling framework next-generation operating systems proceedings joint international conference measurement modeling computer systems sigmetrics performance pages madison wisconsin june smaragdakis kaplan wilson eelru simple ective adaptive page replacement proceedings acm sigmetrics conference measurement modeling computer systems sigmetrics pages atlanta georgia staelin garcia-mollina smart filesystems proceedings usenix winter technical conference usenix winter pages dallas texas january stonebraker operating system support database management communications acm july tamches miller fine-grained dynamic instrumentation commodity operating system kernels proceedings symposium operating systems design implementation osdi pages orleans louisiana february van meter gao latency management storage systems proceedings symposium operating systems design implementation osdi pages san diego california october van renesse masking overhead protocol layering proceedings sigcomm pages stanford california august venkataramani kokku dahlin tcp-nice mechanism background transfers proceedings symposium operating systems design implementation osdi pages boston massachusetts december wahbe lucco anderson graham cient software-based fault isolation proceedings acm symposium operating systems principles sosp pages asheville north carolina december white lepreau stoller ricci guruprasad newbold hibler barb joglekar integrated experimental environment distributed systems networks proceedings symposium operating systems design implementation osdi pages boston massachusetts december young tevanian rashid golub eppinger chew bolosky black baron duality memory communication implementation multiprocessor operating system proceedings acm symposium operating systems principles sosp pages austin texas november 
robust portable scheduling disk mimic florentina popovici andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison abstract propose approach scheduling performs on-line simulation underlying disk simulation integrated system key challenges addressed rst simulator portable full range devices conguration automatic computation memory overheads low simulator disk mimic achieves goals building table-based model disk observes times previous requests show shortest-mimicked-timerst smtf scheduler performs approach perfect knowledge underlying device superior traditional scheduling algorithms c-look sstf results hold seek rotational characteristics disk varied introduction high-performance disk schedulers explored research literature progressively tuned performance characteristics underlying disks generation disk schedulers accounted behavior storage devices time disk schedulers analyzed focused minimizing seek time seek time order magnitude greater expected rotational delay early focus disk schedulers shifted rotational delay account rotational delays seek costs balanced level sophistication disk scheduler takes aspects underlying disk account track cylinder switch costs cache replacement policies mappings logical block number physical block number zero-latency writes worthington demonstrate algorithms effectively utilize prefetching disk cache perform intricate knowledge scheduler disk barriers realization operating system kernels speci cally obstacles overcome scheduler discover detailed knowledge underlying disk variety tools automatically acquire portions knowledge embedded disk model employed scheduler resulting scheduler con gured handle single disk speci characteristics disk scheduler knowledge current state disk exact position disk head head position exposed current disk controllers position predictable due low-level disk techniques wear leveling predictive failure analysis log updates scheduler control current position non-trivial techniques finally computational costs detailed modeling high uncommon time model request time larger time service request due dif culties disk schedulers leverage basic seek costs implemented real disks rotational position previous work performed simulation environments schedulers recently implemented researchers contained substantial simpli cations painstakingly tuned small group disks surprisingly disk schedulers found modern operating systems linux netbsd solaris attempt minimize seek time approach promising alternative approach embedding detailed knowledge disk scheduler embed on-line simulator disk scheduler scheduler on-line simulation underlying storage device predict request queue shortest positioning time variety disk simulators exist targeted performing traditional off-line simulations infrastructure performing on-line simulation fundamentally respects requirements on-line simulator stringent off-line simulator on-line simulator portable simulator model behavior disk drive practice on-line simulator automatic run-time con guration precise characteristics proceedings usenix annual technical conference june san antonio texas underlying device constructing simulator highly undesirable human administrator interact simulator finally on-line simulator low overhead computation memory overheads on-line simulator minimized simulator adversely impact system performance addition complexity introduces on-line simulator ample opportunities simpli cation on-line simulator opportunity observe run-time behavior device simulator con gure simulator adjust behavior device time on-line simulator specialized problem domain question finally on-line simulator parameterizable on-line simulator exploring versions device simulator functional model device contributions address implement scheduler aware underlying disk technology simple portable robust manner achieve goal introduce disk mimic meets requirements on-line simulator disk scheduling disk mimic based simple table-based approach input parameters simulated device index table entry table predicted output device table-based approach on-line simulation portably capture behavior variety devices requires manual con guration performed computational overhead signi challenge size table tractable identify input parameters signi cantly impact desired outputs method reducing input space depends largely domain on-line simulator deployed show disk scheduling input parameters suf cient predicting positioning time logical distance requests request type inter-request distance prediction issues resolved inter-request distance fairly coarse predictor positioning time result high variability times requests distance implication disk mimic observe instances distance summary metric distribution experimentally found summarizing small number samples works large number inter-request distances modern disk drive disk mimic record distances table reasonable size show simple linear interpolation represent ranges missing distances long number interpolations range checked measured values propose disk life scheduling death algorithm block-level shortestmimicked-time- muthian rst sivathanu smtf lakshmi picks bairavasundaram request andrea predicted arpaci-dusseau disk remzi mimic arpaci-dusseau computer sciences department wisconsin madison muthian laksh dusseau remzi wisc abstract fundamental piece information required intelligent storage systems liveness data formalize notion liveness storage present classes techniques making storage systems liveness-aware explicit notification approach shortest positioning time demonstrate smtf scheduler utilize disk mimic ways specifically disk mimic con gured off-line on-line approaches performed automatically disk mimic present robust techniques file system impart liveness information con storage gured off-line free block performs command series implicit probes detection disk approach show inter-request distances information records inferred resulting storage times system efficiently underneath scenario range file disk systems mimic complete control storage interface inter-request demonstrate distances techniques observed interpolated disk prototype mimic implementation con gured secure deleting on-line disk records find requests explicit running interface workload approach resulting desirable times due note simplicity implicit disk approach mimic easy con deploy gured off-line enables quick on-line demonstration simulation functionality performed facilitating on-line rapid migration active explicit interface introduction life pleasant death peaceful transition system show troublesome isaac disk asimov mimic smarter storage systems significantly improve understand throughput disks blocks high live utilization dead speci previous cally work variety demonstrated simulated utility real disks c-look knowledge dead sstf blocks perform store slower rotationally smtf optimal replicas demonstrate data provide disk zero-cost mimic writes successfully con failure gured recovery on-line time show reduced restoring disk mimic live learns blocks storage device liveness smtf information performs worse base modern storage scheduling systems algorithm due c-look narrow sstf blockbased quickly interface performs file close systems off-line con storage guration storage systems simply observe block-level reads writes aware logical operations deletes issued file system limitation precludes storage level approximately optimizations requests rest makes paper organized effective section paper describe address smtf limitation scheduler presenting detail techniques section storage systems describe disk imparted mimic liveness describe information basic perform methodology qualitative evaluation quantitative section comparison investigate approaches issues explicit con guring notification augment disk mimic interface offline storage section free block describe command file additional systems complexities modified con guring properly disk mimic implicit on-line detection show develop performance techniques enable section finally describe related work section conclude section scheduler modern disks implement scheduling device suggest system scheduling obsolete reasons system perform scheduling disks schedule limited number simultaneous requests restrictive space computational power constraints instances storage system increased infer functionality liveness requires information scheduling change system interface level evaluate iyer approaches druschel introduce short formalize waiting notion times liveness scheduler storage proceedings specifically usenix identify annual technical classes conference liveness june content san block antonio generation texas liveness preserve present continuity techniques stream explicit requests implicit single tracking process type interleaving streams techniques imparting liveness processes information shenoy dependent vin implement characteristics service file requirements system study applications range implementing file systems scheduling including framework ext ext system vfat brie describe identify key approach file system properties system impact scheduler feasibility leverages complexity disk mimic techniques refer gain direct algorithm experience implemented scheduler liveness-tracking shortest-mimicked-timerst methods smtf design basic implement function evaluate smtf performs prototype secure order deleting disk queue shreds requests blocks request logically deleted shortest positioning file time system making determined deleted disk data mimic scheduled irrecoverable implement secure delete basic due role extreme requirements optimizations type made accuracy assumptions liveness information paper surface explicit assume implicit approaches goal obvious benefits scheduler drawbacks optimize explicit throughput notification storage promises system simplicity implementation fairness requires broad scheduler industry consensus implicit detection techniques suggests achieving ease fairness deployment weighting cost complexity analysis reveals request age added complex trade-offs find qualitatively explicit approach complicated design implement straightforward modify file systems issue free block commands accurate notification presence crashes entails careful integration file system consistency management schemes noticeably increasing complexity find implicit liveness detection feasible underneath range modern file systems file system behaviors prohibit classes liveness inference identify properties hold order enable simplify implicit liveness inference propose implement minor modifications file systems conform properties finally show implicit liveness detection accurate underneath modern asynchronous file systems secure delete prototype utilizes implicit liveness shred blocks inferred dead proving correct operation implicit secure delete demonstrate implicit liveness storage applications appears sixth symposium operating systems design implementation osdi extreme correctness requirements evaluating performance implicit liveness tracking find comparable explicit approach conclude storage systems easily implement explicit approach interface embellished support implicit approach complementary competitive technology industry consensus interface change slow-moving implicit techniques complex specifically deploying technology explicit interface change implicit techniques readily demonstrate benefits move industry rapidly explicit change paper organized present extended motivation taxonomy liveness list file system properties impact techniques imparting liveness information proceed discussing explicit notification implicit detection describe secure deletion describe initial experience implicit detection ntfs closed-source file system finally present discussion relative merits implicit explicit approaches finish discussing related work concluding appendix includes proof correctness implicit secure delete extended motivation section present examples functionality enabled liveness information motivate alternative approaches gathering information utility liveness liveness information enables variety functionality performance enhancements storage system enhancements implemented higher layers require low-level control storage system eager writing workloads write-intensive run faster storage system capable eager writing writing free block closest disk arm traditional in-place write order select closest block storage system information blocks live existing proposals function long exist blocks written file system writes block storage system identify subsequent death block result delete disk empowered liveness information effective eager writing adaptive raid information block liveness storage system facilitate dynamic adaptive raid schemes autoraid system autoraid utilizes free space store data raidlayout migrates data raidwhen runs short free space knowledge block death make schemes effective optimized layout techniques optimize on-disk layout transparently storage system explored adaptive reorganization blocks disk replication blocks rotationally optimal locations examples knowing blocks free greatly facilitate techniques live blocks collocated minimize seeks free space dead blocks hold rotational replicas smarter nvram caching buffering writes nvram common optimization storage systems synchronous write workloads benefit in-memory delayed writes file system nvram buffering improves performance absorbing multiple overwrites block deleteintensive workloads unnecessary disk writes occur absence liveness information deleted blocks occupy space nvram written disk nvram fills real file system traces found writes deleted typical delayed write interval seconds unnecessarily written disk knowledge block death storage removes overhead intelligent prefetching modern disks perform aggressive prefetching block read entire track block resides prefetched cached internal disk cache aged fragmented file system subset blocks track live caching track result suboptimal cache space utilization reading track efficient disk knowledge liveness enable disk selectively cache blocks live faster recovery liveness information enables faster recovery storage arrays storage system reduce reconstruction time disk failure reconstructing blocks live file system self-securing storage liveness information storage build intelligent security functionality storage systems storage level intrusion detection system ids perimeter security monitoring traffic suspicious access patterns deletes truncates log files detecting patterns requires liveness information secure delete ability delete data manner makes recovery impossible important component data security government regulations require strong guarantees sensitive data forgotten requirements expected widespread government industry future secure deletion requires low-level control block placement storage appears sixth symposium operating systems design implementation osdi system implementing storage level secure delete requires liveness information storage system explore secure deletion section acquiring liveness information clear benefits liveness information storage systems information natural question arises convey liveness information storage systems discuss approaches explicit notification implicit detection explicit notification explicit notification involves augmenting existing storage interface allocate block free block commands modifying file systems commands explicitly convey liveness information storage system main benefit explicit approach potential simplicity interface deployed conveying liveness information seemingly straightforward appearing natural achieve goal problems approach changing interface storage raises legacy issues requires broad industry consensus demand interface requires agreement clear benefits interface difficult achieve deployment interface chicken-and-egg problem implicit detection implicit detection 
intended solve bootstrapping problem explicit interface evolution approach storage system monitors block-level reads writes issued file system underneath unmodified interface infers liveness information implicitly ideally change file system implicit approach enables demonstration benefits due proposed interface change making evolutionary step eventual interface modification previous work semantically-smart storage systems explored implicit detection forms file system information storage system storage-level enhancements degree accuracy required implicit detection techniques case depends nature application information x-ray storage system utilizes implicit information file accesses implement exclusive storage array cache inaccurate information x-ray simply reduces potential performance gain d-graid storage system utilizes implicit information file block belongs order place blocks fault-isolated fashion improving availability storage system multiple disk failures inaccurate information graid leads poor fault isolation impact correctness array exhibits strictly liveness description type utility content data block versioning block block holds eager write valid data fast recovery generation block lifetime secure delete context file storage ids table forms liveness availability traditional raid paper investigate limits implicit detection applications utilize implicit liveness information directly impacts correctness primary concern implicit interface evolution ties interacting layers file system storage system change issue problematic on-disk formats evolve slowly reasons backwards compatibility linux ext file system introduced roughly layout lifetime ext journaling file system backwards compatible on-disk layout ext extensions freebsd file system backwards compatible evidence commercial storage vendors maintain support software specific file system emc symmetrix storage system software understand common file systems trends point commercial viability implicit detection approach liveness storage taxonomy discussed utility liveness information storage system present taxonomy forms liveness information relevant storage liveness information classified dimensions granularity accuracy timeliness granularity liveness depending specific storage-level enhancement utilizes liveness information logical unit liveness tracked vary identify granularities liveness information meaningful content block generation summary presented table content liveness content liveness simplest form liveness unit liveness actual data context block death granularity occurs overwrite block block overwritten data storage system infer contents dead approximate form content liveness readily existing storage systems explored previous work wang appears sixth symposium operating systems design implementation osdi virtual log disk frees past location block block overwritten contents tracking liveness granularity on-disk versioning self-securing storage systems completely accurate storage system block freed file system contents stored block dead overwritten block liveness block liveness tracks disk block valid data data accessible file system unit interest case container contents block liveness granularity required applications intelligent caching prefetching eager writing deciding propagate block nvram disk storage system block live granularity form liveness information tracked traditional storage systems storage system unaware blocks file system thinks live weak form liveness tracked block written inferred dead generation liveness generation disk block lifetime block context file death generation block written disk context file free reallocated file tracking generation liveness ensures disk detect logical file system delete block contents reached disk context deleted file storage level functionality requires generation liveness secure delete track block live contained data belonged file generation longer alive application requires generation liveness information storage-based intrusion detection generation liveness tracked existing storage systems accuracy liveness information dimension liveness accuracy refer degree trust disk place liveness information inaccuracy liveness information lead disk overestimating underestimating set live entities blocks generations degree accuracy required varies specific storage application deletesquashing nvram acceptable storage system slightly overestimate set live blocks performance issue correctness issue hand underestimating set live blocks catastrophic disk lose valid data similarly generation liveness detection secure delete acceptable miss intermediate generation deaths block long latest generation death block timeliness information final axis liveness timeliness defines time death occurring file system disk learning death explicit notification approach file system delays free notifications similar delayed writes time lag disk learns block generation death similarly implicit approach periodicity file system writes metadata blocks imposes bound timeliness liveness information inferred applications eager writing delete-aware caching delayed knowledge liveness acceptable long information changed meantime applications secure delete timely detection provide stronger guarantees file system properties explicit implicit methods imparting liveness information storage dependent characteristics file system storage system study range techniques required liveness notification detection experimenting underneath file systems ext ext vfat experimented ntfs limited scale due lack source code access ntfs experience section ext modes operation synchronous asynchronous modes ext modes writeback ordered data journaling modes update behaviors form rich set file systems begin background file systems outline high level behavioral properties file system relevant context liveness information sections discuss properties influence techniques storage-level liveness tracking file system background subsection provide background information file systems study discuss key on-disk data structures update behavior common properties begin properties common file systems viewpoint liveness tracking basic level file systems track kinds on-disk metadata structure tracks allocation blocks bitmap freelist index structures inodes map logical file groups blocks common aspect update behavior modern file systems asynchrony data metadata appears sixth symposium operating systems design implementation osdi block updated contents block immediately flushed disk buffered memory interval delayed write interval blocks dirty longer delayed write interval periodically flushed disk order delayed writes committed potentially arbitrary file systems enforce ordering constraints linux ext ext file system intellectual descendant berkeley fast file system ffs disk split set block groups akin cylinder groups ffs inode data blocks allocation status live dead data blocks tracked bitmap blocks information file including size block pointers found file inode accommodate large files pointers inode point indirect blocks turn block pointers committing delayed writes ext enforces ordering whatsoever crash recovery requires running tool fsck restore metadata integrity data inconsistency persist ext synchronous mode operation metadata updates synchronously flushed disk similar early ffs linux ext ext file system journaling file system evolved ext basic on-disk structures ext ensures metadata consistency write-ahead logging metadata updates avoiding perform fsck-like scan crash ext employs coarse-grained model transactions operations performed epoch grouped single transaction ext decides commit transaction takes in-memory copy-on-write snapshot dirty metadata blocks belonged transaction subsequent updates metadata blocks result in-memory copy ext supports modes operation ordered data mode ext ensures transaction commits data blocks dirtied transaction written disk data journaling mode ext journals data blocks metadata modes ensure data integrity crash mode data writeback order data writes data integrity 
guaranteed mode vfat vfat file system descends world operating systems paper linux implementation vfat vfat operations centered file allocation table fat entry allocatable block file system entries locate blocks file linkedlist fashion file block address property syn reuse ordering block exclusivity generation marking delete suppression consistent metadata data-metadata coupling table file system properties table summarizes properties exhibited file systems study entry fat find block file entry hold endof-file marker setting block free unlike unix file systems information file found inode vfat file system spreads information fat directory entries fat track blocks belong file directory entry information size type information pointer start block file similar ext vfat preserve ordering delayed updates properties update behavior file system direct influence techniques liveness information imparted storage system based experience aforementioned file systems identify high-level file system properties relevant liveness tracking table summarizes properties reuse ordering file system guarantees reuse disk blocks freed status block bitmaps metadata pointed block reaches disk file system exhibits reuse ordering property sufficient ensure data integrity absence property file end partial contents deleted file crash journaling file system vfat asynchronous mode ext reuse ordering modes ext ext synchronous mode exhibit reuse ordering block exclusivity block exclusivity requires disk block dirty copy block file system cache requires file system employ adequate locking prevent update in-memory copy dirty copy written disk property holds file systems ext vfat ext conform property snapshot-based journaling dirty copies metadata block previous transaction committed current transaction generation marking generation marking property requires file system track reuse file pointer obappears sixth symposium operating systems design implementation osdi jects inodes version numbers ext ext file systems conform property inode deleted reused file version number inode incremented vfat exhibit property delete suppression basic optimization found file systems suppress writes deleted blocks file systems discuss obey property data blocks vfat obey property directory blocks consistent metadata property file system conveys consistent metadata state storage system journaling file systems exhibit consistent metadata property transaction boundaries on-disk log implicitly convey information ext vfat exhibit property data-metadata coupling data-metadata coupling builds consistent metadata property requires notion consistency extended data blocks words file system conforming property conveys consistent metadata state set data blocks dirtied context transaction file systems ext data journaling mode conforms property explicit liveness notification proceed techniques imparting forms liveness information storage systems section discuss explicit notification approach assume special allocate free commands added scsi optimization obviate explicit allocate command treating write previously freed block implicit allocate modifying file systems interface trivial find supporting free command ramifications consistency management file system crashes modified linux ext ext file systems free command communicate liveness information discuss issues free command implemented ioctl pseudo-device driver serves enhanced disk prototype granularity free notification issue arises explicit notification exact semantics free command granularities liveness outlined section block liveness content liveness tracked file system lazy initiating free commands suppressingfreeto blocks subsequently reused generation liveness file system notify disk delete block contents reached disk context deleted file multiple intermediate layers buffering file system contents block reached disk context file simplify file system implementation file system concerned form liveness disk functionality requires approach file system invokes free command logical delete receiving free command block disk marks block dead internal allocation structure bitmap write marks block live responsibility mapping thesefreecommands form liveness information lies disk disk track generation deaths interested free command block thinks live internal bitmaps redundant free block free disk block deleted written disk viewed generation death correct operation file system guarantee write block disk prior allocation write treated implicit allocate guarantee delete suppression property write freed block allocation result incorrect conclusion generation liveness disk note free issued block disk safely block possibly erasing contents timeliness free notification important issue arises explicit notification free file system issues notification option notification file system issues free immediately block deleted memory solution result loss data integrity crash scenarios crash occurs immediately free notification block metadata indicating delete reaches disk disk considers block dead recovery file system views block live delete reached disk live file freed block scenario violation data integrity violations acceptable file systems ext weak data integrity guarantees file systems preserve data integrity ext delay notification effect delete reaches disk delayed notification requires file system conform reuse ordering property block reused live file system effect previous delete reaches disk delayed free command suppressed means disk miss generation death orphan allocations finally explicit notification handle case orphan allocations file system considers block dead disk considers live assume block newly allocated file written disk conappears sixth symposium operating systems design implementation osdi text file crash occurs point metadata indicating allocation written disk disk smtf assume scheduler operating environment heavy disk traf queues disk hundreds thousands requests computational complexity scheduling algorithm important issue large queue lengths feasible perform optimal scheduling decision considers combinations requests greedy approach time request minimized evaluate performance smtf compare algorithms practice rst-comerst-served fcfs shortest-seek-timerst sstf c-look fcfs simply schedules requests order issued sstf selects request smallest difference logical block number lbn accessed disk c-look variation sstf requests serviced lbn proximity request serviced scheduler picks requests ascending lbn order requests serviced algorithm picks request queue lowest lbn continues service requests ascending order compare performance case implemented best-case-greedy scheduler simulated disks best-case scheduler long request simulated disk greedily picks request shortest positioning time refer scheduler greedyoptimal scheduler disk 
mimic disk mimic capture behavior disk drive portable robust cient manner predict performance disk disk mimic simple table indexed relevant input parameters disk disk mimic attempt simulate mechanisms components internal disk simply reproduces output function inputs observed reducing input parameters disk mimic table-driven approach predict time request function observable inputs fundamental issue reducing number inputs table tractable number device treated true black box internal behavior device disk mimic assume service time request function previous requests request ned parameters read write block number size time request data leads prohibitively large number input parameters indices table tractable approach make assumptions behavior device problem domain interest goal scheduler portable realistic range disk drives necessarily work hypothetical storage device high-level assumptions disks behave eliminate signi number input parameters disk mimic make assumptions current implementation disk mimic predicts time request input parameters request type inter-request distance interrequest distance logical distance rst block current request block previous request conclusion request type inter-request distance key parameters agrees previous researchers brie argue inter-request distance request type suitable parameters domain begin summarizing characteristics modern disk drives discussion classic paper ruemmler wilkes interested reader referred paper details background disk drive platters platter surface disk head reading writing surface data stored series concentric circles tracks single stack tracks common distance spindle called cylinder modern disks ram perform caching proceedings usenix annual technical conference june san antonio texas caching algorithm dif cult aspects disk capture model accessing block data requires moving disk head desired block time dominant components rst component seek time moving disk head desired track seek time reads writes reads performed aggressively read performed block read repeated performed wrong sector write rst verify sector avoid overwriting data component rotation latency waiting desired block rotate disk head time platter rotate roughly constant vary nominal rate result dif cult predict location disk head disk idle revolutions important positioning components mechanical movements accounted head track switch time head switch time takes mechanisms disk activate disk head access platter surface track switch time takes move disk head track cylinder rst disk appears client linear array logical blocks logical blocks mapped physical sectors platters indirection advantage disk reorganize blocks avoid bad sectors improve performance disadvantage client logical block located client derive mapping multiple sources complexity tracks numbers sectors specifically due zoning tracks platter sectors subsequently deliver higher bandwidth tracks spindle consecutive sectors track cylinder boundaries skewed adjust head track switch times skewing factor differs zones awed sectors remapped sparing sparing remapping bad sector track xed alternate location slipping sector track subsequent sector track input parameters previously explained read write operations times execute addition type operation issued uences service time account factors table-based model record request type read write current previous requests input parameters input parameter inter-request distance logical block addresses captures aforementioned underlying characteristics disk missing note ordering requests based time distance signi cantly distance due complexity disk geometry requests separated larger logical distance positioned rapidly relationship logical block address distance positioning time linear opinion ruemmler wilkes aspects disk modeled accuracy seek time calculated separate functions depending seek distance current nal cylinder position disk head reads writes head track switches rotation latency data layout including reserved sparing areas assume zoning block track live cylinder skew restart data file caching system views read-ahead block write-behind dead brie on-disk discuss contents extent block belong file components longer captured extant approach file approach system accounts block combined suffered costs generation seek death time head disk track switches rotation layout free notification probabilistic mechanism manner enable accurate tracking inter-request liveness distance orphan probability allocations handling request orphan crosses allocations track file cylinder system boundaries specific requests describe explicit notification ext mentioned ext provide data integrity guarantees crash notification deletes ext invokes free command synchronously block freed memory dealing orphan allocations ext requires simple expensive operation recovery fsck utility conservatively issuesfreenotifications block dead file system explicit notification ext ext guarantees data integrity ordered data journaling modes free notification ext delayed effect distance cross delete reaches number disk boundaries words total notification positioning time delayed number transaction track performed seeks delete number commits head record track switches in-memory list blocks amount rotation deleted note part transaction table-based method issue free tracking notifications positioning time blocks accurate transaction commits advocated ext ruemmler conforms wilkes reuse expressing ordering positioning property time delayed computed notification sum feasible functions crash seek time occur rotation time invocation caching free disk commands mimic records immediately precise positioning time commit transaction distance cost free incurred operations rotation redo-able disk recovery components purpose rotational log distance special free records previous current journal request elapsed replayed time recovery part requests delete amount transaction rotation recovery occurred multiple committed transactions inter-request distance probabilistically captures rotational distance disk mimic propagated record on-disk locations block deleted transaction reallocated amount subsequent time committed transaction elapsed replay request loggedfree omission commands issue disk scheduling guarantee presence completing full free queue commands requests transaction case committing inter-arrival time transaction requests replay disk free commands negligible successfully ignoring committed time transaction inaccuracies log scheduling rst earlier request committed transactions idle period replayed deal disk orphan idle allocations log scheduling block numbers data important blocks problem data layout incorporated written fairly disk written mimic disk recovery number ext issuefree commands set orphan data blocks sectors part track uncommitted number transaction cylinders implicit impact liveness measured detection values section analyze issues sizes determine implicit probability detection liveness request storage inter-request system distance implicit crosses liveness boundary inference requires sizes storage impact system probability semantic observed time understanding on-disk distriproceedings format file usenix system annual running technical coupled conference careful june san observation antonio file system traffic implicit liveness texas detection time file system number dependent requests discuss feasibility generality 
implicit liveness detection file systems ext ext vfat section discuss initial experience implicit detection underneath windows ntfs file system forms liveness address granularity accuracy axes mentioned section accuracy axis accurate approximate inferences approximate instance refers strict over-estimate set live entities timeliness axis address common complex case lack timely information modern file systems delay metadata updates timeliness guaranteed guarantees timeliness synchronously mounted file system implicit inference liveness trivial content liveness discussed section disk observes write contents live data block infer previous contents stored block suffered content death completely accurate content liveness inference requires information block liveness block liveness block liveness information enables storage system block valid data time track block liveness storage system monitors updates structures tracking allocation ext ext specific data bitmap blocks convey information vfat information embedded fat entry fat block free file system writes allocation structure storage system examines entry concludes relevant block dead live allocation bitmaps buffered file system written periodically liveness information storage system stale account allocations deletes occurred interval table depicts time line operations leads incorrect inference storage system bitmap block tracking liveness written step indicating dead subsequently allocated file written disk indicating live buffered memory point disk wrongly believes dead on-disk contents valid appears sixth symposium operating systems design implementation osdi operation in-memory on-disk initial free write disk free alloc alloc write disk written liveness belief live free table naive block liveness detection table depicts time line events leads incorrect liveness inference problem solved shadow bitmap technique address inaccuracy disk tracks shadow copy bitmaps internally file system writes bitmap block disk updates shadow copy copy written addition data block written disk disk pro-actively sets bit shadow bitmap copy block live write leads disk live preventing incorrect conclusion drawn file system properties block liveness shadow bitmap technique tracks block liveness accurately underneath file systems obey block exclusivity data-metadata coupling property block exclusivity guarantees bitmap block written reflects current liveness state relevant blocks file system tracks multiple snapshots bitmap block ext write version bitmap block indicating dead time subsequent allocation write ofb disk wrongly infer dead fact on-disk contents valid belongs newer snapshot uncertainty complicates block liveness inference file system exhibit block exclusivity block liveness tracking requires file system exhibit data-metadata coupling group metadata blocks bitmaps actual data block contents single consistent group file systems typically enforce consistent groups transactions observing transaction boundaries disk reacquire temporal information lost due lack block exclusivity ext data journaling mode transaction newly allocated data blocks bitmap blocks indicating allocation part consistent group commit point disk conclusively infers liveness state state bitmap blocks transaction data writes actual in-place locations occur transaction commits disk guaranteed transaction commit blocks marked dead previous transaction remain dead absence data-metadata coupling newly allocated data block reach in-place location transaction commits live disk disk detects operation in-memory on-disk initial alloc live write disk written delete free alloc alloc write disk live liveness belief missed gen death table missed generation death block liveness table shows scenario illustrate simply tracking block liveness insufficient track generation deaths accuracy block liveness requires file system conform delete suppression property delete suppression hold write block imply file system views block live shadow bitmap technique overestimate set live blocks bitmap write table ext vfat ext data journaling mode readily facilitate block liveness detection generation liveness generation liveness stronger form liveness block liveness builds shadow bitmap technique generation liveness goal find on-disk block generation data file stored block dead block liveness special case generation liveness block dead latest generation stored dead conversely block liveness information sufficient detect generation liveness block live stored dead generation past table depicts case block initially stores generation inode disk thinks block live deleted freeing immediately reallocated file written time continues marked live disk missed generation death occurred bitmap writes generation liveness reuse ordering tracking generation liveness general challenging file system reuse ordering property makes simple track reuse ordering block reused file deleted status block reaches disk reused bitmap block written disk detect dead presence reuse ordering tracking block liveness accurately implies accurate tracking generation liveness file systems ext conform reuse ordering facilitate accurate tracking generation liveness generation liveness reuse ordering underneath file systems ext vfat exhibit reuse ordering property tracking generation appears sixth symposium operating systems design implementation osdi liveness requires disk detailed information specifically disk monitor writes metadata objects link blocks single logical file inode indirect blocks ext directory fat entries vfat disk explicitly track generation block belongs inode written disk records block pointers belong specific inode extra knowledge file block belongs disk identify generation deaths ownership table disk tracked belongs eventually written disk observe change ownership owns block owned past disk conclude generation death occurred complication arises reused reused representing file belongs generation scenario detected generation death ownership change monitor miss detect case require file system track reuse inodes generation marking property ext maintains version number enables detection cases generation deaths version numbers disk tracks block generation belonged generation number combination inode number version number disk observes inode written incremented version number concludes blocks belonged previous version inode incurred generation death call technique generation change monitoring finally pertinent note generation liveness detection generation change monitoring approximate assume disk observes block belongs generation time observes belongs generationg generation change monitoring disk conclude generation death occurred disk generation deaths occurred relevant period freed allocated freed reallocated disk owningb due delayed write show case study weaker form generation liveness summary file system properties required forms implicit liveness inference presented table case study secure delete demonstrate techniques imparting liveness storage present design implementation evaluation secure deleting disk explicit imliveness type properties blockapprox block exclusivity data-metadata coupling blockaccurate blockapprox delete suppression generationapprox blockapprox generation marking generationaccurate blockaccurate reuse ordering table properties implicit liveness detection approx set live entities over-estimated plicit approaches describe implicit secure delete detail briefly discuss explicit secure delete primary reasons chose secure deletion case study secure delete requires tracking generation liveness challenging track secure delete liveness information context correctness paramount false positive detecting delete lead irrevocable deletion valid data false negative result long-term recoverability deleted data violation secure deletion guarantees compared 
previous work functioned simplistic assumption synchronously mounted file system demonstrate accurate inference liveness feasible underneath variety modern file system behaviors implicit secure deletion number requests prototype called faded file-aware data-erasing disk faded works underneath file systems ext vfat ext complete lack ordering guarantees ext presented challenges specifically ext reuse ordering property detecting generation liveness requires tracking generation information disk section focus implementation faded underneath ext finally discuss key differences implementation file systems goals faded desired behavior faded block reaches disk context file delete file trigger secure overwrite shred block behavior corresponds notion generation liveness defined section shred involves multiple overwrites block specific patterns erase remnant magnetic effects past layers recovered techniques magnetic scanning tunneling microscopy recent work suggests overwrites sufficient ensure non-recoverability modern disks traditionally secure deletion implemented file system implementations unreliable modern storage systems high security overwrites off-track writes writes straggling physical track boundaries external erase programs file system perform storage system buffers writes nvram multiple overwrites file system appears sixth symposium operating systems design implementation osdi collapsed single write physical disk making overwrites ineffective finally presence block migration storage system overwrite file system overwrite current block location stray copies deleted data remain storage system proper locale implement secure deletion note faded operates granularity entire volume control individual files shredded limitation dealt storing sensitive files separate volume secure delete functionality enabled basic operation discussed section faded monitors writes inode indirect blocks tracks inode generation block belongs augments information block liveness information collects shadow bitmap technique note ext obeys block exclusivity delete suppression properties block liveness detection reliable block death detected faded safely shred block hand faded detects generation death ownership change generation change monitors block live block liveness module faded simply shred block faded current contents block belong generation deleted generation subsequently allocated block due block reuse current contents block valid shredding block catastrophic deal uncertainty conservative approach generation-death inference conservative convert apparent correctness problem performance problem end performing overwrites required fundamental approach notion conservative overwrite conservative overwrites conservative overwrite block erases past layers data block leaves current contents intact faded subsequent valid write occurred predicted generation death conservative overwrite block safe shred valid data perform conservative overwrite block faded reads block non-volatile ram performs normal secure overwrite block specific pattern ultimately restores original data back block problem conservative overwrite block contents restored conservative overwrite fact data shredded conservative overwrite ineffective case faded guaranteed observe things block reused file system file valid data written eventually delayed write interval file system faded receives write buffers write writing data disk faded performs shred concerned block time faded restore data recent contents block identify writes treat special manner faded tracks list blocks subjected conservative overwrite suspicious blocks list write block list committed secure overwrite block overwrite block removed suspicious list note suspicious list stored persistently nvram order survive crashes block reused file system immediately faded guaranteed observe bitmap reset block flagged block death block liveness detector block liveness tracking reliable faded shred block destroying data cases wrongful restore data faded guaranteed opportunity make error cost conservatism conservative overwrites performance cost conservative overwrite results concerned block treated suspicious data restored conservative overwrite data faded information find stage uncertainty data restored data overwritten subsequent write block context file lead redundant shredding block performance cost faded pays circumvent lack perfect information coverage deletes previous subsection showed generation deaths detected faded ensures block version overwritten compromising valid data faded achieve goals detection techniques sufficient identify cases deletes file system level shredded section show faded detect deletes requires minor modifications ext undetectable deletes weak properties ext deletes missed faded present specific situations identification deletes impossible propose minor ext fix scenarios file truncates generation change monitor assumes version number inode incremented inode reused version number ext appears sixth symposium operating systems design implementation osdi operation in-memory on-disk initial bind bind delete free alloc write disk bind wrong type table misclassified indirect block table shows scenario normal data block misclassified indirect block bind treated indirect block reuse ordering indirect blocks prevents problem incremented complete delete reuse partial truncates affect version number block freed due partial truncate reassigned file faded misses generation death reuse partial truncate argued logical overwrite file delete adopt complex conservative interpretation treating delete handle deletes propose small change ext incrementing version number reallocation inode increment truncate alternatively introduce separate field inode tracks version information non-intrusive change effective providing disk requisite information technique result extra overwrites rare case partial truncates correctness guaranteed spurious overwrites conservative leave data intact reuse indirect blocks subtle problem arises due presence indirect pointer blocks indirect blocks share data region file system user data blocks file system reuse normal user data block indirect block vice versa presence dynamic typing disk reliably identify indirect block faded identify block indirect block observes inodei indirect pointer field faded records fact indirect block observes write faded contents indirect block deleted reused user data block inode scenario illustrated table faded trust block pointers suspected indirect block uncertainty lead missed deletes cases prevent occurrence data block misclassified indirect block ensure file system allocates immediately file system frees indirect block bind concerned data bitmap blockmbind flushed disk disk block freed note weak form reuse ordering indirect blocks show change operation in-memory on-disk initial free free alloc write disk written delete free alloc write disk missed delete table missed delete due orphan write table illustrates delete missed orphan block treated carefully block initially free allocated memory written disk written deleted reallocated written faded associate miss overwrite impact performance indirect blocks tend small fraction set data blocks practicality discussed minimal non-intrusive required modification lines code ext required weak ordering guarantees ext file systems ext exhibit reuse ordering required study ext aimed limit study minimal set file system properties required reliably implement secure deletion disk orphan allocations implicit block liveness tracking faded addresses orphan allocation issue discussed ext recovers crash fsck utility writes copy bitmap blocks block liveness monitor faded detect death orphan allocations orphan writes due arbitrary ordering ext faded observe write newly allocated data block observes owning inode orphan writes treated carefully owning 
inode deleted written disk faded block belonged inode block reused inode faded miss overwriting concerned block written context inode table depicts scenario address problem defer orphan block writes faded observes owning inode potentially memory-intensive solution suspicious block list conservative overwrites track orphan blocks faded observes write orphan block marks suspicious subsequent write arrives contents shredded inode owning block deleted reaching disk write block context file trigger shred block reused bitmap reset delete technique results redundant secure overwrite anytime orphaned block overwritten file sysappears sixth symposium operating systems design implementation osdi persistent liveness monitor block block inode mapping overwrite thread datadelayed overwrites suspicious list shadow bitmaps monitor generation change figure key components faded tem context file cost pay conservatism note overhead incurred time orphan block overwritten guaranteed detection deletes techniques prove block deleted file system reached disk faded overwrites deleted contents proof presented appendix delayed overwrites multiple overwrites block additional disk hurt performance incurred critical path performance faded delays overwrites idle time workload optionally minutes detection faded decides shred block queues low priority thread services queue faded observed foreground traffic duration delayed overwrites faded present writes disk sequential ordering reducing impact foreground performance delaying reduces number overwrites block deleted multiple times notion conservative overwrites crucial delaying overwrites arbitrarily block overwritten written context file note shredding required user perform sync summary key data structures components faded presented figure faded file systems implemented faded underneath file systems case validated implementation testing methodology section due space constraints point key differences observed relative ext faded vfat ext vfat conform reuse ordering faded track generation information block order detect deletes key difference vfat compared ext pre-allocated uniquely addressable inodes version information dynamically allocated directory blocks pointer start block file fat chains start block blocks file detecting deletes reliably underneath unmodified vfat impossible introduced additional field vfat directory entry tracks globally unique generation number generation number incremented create delete file system newly created file assigned current generation number small change lines code vfat generation change monitor accurately detects deletes interest faded ext ext exhibits reuse ordering tracking generation liveness ext tracking block liveness ext obey block exclusivity property tracking block liveness accurately impossible data journaling mode property data-metadata coupling ordered writeback modes make small change metadata transaction logged made ext log list data blocks allocated transaction change lines code coupled reuse ordering property enables accurate tracking deletes explicit secure delete built secure deletion explicit notification framework modified ext ext file systems notify disk logical delete file system modifications accounted lines code receiving notification disk decides shred block similar faded disk delays overwrites idle time minimize impact foreground performance evaluation section evaluate implicit explicit implementations secure delete enhanced disk implemented pseudo-device driver linux kernel driver observes information hardware prototype suffers contention cpu memory host ghz pentiumwith ram rpm ibm lzx disk due space constraints provide results ext version correctness accuracy test faded implementation detected deletes interest instrument file system log delete correlate log writes overwrites faded capture cases unnecessary missed overwrites tested system workloads technique including busy hours file system traces table presents results study trace hour experiment ran faded versions linux ext marked default appears sixth symposium operating systems design implementation osdi config delete overwrite excess miss indirect version time number requests figure distribution off-line probe times inter-request distances graph shows inter-request distance x-axis show probes performed sorted time y-axis show time probe times ibm lzx disk bution zoning behavior bad sectors tracked model previous research shown level detail scheduling aspect model directly general caching disk mimic capture effects simple prefetching important aspect caching scheduling read sector entire track cached disk mimic observe faster performance accesses distances track respect con guring disk mimic on-line observing actual workload accurate con guring off-line locality workload captured complexity inter-request distance concentrate issues related input parameter values request type output disk mimic characteristics explore combinations input parameters discussions refer inter-request distance assume request type xed results illustrate complexity inter-request distance predictor request time show distribution times observed experiments con gure disk mimic off-line disk mimic con gures probing device xed-size requests inter-request distances covering disk negative positive disk mimic samples number points distance accesses block speci distance previous block avoid caching prefetching performed disk disk mimic accesses random location probe required distance observed times recorded table indexed inter-request distance operation type figure show small subset data collected ibm lzx disk gure shows distribution samples inter-request distances case y-axis shows request time sample points axis represent sample sorted increasing request time make important observations sampled times inter-request distance observed request time constant distance requests require require require multi-modal behavior time single request reliably predicted interrequest distance predict request distance faster slower request distance make reasonable predictions based probabilities data conclude request distance longer examining distributions inter-request distances observe number transitions percentage samples time varies inter-request distances number transitions graph corresponds roughly number track cylinder boundaries crossed inter-request distance data shows number important issues remain con guration disk mimic signi variation request times single inter-request distance summary metric summarize distribution samples required adequately capture 
behavior distribution inter-request distance sampled interpolate intermediate distances investigate issues section methodology evaluate performance smtf scheduling range disk drive technology presented proceedings usenix annual technical conference june san antonio texas con guration rotation seek head cyl track cyl sectors num time cyl switch switch skew skew track heads base fast seek slow seek fast rotate slow rotate fast seek rot capacity capacity table disk characteristics con gurations simulated disks times rotation seek head cylinder switch milliseconds cylinder track skews expressed sectors experiments base disk table implemented disk simulator accurately models seek time xed rotation latency track cylinder skewing simple segmented cache rst disk named base disk simulates disk performance characteristics similar ibm lzx disk seek times cache size number segments head cylinder switch times track cylinder skewing rotation times measured issuing scsi commands measuring elapsed time directly querying disk similar approach schindler ganger values provided manufacturer curve seek time modeled probing ibm lzx disk range seek distances measured distance cylinders previous cylinder position current curve tting values two-function equation proposed ruemmler wilkes short seek distances seek time proportional square root cylinder distance longer distances seek time proportional cylinder distance middle seek column represents cylinder distance switch functions occurs base disk seek distance smaller cylinders square root function disk con gurations simulate start base disk vary parameters inuence positioning time disk con guration number fast seek represents disk fast seek time numbers compute seek curve adjusted number sectors constitute cylinder skew similarly disk conguration number fast rotate time execute rotation decreased factor number track cylinder skew sectors increased disk con gurations account disks slower seek time slower rotation time faster seek time faster rotation time capacity base disk addition simulated disks run experiments ibm lzx disk time scaling factor fcfs sstf smtf min smtf probabilistic smtf max smtf median smtf greedy-optimal figure sensitivity summary metrics graph compares performance variety scheduling algorithms base simulated disk week-long trace smtf schedulers interpolation performed samples obtained data point x-axis shows compression factor applied workload y-axis reports time spent disk evaluate scheduling performance show results set traces collected labs cases focus trace busiest disk week performance metric report time workload spent disk impact heavier workloads longer queue lengths compress inter-arrival time requests scaling time attempt preserve dependencies requests workload observing blocks requested assume request repeated block serviced request dependent previous request rst completing hold repeated requests subsequent requests previous identical request completes proceedings usenix annual technical conference june san antonio texas time ordered requests summary metric probability percentage error probabildisk time ordered requests summary metric percentage error meandisk time ordered requests summary metric maximum percentage error maxdisk figure demerit figures smtf probability maximum summary metrics graph shows demerit gure summary metric distributions correspond day experiments shown figure compression factor off-line con guration smtf scheduler con gured on-line off-line explore case disk mimic con gured off-line disk mimic con gured off-line simulation predictions required scheduler performed on-line system previously con guring disk mimic off-line involves probing underlying disk requests range inter-request distances note model con gured off-line process con guring smtf remains automatic portable range disk drives main drawback con guring disk mimic offline longer installation time device added system disk probed workload traf summary data enable smtf scheduler easily compare expected time requests queue disk mimic supply summary distribution function inter-request distance multi-modal characteristics distributions choice summary metric obvious evaluate summary metrics median maximum minimum probabilistic randomly picks sampled distribution probability results summary metrics base simulated disk shown figure workload week-long trace scaled compression factor noted x-axis graph shows fcfs sstf c-look perform worse smtf schedulers expected smtf schedulers perform worse greedy-optimal scheduler approach workload results show inter-request distance predict positioning time merits attention comparing performance smtf approaches summary metric performs time samples fcfs sstf smtf greedy-optimal figure sensitivity number samples graph shows performance smtf improves samples results simulated disk week-long trace compression factor x-axis number samples smtf y-axis shows time spent disk differently ordering performance worse median maximum probabilistic minimum interesting note scheduling performance summary metric correlated accuracy accuracy disk models evaluated demerit gure ned root square horizontal distance time distributions model real disk point brie illustrated figure shows distribution actual times versus predicted times metrics probabilistic maximum expected probabilistic model demerit gure requests distribution predicts expected match real device probabilistic model performs poorly smtf time predicts request differ signi cantly acproceedings usenix annual technical conference june san antonio texas time request inter-request distance full range time request inter-request distance close-up figure values samples function inter-request distance graph left shows time entire set inter-request distances simulated disk graph shows close-up inter-request distances distances qualitatively similar saw-tooth behavior tual time request conversely maximum results poor demerit gure performs adequately scheduling fact smtf maximum performs signi cantly minimum similar demerit gures finally summary distribution achieves performance result demerit gure found performs days traces examined remainder experiments observed samples summary data inter-request distance number samples large variation times single inter-request distance disk mimic perform large number probe samples true distribution reduce time required con gure disk mimic off-line perform samples evaluate impact number samples smtf performance figure compares performance smtf function number samples performance fcfs c-look sstf optimal expected performance smtf increases samples workload disk performance smtf continues improve approximately samples interestingly single sample inter-request distance disk mimic performs fcfs c-look sstf interpolation number samples performed interrequest distance impacts running time off-line probe process greater issue distance explicitly probed intere time percent error check checks checks interpolation sstf figure sensitivity interpolation graph shows performance interpolation function percent allowable error lines correspond numbers check points x-axis percent allowable error y-axis time spent disk results base simulated disk week-long trace compression factor polated distances due large number potential inter-request distances modern storage device times number sectors negative positive distances performing probes signi amount time storing values prohibitive disk size amount memory required table exceed explore distances interpolated making detailed assumptions underlying disk illustrate potential performing simple interpolations show function inter-request distance figure graph left proceedings usenix annual technical conference june san antonio texas check points acceptable error table allowable error 
interpolation table summarizes percentage interpolated relative probed order infer interpolation successful check points performed inter-request distances allowable error increases numbers gathered running number workloads simulated disks observing point performance interpolation degrades relative interpolation shows values inter-request distances simulated disk curve bands emanating middle point corresponds seek curve disk short seeks time proportional square root distance long time linear distance width bands constant corresponds rotation latency disk graph shows close-up inter-request distances graph shows times follow distinct saw-tooth pattern result simple linear model interpolate distances care ensure model applied short distances length linear regions varies disks function track cylinder size goal determine distances interpolated successfully challenge determine interpolated close actual scheduling performance impacted negligibly basic off-line interpolation algorithm disk mimic performs samples interrequest distances left chooses random distance middle left linearly interpolates middle means left interpolated middle error percent probed middle interpolation considered successful distances left interpolated interpolation successful disk mimic recursively checks smaller ranges distances left middle middle intermediate points successfully interpolated points probed additional con dence linear interpolation valid region slight variation points left interpolated checked points predicted desired level accuracy interpolation considered successful intuition performing check points higher error rate interpolation successful figure shows performance smtf distances interpolated graph shows effect increasing number intermediate points checked increasing acceptable error error interpolation make observations graph smtf performance decreases allowable error check points increases result expected note performance decreases dramatically error error checked distances increased interpolated distances inaccurate single check point error level found interpolated values accurate level average error interpolated values increases shown summary error increases signi cantly linear relationship distances left interpolation performed smtf performance xed error increases number intermediate check points effect performing checks con linear interpolation distances valid check points error interpolated points accurate level average error shown table summarizes ndings wider number check points table shows allowable error percentage function number check points achieve scheduling performance similar probes nal probe process operate interpolation distance left error deemed successful distances left errors interpolation successful progressively check points made higher error rates successful approach distances disk interpolated probed scheduling performance virtually unchanged interpolation leads fold memory savings disk characteristics demonstrate robustness portability disk mimic smtf scheduling full range simulated disks table performance fcfs c-look sstf smtf relative proceedings usenix annual technical conference june san antonio texas disk configuration slowdown fcfs sstf smtf figure sensitivity disk characteristics ure explores sensitivity scheduling performance disk characteristics shown table performance shown relative greedy-optimal report values smtf interpolation performance smtf interpolation probes similar greedy-optimal disks summarized figure show performance smtf interpolation performance smtf interpolation identical expected fcfs performs worst entire range disks performing factor slower greedy-optimal c-look sstf perform seek time dominates performance disks sstf performs c-look cases finally smtf performs rotational latency signi component request positioning disks summary range disks smtf performs c-look sstf scheduling greedy-optimal algorithm show smtf handle performance variation real disks compare performance implementation smtf c-look run ibm lzx disk week trace achieve performance improvement smtf compared c-look improvement idle table time correctness removed accuracy trace table performance shows improvement number overwrites signi performed faded reasons configurations ext ibm columns lzx disk order high number ratio blocks seek deleted file system total number rotation logical time overwrites performed performance faded improvement number smtf relative unnecessary overwrites c-look number greater overwrites rotation missed time faded signi note component deletes positioning occurred trace data exercises write large require amount data overwrite config reads disk writes run-time locality workload low trace version seek time dominates table positioning impact time explore performance effect performance workload locality file create system synthetic configurations workload busy random hour reads trace writes shown idle time configuration show maximum inter-request number distance blocks read varied written speci trace run-time x-axis ext file figure system graph shows indirect performance ext improvement modified smtf obey reuse ordering indirect blocks version ext modified increment inode version relaslowdown number maximum truncate inter-request distance real disk configuration comparison represents smtf off-line correct file system figure implementation real required disk performance faded graph column shows slowdown measure c-look extra work compared faded smtf order cope congured off-line inaccurate information workload column synthetically generated number trace missed numbers overwrites averages correct system runs fourth standard column deviation reported cost x-axis inaccuracy shows maximum reasonable inter-request faded distance performs existent roughly overwrites trace minimal amount y-axis reports note percentage slowdown version number modification algorithm ext tive faded c-look misses deletes varies reason missed overwrites reported interrequest distance version varies configuration rarity case involving systems misclassified indirect linux ext block performance optimize impact locality placing evaluate related les performance impact cylinder group made smtf ext optimize running accesses trace c-look versions practice ext table shows smtf results viable option scheduling real performance reduction disks on-line con guration number blocks explore smtf scheduler con guration performed on-line approach overhead installation time probe disk drive disk mimic observes behavior disk workload runs written marginally off-line higher version due synchronous bitmap writes disk indirect mimic block reuse records ordering observed conclude disk times function practical performance inter-request secure distance delete explore case foreground performance control implicit explicit secure inter-request delete distances cost observes overwrites foreground general performance approach impact tracking block on-line generation version liveness assume requires faded perform extra lessons learned processing off-line cost con reverse guration engineering hold directly impacts application continue performance incurred represent critrun-time distribution system times implicit explicit inter-request postmark distance trace trace continue rely default interpolation securedelete note securedelete disk mimic con securedelete gured table on-line foreground interpolation impact postmark trace saving run-times space postmark providing trace shown information faded distances overwrite passes observed comparison primary run-time challenge explicit smtf secure delete address trace situation shown postmark schedule requests configured files inter-request transactions distances ical path unknown times disk operation inter-request quantify distance impact extra processing observed required faded proceedings foreground performance usenix annual software technical prototype competes conference cpu june memory san resources antonio texas host sstf worst case estimates slowdown base-line overheads pri run interp postmark pri file system interp benchmark set interp trace set file system running top faded postmark interp metadata percentage intensive slowdown small-file day benchmark performance hybrid versions sstf heavily exercises set sstf inferencing set mechanisms sstf interp faded arrive set pessimistic estimate set perform sync interp end figure performance phase on-line postmark smtf causing rst disk graph writes compares complete performance account time variations results online note smtf performance wait completion day delayed overwrites week-long trace shown relative numbers off-line smtf performance graph perceived shows foreground performance task online-set table improves compares time performance inter-request faded distances observed disk default mimic disk disk explicit mimic secure unable delete con table interpolated successfully overwrite algorithms passes foreground comparison performance algorithms affected assume base extra cpu scheduler processing c-look faded sstf lower performance disk compared mimic modified file suf system cient running normal information disk rst explicit algorithm implementation online-priority performs schedules requests incur overhead disk inference mimic information speci require cally file online-priority system strict modifications priority reported table requests corresponds queue row inter-request table distance note time model cost requests sending free command times scsi request bus minimum overheads time explicit case picked optimistic idle time online-priority required base quantify scheduler cost performing c-look overwrites sstf shredding microbenchmarks verified inter-request distances overwrites obtained current sequential queue bandwidth due delayed ordered issue problems found approach block reuse occurs preference file system scheduling resulting multiple deletes inter-request distances block online-priority delaying overwrites perform significantly worse reduces overwrite base traffic scheduler omit schedules results due diversity space distances constraints explore produced time required disk overwrites mimic observe postmark configuration cient distances measure time algorithm benchmark online-set complete improves including delayed overwrites limitations decision base scheduler postmark starting deletes point files scheduling end run request face worst disk case mimic scenario knowledge entire working set performance benchmark improved speci cally overwritappears online-set rst sixth considers symposium request operating systems base design scheduler implementation pick osdi run-time time overwrites system distance implicit explicit postmark disk trace mimic trace request default scheduled securedelete time securedelete requests securedelete table inter-request idle time distances requirement considered table shows total run-time fastest benchmarks chosen postmark online-set trace time improve reported includes performance completion base delayed scheduler overwrites ten accounting schedule large variety overwrite times inter-request reported table hp-trace distances overwrite times 
learning experimental reasonable results blocks evaluate deleted performance trace on-line reused algorithms subsequent return writes base simulated overwrites disk performed left-most graph conservative figure accounts compares steep performance increase online-priority overwrite passes online-set implicit c-look case sstf explicit implementation incurs baseline lower algorithm overwrite times compared faded interpolation perfect performance information expressed deletes terms avoids slowdown extra relative overwrites incurred due conservatism implicit detection ntfs section present experience building support implicit liveness off-line detection version underneath smtf windows make ntfs file observations system main graph challenge faced underneath surprising ntfs c-look absence source performs code sstf file system workload basic disk on-disk smtf format performs ntfs noticeably details sstf update semantics c-look journaling base behavior c-look publicly disk mimic result observe implementation inter-request tracks distances block liveness negative requires backward knowledge on-disk layout discover generation distances liveness tracking close implemented details online-set ntfs performs journaling mechanism onlinepriority fundamental piece sstf metadata ntfs base scheduler master file table interpolation mft signi record cantly mft improve information performance unique online-priority file piece online-set metadata ntfs c-look leads small improvement online-set sstf off-line con guration primary bene interpolation reduce memory requirements disk mimic opposed improving performance right-most graph figure illustrates performance online-set improves time inter-request distances observed performance 
online-set algorithms interpolation base-line schedulers sstf c-look day original trace approximately requests performance online-set sstf converges off-line version days requests point feel opportunities proceedings usenix annual technical conference june san antonio texas improving performance on-line smtf relative off-line smtf current on-line implementations slow time distance observed initially scheduler avoid distance faster address requiring distance minimum number samples classi current algorithm leverage idle time perform probes unknown inter-request distances idle times disk mimic learn characteristics disk related work approach propose brings areas study disk modeling disk scheduling treated regular file file present related work areas compare method disk modeling classic paper describing models disk drives ruemmler wilkes main focus work enable informed trade-off simulation effort resulting accuracy model ruemmler wilkes evaluate aspects disk modeled high level accuracy demerit gure researchers noted mft additional file non-trivial assumptions recovery log made model disks allocation status desired accuracy blocks level volume modeling cache maintained behavior file called challenging cluster aspect bitmap similar detailed knowledge block bitmap modeling tracked disks ext block allocations documentation researchers deletions ntfs developed regularly innovative writes methods modified acquire bitmap blocks information prototype implementation worthington runs device driver linux similar describe techniques setup scsi earlier drives file extract time systems parameters virtual disk seek curve interpose rotation speed exported command logical disk overheads virtual machine information instance windows data layout running disk vmware caching workstation track prefetching block characteristics techniques liveness automated implementation work shadow modeling bitmap storage technique devices mentioned tables section past detailed performance empirical observation explored long-running previous work workloads found previous ntfs work high-level exhibit system violation parameters block load exclusivity number delete disks suppression operation properties type mentioned section indices due table absence anderson source code results assert online ntfs assist conforms recon guration properties disk arrays limitation points approach general similar difficulty implicit thornock techniques underneath closed-source work file systems authors stochastic methods build file model system conforms underlying drive properties application guaranteed model file system standard vendor off-line simulation absence specifically guarantees authors study utility block implicit reorganization techniques similar limited earlier work optimizations ruemmler afford wilkes occasionally higher wrong level seltzer implicit small inference suggest experience situ ntfs simulation points method building utility adaptive characterizing operating precise set systems file system work properties authors required suggest forms operating systems liveness inference utilize in-kernel set monitoring properties adaptation constitutes make minimal informed interface policy decisions communication file tracing system application activity storage vendors vino system ntfs determine confirmed current conformance policy block behaving exclusivity delete suppression properties storage system safely implement aggressive optimizations rely implicit inference discussion section reflect lessons learned expected case policy study refine switched comparison place strengths actual simulations weaknesses system explicit behavior implicit performed approaches offline ideal scenario resort poor implicit approach performance detected disk required scheduling disk scheduling storage system long topic file study system computer interface science rotationally-aware practice schedulers accurate liveness existence detection requires early file system work properties seltzer means file system jacobson modified wilkes conform due dif requisite culty properties implementation face early works focused solely storage simulation explore basic ideas recently implementations rotationally-aware schedulers literature crafted extreme care recently worthington examine bene detailed knowledge system disk drives file system os-level disk schedulers implicit approach algorithms mesh pragmatic modern explicit approach prefetching caches changing perform interface detailed logical-to-physical main reasons mapping information implicit approach anticipatory file system scheduling recent scheduling required development file system complementary conforms on-line requisite simulationbased properties approach anticipatory scheduler file makes systems assumption ext vfat ext -data locality journaling stream ntfs requests amenable block liveness detection change file system process ext file waiting system data journaling request mode servicing conforms request properties required generation process liveness performance detection improved authors cases note implicit approach dif culty enables non-intrusive building deployment rotationally-aware functionality scheduler modifying empirically-generated file system curvetted estimate conform disk set access-time costs well-defined properties general modifying file system interface convey specific piece information discussed file system properties viewpoint implicit liveness detection properties enable richer information inferred association block owning inode required applications file-aware layout tracked accurately file system obeys reuse ordering consistent metadata properties ultimate goal arrive set properties enable wide variety information tracked implicitly outlining file systems designed enable appears sixth symposium operating systems design implementation osdi transparent extension storage system contrast approach changing interface requires introducing interface time piece information required related work liveness information storage systems recognized previous work existing proposals interface communicate liveness part radical set existing storage interface logical disks list-based interface storage includes command delete block list recent work suggests object-like interface storage moves responsibilities low-level storage management liveness tracking file system drives contrast wide-scale explicit notification approach imparting liveness intrusive large body file systems utilize existing block-based interface storage work implementing smarts storage system interface change similar implicit approach systems utilize limited form liveness inference autoraid requires information free space decide amount data stored raidautoraid infers blocks written dead inference weak form liveness block written subsequent deletes detected systems programmable disk make similar inferences existence proposals liveness information important storage systems systematic techniques acquiring information missing related implicit techniques work previous work semantically-smart disks work presented techniques blockbased storage system infer file system level information implemented set case studies trackaligned extents journaling secure delete correctness-sensitive case studies implemented required file system synchronously mounted synchronous file systems implicit information tracking trivial recent work d-graid considered asynchronous file systems layout mechanisms d-graid depend accuracy correctness acceptable d-graid predictions wrong fast recovery d-graid utilized block liveness easier property track generation liveness specific assumptions file system behavior work previous work generalizing techniques inference underneath wide range realistic file system behaviors demonstrating storage-level functionality correctness paramount utilize information reliably conclusion system layers evolve explicit implicit file system storage system interface change change change time interfaces layers obsolete sub-optimal necessitating evolution presented approaches interface evolution explicit implicit context embedding liveness information storage qualitative summary complexity approaches axes presented figure shown explicit approach appearing straightforward entails fair amount file system change practice requiring minimal support storage system factors explicit approach results simpler systems implicit case main strength implicit approach permits demonstration functionality interface enabling seamless deployment catalyzing rapid interface evolution acknowledgments nitin agrawal john bent timothy denehy todd jones james nugent florentina popovici vinod yegneswaran helpful comments mendel rosenblum excellent shepherding anonymous reviewers thoughtful feedback gordon hughes comments secure delete work sponsored nsf ccrccr- ccrngs- itritr- ibm emc agrawal kiernan srikant hippocratic databases vldb bairavasundaram sivathanu arpaci-dusseau arpaci-dusseau x-ray non-invasive exclusive caching mechanism raids isca bauer priyantha secure data deletion linux file systems usenix security august jonge kaashoek hsieh logical disk approach improving file systems sosp denehy arpaci-dusseau arpaci-dusseau bridging information gap storage protocol stacks usenix monterey june dowse malone recent filesystem optimisations freebsd freenix june emc corporation symmetrix enterprise information storage systems http emc english stepanov loge self-organizing disk controller usenix jan ganger blurring line oses storage devices scs cmu-cs- disk mimic yield performance bene simpli approach conclusions paper explored issues simulation system make run-time scheduling decisions focused disk simulator automatically model range disks human intervention shown disk mimic model time request simply observing request type logical distance previous request predicting behave similarly past requests parameters disk mimic con gure disk probing disk off-line slight performance cost observing requests disk on-line demonstrated shortest-mimicked-timerst smtf disk scheduler signi cantly improve disk performance relative fcfs sstf c-look range disk characteristics future plan show smtf scheduling range storage devices disk drives raid systems networkproceedings usenix annual technical conference june san antonio texas attached storage devices mems-based devices tapes non-volatile memory building blocks storage system devices complex performance characteristics ideal scheduler automatically adapt devices acknowledgments nathan burnett timothy denehy brian forney muthian sivathanu feedback paper vern paxson shepherd anonymous reviewers thoughtful suggestions greatly improved content paper finally computer systems lab tireless assistance providing terri environment computer science research work sponsored nsf ccrccr- ccrngs- itran ibm faculty award wisconsin alumni research foundation anderson simple table-based modeling storage devices technical report hpl-ssp- laboratories july andrews bender zhang algorithms disk scheduling problem ieee symposium foundations computer science focs pages arpaci-dusseau arpaci-dusseau information control gray-box systems symposium operating systems principles sosp pages october ganger worthington patt disksim simulation environment version manual http citeseer nec article ganger disksim html gibson nagle amiri chang feinberg gobioff lee ozceri riedel rochberg zelenka file server scaling network-attached secure disks proceedings acm sigmetrics international conference measurement modeling computer systems pages seattle june golding bosch staelin sullivan wilkes idleness sloth proceedings winter usenix technical conference pages orleans louisiana january gotlieb macewen performance movable-head disk storage devices journal association computing machinery grif schindler schlosser bucy ganger timing-accurate storage emulation proceedings usenix conference file storage technologies fast pages monterey january hillyer silberschatz modeling performance characteristics serpentine tape drive proceedings sigmetrics conference measurement modeling computer systems pages hofri disk scheduling fcfs sstf revisited communications acm huang chiueh implementation rotation latency sensitive disk scheduler technical report ecsl-tr suny stony brook march iyer druschel anticipatory scheduling disk scheduling framework overcome deceptive idleness synchronous acm symposium operating systems principles pages october jacobson wilkes disk scheduling algorithms based rotational position technical report hpl-csp- laboratories kotz toh radhakrishnan detailed simulation model disk drive technical report dartmouth college patterson gibson katz case redundant arrays inexpensive disks raid sigmod record acm special interest group management data september ruemmler wilkes disk shuf ing technical report hpl- hewlett packard laboratories october ruemmler wilkes unix disk access patterns proceedings usenix winter technical conference pages ruemmler wilkes introduction disk drive modeling ieee computer proceedings usenix annual technical conference june san antonio texas schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon november schlosser grif nagle ganger designing computer systems memsbased storage architectural support programming languages operating systems pages seltzer chen ousterhout disk scheduling revisited proceedings usenix winter technical conference pages berkeley seltzer small self-monitoring self-adapting systems proceedings workshop hot topics operating systems pages chatham shenoy vin cello disk scheduling framework next-generation operating systems proceedings sigmetrics conference measurement modeling computer systems pages june shriver merchant wilkes analytic behavior model disk drives readahead caches request reordering proceedings sigmetrics conference measurement modeling computer systems pages talagala arpaci-dusseau patterson microbenchmark-based extraction local global disk characteristics technical report csd- california berkeley teorey pinkerton comparative analysis disk scheduling policies communications acm thornock flanagan stochastic disk simulation technique proceedings winter simulation conference pages wang reiher popek kuenning conquest performance disk persistent-ram hybrid system proceedings usenix annual technical conference usenix pages monterey june wilhelm anomaly disk scheduling comparison fcfs sstf seek scheduling empirical model disk accesses communications acm wilkes pantheon storage-system simulator technical report hpl-ssp- laboratories palo alto december worthington ganger patt scheduling algorithms modern disk drives proceedings acm sigmetrics conference measurement modeling computer systems pages nashville usa worthington ganger patt 
wilkes on-line extraction scsi disk drive parameters technical report cse-tr- carnegie mellon dec ganger mckusick soules patt soft updates solution metadata update problem file systems acm tocs golding bosch staelin sullivan wilkes idleness sloth usenix winter pages gutmann secure deletion data magnetic solidstate memory usenix security july hughes personal communication appears sixth symposium operating systems design implementation osdi hughes coughlin secure erase disk drive data idema insight magazine katcher postmark file system benchmark netapp troctober mckusick joy leffler fabry fast file system unix tocs aug mesnier ganger riedel object-based storage ieee communications magazine august pennington strunk griffin soules goodson ganger storage-based intrusion detection watching storage activity suspicious behavior usenix security riedel kallahalla swaminathan framework evaluating storage system security fast roselli lorch anderson comparison file system workloads usenix ruemmler wilkes disk shuffling technical report hpl- laboratories schindler griffin lumb ganger trackaligned extents matching access patterns disk drive characteristics fast january 
sivathanu prabhakaran arpaci-dusseau arpaci-dusseau improving storage system availability graid fast mar sivathanu prabhakaran popovici denehy arpaci-dusseau arpaci-dusseau semantically-smart disk systems fast sourceforge srm secure file deletion posix systems http srm sourceforge net sourceforge wipe secure file deletion http wipe sourceforge net sourceforge linux ntfs project http linux-ntfs net strunk goodson scheinholtz soules ganger self-securing storage protecting data compromised systems osdi tweedie future directions ext filesystem freenix june vmware vmware workstation http vmware products wang anderson patterson virtual log-based file systems programmable disk osdi wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february gum chen wang krishnamurthy anderson trading capacity performance disk array osdi guaranteed detection deletes prove techniques faded ext guarantee shredding deletes blocks contents reached disk delete inode occurs ext set blocks freed file results increment version number reset relevant bits data bitmap block pertaining freed blocks block freed assume written disk context written disk disk perform overwrite case bitmap block status block inode possibilities reused file system written disk reused write case block reused reused immediately file bitmap block dirtied eventually written disk disk immediately delete block liveness module overwrite case block reused case whereb reused inode possibilities case point receiving write disk thinks belongs thinks free belongs inode case disk thinks disk knew disk tracked previous version number eventually observes write dirtied version number increment disk note version number increased overwrite blocks thought belonged case includesb thusb overwritten restoring newer discussed section conservative overwrite contents guaranteed shredded case disk thinks free disk thinksb free treat orphan block written mark suspicious written context inode contents shredded case disk thinks disk observed pointing point current write disk observed allocated file system case c-i disk observed allocated thinks written context means disk case block deleted time past order allocated led version number incrementing disk observes written perform overwrite thinks belong case c-ii occurs means written disk owning deleted written case written context live overwritten discussed section holds block exclusivity property ext note case block deleted file quickly reallocated file special case case cases block written disk context file delete block file lead shred deleted contents indirect block detection uncertain disk wrongly corrupt pointer false indirect block file system change reuse ordering indirect blocks prevents case 
gum chen wang krishnamurthy anderson trading capacity performance disk array proceedings symposium operating systems design implementation pages san diego usenix association 
improving storage system availability d-graid muthian sivathanu vijayan prabhakaran andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison fmuthian vijayan dusseau remzig wisc abstract present design implementation evaluation d-graid gracefully-degrading quickly-recovering raid storage array d-graid ensures les system remain unexpectedly high number faults occur d-graid recovers failures quickly restoring live system data hot spare graceful degradation live-block recovery implemented prototype scsibased storage system underneath unmodi systems demonstrating powerful le-system functionality implemented narrow block-based interface introduction tree falls forest hears make sound george berkeley storage systems comprised multiple disks backbone modern computing centers storage system entire center grind halt downtime expensive on-line business world millions dollars hour lost systems storage system availability formally ned time failure mtbf divided sum mtbf time recovery mttr mtbf mtbf mttr improve availability onecan increase mtbf decrease mttr surprisingly researchers studied components availability increase time failures large storage array data redundancy techniques applied keeping multiple copies blocks sophisticated redundancy schemes parity-encoding storage systems tolerate small xed number faults decrease time recovery hot spares employed failure occurs spare disk activated lled reconstructed data returning system normal operating mode quickly narrow interface systems storage curtailed opportunities improving mtbf mttr raidstorage array disk fails repaired entire array corrupted availability cliff result storage system laying blocks oblivious semantic importance relationship les corrupted inaccessible extra disk failure time-consuming restore backup entire array remains unavailable disks operational storage array information blocks live system recovery process restore blocks disk unnecessary work slows recovery reduces availability ideal storage array fails gracefully disks system data unavailable ideal array recovers intelligently restoring live data effect important data disappear failure data restored earlier recovery strategy data availability stems berkeley observation falling trees isn process access recovered failure explore concepts provide storage array graceful failure semantics present design implementation evaluation d-graid raid system degrades gracefully recovers quickly d-graid exploits semantic intelligence disk array place system structures disks fault-contained manner analogous fault containment techniques found hive operating system distributed systems unexpected double failure occurs d-graid continues operation serving les accessed d-graid utilizes semantic knowledge recovery speci cally blocks system considers live restored hot spare aspects d-graid combine improve effective availability storage array note graid techniques complementary existing redunappears usenix symposium file storage technologies fast dancy schemes storage administrator con gures d-graid array utilize raid level single disk fail data loss additional failures lead proportional fraction unavailable data paper present prototype implementation d-graid refer alexander alexander semantically-smart disk system built underneath narrow block-based scsi storage interface disk system understands system data structures including super block allocation bitmaps inodes directories important structures knowledge central implementing graceful degradation quick recovery intricate understanding system structures operations semantically-smart arrays tailored systems alexander functions underneath unmodi linux ext vfat systems make important contributions semantic disk technology deepen understanding build semantically-smart disk systems operate correctly imperfect system knowledge demonstrate technology applied underneath widely varying systems demonstrate semantic knowledge raid system apply redundancy techniques based type data improving availability key aspects alexander implementation graceful degradation rst selective metadata replication alexander replicates naming system meta-data structures system high degree standard redundancy techniques data small amount overhead excess failures render entire array unavailable entire directory hierarchy traversed fraction les missing proportional number missing disks fault-isolated data placement strategy ensure semantically meaningful data units failure alexander places semantically-related blocks blocks storage array unit fault-containment disk observing natural failure boundaries found array failures make semantically-related groups blocks unavailable leaving rest system intact fault-isolated data placement improves availability cost related blocks longer striped drives reducing natural bene parallelism found raid techniques remedy alexander implements access-driven diffusion improve throughput frequently-accessed les spreading copy blocks hot les drives system alexander monitors access data determine les replicate fashion nds space replicas pre-con gured performance reserve opportunistically unused portions storage system evaluate availability improvements d-graid trace analysis simulation d-graid excellent job masking arbitrary number failures processes enabling continued access important data evaluate prototype alexander microbenchmarks trace-driven workloads construction d-graid feasible imperfect semantic knowledge powerful functionality implemented block-based storage array run-time overheads d-graid small cpu costs compared standard array high show access-driven diffusion crucial performance live-block recovery effective disks under-utilized combination replication data placement recovery techniques results storage system improves availability maintaining high level performance rest paper structured section present extended motivation section discuss design principles d-graid section present trace analysis simulations discuss semantic knowledge section section present prototype implementation evaluate prototype section discuss alternative methods implementing d-graid commercial feasibility semantic disk based approach section section present related work conclude section extended motivation case graceful degradation raid redundancy techniques typically export simple failure model fewer disks fail raid continues operate correctly degraded performance disks fail raid unavailable problem corrected restore tape raid schemes small disks working users observe failed disk system graceful degradation raid system absolutely tolerate xed number faults excess failures catastrophic data amount proportional number disks system continues allowing access data failed data restored matter users applications entire contents volume present matters set les question realistic expect catastrophic failure scenario raid system raidsystem high mtbf reported disk manufacturers appears usenix symposium file storage technologies fast disk failure highly occur rst failed disk repaired multiple disk failures occur primary reasons correlated faults common systems expected raid carefully designed orthogonal manner single controller fault component error render fair number disks unavailable redundant designs expensive found higher end storage arrays gray points system administration main source failure systems large percentage human failures occur maintenance maintenance person typed wrong command unplugged wrong module introducing double failure page evidence suggests multiple failures occur ibm serveraid array controller product includes directions attempt data recovery multiple disk failures occur raidstorage array organization data stored servers raidin servers single disk failed indicator informed administrators problem problem discovered disk array failed full restore backup ran days scenario graceful degradation enabled access large fraction user data long restore approach dealing multiple failures employ higher level redundancy enabling storage array tolerate greater number failures loss data techniques expensive three-way data mirroring bandwidth-intensive write redundant store graceful degradation complementary techniques storage administrators choose level redundancy common case faults graceful degradation enacted worse expected fault occurs mitigating ill 
effect semantically-smart storage implementing functionality semantically-smart disk system key bene enabling wide-scale deployment underneath unmodi scsi interface modi cation working smoothly existing systems software base desire evolve interface systems storage reality current interfaces survive longer anticipated bill joy systems protocols live forever mechanism d-graid deployed non-intrusive existing infrastructure semantic disks ensure design d-graid expectations section discuss design d-graid present background information systems data layout strategy required enable graceful degradation important design issues arise due layout process fast recovery file system background semantic knowledge system speci discuss d-graid design implementation widely differing systems linux ext microsoft vfat system inclusion vfat represents signi contribution compared previous research operated solely underneath unix systems ext system intellectual descendant berkeley fast file system ffs disk split set block groups akin cylinder groups ffs bitmaps track inode data block allocation inode blocks data blocks information including size block pointers found inode vfat system descends world operating systems paper linux vfat implementation fatalthough work general applies variants vfat operations centered eponymous allocation table entry allocatable block system entries locate blocks linked-list fashion rst block address entry fat block entry hold end-ofle marker setting block free unlike unix systems information found inode vfat system spreads information fat directory entries fat track blocks belong directory entry information size permission type information graceful degradation ensure partial availability data multiple failures raid array d-graid employs main techniques rst fault-isolated data placement strategy d-graid places semanticallyrelated set blocks unit fault containment found storage array simplicity discussion assume semantically-related set blocks single disk unit fault containment generalize easily generalized failure boundaries observed scsi chains refer physical disk belongs home site disk fails fault-isolated data placement ensures les disk appears usenix symposium file storage technologies fast foo bar inode foo inode bar data bar data bar data root data foo inode root foo bar inode foo inode bar data bar data bar data root data foo inode root inode foo inode bar data bar data bar foo data root bar data foo inode root inode root inode root inode root inode fooinode fooinode foo foo data root foo data root foo data root bar data foo bar data foo bar data foo figure comparison layout schemes gures depict layouts foo bar unix system starting root inode directory tree data vertical column represents disk simplicity assumes data redundancy user data left typical system layout non-d-graid disk system blocks pointers spread system single fault render blocks bar inaccessible middle fault-isolated data placement les directories scenario access inode access data indirect pointer blocks constrained disk finally selective meta-data replication replicating directory inodes directory blocks d-graid guarantee users les requisite pointers removed rightmost gure simplicity color codes white user data light shaded inodes dark shaded directory data home site unavailable les remain accessible les technique selective meta-data replication d-graid replicates naming system meta-data structures system high degree directory inodes directory data unix system d-graid ensures live data reachable orphaned due failure entire directory hierarchy remains traversable fraction missing user data proportional number failed disks d-graid lays logical system blocks availability single depends disks traditional raid array dependence set entire set disks group leading entire system unavailability unexpected failure unix-centric typical layout fault-isolated data placement selective meta-data replication depicted figure note techniques d-graid work meaningful subset system laid single d-graid array system striped multiple d-graid arrays single array meaningful view system scenario d-graid run logical volume manager level viewing arrays single disk techniques remain relevant d-graid treats system block type differently traditional raid taxonomy longer adequate describing d-graid behaves ner-grained notion raid level required graid employ redundancy techniques types data d-graid commonly employs n-way mirroring naming system meta-data standard redundancy techniques mirroring parity encoding raidfor user data note administrative control determines number failures d-graid degrade gracefully section explore data availability degrades varying levels namespace replication design considerations layout replication techniques required enable graceful degradation introduce host design issues highlight major challenges arise semantically-related blocks fault-isolated data placement d-graid places logical unit system data fault-isolated container disk blocks d-graid considers related determines data remains failure basic approach le-based grouping single including data blocks inode indirect pointers treated logical unit data technique user les directory unavailable frustration confusion groupings preserve meaningful portions system volume failure directory-based grouping d-graid ensures les directory unit fault containment automated options allowing users arbitrary semantic groupings d-graid treats unit load balance fault-isolated placement placing blocks disks blocks isolated single home site isolated placement improves availability introduces problem load balancing space time components terms space total utilized space disk maintained roughly level fraction disks fail roughly fraction data unavailable balancing addressed foreground data rst allocated background migration files directories larger amount free space single disk handled potentially appears usenix symposium file storage technologies fast expensive reorganization reserving large extents free space subset drives files larger single disk split disks pressing performance problems introduced fault-isolated data placement previous work striping data disks performance compared sophisticated placement algorithms d-graid makes additional copies user data spread drives system process call access-driven diffusion standard d-graid data placement optimized availability access-driven diffusion increases performance les frequently accessed surprisingly access-driven diffusion introduces policy decisions d-graid including place replicas made performance les replicate create replicas meta-data replication level degree meta-data replication d-graid determines resilient excessive failures high degree replication desirable meta-data replication costs terms space time space overheads trade-offs obvious replicas imply resiliency difference traditional raid d-graid amount space needed replication naming system meta-data dependent usage volume directories induces greater amount overhead time overheads higher degree replication implies lowered write performance naming system meta-data operations observed lack update activity higher levels directory tree lazy update propagation employed reduce costs fast recovery main design goal d-graid ensure higher availability fast recovery failure critical straightforward optimization d-graid recover live system data assume restoring data live mirror hot spare straightforward approach d-graid simply scans source disk live blocks examining system structures determine blocks restore process readily generalized complex redundancy encodings d-graid potentially prioritize recovery number ways restoring important les rst importance domain speci les users manner similar hoarding database coda exploring graceful degradation section simulation trace analysis 
evaluate potential effectiveness graceful degradation impact semantic grouping techniques rst quantify space overheads level replication -way -way -way ext ext vfat vfat table space overhead selective meta-data replication table shows space overheads selective metadata replication percentage total user data level naming system meta-data replication increases leftmost column percentage space overhead meta-data replication shown columns depict costs modest -way paranoid -way schemes row shows overhead system ext vfat block size set graid demonstrate ability d-graid provide continued access proportional fraction meaningful data arbitrary number failures importantly demonstrate d-graid hide failures users replicating important data simulations system traces collected labs cover days activity data spread logical volumes space overheads rst examine space overheads due selective meta-data replication typical d-graidstyle redundancy calculate cost selective meta-data replication percentage overhead measured volumes trace data calculate highest selective meta-data replication overhead percentage assuming replication user data user data mirrored overheads cut half table shows selective meta-data replication induces mild space overhead high levels meta-data redundancy linux ext vfat systems -way redundancy meta-data space overhead incurred worst case vfat blocks increasing block size ext space due internal fragmentation larger directory blocks overheads decrease vfat phenomenon due structure vfat xed-sized system block size grows allocation table shrinks blocks directory data grow static availability examine d-graid availability degrades failure semantic grouping strategies rst strategy le-based grouping information single failure boundary disk directory-based grouping allocates les directory analysis place entire les directories trace simulated -disk sysappears usenix symposium file storage technologies fast percent directories completely number failed disks static data availability directory-based -way directory-based -way file-based -way directory-based -way figure static data availability percent entire directories shown increasing disk failures simulated system consists disks loaded trace strategies semantic grouping shown le-based directory-based line varies level replication namespace meta-data point shows average deviation trials trial randomly varies disks fail tem remove simulated disks measure percentage directories assume user data redundancy d-graid level figure shows percent directories directory les accessible subdirectories les gure observe graceful degradation works amount data proportional number working disks contrast traditional raid disk crashes lead complete data unavailability fact availability degrades slightly expected strict linear fall-off due slight imbalance data placement disks directories modest level namespace replication -way leads good data availability failure conclude le-based grouping les directory disappear failure leading user dissatisfaction dynamic availability finally simulating dynamic availability examine users applications oblivious graid operating degraded mode speci cally run portion trace simulator number failed disks record percent processes observed failure run experiment namespace replication les needed processes replicated experiment set degree namespace replication full replication vary level replication contents popular directories usr bin bin lib figure percent unaffected processes number failed disks dynamic per-process availability popular replication -way -way -way figure dynamic data availability gure plots percent processes run unaffected disk failure busy hour trace degree namespace replication set aggressively line varies amount replication popular directories -way implies directories replicated -way -way show modest extreme amount replication means deviations trials shown shows replicating contents directories percent processes run ill-effect lower expected results figure directories replicated percentage processes run completion disk failure expected reason clear substantial number processes require executable libraries run correctly popular directory replication excellent availability failure fortunately popular les read directories wide-scale replication raise write performance consistency issues space overhead due popular directory replication minimal sized system trace directories account total system size semantic knowledge move construction d-graid prototype underneath block-based scsi-like interface enabling technology underlying d-graid semantic knowledge understanding system utilizes disk enables d-graid implement graceful degradation failure quick recovery exact details acquiring semantic knowledge disk raid system assume basic understanding system layout structures storage system speci cally assume d-graid static knowledge system layout including regions disk block types contents speci block types elds inode appears usenix symposium file storage technologies fast file system behaviors paper extend understanding semanticallysmart disks presenting techniques handle general system behaviors previous work required system mounted synchronously implementing complex functionality disk relax requirement describe assumptions general system behavior modern systems adhere behavioral guidelines blocks system dynamically typed system locate types blocks physical location disk lifetime system unix system block data region user-data block indirect-pointer block directory-data block system delay updates disk delayed writes system facilitate batching small writes memory suppressing writes les subsequently deleted consequence delayed writes order system writes data disk arbitrary systems order writes carefully remain general make assumptions ordering note assumptions made practical reasons linux ext system exhibits aforementioned behaviors accuracy information assumptions general system behavior imply storage system accurately classify type block block classi cation straightforward type block depends location disk berkeley fast file system ffs regions disk store inodes xed system creation traf regions inodes type information spread multiple blocks block lled indirect pointers identi observing inode speci cally inode indirect pointer eld address indirect block formally identify indirect block semantic disk inode block indirect pointer eld relevant inode block written disk disk infers indirect block observes block written information classify treat block indirect block due delayed write reordering behavior system time disk writes block freed original inode reallocated inode type normal data block disk operations place memory ected disk inference made semantic disk block type wrong due inherent staleness information tracked implementing correct system potentially inaccurate inferences challenges address paper implementation making d-graid discuss prototype implementation graid alexander alexander faultisolated data placement selective meta-data replication provide graceful degradation failure employs access-driven diffusion correct performance problems introduced availability-oriented layout alexander replicates namespace system meta-data administrator-controlled stores user data raidor raidmanner refer systems d-graid levels pursuing d-graid level implementation logstructuring avoid small-write problem exacerbated fault-isolated data placement section present implementation graceful degradation live-block recovery complexity discussion centered graceful degradation simplicity exposition focus construction alexander underneath linux ext system end section discuss differences implementation underneath vfat graceful degradation present overview basic operation graceful degradation alexander indirection map similar scsi-based raid system alexander presents host systems linear logical block address space internally alexander place blocks facilitate graceful degradation control placement alexander introduces transparent level indirection logical array system physical placement disks indirection map imap similar structures unlike systems imap maps live logical system block replica list physical 
locations unmapped blocks considered free candidates d-graid reads handling block read requests d-graid level straightforward logical address block alexander imap replica list issues read request replicas choice replica read based criteria alexander randomized selection appears usenix symposium file storage technologies fast figure anatomy write gure depicts control sequence write operations alexander rst gure inode block written alexander observes contents inode block identi newly added inode selects home site inode creates physical mappings blocks inode home site inode block aggressively replicated gure alexander observes write data block inode mapped write directly physical block gure alexander write unmapped data block defers block alexander nally observes inode fourth gure creates relevant mappings observes blocks deferred issues deferred write relevant home site writes contrast reads write requests complex handle alexander handles write request depends type block written figure depicts common cases block static meta-data block inode bitmap block unmapped alexander allocates physical block disks replica reside writes copies note alexander easily detect static block types inode bitmap blocks underneath unix systems simply observing logical block address inode block written d-graid scans block newly added inodes understand inodes d-graid compares newly written block copy process referred block differencing inode d-graid selects home site lay blocks belonging inode records inode-to-homesite hashtable selection home site balance space allocation physical disks d-graid greedy approach selects home site disk space utilization write unmapped block data region data block indirect block directory block allocation d-graid block belongs actual home site case d-graid places block deferred block list write disk learns block crash inode write make block inaccessible system in-memory deferred block list reliability concern d-graid newly added block pointers inode indirect block written newly added block pointer refers unmapped block graid adds entry imap mapping logical block physical block home site assigned inode newly added pointer refers block deferred list d-graid removes block deferred list issues write physical block writes deferred blocks written owner inode blocks inode written rst subsequent data writes mapped disk directly block type interest d-graid data bitmap block data bitmap block written d-graid scans newly freed data blocks freed block graid removes logical-to-physical mapping exists frees physical blocks block deferred list freed block removed deferred list write suppressed data blocks written system deleted inode written disk generate extra disk traf similar optimizations found systems removing blocks deferred list important case freed blocks alexander observe owning inode deferred block stays deferred list bounded amount time inode owning block written bitmap block indicating deletion block written exact duration depends delayed write interval system block reuse discuss intricate issues involved implementing graceful degradation rst issue block reuse existing les deleted truncated les created blocks part reallocated graid place blocks correct home site reuse blocks detected acted d-graid handles block reuse manner inode block indirect block written d-graid examines valid block pointer physical block mapping matches home site allocated inode d-graid mapping block correct home site write block made context home site copied physical location location blocks copied added pending copies list background thread copies appears usenix symposium file storage technologies fast blocks home site frees physical locations copy completes dealing imperfection dif culty arises semantically-smart disks underneath typical systems exact knowledge type dynamically-typed block impossible obtain discussed section alexander handle incorrect type classi cation data blocks data directory indirect blocks d-graid understand contents indirect blocks pointers place blocks home site due lack perfect knowledge fault-isolated placement compromised note data loss corruption issue goal dealing imperfection conservatively avoid eventually detect handle cases speci cally block construed indirect block written assume valid indirect block live pointer block d-graid action cases rst case pointer refer unmapped logical block mentioned d-graid creates mapping home site inode indirect block belongs indirect block pointer valid mapping correct mapping indirect block misclassi pointer invalid d-graid detects block free observes data bitmap write point mapping removed block allocated bitmap written d-graid detects reallocation inode write creates mapping copies data contents home site discussed case potentially corrupt block pointer point mapped logical block discussed type block reuse results mapping copy block contents home site indirect block pointer valid mapping correct block indirect block misclassi cation alexander wrongly copies data home site note data accessible original block belongs blocks incorrect home site fortunately situation transient inode written d-graid detects reallocation creates mapping back original home site restoring correct mapping files accessed properly laid infrequent sweep inodes rare cases improper layout optimizations d-graid eventually move data correct home site preserving graceful degradation reduce number times misclassi cation occurs alexander makes assumption contents indirect blocks speci cally number valid unique pointers null pointers alexander leverage assumption greatly reduce number misclassi cations performing integrity check supposed indirect block integrity check reminiscent work conservative garbage collection returns true pointers -byte words block point valid data addresses volume non-null pointers unique set blocks pass integrity check corrupt data contents happened evade conditions test run data blocks system small fraction data blocks pass test blocks pass test reallocated data block indirect block misclassi access-driven diffusion issue d-graid address performance fault-isolated data placement improves availability cost performance data accesses blocks large directory-based grouping les directory longer parallelized improve performance alexander performs access-driven diffusion monitoring block accesses determine hot diffusing blocks replication disks system enhance parallelism access-driven diffusion achieved logical physical levels disk volume logical approach access individual les monitored considered hot diffused perle replication fails capture sequentiality multiple small les single directory pursue physical approach alexander replicates segments logical address space disks volume systems good allocating contiguous logical blocks single les directory replicating logical segments identify exploit common access patterns implement access-driven diffusion alexander divides logical address space multiple segments normal operation gathers statistics utilization access patterns segment background thread selects logical segments bene access-driven diffusion diffuses copy drives system subsequent reads writes rst replicas background updates original blocks imap entry block copy date amount disk space allocate performanceoriented replicas presents important policy decision initial policy alexander implements reserve minimum amount space speci sysappears usenix symposium file storage technologies fast tem administrator replicas opportunistically free space array additional replication approach similar autoraid mirrored data autoraid identify 
data considered dead system written contrast d-graid semantic knowledge identify blocks free live-block recovery implement live-block recovery d-graid understand blocks live knowledge correct block live considered dead lead data loss alexander tracks information observing bitmap data block traf bitmap blocks liveness state system reected disk due reordering delayed updates uncommon observe write data block bit set data bitmap account d-graid maintains duplicate copy bitmap blocks sees write block sets bit local copy bitmap duplicate copy synchronized system copy data bitmap block written system conservative bitmap table ects superset live blocks system perform live-block recovery note assume pre-allocation state bitmap written disk subsequent allocation locking linux modern systems ensures technique guarantees live block classi dead disk block live longer situation arise system writes deleted blocks disk implement live-block recovery alexander simply conservative bitmap table build list blocks restored alexander proceeds list copies live data hot spare aspects alexander host aspects implementation required successful prototype discuss length due space limitations found preserving logical contiguity system important block allocation developed mechanisms enable placement directory-based grouping requires sophistication implementation handle deferral writes parent directory block written time block allocation prevents misclassi indirect blocks causing spurious physical block allocation deferred list management introduces tricky issues memory alexander preserves sync semantics returning success inode block writes deferred block writes waiting inode complete number structures alexander maintains imap reliably committed disk preferably good performance buffered small amount non-volatile ram important component missing alexander decision popular read-only directories usr bin replicate widely alexander proper mechanisms perform replication policy space remains unexplored initial experience simple approach based monitoring frequency inode access time updates effective alternative approach administrators directories treated manner interesting issue required change design behavior linux ext partial disk failure process read data block unavailable ext issues read returns failure process block recovery process issues read ext issue read works expected process open inode unavailable ext marks inode suspicious issue request inode block alexander recovered block avoid change system retain ability recover failed inodes alexander replicates inode blocks namespace meta-data collocating data blocks alexander fat surprised similarities found implementing d-graid underneath ext vfat vfat overloads data blocks user data blocks directories alexander defer classi cation blocks manner similar ext implementation instances vfat implementation d-graid differed interesting ways ext version fact pointers located allocation table made number aspects d-graid simpler implement vfat indirect pointers worry ran occasional odd behavior linux implementation vfat linux write disk data blocks allocated freed avoiding obvious common system optimization indicative untuned nature linux implementation served indicator semantic disks wary assumptions make system behavior evaluating alexander present performance evaluation alexander focus primarily linux ext variant appears usenix symposium file storage technologies fast misplaced blocks time sec misplaced blocks remapping remapping close-up close-up figure errors placement gure plots number blocks wrongly laid alexander time running busy hour trace experiment run disks total number blocks accessed trace include baseline measurements vfat system answer questions alexander work correctly time overheads introduced effective access-driven diffusion fast live-block recovery bene expect d-graid complex implementation platform alexander prototype constructed software raid driver linux kernel file systems mount pseudo-device normal disk environment excellent understanding issues involved construction real hardware d-graid system limited ways importantly alexander runs system host applications interference due competition resources performance characteristics microprocessor memory system found actual raid system experiments utilize mhz pentium iii k-rpm ibm disks alexander work correctly alexander complex simple raid systems ensure alexander operates correctly put system numerous stress tests moving large amounts data system problems extensively tested corner cases system pushing situations dif cult handle making system degrades gracefully recovers expected repeatedly crafted microbenchmarks stress mechanisms detecting block reuse handling imperfect information dynamically-typed blocks constructed benchmarks write user data blocks disk slowdown versus raidoperational overheads ext fat create read overwrite unlink figure time overheads gure plots time overheads observed d-graid level versus raid level series microbenchmarks tests run disk systems experiment operations enacted creations operation worst case data data appears valid directory entries indirect pointers cases alexander detect blocks indirect blocks move les directories proper fault-isolated locations verify alexander places blocks disk instrumented system log block allocations addition alexander logs events interest assignment home site inode creation mapping logical block re-mapping blocks homesite receipt logical writes system evaluate behavior alexander workload run workload alexander obtain time-ordered log events occurred system alexander process log off-line number blocks wrongly laid time ran test hours traces found hours examined number blocks misplaced temporarily low blocks report detailed results hour trace observed greatest number misplaced blocks hours examined figure shows results gure parts bottom part shows normal operation alexander capability react block reuse remapping copying blocks correct homesite gure shows alexander quickly detect wrongly blocks remap appropriately number blocks misplaced temporarily total number blocks accessed trace top part gure shows number misplaced blocks experiment assuming remapping occur expected delinquent blocks remain misplaced dip end trace occurs appears usenix symposium file storage technologies fast run-time blocks written seconds total meta uniquedata raidd-graid d-graid d-graid d-graid table performance postmark table compares performance d-graid level raidon postmark benchmark row marked d-graid speci level metadata replication rst column reports benchmark run-time column shows number disk writes incurred column shows number disk writes metadata blocks fourth column number unique metadata blocks written experiment run disks misplaced blocks assigned homesite accidentally correcting original misplacement time overheads introduced explore time overheads arise due semantic inference primarily occurs blocks written system creation figure shows performance alexander simple microbenchmark allocating writes slower due extra cpu cost involved tracking fault-isolated placement reads overwrites perform comparably raidthe high unlink times graid fat fat writes data pertaining deleted les processed d-graid newly allocated data implementation untuned infrastructure suffers cpu memory contention host worst case estimates overheads cost d-graid explore overhead metadata replication purpose choose postmark metadata intensive system benchmark slightly modi postmark perform sync deletion phase metadata writes accounted making pessimistic evaluation costs table shows performance alexander degrees metadata replication table synchronous replication metadata blocks signi effect performance metadata intensive workloads sizes postmark range bytes note alexander performs default raidfor lower degrees replication physical block allocation ext contiguous free chunk 
blocks allocate layout sub-optimal small les table shows number disk writes incurred benchmark percentage extra disk writes roughly accounts difference perbandwidth file size access-driven diffusion raidd-graid file-based access-driven diffusion d-graid directory-based access-driven diffusion d-graid file-based d-graid directory-based figure access-driven diffusion gure presents performance d-graid level standard raidunder sequential workload experiment number les size read sequentially total volume data xed d-graid performs smaller les due physical block layout formance replication levels extra writes metadata blocks count number unique physical writes metadata blocks absolute difference replication levels small suggests lazy propagation updates metadata block replicas idle time freeblock scheduling greatly reduce performance difference cost added complexity lazy update propagation replicas updated d-graid incur extra disk writes played back portion traces minutes standard raidsystem d-graid disks playback engine issues requests times speci trace optional speedup factor speedup implies idle time requests reduced factor speedup factors d-graid delivered persecond operation throughput raidutilizing idle time trace hide extra cpu overhead scaling factor operation throughput lagged slightly d-graid showing slowdown rst one-third trace execution caught due idle time effective access-driven diffusion show bene access-driven diffusion trial experiment perform set sequential reads les increasing size compare standard raidstriping d-graid access-driven diffusion figure shows results experiment gure access-driven diffusion sequential access larger les run rate single disk system bene potential parallelism access-driven diffusion performance improved reads directed appears usenix symposium file storage technologies fast reconstruction time live volume percentage costs reconstruction d-graid level worst case d-graid level case idealized raid level figure live-block recovery gure shows time recover failed disk hot spare d-graid level mirrored system live-block recovery lines graid plotted worst case live data spread entire volume case compacted smallest contiguous space plotted recovery time idealized raid level diffused copies disks system note case arrange les diffused start experiment reading threshold number times investigating sophisticated policies initiate access-driven diffusion left future work fast live-block recovery explore potential improvement live-block recovery figure presents recovery time d-graid varying amount live system data gure plots lines worst case case live-block recovery worst case live data spread disk case compacted single portion volume graph live-block recovery successful reducing recovery time disk half full note difference worst case case times difference suggests periodic disk reorganization speed recovery moving live data localized portion bene expect d-graid demonstrate improved availability alexander failures figure shows availability performance observed process randomly accessing les running d-graid raidto ensure fair comparison d-graid raidlimit reconstruction rate gure shows reconstruction volume live data completes faster graid compared raids extra failure occurs availability raiddrops d-graid continues availability surprisingly restore raidstill fails les linux retry inode blocks fail remount required availability ops succeed file throughput files sec time sec raid availability raid throughput d-graid availability d-graid throughput operation failure firstfailure reconcomplete failureafter recon secondfailure restore offailed disk re-mount reconcomplete figure availability pro gure shows operation d-graid level raid failures array consists data disks hot spare rst failure data reconstructed hot spare d-graid recovering faster raid failures occur raid loses les d-graid continues serve les workload consists read-modify-writes les randomly picked working set raidreturns full availability complex implementation brie quantify implementation complexity alexander table shows number statements required implement components alexander table core system inferencing module ext requires lines code counted number semicolons core mechanisms d-graid contribute lines code rest spent hash table avl tree wrappers memory management compared tens lines code comprising modern array rmware added complexity d-graid signi discussion section rst compare semantic-disk based approach alternative methods implementing graid discuss concerns commercial feasibility semantic disk systems alternative approaches semantic disk based approach ways implementing d-graid trade-offs similar modern processors innovate beneath unchanged instruction sets semantic disk level implementation facilitates ease deployment inter-operability unchanged client infrastructure making pragmatic cost approach complexity rediscovering semantic knowledge tolerant inaccuracies alternative approach change interface systems storage convey richer information layers instance storage system expose failure boundaries system appears usenix symposium file storage technologies fast semicolons total d-graid generic setup fault-isolated placement physical block allocation access driven diffusion mirroring live block recovery internal memory management hashtable avl tree file system speci sds inferencing ext sds inferencing vfat total table code size alexander implementation number lines code needed implement alexander shown rst column shows number semicolons column shows total number lines including white-spaces comments system explicitly allocate blocks fault-isolated manner alternatively system tag write logical fault-container storage system implement faultisolated data placement techniques intrusive existing infrastructure software base conceivably complex approach object-based storage interface considered makes boundaries visible storage layer objectbased interface semantically-smart technology relevant discover relationships objects instance inferring directory object points set objects collocated commercial feasibility nition d-graid semantically-smart storage systems detailed knowledge system embedding higher degree functionality storage system leads concerns commercial feasibility systems rst concern arises placing semantic knowledge disk system ties disk system intimately system system on-disk structure storage system change issue problematic on-disk formats evolve slowly reasons backwards compatibility basic structure ffs-based systems changed introduction period twenty years linux ext system introduced roughly exact layout lifetime nally ext journaling system backwards compatible ext on-disk layout extensions freebsd system backwards compatible evidence storage vendors maintain support software speci system emc symmetrix storage system software understand format common systems concern storage system semantic knowledge system interacts fortunately large number systems supported cover large fraction usage population semantic storage system system support storage system detect system conform expectations turn special functionality case d-graid revert normal raid layout detection simple techniques observing system identi partition table nal concern arises processing required disk system major issue general trend increasing disk system intelligence processing power increases disk systems substantial computational abilities modern storage arrays exhibit fruits moore law emc symmetrix storage server congured processors ram related work d-graid draws related work number areas including distributed systems traditional raid systems discuss turn distributed file systems designers distributed systems long ago realized problems arise spreading directory tree machines system walker discuss importance directory namespace replication locus distributed system coda mobile system takes explicit care regard directory tree speci cally cached coda makes cache directory root directory tree coda guarantee remains accessible disconnection occur interesting extension work reconsider host-based inmemory caching 
availability mind slice route namespace operations les directory server recently work wide-area systems re-emphasized importance directory tree pangaea system aggressively replicates entire tree root node accessed island-based system points fault isolation context widearea storage systems island principle similar fault-isolated placement d-graid finally systems past place entire single machine similar load balancing issues problem dif cult space due constraints placement block appears usenix symposium file storage technologies fast migration simpler centralized storage array traditional raid systems draw long history research classic raid systems autoraid learned complex functionality embedded modern storage array background activity utilized successfully environment afraid learned exible trade-off performance reliability delaying updates raid research focused redundancy schemes early work stressed ability tolerate single-disk failures research introduced notion tolerating multiple-disk failures array stress work complementary line research traditional techniques ensure full system availability number failures d-graid techniques ensure graceful degradation additional failures related approach parity striping stripes parity data achieve fault isolation layout oblivious semantics data blocks level redundancy irrespective importance meta-data data multiple failures make entire system inaccessible number earlier works emphasize importance hot sparing speed recovery time raid arrays work semantic recovery complementary approaches finally note term graceful degradation refer performance characteristics redundant disk systems failure type graceful degradation discuss paper systems continues operation unexpected number failures occurs conclusions robust system continues operate correctly presence class errors robert hagmann d-graid turns simple binary failure model found storage systems continuum increasing availability storage continuing operation partial failure quickly restoring live data failure occur paper shown potential bene d-graid established limits semantic knowledge shown successful d-graid implementation achieved limits simulation evaluation prototype implementation found d-graid built underneath standard block-based interface system modi cation delivers graceful degradation live-block recovery access-driven diffusion good performance conclude discussions lessons learned process implementing d-graid limited knowledge disk imply limited functionality main contributions paper demonstration limits semantic knowledge proof implementation limitations interesting functionality built inside semantically-smart disk system semantic disk system careful assumptions system behavior hope work guide pursue similar semantically-smart disks easier build systems reorder delay hide operations disks reverse engineering scsi level dif cult small modi cations systems substantially lessen dif culty system inform disk believes system structures consistent ondisk state challenges disk lessened small alterations ease burden semantic disk development semantically-smart disks stress systems unexpected ways file systems built operate top disks behave d-graid speci cally behave part volume address space unavailable heritage inexpensive hardware linux systems handle unexpected conditions fairly exact model dealing failure inconsistent data blocks missing reappear true inodes semantically-smart disks push functionality storage systems evolve accommodate detailed traces workload behavior invaluable excellent level detail traces simulate analyze potential d-graid realistic settings traces per-process information anonymize extent pathnames included trace utilize study remaining challenge tracing include user data blocks semantically-smart disks sensitive contents privacy concerns campaign encounter dif cult overcome acknowledgments anurag acharya erik riedel yasushi saito john bent nathan burnett timothy denehy brian forney florentina popovici lakshmi bairavasundaram insightful comments earlier drafts paper richard golding excellent shepherding anonymous reviewers thoughtful suggestions greatly improved content paper finally appears usenix symposium file storage technologies fast computer systems lab providing terri environment computer science research work sponsored nsf ccrccr- ccrngs- itritr- ibm emc wisconsin alumni research foundation acharya uysal saltz active disks programming model algorithms evaluation asplos viii san jose october alvarez burkhard cristian tolerating multiple failures raid architectures optimal storage uniform declustering isca pages anderson chase vahdat interposed request routing scalable network storage acm transactions computer systems february bitton gray disk shadowing vldb pages los angeles august boehm weiser garbage collection uncooperative environment software practice experience september burkhard menon disk array storage system reliability ftcspages toulouse france june chapin rosenblum devine lahiri teodosiu gupta hive fault containment shared-memory multiprocessors sosp december chen lee gibson katz patterson raid high-performance reliable secondary storage acm computing surveys june denehy arpaci-dusseau arpaci-dusseau bridging information gap storage protocol stacks usenix june dowse malone recent filesystem optimisations freebsd freenix monterey june emc corporation symmetrix enterprise information storage systems http emc english stepanov loge self-organizing disk controller usenix winter january ganger blurring line oses storage devices technical report cmu-cs- carnegie mellon december ganger mckusick soules patt soft updates solution metadata update problem file systems acm tocs ganger worthington hou patt disk subsystem load balancing disk striping conventional data placement hicss gibson nagle amiri butler chang gobioff hardin riedel rochberg zelenka costeffective high-bandwidth storage architecture asplos viii october gray computers stop international conference reliability distributed databases june gray horst walker parity striping disc arrays low-cost reliable storage acceptable throughput proceedings international conference large data bases vldb pages brisbane australia august gribble robustness complex systems hotos viii schloss elmau germany hagmann reimplementing cedar file system logging group commit sosp november holland gibson siewiorek fast on-line failure recovery redundant disk arrays ftcsfrance hsiao dewitt chained declustering availability strategy multiprocessor database machines international data engineering conference ibm serveraid recovering multiple disk failures http ibm qtechinfo migrhtml felten wang singh archipelago islandbased file system highly scalable internet services usenix windows symposium august katcher postmark file system benchmark technical report trnetwork appliance oct keeton wilkes automating data dependability proceedings acm-sigops european workshop pages saint-emilion france september kistler satyanarayanan disconnected operation coda file system acm tocs february mckusick joy lef fabry fast file system unix acm tocs august menon mattson comparison sparing alternatives disk arrays isca gold coast australia microsoft corporation http microsoft hwdev december orji solworth doubly distorted mirrors sigmod washington park balasubramanian providing fault tolerance parallel secondary storage systems technical report cs-tr- princeton november patterson gibson katz case redundant arrays inexpensive disks raid sigmod june patterson availability maintainability performance focus century key note fast january popek walker chow edwards kline rudisin thiel locus network transparent high reliability distributed system sosp december reddy banerjee gracefully degradable disk arrays ftcspages montreal canada june riedel gibson faloutsos active storage largescale data mining multimedia proceedings international conference large databases vldb york york august riedel kallahalla swaminathan framework evaluating storage system security fast pages monterey january rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february rowstron druschel storage management caching past large-scale persistent peer-to-peer storage 
utility sosp banff canada october ruemmler wilkes disk shuf ing technical report hpl- hewlett packard laboratories saito karamanolis karlsson mahalingam taming aggressive replication pangaea wide-area system osdi boston december savage wilkes afraid frequently redundant array independent disks usenix pages san diego january sivathanu prabhakaran popovici denehy arpaci-dusseau arpaci-dusseau semantically-smart disk systems fast san francisco march tweedie future directions ext filesystem freenix monterey june wang anderson patterson virtual log-based file systems programmable disk osdi orleans february wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february wolf placement optimization problem practical solution disk file assignment problem sigmetrics pages berkeley 
semantically-smart disk systems muthian sivathanu vijayan prabhakaran florentina popovici timothy denehy andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison abstract propose evaluate concept semantically-smart disk system sds opposed traditional smart disk sds detailed knowledge system disk system including information on-disk data structures system sds exploits knowledge transparently improve performance enhance functionality beneath standard block read write interface automatically acquire knowledge introduce tool eof discover le-system structure types systems show sds exploit knowledge on-line understand le-system behavior quantify space time overheads common sds showing excessive study issues surrounding sds construction designing implementing number prototypes case studies case study exploits knowledge aspect system implement powerful functionality beneath standard scsi interface surprising amount functionality embedded sds hinting future disk manufacturers compete enhanced functionality simply cost-per-byte performance introduction true knowledge confucius microprocessors memory chips smaller faster cheaper embedding processing memory peripheral devices increasingly attractive proposition placing processing power memory capacity smart disk system functionality migrated system disk raid providing number potential advantages traditional system computation takes place data improve performance reducing traf host processor disk disk system exploit low-level information typically le-system level including exact head position blockmapping information finally unmodi systems leverage optimizations enabling deployment broad range systems smart disk systems great promise realizing full potential proven dif cult causative reason shortfall narrow interface systems disks disk subsystem receives series block read write requests inherent meaning data structures system bitmaps tracking free space inodes data blocks directories indirect blocks exposed research efforts limited applying disk-system intelligence manner oblivious nature meaning system traf improving write performance writing blocks closest free space disk ful potential retain utility smart disk systems smarter interface storage remains system acquire knowledge system exploit understanding order enhance functionality increase performance storage system understands blocks constitute perform intelligent prefetching perle basis storage system blocks unused system utilize space additional copies blocks improved performance reliability storage system detailed knowledge system structures policies semantically-smart disk system sds understands meaning operations enacted important problem solved sds information discovery disk learn details system on-disk data structures straight-forward approach assume disk exact white-box knowledge system structures access relevant header les cases information unavailable cumbersome maintain paper explore gray-box approach attempting proceedings usenix conference file storage technologies fast san francisco california automatically obtain le-system speci knowledge storage system develop present ngerprinting tool eof automatically discovers le-system layout probes observations show eof smart disk system automatically discover layout class systems similar berkeley fast file system ffs show exploit layout information infer higher-level le-system behavior processes classi cation association operation inferencing refer ability categorize disk block data inode bitmaps superblock detect precise type data block directory indirect pointer associate data block inode relevant information identify higher-level operations creation deletion sds techniques implement desired functionality prototype smart disk system software infrastructure in-kernel driver interposes read write requests system disk prototype environment explore challenges adding functionality sds adhering existing interfaces running underneath stock system paper focus linux ext ext systems netbsd ffs understand performance characteristics sds study overheads involved ngerprinting classi cation association operation inferencing microbenchmarks quantify costs terms space time demonstrating common overheads excessive finally illustrate potential semantically-smart storage systems implemented number case studies sds framework aligning les track boundaries increase performance smallle operations information lesystem structures implement effective secondlevel caching schemes volatile non-volatile memory secure-deleting disk system ensures non-recoverability deleted les journaling storage system improve crash recovery time case studies demonstrate broad range functionality implemented semantically-smart disk system cases demonstrate sds tolerate imperfect information system key building robust semantically-smart disk systems rest paper organized section discuss related work discuss lesystem ngerprinting section classi cation association section operation inferencing section evaluate system section present case studies section conclude section related work related work smart disks grouped categories rst group assumes interface storage systems xed changed category sds belongs research group proposes storage interface requiring systems modi leverage interface finally group proposes interface programming model applications fixed interfaces focus paper integration smart disks traditional system environment environment system narrow scsi-like interface storage disk persistent store data structures early smart disk controller loge harnessed processing capabilities improve performance writing blocks current disk-head position wang log-based programmable disk extended approach number ways quick crash-recovery free-space compaction systems assume require knowledge system structures storage system interfaces developed provided local setting opportunities functionality network packet lter slice virtual service slice interpose nfs traf clients implement range optimizations preferential treatment small les interposing nfs traf stream simpler scsi-disk block stream contents nfs packets well-de ned high-end raid products perfect place semantic smartness typical enterprise storage system substantial processing capabilities memory capacity emc symmetrix server eighty mhz motorola microprocessors con gured memory high-end raid systems leverage resources perform bare minimum semanticallysmart behavior storage systems emc recognize oracle data block provide extra checksum assure block write comprised multiple sector writes reaches disk atomically paper explore acquisition exploitation detailed knowledge system behavior expressive interfaces primary factors limits addition functionality smart disk narrow interface systems storage surprising research investigates changing interface brie highlight projects mime investigates enhanced interface context intelligent raid controller speci cally mime adds primitives proceedings usenix conference file storage technologies fast san francisco california clients control updates storage visible traf streams commit order operations logical disks expand interface allowing system express grouping preferences lists systems simpli maintain information raid exposes per-disk information informed system lfs providing performance optimizations control redundancy improved manageability storage finally ganger suggests reevaluation interface needed outlines relevant case studies track-aligned extents explore paper freeblock scheduling recent work storage community suggests evolution storage place disks general-purpose network standard scsi bus suggested network disks export higher-level object-like interface moving responsibilities low-level storage management system drives speci challenges context xed object-based interface systems storage provide interesting avenue research utility semantic awareness programming environments contrast integration underneath traditional system work focused incorporating active storage parallel programming environments recent work active disks includes acharya riedel amiri research focuses partition applications host disk cpus minimize data transferred system busses inferring on-disk structures fingerprinting file system semantically smart disk implement interesting functionality interpret types blocks read written disk speci characteristics blocks sds practical information obtained robust manner require human 
involvement alternatives obtaining information rst approach directly embeds knowledge system sds onus understanding target system developer sds obvious drawbacks sds rmware updated system upgraded sds robust target system approach target system informs sds data structures run-time case responsibilities target system numerous disadvantages approach importantly target system changed system process access information directly communicate sds communication channel existing protocols added target system sds finally dif cult ensure speci cation communicated sds matches actual system implementation approach sds automatically infers system data structures bene approach speci knowledge target system required sds developed assumptions made sds target system checked deployed additional work required con gure sds installed sds deployed environments difculty approach potential semantically-smart storage system explore sds automatically acquire layout information ngerprinting software automatically inferring system structures bears similarity research efforts reverseengineering researchers shown bit-level machine instruction encodings semantic meaning assembly instructions deduced developed techniques identify parameters tcp protocol extract lowlevel characteristics disks determine buffer-cache policies understand behavior real-time cpu scheduler assumptions automatically inferring layout information arbitrary system challenging problem important rst step developed utility called eof extraction filesystems extract layout information ffs-like systems journaling capabilities veri eof identify data structures employed linux ext ext netbsd ffs eof understand future ffs-like system adheres assumptions layout data structures disk general disk blocks statically exclusively assigned categories data inodes bitmaps free allocated data blocks inodes summary information superblock group descriptors log data eof identi block addresses disk allocated category data blocks data block dynamically data directory listings pointers data blocks indirect block data blocks shared les eof identi structure directory data proceedings usenix conference file storage technologies fast san francisco california eof assumes record directory data block length record entry length entry inode number entry eld directory entry assumed multiple bits eof assumes indirect blocks -bit pointers inode blocks inode block inodes inode consumes n-th block eof assumes nition inode eld static time eof identi location absence elds inode size blocks number data blocks allocated inode ctime time inode changed mtime time data changed dtime deletion time links number links inode generation number data pointers number combination direct pointers single double triple indirect pointers dir bits bits change directory inodes exception dir bits elds identify default assumed multiple bits multiple elds identi bits blocks links elds size eld assumed largest multiple bits lead overlapping elds bitmap blocks bitmaps data inodes share single block separate blocks bits data inode bitmap blocks one-to-one linear mapping data blocks inodes bitmap block valid log data log data journaling system managed circular contiguous buffer make assumptions contents log future feasibility inferring on-disk data structures depends assumption production systems change slowly time assumption hold system developers strong motivation on-disk structures legacy systems continue operate examining systems past present corroborates belief on-disk structure ffs system changed years linux ext system layout conception ext journaling system backward compatible ext extensions freebsd ffs designed avoid on-disk algorithm overview eof software system made sds partition eof run partition sds understands context deployed basic structure eof user-level probe process performs operations system generating controlled traf streams disk sds high-level operations performed disk traf result observing blocks written bytes blocks change sds infers blocks type system data structures offsets block type eld sds knowledge con gure simultaneously verifying target system behaves expected sds correlate traf observes system operations performed probe process correlation requires pieces functionality probe process ensure blocks operation ushed system cache written sds ensure probe process unmounts system unmounting re-mounting sparingly increases running time eof probe process occasionally inform sds speci operation ended probe process communicates sds writing distinct pattern fencepost sds pattern resulting traf message probe process general techniques eof identify blocks inode elds identify data blocks sds pattern probe process writes test les classify blocks elds sds attempts isolate unique unclassied block written operation set operations operations algorithm phases eof composed phases eof isolates summary blocks log eof identi data blocks data bitmaps eof inodes inode bitmaps blocks classi eof isolates inode elds finally eof identi elds directory entries bootstrapping phase goal bootstrapping isolate blocks frequently written phases tered blocks interest phase isolates summary blocks log inode data blocks fencepost test directory test les probe process creates fencepost number test les test directory sds identies data blocks searching patterns eof identi blocks belonging log exists step probe process synchronously appends data pattern proceedings usenix conference file storage technologies fast san francisco california test les sds observes blocks meta-data blocks written circular pattern belong log block traf matches pattern eof infers system perform journaling eof identi summary blocks probe process unmounts system written blocks classi log data identi summary blocks isolate inode blocks repeatedly written probe process performs chmod fencepost test directory test les case inode written allowing classied data blocks belonging test directory identi changing test blocks previously unidenti blocks written finally determine separate bitmap blocks data inode blocks linux ext ext single bitmap block shared netbsd ffs eof creates sds observes unclassi blocks determine bitmap blocks shared separate data inodes simplify presentation remainder discussion case data inode bitmaps separate blocks eof correctly handles shared case case eof isolates speci bits shared bitmap block devoted inode data block state data data-bitmap blocks phase eof continues identifying blocks disk data data bitmaps isolate blocks probe process appends blocks data pattern test les blocks match pattern classi assumed data-bitmap blocks indirect-pointer blocks eof differentiates inferring blocks written les data-bitmap blocks care create small les single lls bitmap block bitmap block special case smaller expected completely cleanup phase test les deleted inodes inode-bitmap blocks phase identifying inodes bitmaps requires creating les distinct steps required probe process creates les inodes inode bitmaps modi probe process performs chmod les inodes inode bitmaps written inodes inode bitmaps distinguished phase calculates size inode performed recording number times block identi inode dividing block size observed number inodes block inode fields phase point eof classi blocks disk belonging categories data structures phase identi elds inodes observing elds change operations brevity describe eof infers blocks links generation number elds rst inode elds eof identi size times requires steps probe process creates sds 
stores inode data compare inode data written steps probe process overwrites data inode elds change related time probe process appends small amount data data pointer added point size eld identi data changed step step fourth probe process performs operation change inode changing data adding link changing permissions sds isolate mtime changed step ctime changed finally deleted deletion-time eld observed eof identi location level data pointers inode probe process repeatedly appends sds observes bytes inode change changed previous step eof infers location indirect pointers observing additional data block written additional pointer updated inode improve performance write block probe process seeks progressively larger amount seek distance starts block increases size handled detected indirection level finally eof isolates inode bit elds designate directories probe process alternately creates les directories sds histograms directory inodes histogram eof records count times bit inode type determine directory elds eof isolates bits les directories vice versa bits values considered identify les versus directories soft link bits identi similar manner directory entries phase nal phase eof identi structure entries directory eof infers offsets entry length probe proproceedings usenix conference file storage technologies fast san francisco california cess creates sds searches directory data block eld designating length validation deleted step repeated numerous times lenames lengths eof nds location record length assumption length record remaining space directory data block length reduced record added probe process creates additional les sds simply records offsets change previous entries finally offset inode number found assumption directory entry step probe process creates empty directories sds isolates inode offset recording differences data blocks directories assertion assumptions major challenge automatic inferencing ensure sds correctly identi behavior target system robust system meeting assumptions eof mechanisms detect assumption fails case system identi non-supported sds operates correctly semantic knowledge blocks expected written speci step speci blocks observed eof detects violation veri violations identi appropriately eof run non-ffs systems msdos vfat reiserfs additional bene eof con gure sds system bugs identi running eof ext linux isolated bugs sds observed incomplete traf key steps problem tracked back ext bug data written seconds prior unmount ushed disk probe process noted error inodes allocated case ext incorrectly marks system dirty eof enables checks system easily obtained methods exploiting structural knowledge classi cation association key advantage sds ability identify utilize important properties block disk properties determined direct indirect classi cation association direct classi cation blocks easily identi location disk indirect classi cation blocks identi additional information identify directory data indirect blocks inode examined finally association data block inode connected cases sds requires functionality identify change occurred block functionality implemented block differencing infer data block allocated single-bit change data bitmap observed change detection potentially costly operations sds reasons compare current block version block sds fetch version block disk avoid overhead cache blocks employed comparison expensive location difference byte block compared byte controlling block place quantify file costs system gray-box section techniques direct james classi nugent cation andrea direct classi arpaci-dusseau cation remzi simplest arpaci-dusseau computer sciences cient department form on-line wisconsin block madison identi abstract cation present design sds implementation sds place determines gray-box library type controlling block layout performing top simple ffslike bounds check systems place calculate exploits knowledge set ffs block layout ranges policies users block place falls ffs-like system les superblock directories bitmaps speci inodes localized data portions blocks disk identi applications place technique collocate les indirect classi exhibit temporal cation locality indirect access classi cation improving required performance type series microbenchmarks block analyze vary overheads dynamically controlling simple layout direct top classi cation system showing precisely overheads determine type prohibitive block discuss limitations ffs-like approach finally systems demonstrate indirect classi utility cation place case studies determine demonstrate data potential block layout data rearrangement directory web-server data environment form build indirect benchmarking pointer tool block exploits control single placement double quickly triple extract low-level indirect block details illustrate disk system concepts traditional focus gray-box manner directory place data library achieves differentiated ends data user level steps changing identifying single indirect line blocks operating system versus source pure code data introduction creators similar identifying high-performance directory o-intensive data applications basic including challenge database management identifying systems data block web belongs servers long yearned directory control track placement inode data points disk proper data data allocation check exploit locality type access workload directory increasing disk perform ciency tracking improving sds snoops performance inode traf systems provide disk explicit controls directory needed inode applications observed affect desired data block layouts numbers unix inserted systems based hash table berkeley fast file sds system removes data ffs blocks group les hash set table heuristics speci observing cally blocks group inodes freed data blocks les block reside differencing directory bitmaps applications sds full control identify layout block traditionally avoided directory block systems altogether presence relinquishing table convenience control gray-box directory data techniques promising discuss approach complications gather information exert approach control proceedings systems usenix export conference file interfaces treating system gray box assumes general knowledge system behaves implemented knowledge combined run-time observations system enables construction powerful services exported base system paper storage technologies fast san francisco california sds guarantee correctly identify blocks les directories speci cally data block present hash table sds infers data corresponds cases directory inode sds result hash table situation occur directory created blocks allocated existing directories system explore guarantee application inode gray-box blocks techniques written placement data problem blocks speci sds cally incorrectly retain classify convenience newly written data system blocks problem regaining control occur placement classifying introduce data place blocks positional read layout controller case system exploits system gray-box read techniques give applications inode improved block control data placement block system depicted data figure block important number component place sds place information inode control rst layer icl correctly place identify icl subsequent data applications blocks group les directories transient localized misclassi portions cation disk problem speci depends cally functionality group provided proper placement sds data instance improve sds read simply caches write directory performance blocks collocating les performance accessed tolerate temporary time inaccuracy applications improve sds performance requires accurate short-stroking information disk reducing correctness cost seeks ways limiting arm movement ensured rst portion option disk guarantee applications system place library writes operate inode expected blocks key data place blocks implementation true shadow default directory tree ffs sdt sdt soft hidden updates control structure linux ext place icl mounted control synchronous les mode disk option carefully creating buffer writes structure time exploiting gray-box classi knowledge cation system behavior made sdt deferred enables classi place cation icl occurs place inode les written user disk preferences correct data cient block manner freed creating inferred maintaining monitoring data structure bitmap traf central challenges sds implementing perform place excess rst work evaluate place icl obliviously inserts set data microbenchmarks blocks understand basic hash costs table potential directory bene inode read place written costs inode place recently reasonable passed controlled sds directory causing creation hash table costly standard updated versions proceedings optimize performance usenix annual sds technical infer conference june san block antonio texas unmodified added ffs modi file system deleted place icl place tools time command line directory place inode application observed pmkfs group ensure group group figure blocks place added system place deleted system consists hash components table highlighted process gray operation gure inferencing important component detail place section information identifying control indirect layer icl blocks process gray-box techniques identifying discover indirect information blocks identical system exploits identifying knowledge directory enable data applications blocks link case control sds tracks directory layout indirect block pointers components place inodes tool read pmkfs written initialize place on-disk structures set place command-line tools place works top ffs-like systems learning internal group structure exposing structure place icl operation prototype implementation potential bene substantial random maintaining hash table single double triple indirect block addresses sds determine data block indirect block association association connect data blocks inodes size performance improves creation date dramatically related sds data association items grouped achieved small portion simple disk space-consuming large les approach similar indirect outer tracks classi cation disk improve sds throughput snoops due zoning inode traf effects inserts demonstrate data utility pointers place separate addressto-inode application hash studies table rst concern show web server table size place group accurate les association exhibit temporal table access grows locality proportion utilizing simple number placement unique heuristics data collocation blocks place improves web read server throughput written noticeably storage system show high-speed system user-level booted benchmarking tool called approximate fast information place tolerated rapidly construct sds testing size infrastructure table controlled placement bounded les fast detecting high-level extract important behavior disk operation characteristics inferencing seek block time classi bandwidth cation seconds association rest provide paper sds organized cient identifying section special kinds describe blocks design implementation operation inferencing place section understand measure semantic costs show bene meaning section present observed case studies place blocks usage describe outline related work sds section identify future directions system section operations conclude observing section key place design challenge implementation operation section inferencing describe place system sds controlling distinguish layout blocks rst provide background valid describe goals version implementing place describe instance api exposed newly allocated place icl directory block presenting written programming interface discuss compared place implementation contents including system block initialization shadow block structures contained arbitrary control data placement identify discuss general operation versions issues sds concurrency simple limitations insight current implementation metadata background block written read contents block relevant detect modern situation unix sds systems maintains hash based table meta-data berkeley block fast addresses file system including read direct descendants found past bsd meta-data solaris block families read intellectual added descendants list linux ext block freed main innovations block ffs bitmap reset emphasis removed locality list placing related data objects block allocated disk data ffs provided freed quantum reallocated leap directory performance block systems address scattered data present disk hash table oblivious manner sds primary construct ffs contents manage disk illustrative locality purposes cylinder section group 
examine sds infer create delete operations discussion speci ext similar techniques applied ffs-like systems file creates deletes steps identifying creates deletes rst actual detection create delete determining inode affected describe detection mechanisms logic determining inode rst detection mechanism involves inode block inode block written sds examines determine inode created deleted valid inode non-zero modi cation time proceedings usenix conference file storage technologies fast san francisco california deletion time modi cation time non-zero deletion time non-zero means inode newly made valid created similarly reverse change newly freed inode deleted indication change version number valid inode delete create occurred cases inode number calculated physical position inode disk on-disk inodes inode numbers detection mechanism involves inode bitmap block bit set inode bitmap created inode number represented bit position similarly newly reset bit deleted update directory block indication newly created deleted directory data block written sds examines block previous version directory entry dentry added inode number obtained dentry case removed dentry contents dentry inode number deleted newly created deleted choice mechanism combinations thereof depends functionality implemented sds sds identify deletion immediately creation inode number inode bitmap mechanism sds observe change bitmap operations grouped due delayed write system case modi cation times version numbers similarly newly created deleted directory block-based solution cient file system operations general technique inferring logical operations observing blocks versions detect system operations note cases conclusive inference speci logical operation sds observe correlated multiple meta-data blocks semantically-smart disk system infer renamed observes change directory block entry inode number stays note version number inode stay similarly distinguish creation hard link normal directory entry inode examined evaluation section answer important questions sds framework cost ngerprinting system time overheads classi cation association operation inferencing space overheads proceeding evaluation rst describe experimental environment platform prototype sds employ software-based infrastructure implementation inserts pseudo-device driver kernel interpose traf system disk similar software raid prototype appears systems device system mounted primary advantage prototype observes information traf stream actual sds system current infrastructure differs important ways true sds importantly prototype direct access low-level drive internals information made dif cult sds runs system host interference due competition resources initial case studies prime importance performance characteristics microprocessor memory system actual sds high-end storage arrays signi processing power processing capacity trickle lower-end storage systems experimented prototype sds linux linux netbsd operating systems underneath ext ext ffs systems experiments paper performed processor slow modern standards mhz pentium iii processor k-rpm ibm lzx k-rpm quantum atlas iii disk experiments employ fast system comprised ghz pentium k-rpm seagate cheetah disk gauge effects technology trends off-line layout discovery subsection show time run ngerprinting tool eof reasonable modern disks eof run system runtime eof determine common case performance sds runtime eof prohibitive disks larger potential solution parallelism proceedings usenix conference file storage technologies fast san francisco california time partition size costs fingerprinting eof phase phase slow system fast system figure costs fingerprinting gure presents time breakdown ngerprinting slow system ibm disk fast system running underneath linux ext x-axis vary size partition ngerprinted y-axis shows time phase time-consuming components eof parallelizable reduce run-time disk arrays figure presents graph time run eof single-disk partition size partition increased show performance results slow system ibm disk fast system graph shows phase determines locations data blocks data bitmaps phase determines locations inode blocks inode bitmaps dominate total cost ngerprinting time phases increases linearly size partition requiring approximately seconds slow system seconds fast system comparing performance systems conclude increases sequential disk performance directly improve eof ngerprinting time phases require small amount time partition size on-line time overheads classi cation association operation inferencing potentially costly operations sds subsection employ series microbenchmarks illustrate costs actions results experiments sds underneath linux ext presented table action microbenchmark cases rst case system mounted synchronously ensuring meta-data operations reach sds order allowing sds guarantee correct classi cation additional effort synchronous mounting linux ext similar traditional ffs handling meta-data updates case system mounted asynchronously case guarantee correct classi cation association sds perform operation inferencing microbenchmarks perform basic system operations including directory creates deletes report perle per-directory overhead action test experiments make number observations operations tend cost order tens microseconds directory operations require block group ext terms interchangeably simplicity cylinder group divides disk number contiguous regions consists inodes data blocks bitmaps tracking inode block usage small number blocks store implementation-speci information placing related data objects cylinder group conversely spreading unrelated objects groups locality access achieved dif culty deciding objects related typically simple heuristics based system namespace speci cally group related objects implementations place inodes data blocks les directory group assuming locality access les conversely directories groups spread unrelated les disk leaving room grow group original ffs implementation descendants spread large les groups avoid lling group single large designing place icl seek exploit gray-box knowledge ffs-like systems perform layout order users control les disk understand limits gray-box control including types functionality realized top modern systems proceedings usenix annual technical conference june san antonio texas design goals designing place goals simple intuitive control layout applications straightforward representation disk locality exploit application-speci knowledge improve performance easy place easy substantial code modi cations required programming apis commandline tools provided compatible non-place applications applications place top system operate basic system structure usage unmodi applications change unaffected system namespace applications users les conventions desire layout dependent specialized naming schemes goals impact design implementation place abstractions api basic abstraction place exposes underlying groups ffs-like systems applications link place library applications knowledge access patterns place related les directories speci group exploiting spatial locality improved performance number group applications pieces information applications safely assume les proximate groups close object group close object group close object group lower group numbers located outer tracks disk higher group numbers located tracks applications utilize zone-sensitive placement large les improve throughput note abstract virtual groupings group hierarchies layered top physical group interface desired simplicity focus solely lowest level abstraction rest paper applications place les directories speci groups place basic functions applications place createfile char pathname mode mode int group creates speci pathname mode set mode group number group rst arguments identical creat system call place createdir char pathname mode mode int group creates directory speci bypathnamewith mode set mode group number group rst arguments identical mkdir system call theplace createfilecall ne-grained placement les groups place createdir function applications create directory controlled manner subsequent allocations directory place collocated due standard ffs policy place allocate directory group 
due insuf cient resources free data blocks inodes left group case standard behavior routine return error indicating object created alternative interface routines search nearby group failure place directory utility convenience functions provided applications discover number groups system current utilization level group number group utilized user re-write application place api set command-line tools utilized tools users move directories les speci groups create speci groups subsequent data access unmodi applications enjoy bene rearrangement basic operation place exploits ffs tendency namespace hint placement gain control layout place rst create structure les directories created controlled fashion created place library renames les moving back proper location system namespace system structure shadow directory tree sdt central place implementation initialization process performed system place produces sdt structure appears system namespace shown figure important entities found sdt superblock persistent inproceedings usenix annual technical conference june san antonio texas hidden superblock hidden concurrency hidden hidden hidden figure shadow directory tree hidden shadow directory tree structure presented superblock persistent information needed place concurrency manage multi-user access finally directories control placement formation place concurrency manage concurrent access les place api les discussed detail interesting set directories namedd throughdn number cylinder groups system initialization procedure detail ensures directory cylinder group note structures hidden directory applications traversing directory tree controlling file creation sdt place creating group straightforward application calls place createfile passing pathname created mode bits desired group place internally place icl creates shadow directory simply calls rename put proper location namespace place checks make allocated group user requested i-number newly allocated initialization place learns records number group mapping information determine allocation successful controlling directory creation placing directory proper group place createdir challenging creating directory proper shadow directory suf ffs-like systems place child directory cylinder group parent approach required shown algorithm algorithm works creating temporary directory checking desired group i-number repeat tmp picknewname mkdir tmp indesiredgroup tmp break end fillothergroups forever rename tmp dirname algorithm directory creation algorithm basic algorithm create directory speci group disk presented repeating process temporary directory created correct group directory created renamed proper location namespace complication arises due directory allocation policies ffs-like systems linux ext policy searches group above-average number free inodes fewest allocated data blocks netbsd ffs picks group above-average number free inodes fewest allocated directories algorithm create temporary les directories coerce system creating directory desired group process referred algorithm fillothergroups creates number les non-target groups ensure les spread groups uncontrolled manner place creates small les les utilize indirect pointers basic algorithm slow demonstrate section speed process common case build shadow cache directories group numbers sdt attempting create directory group directory creation algorithm rst consults shadow cache directory group exists place simply renames directory nished avoiding expensive directory creation algorithm place directory cache performs fulledged algorithm case directories created algorithm added cache repopulating shadow cache periodically sdt initialization discuss initialization process required place encapsulated tool call pmkfs place mkfs steps pmkfs proceedings usenix annual technical conference june san antonio texas pmkfs discovers system parameters algorithms pmkfs creates sdt on-disk data structures populates shadow cache parameter discovery place requires pieces information create on-disk structures support controlled allocation number groups system ngrp number blocks bgrp inodes igrp group total number blocks inodes system readily statfs system call finding number groups slightly challenging current algorithm calculates number allocating directories recording difference inode numbers subsequently allocated directories directory group common difference number inodes group place detects allocation wrapped fact directory i-number close previously allocated directory igrp calculate group number gnum object inode number inum computing gnum inum igrp system calculates number complete direct pointers cost inode due per-block size cost small operation required inferencing directory synchronous creation mode algorithm work create multiple workload ffs takes platforms roughly discovered corresponds synchronously writing blocks base cost monitoring create number workload free blocks cost system approximately statfs small block size discovered costs point rise single size allocating block increases write decreases sds incurs free block count small per-block blocks overhead indicating compared indirect actual block disk writes allocated current implementation place number requires milliseconds exclusive access complete empty system cases initialization overheads reason ext restriction system run asynchronous igrp mode exported lower system run synchronous mode asynchronous mode numerous updates meta-data blocks batched costs block differencing amortized synchronous mode meta-data operation ected disk system incurring higher overhead sds observe synchronous mode classi cation expensive association expensive inferencing sds care employ actions needed implement desired functionality on-line space overheads sds require additional memory perform classi cation association operation inferencing speci cally hash tables required track mappings data blocks inodes caches needed implement cient block differencing quantify memory overheads variety workloads table presents number bytes hash table support classi cation association operation inferencing sizes maximum reached run workload netnews postmark modi andrew benchmark netnews postmark vary workload size caption table dominant memory overhead occurs sds performing block-inode association classi cation operation inferencing require table sizes proportional number unique meta-data blocks pass sds association requires information unique data block passes worst case entry required proceedings usenix conference file storage technologies fast san francisco california indirect block-inode operation classi cation association inferencing sync async sync async sync async create create delete delete mkdir rmdir table sds time overheads table breaks costs indirect classi cation block-inode association operation inferencing microbenchmarks row stress aspects action create benchmark creates les size delete benchmark similarly deletes les mkdir rmdir benchmarks create remove directories result presents average overhead operation extra time sds takes perform classi cation association inferencing experiments run slow system ibm lzx disk linux ext mounted synchronously sync asynchronously async data block disk memory disk space space costs tracking association information high prohibitive memory resources scarce sds choose tolerate imperfect information swap portions table disk addition hash tables needed perform classi cation association operation inferencing cache data blocks perform block differencing effectively recall differencing 
observe pointers allocated freed inode indirect block check time elds inode changed detect bitwise bitmap monitor directory data creations deletions performance system sensitive size cache cache small difference calculation rst fetch version block disk avoid extra size cache roughly proportional active meta-data working set postmark workload found sds cache approximately blocks hold working set cache smaller block differencing operations disk retrieve older copy block increasing run-time benchmark roughly case studies section describe case studies implementing functionality sds implement drive raid semantic knowledge case studies indirect block-inode operation classi cation association inferencing netnews netnews netnews postmark postmark postmark andrew table sds space overheads table presents space overheads structures performing classi cation association operation inferencing workloads netnews postmark modi andrew benchmark workloads netnews postmark run amounts input correspond roughly number transactions generates netnews implies transactions run number table represents maximum number bytes stored requisite hash table benchmark run hash entry bytes size experiment run slow system linux ext asynchronous mode ibm lzx disk built system proper implementing le-system functionality storage system advantages semantic intelligence storage-system manufacturers augment products broader range capabilities due space limitations fully describe case studies paper highlight functionality case study implements present performance evaluation conclude analyzing complexity implementing functionality sds performance evaluation included demonstrate interesting functionality implemented effectively sds leave detailed performance studies future work theme explore section usage approximate information scenarios sds wrong understanding system case studies track-aligned extents proposed schindler track-aligned extents traxtents improve disk access times placing medium-sized les tracks avoiding track-switch costs detailed level knowledge traxtents-enabled system requires underlying disk mapping logical block numbers physical tracks traxtents natural candidate implementation sds information readily obtained fundamental challenge implementing traxtents sds system adapting policies system system speci cally traxtent sds uence system allocation prefetching mid-sized les proceedings usenix conference file storage technologies fast san francisco california prefetching prefetching ext traxtent sds table track-aligned extents table shows bandwidth obtained reading les randomized order roughly size track case examine default track-aligned allocation varying track-sized prefetching enabled sds experiment run slow system running linux ext system mounted asynchronously quantum atlas iii disk allocated consecutive data blocks span track boundaries accesses track-sized units components interest traxtent sds implementation bitmap blocks rst read system sds marks bitmap block track allocated similar technique schindler wastes small portion disk fake allocation uences system allocate les span tracks system decides allocate tracks sds dynamically remaps blocks track-aligned locale similar block remapping loge smart disks major difference sds remaps blocks part mid-sized les benet track-alignment non-semantically aware disks make distinction traxtent sds performs additional prefetching ensure accesses smaller track linux ext ffs prefetches blocks initially read traxtent sds observes read rst block track-aligned requests remainder track places data blocks cache traxtent sds relies piece exact information correctness location bitmap blocks marks trick system track-aligned allocation information static obtained reliably eof performance cost runtime indirect classi cation data belonging medium-sized les occasionally incorrect remapping performance correctness table shows traxtent sds prefetching results roughly improvement bandwidth medium-sized les structural caching discuss semantic information caching sds simple lru management disk cache duplicate contents system cache wastes memory storage system waste onerous storage arrays due large amounts memory contrast sds structural undertpc-b tpc-b ffs lru sds file-aware caching sds table file-aware caching table shows time seconds takes execute tpc-b transactions experiments transactions rst run warm system large scan run series transactions timed table compares netbsd ffs standard disk sds lru-managed cache sds le-aware cache experiments run slow system ibm lzx disk standing system cache blocks intelligently avoid wasteful replication explore caching blocks volatile memory dram non-volatile memory nvram presents unique opportunities optimization rst examine simple optimization avoids worst-case lru behavior file-aware caching sds fac sds exploits knowledge size selectively cache blocks les small cache les accessed sequentially strategy avoids caching blocks large les scanned ush cache blocks implement le-aware caching fac sds identi cacheable blocks indirect classi cation association case hash table holds block addresses correspond les meet caching criteria previously sds misclassify blocks cases inode written disk data blocks fac sds small amount state active order detect sequential access patterns table shows performance fac sds database workload scenario run tpc-b transactions periodically intersperse large scans system emulating system running mixed interactive batch transactions large scan ushes contents traditional lru-managed cache degrades performance subsequent transactions le-aware cache cache blocks large scans keeping transactional tables sds memory improving performance examine sds semantic knowledge store important structures non-volatile memory explore possibilities rst exploit semantic knowledge store ext journal nvram implement journal caching sds sds sds recognize traf journal redirect nvram straightforward eof tool determines blocks belong journal classifying caching data reads proceedings usenix conference file storage technologies fast san francisco california create create sync ext lru sds lru sds journal caching sds table journal caching table shows time create -kb les ext sds sds performs lru nvram cache management cache journal caching sds storing journal nvram create benchmark performs single sync les created create sync benchmark performs sync creation inducing journaling-intensive workload experiments run slow system running linux utilizing ibm lzx disk writes journal sds implement desired functionality place meta-data bitmaps inodes indirect blocks directories netbsd ffs nvram inodes bitmaps identi location disk pointer blocks directory data blocks identi indirect classi cation occasionally miss blocks exploit fact approximate information adequate sds writes unclassi blocks disk nvram observes inode track meta-data blocks meta-data caching sds mdc sds additional map record in-core location tables show performance sds mdc sds cases simple nvram caching structures journal system meta-data effective reducing run times dramatically greatly reducing time write blocks stable storage lru-managed cache effective case cache large working set main bene structural caching nvram size cached structures sds guarantees effective cache utilization hybrid combine worlds storing important structures journal meta-data nvram managing rest cache space lru fashion future plan investigate ways semantic information improve storagesystem cache management sds types meta-data updates last-accessedtime updates inode order ascertain les system cache prefetching sds intelligent system awareness make guess block read finally blocks deleted removed cache freeing space live blocks create read delete postmark ffs lru sds lru sds 
mdc sds table meta-data caching left columns table show time seconds complete phase lfs microbenchmark experiment lfs benchmark creates reads deletes -kb les column shows total time seconds postmark benchmark run les transactions directories rows compare performance netbsd ffs slow system ibm disk sds sds performs lru nvram cache management cache mdc sds strategy secure deletion advanced magnetic force scanning tunneling microscopy stm person physical access drive lot time potentially extract sensitive data user deleted case study explore secure-deleting sds disk guarantees data deleted les unrecoverable previous approaches incorrectly functionality system over-writing deleted blocks multiple times patterns guarantee data removed disk copies data blocks exist due bad-block remapping storage system optimizations multiple consecutive le-system writes reach disk media due nvram buffering sds locale secure delete implemented ensure stray copies data exist over-writes performed disk nature case study approximate incorrect information blocks deleted acceptable secure-deleting sds recognizes deleted blocks operation inferencing overwrites blocks data patterns speci number times system reallocate blocks possibly write block fresh contents meantime sds tracks deleted blocks queues writes blocks overwrite nished note mount ext system synchronously secure deletion operate correctly investigating techniques relax requirement part future work table shows overhead incurred sds function number over-writes overwrites performed data recoverable noticeable price paid securedelete functionality loss acceptable highlysensitive applications requiring security performance improved delaying secureproceedings usenix conference file storage technologies fast san francisco california delete postmark ext secure-deleting sds secure-deleting sds secure-deleting sds table secure deletion table shows time seconds complete delete microbenchmark postmark benchmark secure-deleting sds delete benchmark deletes -kb les postmark benchmark performs transactions row secure-deleting sds shows performance number over-writes experiment place slow system running linux ext mounted synchronously ibm lzx disk overwrite disk idle performing immediately freeblock scheduling minimize performance impact journaling nal case study complex sds implements journaling underneath unsuspecting system view journaling sds extreme case helps understand amount information obtain disk level unlike case studies journaling sds requires great deal precise information system due space limitations present summary implementation fundamental dif culty implementing journaling sds arises fact disk transaction boundaries blurred instance system create system inode block parent directory block inode bitmap block updated part single logical create operation block writes grouped single transaction straight-forward fashion sds sees stream meta-data writes potentially interleaved logical system operations challenge lies identifying dependencies blocks handling updates atomic transactions result journaling sds maintains transactions coarser granularity journaling system basic approach buffer meta-data writes memory write disk in-memory state meta-data blocks constitute consistent metadata state logically equivalent performing incremental in-memory fsck current set dirty meta-data blocks writing disk check succeeds current set dirty meta-data blocks form consistent state treated single atomic transaction ensuring on-disk meta-data contents remain previous consistent state fully updated consistent state bene coarse-grained transactions batching commits performance improved traditional journaling systems create read delete ext sync ext async ext ext sync journaling sds table journaling table shows time complete phase lfs microbenchmark seconds -kb les con gurations compared ext linux mounted synchronously mounted asynchronously journaling ext linux journaling sds synchronously mounted ext linux experiment place slow system ibm lzx disk guarantee bounded loss data crash journaling sds limits time elapse successive journal transaction commits journaling daemon wakes periodically con gurable interval takes copy-on-write snapshot dirty blocks cache dependency information point subsequent meta-data operations update copy cache introduce additional dependencies current epoch similar secure-deleting sds current journaling sds implementation assumes system mounted synchronously robust sds requires verify assumption holds turn journaling meta-data state written disk journaling sds consistent synchronous asynchronous mount problem imposed asynchronous mount sds miss operations reversed create delete lead dependencies resolved inde nite delays journal transaction commit process avoid problem journaling sds suspicious sequence meta-data blocks single change expected multiple inode bitmap bits change part single write turns journaling cases fall-back journaling sds monitors elapsed time commit dependencies prolong commit time threshold suspects asynchronous mount aborts evaluate correctness performance journaling sds check correctness crashed system numerous times ran fsck verify inconsistencies reported performance journaling sds summarized table sds requires system mounted synchronously performance similar asynchronous versions semantically-smart disk system delays writing meta-data disk read test sds similar performance base system ext delete test similar performance journalproceedings usenix conference file storage technologies fast san francisco california eof fingerprinting probe process sds sds infrastructure case studies initialization traxtents hash table cache file-aware cache direct classi cation journal cache indirect classi cation meta-data cache association secure delete operation inferencing journaling table code complexity number lines code required implement aspects sds presented sds component eof tool lines code roughly lines shared system types rest le-system speci ing system ext creation sds pays signi cost relative ext overhead block differencing hash table operations noticeable impact purpose case study demonstrate sds implement complex functionality small overhead acceptable complexity analysis brie explore complexity implementing software sds table shows number lines code components system case studies table complexity found eof tool basic cache hash tables operation inferencing code case studies trivial implement top base infrastructure traxtent sds journaling sds require thousand lines code conclude including type functionality sds pragmatic conclusions beware false knowledge dangerous ignorance george bernard shaw recent article wise drives gordon hughes associate director center magnetic recording research writes favor smarter drives stressing great potential improving storage system performance functionality believes interface systems storage required widespread drive input output command requirements interface speci cation short industry consensus task general interest offers market opportunities multiple computer drive companies hughes comments illustrate dif culty interfaces require wide-scale industry agreement eventually limits creativity inventions existing interface framework information system disk low-level knowledge drive internals sds sits ideal location implement powerful pieces functionality disk system implement enabling innovations existing interfaces storage system manufacturers embed optimizations previously relegated domain systems enabling vendors compete axes cost performance paper demonstrated underneath class ffs-like systems le-system information automatically gathered exploited implement functionality drives heretofore implemented system implemented shown costs reverse-engineering system structure behavior reasonable challenges remain including understanding generality robustness semantic inference broader range systems sophisticated systems wider range platforms probed reveal workings approximate information exploited implement interesting functionality techniques tools developed assure correct operation 
semantic technology answer questions research experimentation nal answer elicited acknowledgments members wind research group feedback ideas presented paper keith smith excellent shepherding anonymous reviewers thoughtful suggestions greatly improved content paper finally computer systems lab tireless assistance providing terri environment computer science research work sponsored nsf ccrccr- ccrngs- itran ibm faculty award wisconsin alumni research foundation timothy denehy sponsored ndseg fellowship department defense proceedings usenix conference file storage technologies fast san francisco california acharya uysal saltz active disks proceedings conference architectural support programming languages operating systems asplos viii san jose october amiri petrou ganger gibson dynamic function placement dataintensive cluster computing proceedings usenix annual technical conference pages june anderson chase vahdat interposed request routing scalable network storage transactions computer systems tocs february arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october baker asami deprit ousterhout seltzer non-volatile memory fast reliable file systems proceedings international conference architectural support programming languages operating systems pages boston massachusetts october acm sigarch sigops sigplan bauer priyantha secure data deletion linux file systems tenth usenix security symposium washington august brown yamaguchi oracle hardware assisted resilient data oracle technical bulletin note burnett bent arpaci-dusseau arpaci-dusseau exploiting gray-box knowledge buffer-cache contents proceedings usenix annual technical conference usenix pages monterey june chao english jacobson stepanov wilkes mime high performance parallel storage device strong recovery guarantees technical report hpl-csp- rev laboratories november collberg reverse interpretation mutation analysis automatic retargeting conference programming language design implementation pldi las vegas nevada june jonge kaashoek hsieh logical disk approach improving file systems proceedings acm symposium operating systems principles pages asheville december denehy arpaci-dusseau arpaci-dusseau bridging information gap storage protocol stacks proceedings usenix annual technical conference usenix pages monterey june dowse malone recent filesystem optimisations freebsd proceedings usenix annual technical conference freenix track monterey california june emc corporation symmetrix enterprise information storage systems http emc english stepanov loge selforganizing disk controller proceedings usenix winter technical conference pages san francisco january ganger blurring line oses storage devices technical report cmu-cs- carnegie mellon december gibson nagle amiri butler chang gobioff hardin riedel rochberg zelenka cost-effective high-bandwidth storage architecture proceedings conference architectural support programming languages operating systems asplos viii october gibson nagle amiri chang gobioff riedel rochberg zelenka filesystems network-attached secure disks technical report cmu-cs- carnegie mellon gray storage bricks arrived invited talk usenix conference file storage technologies fast gutmann secure deletion data magnetic solid-state memory sixth usenix security symposium san jose california july hagmann reimplementing cedar file system logging group commit proceedings acm symposium operating systems principles november proceedings usenix conference file storage technologies fast san francisco california hsieh engler back reverseengineering instruction encodings proceedings usenix annual technical conference usenix boston massachusetts june hughes wise drives ieee spectrum august katcher postmark file system benchmark technical report trnetwork appliance october king dirty lesystem bug ext https listman redhat pipermail ext users -april html march lumb schindler ganger freeblock scheduling disk firmware proceedings usenix conference file storage technologies fast monterey january mckusick joy lef fabry fast file system unix acm transactions computer systems august morton data corrupting bug ext http uwsg hypermail linux kernel html dec ousterhout aren operating systems faster fast hardware proceedings usenix summer technical conference anaheim june padhye floyd inferring tcp behavior sigcomm san deigo august regehr inferring scheduling behavior hourglass proceedings usenix annual technical conference freenix track monterey june riedel gibson faloutsos active storage large-scale data mining multimedia vldb york august rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon schindler grif lumb ganger track-aligned extents matching access patterns disk drive characteristics proceedings usenix conference file storage technologies fast monterey january seltzer ganger mckusick smith soules stein journaling versus soft updates asynchronous meta-data protection file systems proceedings usenix annual technical conference pages san diego june swartz brave toaster meets usenet lisa pages chicago illinois october talagala arpaci-dusseau patterson microbenchmark-based extraction local global disk characteristics technical report csd- california berkeley tweedie future directions ext filesystem proceedings usenix annual technical conference freenix track monterey california june wang anderson patterson virtual log-based file systems programmable disk proceedings symposium operating systems design implementation osdi orleans february wong wilkes cache making storage exclusive proceedings usenix annual technical conference usenix monterey june gum chen wang krishnamurthy anderson trading capacity performance disk array proceedings fourth symposium operating systems design implementation osdi san diego october zhou philbin multi-queue replacement algorithm level buffer caches proceedings usenix annual technical conference boston june 
flexibility manageability performance grid storage appliance john bent venkateshwaran venkataramani nick leroy alain roy joseph stanley andrea arpaci-dusseau remzi arpaci-dusseau miron livny department computer sciences wisconsin-madison abstract present nest flexible software-only storage appliance designed meet storage grid nest key features make well-suited deployment grid environment nest generic data transfer architecture supports multiple data transfer protocols including gridftp nfs easy addition protocols nest dynamic adapting on-the-fly runs effectively wide range hardware software platforms nest grid-aware implying features integration grid storage space guarantees mechanisms resource data discovery user authentication quality service part nest infrastructure introduction data storage movement increasing importance grid time scientific applications evolved process larger volumes data throughput inextricably tied timely delivery data usage grid evolves include commercial applications data management central today data management aspects performance long focus storage systems research recent trends factors including reliability availability manageability relevant argue manageability dominant criterion evaluating storage solutions cost storage management outweighs cost storage devices factor potential solution storage management problem specialized storage devices appliances pioneering products filers network appliance reduce burden management specialization specifically storage appliances designed solely serve files clients toaster designed solely toast results convincing field testing network appliance filers shown easier manage traditional systems reducing operator error increasing system uptime considerably storage appliances natural match storage grid easy manage provide high performance number obstacles prevent direct application commercial filers grid environment commercial storage appliances inflexible protocols support defaulting common local area unix windows environments nfs cifs filers readily mix world-wide shared distributed computing infrastructure non-standard specialized grid protocols data transfer commercial filers expensive increasing cost raw cost disks factor ten greater storage appliances missing features crucial integration grid environment ability interact larger-scale global scheduling resource management tools overcome problems bring appliance technology grid introduce nest open-source user-level software-only storage appliance compared current commercial storage appliances nest primary advantages flexibility cost grid-aware functionality briefly discuss advantages detail nest flexible commercial storage appliances nest generic data transfer architecture concurrently supports multiple data transfer protocols including gridftp nfs nest framework protocols added grid evolves nest open-source softwareonly appliance low-cost alternative commercial storage appliances expenses incurred raw hardware costs disks nest software-based appliance introduces problems traditional appliances encounter nest run hardware tailored tested nest ability adapt characteristics underlying hardware operating system allowing nest deliver control flow data flow dispatcher transfer managerstorage manager concurrency models physical storage chirp http nfsgrid ftpftp common protocol layer physical network figure nest software design diagram depicts nest major components protocol layer storage manager transfer manager dispatcher control data flow paths depicted high performance retaining ease management benefits storage appliances finally nest grid-aware key features storage space guarantees mechanisms resource data discovery user authentication quality service fundamental part nest infrastructure functionality enables nest integrated smoothly higher-level job schedulers distributed computing systems rest paper organized section describes design nest protocol layer mediates interaction clients section section describes transfer manager responsible monitoring scheduling concurrency section describes storage layer manages actual physical storage system usage nest traced section evaluation presented section comparisons related work section conclusions drawn section design overview grid storage appliance nest mechanisms file directory operations resource management implementation provide mechanisms heavily dependent nest modular design shown figure major components nest protocol layer storage manager transfer manager dispatcher briefly examine components separately show work tracing client interaction component descriptions protocol layer nest connectivity network client interactions mediated clients communicate nest supported file transfer protocols including http restricted subset nfs ftp gridftp chirp native protocol nest role protocol layer transform specific protocol client common request interface understood components nest refer virtual protocol connection describe motivation multiple protocol support section dispatcher main scheduler macrorequest router system responsible controlling flow information components examines client request received protocol layer routes appropriately storage transfer manager data movement requests transfer manager requests resource management directory operation requests handled storage manager dispatcher periodically consolidates information resource data availability nest publish information classad global scheduling system storage manager main responsibilities virtualizing controlling physical storage machine underlying local filesystem raw disk physical memory storage system directly executing non-transfer requests implementing enforcing access control managing guaranteed storage space form lots lots discussed detail section storage operations execute quickly order milliseconds chosen simplify design storage manager requests execute synchronously responsibility dispatcher ensure storage requests serialized executed storage manager thread-safe schedule transfer manager controls data flow nest specifically transfers data protocol connections allowing transparent threeand four-party transfers file data transfer operations managed asynchronously transfer manager synchronously approved storage manager transfer manager concurrency models threads processes events schedules transfer models scheduling policies preferential scheduling scheduling optimizations responsibility transfer manager discussed section client interaction examine components function tracing sequence events interacting client case client creates directory nontransfer request inserts file directory transfer request client initially connects nest request create directory dispatcher wakes asks protocol layer receive connection depending connecting port protocol layer invokes handler protocol handler authenticates client parses incoming request common request format returns virtual protocol connection dispatcher dispatcher asks storage manager create directory checking access permissions storage manager synchronously creates directory sends acknowledgment back client dispatcher virtual protocol connection point dispatcher assumes responsibility client listens requests channel client sees directory created successfully requests permission send file dispatcher invokes virtual protocol connection receive request queries storage manager storage manager transfer returns virtual protocol connection transfer written dispatcher passes connections transfer manager stops listening client channel sleeps waiting client request transfer manager free schedule queue request request scheduled transfer manager past information predict concurrency model provide service passes connection selected model transfer continues chosen concurrency model transfers data client connection storage connection performing acknowledgment client desired finally transfer status returned transfer manager dispatcher sections describe important aspects nest motivate importance supporting multiple communication protocols virtual protocol layer describe transfer manager adapts client workload underlying system pick concurrency model performance show transfer manager apply scheduling policies connections fourth explain role storage guarantees nest explain storage manager implements functionality protocol layer supporting multiple protocols fundamental requirement storage appliances grid standardization common protocols globus toolkit diversity reign community widespread fastmoving grid wide-area transfers conducted gridftp local-area file access dominated nfs afs cifs protocols multiple protocols 
supported nest virtual protocol layer design implementation virtual protocol layer clients communicate nest preferred file transfer protocol shields components nest detail protocol allowing bulk nest code shared protocols virtual protocol layer nest virtual file system vfs layer operating systems alternative approach single nest server virtual protocol layer implement separate servers understand individual protocol run simultaneously refer approach bunch servers jbos relative advantage jbos servers added upgraded easily immediately implementation protocol nest incorporating upgraded protocol effort protocol operations mapped nest common framework advantages single server outweigh implementation penalty number reasons single server enables complete control underlying system server give preferential service requests protocols users protocols single interface tasks administering configuring nest simplified line storage appliance philosophy single server optimizations part system transfer manager concurrency model applied protocols fourth single server memory footprint considerably smaller finally implementation penalty reduced protocol implementation nest leverage existing implementations implement gridftp server-side libraries provided globus toolkit sun rpc package rpc communication nfs point implemented file transfer protocols nest http subset nfs ftp gridftp nest native protocol chirp experience request types protocols similar directory operations create remove read file operations read write put remove query fit easily virtual protocol abstraction interesting exceptions instance nfs protocol lookup mount request chirp protocol supports lot management plan include grid-relevant protocols nest including data movement protocols ibp resource reservation protocols developed part global grid forum expect protocols added implementation effort focused mapping specifics protocol common request object format protocols require additions common internal interface authentication mechanism protocol specific protocol handler performs authentication clients drawback approach devious protocol handler falsify client authenticated grid security infrastructure gsi authentication chirp gridftp connections protocols allowed anonymous access transfer manager heart data flow nest transfer manager transfer manager responsible moving data disk network request transfer manager protocol agnostic machinery developed manager generic moves data protocols highlighting advantages nest design mount technically part nfs protocol nest mount handled nfs handler multiple concurrency models inclusion grid environment mandates support multiple on-going requests nest provide means supporting concurrent transfers single standard concurrency operating systems platforms choice threads processes cases events making decision difficult fact choice vary depending workload requests hit cache perform events bound perform threads processes avoid leaving decision administrator avoid choosing single alternative perform poorly workloads nest implements flexible concurrency architecture nest supports models concurrency threads processes events future plan investigate advanced concurrency architectures seda crovella experimental server deliver high performance nest dynamically chooses architectures choice enabled distributing requests architectures equally monitoring progress slowly biasing requests effective choice scheduling multiple outstanding requests nest nest selectively reorder requests implement scheduling policies scheduling multiple concurrent transfers server decide resources dedicate request basic strategy service requests first-come first-served fcfs manner nest configured employ transfer manager control on-going requests scheduling policies nest supports proportional share cache-aware scheduling addition fcfs proportional-share scheduling deterministic algorithm fine-grained proportional resource allocation previously cpu scheduling network routers current implementation nest administrator proportional preferences protocol class nfs requests bandwidth gridftp requests future plan extend provide preferences per-user basis byte-based strides scheduling policy accounts fact requests transfer amounts data nfs client reads large file entirety issues multiple requests http client reading file issues give equal bandwidth nfs requests http requests transfer manager schedules nfs requests times frequently ratio average file size nfs block size nest proportional-share scheduling similar bandwidth request throttling module apache proportional-share scheduling nest offers flexibility schedule multiple protocols apache requestthrottling applies http requests apache server processes applied traffic streams jbos environment cache-aware scheduling utilized nest improve average client perceived response time server throughput modeling kernel buffer cache gray-box techniques nest predict requested files cache resident schedule requests files fetched secondary storage addition improving client response time approximating shortest-job scheduling scheduling policy improves server throughput reducing contention secondary storage earlier work examined cache-aware scheduling focus web workloads independence transfer manager virtual protocol layer clear policy works protocols illustrates major advantage nest jbos optimizations transfer code immediately realized protocols reimplemented multiple servers storage manager protocol layer multiple types network connections channeled single flow storage manager designed virtualize types physical storage provide enhanced functionality properly integrate grid environment specific roles fulfilled storage manager implement access control virtualize storage namespace provide mechanisms guaranteeing storage space access control provided nest generic framework built top collections classad afs-style access control lists determine read write modify insert privileges typical notions users groups maintained nest support access control generic policies enforced protocols nest supports clients communicate native chirp protocol supported protocol access control semantics set nest virtualizes physical namespace underlying storage enabling nest run wide variety storage elements current implementation local filesystem underlying storage layer nest plan physical storage layers raw disk future running remote location grid users higher-level scheduling systems assured exists sufficient storage space save data produced computation stage input data subsequent access address problem nest interface guarantee storage space called lot requests made space allocations similar reservations network bandwidth lot defined characteristics owner capacity duration files owner client entity allowed lot individual owners allowed group lots included release capacity total amount data stored lot duration amount time lot guaranteed exist finally lot set files number files lot bounded file span multiple lots fit single duration lot expires files contained lot immediately deleted allowed remain indefinitely space reclaimed creation lot refer behavior best-effort lots investigating selection policies reclaiming space create files nest user access lot file transfer protocols support creating lots environment lot obtained ways system administrators grant access nest simultaneously make set default lots users client directly chirp protocol create lot accessing server alternative data-transfer protocol lots implemented current implementation relies quota mechanism underlying filesystem nest limit total amount disk space allocated user utilizing quota system affords number benefits direct access file system nest observe quota restrictions allowing clients utilize nest make space guarantee bypass nest transfer data directly local file system existing software file system nest implementation simplified approach benefits lots user overfill single lot fill lot capacity future plan investigate costs benefits nest-managed lot enforcement nest global execution manager nest argonne cluster chirp gftp nfs submit madison figure nest grid diagram illustrates information flow scenario multiple nest servers 
utilized grid nest grid basic understanding nest place illustrate multiple nest servers global grid environment figure depicts scenario major events labeled sequence numbers defined description figure user input data permanently stored home site case nest madison wisconsin step user submits number jobs remote execution global execution manager manager aware remote cluster labeled argonne cluster large number cycles nest gateway appliance argonne previously published resource data availability global grid discovery system manager aware argonne nest sufficient amount storage manager decides run user jobs argonne site staging user input data step manager chirp create lot user files argonne guaranteeing sufficient space input output files step manager orchestrates gridftp third-party transfer madison nest nest argonne cluster data movement protocols kangaroo utilized move data site site step manager begins execution jobs argonne jobs access user input files nest local file system protocol case nfs jobs execute output files generate stored nest note ability give preference users protocols harnessed local administrators ensure preference jobs global manager ensure timely data movement finally step jobs begin complete point manager moves output data back madison utilizing gridftp wide area movement manager free chirp terminate lot nest nest wu-ftpd nest apache nest linux nfsd nest jbos server bandwidth nest jbos chirp gridftp http nfs total figure multiple protocols experiment measures bandwidth clients request files protocol sets bars single protocol workload single server jbos set bars workload protocols pair bar shows performance nest bar jbos step inform user output files local nest note steps guaranteeing space moving input data executing jobs moving output data terminating reservations encapsulated request execution manager condor directedacyclic-graph manager dagman higherlevel storage resource managers srm nest services synchronize access globallyshared storage resources experiments section perform evaluation key components nest experiments performed cluster pentium-based machines running linux ibm lzx disks connected gigabit ethernet solaris-based runs performed cluster netra machines running solaris connected mbit ethernet support multiple protocols illustrate supporting multiple protocols nest framework incurs overhead compared native implementations individual protocol figure compares bandwidth delivered clients nest server delivered native servers implementing individual protocol sets bars graph evaluate workloads requests protocol fifo server bandwidth scheduling configuration proportional protocol scheduling total chirp gftp http nfs desired figure proportional protocol scheduling workload identical figure results shown nest set bars bar represents total delivered bandwidth protocols remaining bars show bandwidth protocol labels sets bars show proportional ratios desired lines show ideal proportions note nest achieve close desired ratios case right-most time jbos single server running make observations results delivered bandwidth varies widely protocols chirp http deliver in-cache files peak bandwidth determined network gridftp nfs achieve approximately half bandwidth importantly performance nest protocols similar native server rightmost pair bars show delivered bandwidth workload requests multiple protocols jbos multiple servers running simultaneously total delivered bandwidth nest jbos similar roughly allocation bandwidth protocols bandwidth delivered nfs clients lower nest jbos nfs block-based protocol protocols file-based default transfer manager nest ends disfavoring nfs schedules requests fifo order quality service advantage nest relative jbos transfer manager nest easily extended scheduling policies implemented simple stride scheduler nest proportional share server bandwidth delivered types requests results shown figure set bars shows base case nest transfer manager simple fifo scheduler sets bars adjust desired ratio bandwidth protocol make conclusions graph proportional share scheduler imposes slight performance penalty fifo scheduling delivering total approximately proportional-share scheduler achieves close desired ratios cases specifically jain metric fairness represents ideal allocation achieve values greater ratios exception allocating additional bandwidth nfs chirp gridftp http nfs extremely difficult jain fairness case drops challenge sufficient number nfs requests transfer manager schedule interval case nfs request current implementation work-conserving schedules competing request server idle implementing non-work-conserving policy idle server waits period time scheduling competitor policy pay slight penalty average response time improved allocation control concurrency architecture adaptation show benefits automatically adapting concurrency architecture platform workload run simple experiments results shown figure experiment shown left run nest solaris server clients small files cache results illustrate workload event-based model lower average response time threaded model nest adaptive scheme performing experiment shown run nest linux server clients larger files case threaded model procedure previously determine number made source system administrator place initialized top system sdt creation step pmkfs stores information superblock creates directory tree directoriesd throughdn assuming groups process creating directories identical directory creation algorithm found algorithm typical directory creation procedure excess directories created added shadow cache general place maintain minimal threshold shadow directories group avoid costly directory creation algorithm obtain understanding threshold examined system traces labs typical busy day found thousand long-lived directories created giving rough upper bound number shadow directories place maintain absorb day worth controlled directory creation environment issues crash recovery concurrency directory creation place create les directories sdt potential data accrue time occur created sdt system crashes rename place worse job killed midst place library call place include basic crash recovery mechanism order periodically remove les refer process sdt cleaning current implementation sdt cleaner scans sdt directory structures removes data objects left system crashes run cleaner alternatives current implementation invokes cleaner invocations place set conservative longer directory-allocation process run alternatives include running cleaner time interval day background process issues arise place usage multiple processes users concurrent place processes problem current implementation basic algorithm allocate directory situation competing controlled directory creations groups lead signi dif culty creating directory desired location avoid problem place acquires advisory lock concurrency mode lock signify usage basic algorithm practice usage basic algorithm repopulates shadow cache reducing mode operation cooperative approach processes share work gaining control introduce signi complexity multiple users introduce issue sdt shared private user sharing requires level trust applications sdt writable location shared sdt vulnerable types attacks changing structures place lead poor allocations lling sdt causing denial service proceedings usenix annual technical conference june san antonio texas environments problem single user application sole access system trustworthy settings sdt replicated per-user basis increases space utilization duplicates effort circumvents security issues arise due sharing limitations primary limitation place implemented ffs-like systems modern unix systems ffs-like recent features including journaling ext soft updates found bsd family ffs implementations affect ability control placement techniques limitation arises due internal implementation ffs implementations spread larger les cylinder groups order avoid lling single group quickly ffs behavior prevents place controlling large les laid disk provide interface query place largest size allocation guaranteed controllable notable exception standard 
ffs implementation strategy occurs ext spread larger les groups implementation strategy hints graybox implementors inside systems build top behavior simple understand easy control place directly ne-grained placement les group applications modify order creation pack les group controlled fashion alternative initially explored overcomes limitations mesh applications place alternative approach place initially lls target system set dummy les discovering exact locations place free space applications request space data allocations controlled deemed approach unacceptable unmodi applications work correctly applications system appears full analysis section analyze behavior place demonstrating functionality basic overheads rst discuss experimental environment proceed series microbenchmarks demonstrating effectiveness layout control revealing approach group number group utilization figure controlled allocation graph depicts experiments creates -kb les rst standard system interfaces number directories les created varied experiments labeled fourth experiment place api create les directories place single group middle disk labeled graph group number varied x-axis shaded bar data group darker bars indicating data debugfs command gather needed information costs system creation usage show improvement expected reorganizing data controlling layout account zonedbit recording finally discuss experience broader range platforms experimental environment present results place top linux ext system experiments platform performed mhz pentium-iii processor main memory ibm lzx disk default ext system built disk consists block groups report experience systems end section layout control begin simple experiment demonstrate place effectively collocate les speci group disk speci cally compare methods creating directory tree allocated uniformly-sized les rst standard system interfaces alter number directories place les fourth place icl create les underneath directories direct system proceedings usenix annual technical conference june san antonio texas time number shadow directories system creation time place figure system initialization system initialization time plotted x-axis vary number shadow directories created group y-axis plots total time initialization complete place les directories single group middle disk figure shows group utilization approach directory trees data gure directories standard layout algorithms data les scattered disk contrast place data located middle group system desired system creation demonstrated basic control layout seek understand costs system rst cost present system initialization performed pmkfs tool figure presents system initialization time dominant cost system initialization number shadow directories created shadow cache present sensitivity initialization time number shadow directories created group gure cost scale increasing number directories linux ext system increasing amount data created order allocate directories groups successfully api overheads present overheads controlled directory creation place goal understand costs gray-box control data placement table breaks cost creating different-sized les place createfile interface costs presented table broken time percentage base state alloc ren misc total table file allocation overheads result shows average controlled creations place icl variance runs time percentage shadow cache shadow cache min median max base state alloc ren clean misc total table directory allocation overheads result shows average controlled directory creations place icl note times milliseconds rightmost column max shows time seconds time shown appears due rounding categories creation tests categories base time create standard interfaces state time read superblock access system statistics con guration information alloc time control allocation case stat system call check inode number ren time rename correct namespace misc additional software processing overhead table place api creation adds roughly overhead creation cost due place initialization amortized multiple calls place library signi overhead allocation rename software overheads finally size increases overheads unsurprisingly amortized explore overheads directory creation place createdir api table presents cost breakdown controlled directory allocation shadow cache note category included labeled cleanup includes time spent cleaning sdt directory-allocation process run note alloc case refers proceedings usenix annual technical conference june san antonio texas time number directories directory tree create performance place naive place directories place directories shadow cache standard figure create performance cost moving directory tree speci group presented varying number sub-directories structure x-axis xed amount data spread evenly les approaches creating structure compared text y-axis presents total time bulk collocation log scale costs creating les directories required directory-allocation algorithm table make number observations shadow cache time controlled directory creation reasonable roughly substantially higher base directory creation cost approximately factor faster shadow cache times higher median cost column lists maximum time shadow cache potential cost running full directorycreation process worst case takes seconds create directory correct group dif culty arises controlled creation smaller group ext allocates directories based free bytes remaining takes excessively long time groups coerce directory allocation group base alloc state times essentially constant constitute negligible part total maximum case shadow cache basic algorithm clean afterward bulk collocation costs common usage place move entire directory tree speci group disk accomplished place command-line tools interested strategy tool moving large amount data source nal destination group small number groups time number directories directory tree read performance standard random place random standard optimal place optimal figure smallle reads time read -kb les data shown settings varying number directories data settings standard system apis create les settings place collocate data single group orders shown random reads les random order optimal reads single scan disk figure presents time perform bulk collocation data spread evenly -kb les varying number sub-directories schemes compared rst place naive fashion creating directories les target group recursively assuming shadow cache exists approach dramatically slow directory creation algorithm nds increasingly dif cult force data target group approach creates directories rst performance improves tremendously ext allocation policy number bytes allocated group-selection policy creating les target group easier coerce system choosing scheme shows time approach assuming directories allocated shadow cache improves performance bulk collocation seconds finally traditional directory-tree copy shown comparison point fast overhead spread data disk localized manner bene collocation quantify potential read performance improvement place perform nal set microbenchmarks figure shows performance rst set tests present time takes read set les collocated disk gure application reads proceedings usenix annual technical conference june san antonio texas bandwidth group number exploiting zoned-bit recording ext ffs figure largele reads performance reading shown ext ffs varying group created x-axis cache ushed umount mount cycle read ensure disk bandwidth properly measured point average trials variance trials low set les random order collocating localized portion disk improves performance factor random lines graph les read optimal order essentially scanning 
disk single sweep bene collocation small case spreading data disk results additional seeks makes difference performance demonstrate place advantage zoned bandwidth characteristics modern disks figure plots performance large sequential scans les speci groups gure depicts performance place systems standard ext modi ext acts traditional bsd ffs gure ext platform placing data lower-numbered groups corresponds directly placing data outer zones disk improving performance observe experiment run top ffs system zoning nature disks hidden ffs spreads blocks large les disk place control placement blocks experience systems primary focus ext system modern implementation ffs concepts popular system linux community designed aspects place general ffslike systems mind interested studying behavior place platforms rst test generality run place top ext system journaling version ext ext great lengths preserve backwardscompatibility ext on-disk structures utilized surprised place works issue top ext tested place top implementation ffs allocation algorithms linux kernel place worked modi cation environment limitations discussed section shown directly figure relating placement large les case studies section describe place library rst demonstrate web server reorganize les place improve server throughput response time describe high-speed system benchmarking infrastructure place quickly extract characteristics underlying system improving web server throughput rst apply place order understand potential performance improvement web server environment reorganizing les popularly accessed les close disk seek costs reduced web service good target place structure typical web directory tree necessarily match locality assumptions encoded ffs-like systems change source code web server reorganization performed off-line command-line tools study potential bene simpli trace-based approach utilize web trace wisconsin-madison web server trace rst preprocessed remove requests induce system activity errors redirects requests remain transfer data http replies reply cache coherence check trace roughly million requests accesses total directory tree size understand potential gains collocation run trace system request generator trace entry request generator invokes system call records response time specifically model http requests generator performs stat system call requests transfer data maps memory touches page approach capture full complexity web environment give proceedings usenix annual technical conference june san antonio texas time memory size standard place figure web server performance time play back component web trace shown standard line plots performance typical layout place approach packs data small portion disk point represents trials variance low size directory tree served baseline potential performance improvement system reorganization utilize place command-line tools collocate directory tree outer-most tracks disk compare organization directory tree spread drive determined typical system heuristics figure time replay trace function amount memory range memory sizes collocation place improves performance roughly bene result directly reduction seek costs demonstrated instrumentation testing apparatus speci cally recording group number access compute average group distance traversed requests standard layout average number groups requests place performance gains limited due access patterns found web trace trace requests les single image directory les collocated standard ffs policy reducing placeassisted placement environment place improve performance simple direct manner greater bene expected environments access patterns match directory structure closely rapid file system microbenchmarking examine place context fast discovery performance characteristics tools developed time extract performance characteristics underlying system benchmarking tools run root run uncontrolled potentially lengthy amount time chen patterson self-scaling benchmark runs hours days reporting results back user settings system benchmarking tool ran quickly trading accuracy shorter run-time running application foreign computing environment seti home wide-area shared computing system condor globus mobile application quickly extract characteristics underlying system parameterize properly system benchmark run user-level requiring special privileges discover system parameters develop benchmarking tool fast fast accurate system extraction mobile application extract performance characteristics underlying system xed time budget user level fast extract information system memory system system component utilizes place mobile application examine single processor version now-sort worldrecord-breaking sorting application traditionally thought database contexts sorting commonly found scienti computation pipelines reasonable candidate mobile execution scienti peer-to-peer shared computing systems now-sort requires parameters tune host system rst parameters bandwidth expected local disk worst-case seek time numbers sort estimate large buffers merge phase order amortize seek costs size caches memory-hierarchy sorting data cachesized chunks sorting proceeds faster rate dif cult parameters generally extract maximum seek cost place api fast tool create les disk issue synchronous update rst start timer issue synchronous update record elapsed time write giving coarse estimate full-stroke seek nements made time order remove rotational costs desired table presents costs running fast test system mode operation fast runs quickly garnering coarse estimates required system parameters table observe proceedings usenix annual technical conference june san antonio texas time cache bandwidth max seek pmkfs total table fast performance table presents time fast takes discover system parameters mode fast congured run quickly extracting coarse estimates consuming time total time extract needed information sorting roughly seconds sorts massive data sets spending extra seconds con gure application worth time finally note pmkfs specialized task hand giving command-line options prevent creation shadow directories initialization time reduced small xed overhead related work work directly related place gray-box file layout detector controller fldc original gray-box paper fldc components rst decide order access set les re-write directory improve accesses components place fldc exposing ne-grained control directory layout applications applications long sought control underlying operating system policies mechanisms response demand previous research developed operating systems including spin exokernel vino much-improved control operating system behavior gray-box approach route improved control underlying exploiting knowledge behavior place demonstrates directory layout realized user-level place method exposing group numbers conceptually similar exokernel philosophy exposing physical names place treats system underlying entity exposes internal structure ext block groups exokernel exposes details hardware physical sector numbers moving data blocks spatial arrangement web server case study explored contexts work disk shuf ing ruemmler wilkes track frequency block accesses reorder disk blocks reduce seek times higher level staelin garcia-molina rearrange les system major difference approaches place performed transparently users applications control exposed sophisticated tracking blocks les accessed temporal succession hope develop access-tracking tool future work improving web server performance similar work improving web proxy performance hummingbird library-based system designed web proxies place features hummingbird users collocate les tie locality naming contrast place implemented top ffs-like system hummingbird performs functions library runs raw disk hummingbird specialized web-proxy environment place 
general-purpose tool finally fast tool bears similarity recent work database management systems online aggregation dbms returns approximate result selection query user immediately includes statistical estimate accuracy result user query running system nes result time data sampled answer precise fast tool applies philosophy benchmarking system future work number avenues exist future research plan explore breadth applicability place top systems platform interested bsd family challenges domain recent bsd implementations ffs utilize dirprefs algorithm directory group selection algorithm places directories parents attempt increase performance common operations unpacking large directory tree building gray-box controller place top dirprefs require extra care spread directories groups building place top log-structured system lfs interesting grouping related les generally straightforward higher bandwidth event model adaptive scheme close performance model experiments discern cost adaptation nest models periodically order find current workload components receive proportional shares fairness allocation defined fairness ratio delivered allocation desired allocation components ideal allocation events threads adaptive average time request model solaris events threads adaptive bandwidth model linux figure adaptive concurrency graph left experiment measures average request latency solaris requests events threads adaptive nest approach graph experiment measures bandwidth linux requests models cases nest adaptively picks model overhead note process model disabled experiments sake clarity lot management overhead measured overhead quota mechanism implement lots nest found quotas enabled write performance disk decreases roughly worst case single sequential write stream shown figure read performance unaffected surprisingly cost writing quotas enabled hidden server network-bound concurrent write streams investigating additional complexity implementing lots directly monitoring write operations nest worth performance improvement ability distinguish lots correctly related work storage appliance nest relates closely filers network appliance enterprise storage platforms emc nest attempt compete commercial offerings terms raw performance primarily intended target domain nest offers low-cost softwareonly alternative offers protocol flexibility grid-aware features needed enable scientific computations grid server bandwidth write size performance overhead lots quotas disabled quotas enabled figure overhead lots graph shows overhead imposed implementing lots kernel quota system notice small files cost negligible increases quickly file size grid community number projects related nest gara architecture advance reservations variety resources including computers networks storage devices nest gara reservations similar nest lots users make advance gara provide best-effort lots sophisticated user management nest disk resource managers srm storage depots ibp legionfs servers provide grid storage services projects designed provide local storage management global scheduling middleware conversely nest local storage management solution designed integrate number global scheduling systems distinction account key difference nest storage servers systems designed work primarily self-contained middleware projects protocol independence servers unique feature nest dynamic concurrency adaptation note intrinsic design nest incorporated systems srm ibp provide space guarantees manners similar nest lots difference srm srm guarantees space allocations 
multiple related files two-phased pinning lots nest provide functionality client flexibility control implementation complexity comparing nest lots ibp space guarantees difference ibp reservations allocations byte arrays makes extremely difficult multiple files contained allocation client build file system byte array difference ibp permanent volatile allocations nest permanent lots users allowed indefinitely renew best-effort lots analogous volatile allocations mechanism ibp switching allocation permanent volatile lots nest switch automatically best-effort duration expires nest legionfs recognizes importance supporting nfs protocol order unmodified applications benefit grid storage resources legionfs builds support client side nest server side legionfs client-based nfs easier server implementation makes deployment difficult legion-modified nfs module deployed client locations nest grid storage system supports multiple protocols server pfs srb middleware client side approaches complementary enable middleware server negotiate choose protocol transfer nfs locally gridftp remotely conclusion presented nest open-source user-level software-only storage appliance nest specifically intended grid designed concepts flexibility adaptivity grid-awareness flexibility achieved virtual protocol layer insulates transfer architecture particulars file transfer protocols dynamic adaptation transfer manager additional flexibility enabling nestto run effectively wide range hardware software platforms supporting key grid functionality storage space guarantees mechanisms resource data discovery user authentication quality service nest grid-aware integrate cleanly distributed computing systems experimental results demonstrated inclusion multiple protocols single storage appliances enables proportional-share scheduling jbos model presented experimental results showing nest adjusts workload solaris linux systems adjusts highest performing concurrency model finally illustrate vision nest role grid computation scenario utilizes grid middleware multiple nests coordinate reservation scheduling cpus reservation scheduling storage resources nest development release runs linux solaris version support nfs protocol operational supported download http wisc condor nest production release released end acknowledgments members condor team numerous list members wind group nathan burnett timothy denehy brian forney florentina popovici muthian sivathanu specially mention erik paulson douglas thain peter couvares todd tannenbaum condor team people anonymous reviewers contributed suggestions specifically paper development nest project general extend gratitude members computer systems lab outstanding job keeping computers running networks work sponsored nsf ccrccr- ngsccr- itrand wisconsin alumni research foundation allcock bester bresnahan chervenak liming tuecke grid ftp protocol extensions ftp grid http www-fp mcs anl gov dsl gridftpprotocol-rfc-draft pdf march arpaci-dusseau arpaci-dusseau information control gray-box systems symposium operating systems principles sosp oct baru moore rajasekar wan sdsc storage resource broker proceedings cascon toronto canada burnett bent arpaci-dusseau arpaci-dusseau exploiting gray-box knowledge buffer-cache management usenix chervenak foster kesselman tuecke protocols services distributed data-intensive science proceedings acat chiu jain analysis increase decrease algorithms congestion avoidance computer networks journal computer networks isdn volume pages june condor condor directed-acyclic-graph manager dagman http wisc condor dagman crovella frangioso harchol-balter connection scheduling web servers usenix symposium internet technologies systems emc corporation http emc fielding gettys mogul frystyk berners-lee rfchttp hypertext transfer protocol specification version network working group requests comments january foster kesselman globus metacomputing intrastructure toolkit international journal supercomputer applications foster kesselman tsudik tuecke security architecture computational grids proceedings acm conference computer communications security conference pages frey tannenbaum livny tuecke condor-g computation managament agent multiinstitutional grids proceedings tenth ieee symposium high performance distributed computing hpdc pages san francisco california august grimshaw wulf legion vision worldwide virtual computer communications acm january hitz lau malcolm file system design nfs file server appliance proceedings usenix winter technical conference pages san fransisco usa howe bandwidth request throttling apache http snert software throttle iyer druschel anticipatory scheduling disk scheduling framework overcome deceptive idleness synchronous acm symposium operating systems principles october kleiman vnodes architecture multiple file system types sun unix usenix conference proceedings pages kohler morris chen jannotti kaashoek click modular router acm transactions computer systems august lancaster rowe measuring real world data availability proceedings lisa systems administration conference pages san diego california december lohr supercomputing business move closer york times business financial desk february pai druschel zwaenepoel flash efficient portable web server proceedings usenix technical conference patterson availability maintainability performance focus century key note lecture usenix conference file storage technologies fast january plank bassi beck moore swany wolski managing data storage network ieee internet computing september october postel rfcftp file transfer protocol specification june raman matchmaking frameworks distributed resource management phd thesis wisconsin october raman livny solomon matchmaking distributed resource management high throughput computing proceedings seventh ieee international symposium high performance distributed computing hpdc july roy end-to-end quality service high-end applications phd thesis chicago satyanarayanan digest seventh ieee workshop hot topics operating systems rice conferences hotos digest digesthtml html march sharpe smb samba cifs docs whatis-smb html september shoshani sim storage resource managers middleware components grid storage nineteenth ieee symposium mass storage systems mss sun microsystems rfcnfs network file system protocol specification network working group requests comments march thain basney son livny kangaroo approach data movement grid proceedings tenth ieee symposium high performance distributed computing hpdc san francisco california august thain bent arpaci-dusseau arpaci-dusseau livny gathering creating communities grid proceedings supercomputing denver colorado november thain livny pluggable file system http wisc condor pfs vazhkudai tuecke foster replica selection globus data grid ieee international symposium cluster computing grid ccgrid waldspurger weihl stride scheduling deterministic proportional-share resource mangement technical report mit lcs tmmassachusetts institute technology mit laboratory computer science june walsh lyon sager chang goldberg kleiman lyon sandberg weiss overview sun network file system proceedings usenix winter conference pages jan welsh culler brewer seda architecture well-conditioned scalable internet services proceedings eighteenth symposium operating systems principles sospbanff canada october white walker humphrey grimshaw legionfs secure scalable file system supporting cross-domain high-performance applications proceedings supercomputing denver colorado november zhang deering estrin shenker zappala rsvp resource reservation protocol ieee networks magazine september 
user wishes group les les written time aspects make lfs challenging including grouping les span multiple segments controlling off-line behavior cleaner generally interested developing techniques control alloproceedings usenix annual technical conference june san antonio texas cation broader range systems investigate utility methods range storage devices specifically determine controlled placement top modern disk arrays finally tool place low-level mechanism placing les controlled manner disk les higher-level policy decision requires detailed knowledge les accessed time similar previous work data rearrangement plan develop tool track les blocks accessed generate inputs placement conclusions classic paper hints computer system design lampson tells don hide power higherlevel abstractions hide undesirable properties functionality contrast exposed client unix systems expose explicit controls laying les user demands standard layout heuristics workloads conform locality assumptions set stone years ago perform poorly paper present design implementation evaluation place gray-box information control layer exposes directory information applications exploiting knowledge internal algorithms common ffs-like systems place control directory allocations microbenchmarks shown costs gray-box control overly burdensome potential bene controlled allocation substantial case studies demonstrated place system realistic diverse application settings discussed limitations place gray-box approach controlled allocation highlighting features system allocation policies make simple dif cult build control top gray-box approach alternative path innovation requiring underlying operating system dif cult implement maintain distribute gray-box icl embeds knowledge underlying system exploits knowledge implement functionality portable manner important question remains full range functionality implemented gray-box manner ultimate limitations icl small step nal answer acknowledgments nathan burnett tim denehy florentina popovici vijayan prabhakaran muthian sivathanu feedback paper special muthian assistance traces geoffrey kuenning excellent shepherding anonymous reviewers thoughtful suggestions combination greatly improved content paper john heim staff doit providing recent web trace included path names tom engle implementation ffs allocation algorithm linux kernel finally computer systems lab providing superb environment computer science research work sponsored nsf ccrccr- ccrngs- itran ibm faculty award wisconsin alumni research foundation arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october arpaci-dusseau arpaci-dusseau culler hellerstein patterson highperformance sorting networks workstations proceedings acm sigmod conference management data sigmod tucson arizona bershad savage przemyslaw pardyak fiuczynski becker chambers eggers extensibility safety performance spin operating system proceedings acm symposium operating systems principles december burnett bent arpaci-dusseau arpaci-dusseau exploiting gray-box knowledge buffer-cache contents proceedings usenix annual technical conference usenix pages monterey june chen patterson approach performance evaluation self-scaling benchmarks predicted performance inproceedings acm sigmetrics conference pages dowse malone recent filesystem optimisations freebsd proceedings usenix annual technical conference freenix track monterey california june engler kaashoek toole exokernel operating system architecture proceedings usenix annual technical conference june san antonio texas application-level resource management proceedings acm symposium operating systems principles december foster kesselman globus metacomputing infrastructure toolkit international journal supercomputer applications hellerstein haas wang online aggregation sigmod international conference management data sigmod pages tucson arizona holtman cms data grid system overview requirements cms note cern july lampson hints computer system design proceedings acm symposium operating system principles pages bretton woods december acm litzkow livny mutka condor hunter idle workstations proceedings acm computer network performance symposium pages june mckusick joy lef fabry fast file system unix acm transactions computer systems august mcvoy staelin lmbench portable tools performance analysis proceedings usenix winter technical conference january meter observing effects multi-zone disks proceedings usenix conference january nyberg barclay cvetanovic gray lomet alphasort risc machine sort acm sigmod conference riedel kallahalla swaminathan aframework evaluating storage system security proceedings usenix symposium file storage technologies fast pages monterey california january rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february ruemmler wilkes disk shuf ing technical report hpl- hewlett packard laboratories oct saavedra smith measuring cache tlb performance effect bench-mark runtimes ieee transactions computers schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon seltzer endo small smith dealing disaster surviving misbehaved kernel extensions proceedings usenix symposium operating systems design implementation osdi october seltzer ganger mckusick smith soules stein journal-ing versus soft updates asynchronous meta-data protection file systems proceedings usenix annual technical conference pages san diego june shriver gabber huang stein storage management web proxies proceedings usenix annual technical conference usenix pages boston massachussetts june staelin garcia-molina smart filesystems proceedings usenix winter technical conference dallas texas january stonebraker operating system support database management communications acm july sullivan werthimer bowyer cobb gedye anderson major seti project based project serendip data personal computers proceedings international conference bioastronomy talagala arpaci-dusseau patterson microbenchmark-based extraction localand global disk characteristics technical report csd- california berkeley tweedie future directions theext filesystem proceedings usenix annual technical conference freenix track monterey california june 
ps-adobecreator dvips copyright radical eye software title grid community dvi pages pageorder ascend boundingbox documentfonts helvetica-bold cmsy helvetica times-bold times-italic times-roman cmmi courier cmr times-bolditalic documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips grid community grid community dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict dict begin adict dict matrix currentmatrix bind slw setlinewidth load clw currentlinewidth load currentpoint load exch bind lineto load translate load tmatrix rangle atan atan load stopped pop pop div dup pop div ifelse net neg exch neg exch pyth dup mul exch dup mul add sqrt ptoc copy cos mul roll sin mul pathlength pyth add pathlength flattenpath pathlength pathlength pathforall load stopped pop pop pop pop stp dup scale stv sdict begin normalscale end stp dashline dup pathlength exch div pop pathlength ifelse add mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke dotline pathlength clw add div add ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add repeat grestore mul moveto rlineto stroke add repeat grestore pop pop modification end beginarrow adict begin mtrx gsave copy index neg exch index exch atan rotate newpath endarrow mtrx setmatrix grestore end arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore tbar clw mul add div clw div moveto rlineto stroke clw moveto bracket clw mul add dup clw div mul clw add clw div neg moveto neg clw div clw div stroke clw moveto roundbracket clw mul add dup div mul mtrx clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto arc fill enddot ifelse clw add clw div moveto shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec narray aload length div dup dup cvi exch pop exch cvi narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse line narray arrowa lineto repeat roll arrowb pop pop arcto roll cvx arcto load stopped ifelse pop repeat checkclosed dup mul index index mul add index pop pop polygon narray pop pop repeat checkclosed mul roll add div add div moveto lineto repeat roll lineto lineto pop pop closepath ifelse diamond mtrx rotate dup pop clw mul neg atan sin div add cos div add ifelse mark div div neg neg div div arrowa moveto arrowb false line closepath mtrx setmatrix modification begin jan triangle mtrx translate rotate div dup pop clw mul atan sin div atan div dup cos exch sin div mul ifelse mark neg arrowa moveto arrowb false line closepath mtrx setmatrix triangle mtrx translate rotate div dup clw mul atan sin div atan div dup cos exch sin div mul mark neg arrowa moveto arrowb false line closepath mtrx modification begin jun patch michael vulis setmatrix setmatrix pop modification end cca copy pyth cca copy pyth cca exp mul exp mul add exp mul exp mul add atan atan div cos abs exp mul pyth div div mul mul mul mul mul mul neg mul mul neg add ifelse mul div cos exp div cca boc arrowa roll curveto curveto eoc roll arrowb copy curveto bac moveto arrowa nac curveto eac arrowb curveto pop pop opencurve narray pop pop repeat boc repeat eoc ifelse altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac nac repeat eac ifelse closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse moveto neg neg neg neg fill moveto neg fill gsave moveto rotate repeat fill grestore fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont rect add div moveto lineto lineto lineto lineto closepath ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse beziernarray counttomark div dup cvi exch pop neg mod add mod add repeat aload points mul add roll pop ifelse openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore parab exch exch exch exch div div add arrowa add add mul arrowb curveto points mul grid newpath string cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi div round cvi ifelse ifelse div clw div add helvetica findfont scalefont setfont mul clw div add systemdict setstrokeadjust true setstrokeadjust transform round add exch round add exch itransform bind ifelse gsave setlinecap div div div setdash setlinecap ifelse mul div div mul mul div div mul add mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse mul div div mul mul div div mul add mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add repeat grestore arcarrow gsave newpath moveto clip newpath grestore mul pop pop 
pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg ellipse mtrx scale roll arc mtrx setmatrix rot translate roll neg rotate net rotbegin dict tmatrix tmatrix rangle tmatrix tmatrix cvx rot rangle rangle dup add cvx rotend tmatrix tmatrix setmatrix cvx rangle rangle pop cvx putcoor gsave stv exch exec moveto setmatrix grestore putbegin tmatrix tmatrix cvx roll moveto putend tmatrix tmatrix setmatrix cvx moveto uput add div div sin cos abs abs copy dup pop exch pop ifelse div mul div mul abs dup mul abs abs dup mul abs ifelse uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch beginol dup exch theol ifvisible visible ifvisible true ifvisible invisible ifvisible false ifelse initol olunit matrix defaultmatrix dtransform cvx visible olunit idtransform moveto invisible olunit neg exch neg exch idtransform moveto bol beginol ifvisible true end end pstricks pro endprocset beginprocset tex pro texdict dict texdict begin bind exch dup translate isls false vsize mul hsize mul landplus false rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc psencodingfile author rahtz mackay alan jeffrey horn berry version date july filename enc tex-fonts tug docstring encoding truetype type fonts tex idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting remaining positions left undefined upward-compatible revisions someday characters generally hyphen appears compatibility ascii windows texbase encoding encoded characters adobe standard windows notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef remaining unencoded characters include zcaron zcaron caron dotlessi unusual tex characters lucida bright dotlessj ffi ffl notdef notdef notdef notdef notdef notdef notdef notdef contentious painful quoteleft quoteright move things found grave quotesingle ascii begins space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef rubout ascii ends notdef notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft notdef notdef notdef notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright notdef notdef ydieresis notdef nobreakspace exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen windows softhyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div ifelse forall metrics metrics currentdict end index currentdict end definefont roll makefont setfont cvx cvx obliqueslant dup sin cos div neg slantfont index mul add extendfont roll mul exch reencodefont charstrings rcheck encoding false dup exch dup charstrings exch pop notdef encoding true forall encoding exch pop cleartomark ifelse encoding exch end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter note legal scaleunit hscale scaleunit div hsc vscale scaleunit div vsc hsize clip vsize clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform roll itransform roll itransform roll curveto closepath pathforall newpath counttomark array astore xdf pop put courier fnt invertflag paintblack txpose pxs pys scale ppr aload pop por noflips 
pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage copypage macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse clip newpath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath clip showpage erasepage copypage newpath endspecial count ocount pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset beginfont cmr ps-adobefontcmr creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly notice copyright american mathematical society rights reserved readonly fullname cmr readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmr painttype fonttype fontmatrix readonly encoding array index exch notdef put dup put readonly fontbbox readonly uniquexx currentdict end currentfile eexec bacdd abda cfc dfaeb aacdc cbbc aad fbfee fddf bef fbd ebed bbec ece bcf cac edad ebc bda cbe dbd bda dfdd feea eefbcbb aae bbc ecfa fcc cccaf ebc ead bca efa dacc dac eef bee fdf efc cee fae deda bff ddc fcee fba eac edf cdfd dddddc aaccf febebbc ada ade fab bba fedf caa bcea dfa bfc fadf bae faf fce bdf fcf feef ffc dce faf eea fcf cbf cab dbaed cad aad cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly notice copyright american mathematical society rights reserved readonly fullname cmmi readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmmi painttype fonttype fontmatrix readonly encoding array index exch notdef put dup put readonly fontbbox readonly uniquexx currentdict end currentfile eexec fba cdfdddf bfbbfcb fdc add fbd efe fceb dacfdcd bdd abefd bfe efe bbaee ffea bfd bcedc ccbd cda ddf efac afac edecd bedf ebf dbd fbf dfb ebc afd ceeb daf fbe ddf ecebcbe cadf abc fcf cfc eac bee ced edf aedeb ffd aac aeb ebddc eae bfd fea dad eef bea fdd eafe bce bcda eca dedf dae adc ffd eedc bcf debc bcc cbde ffef bbfe bfbfe bfd dca dbc cbc efca bfb cdd cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly notice copyright american mathematical society rights reserved readonly fullname cmsy readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmsy painttype fonttype fontmatrix readonly encoding array index exch notdef put dup asteriskmath put readonly fontbbox readonly uniquexx currentdict end currentfile eexec bac ced ecf dcecec ccde cdf dcefcdbd baffaeb ffb fbefc bca ddc acb ddf daee ffaec bcfe fec fddf cdfdaa dcd cda acfce eebb cecc bfdac aff aee bef cbc bac bbe ded eba cebb daa bdaf bee bdb aeee feb bcab feabba efd baa eca ade efb eef cad dfe aea cleartomark endfont texdict begin grid community dvi start texbase encoding reencodefont times-bolditalic cmr texbase encoding reencodefont times-roman texbase encoding reencodefont courier texbase encoding reencodefont courier cmmi texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman texbase encoding reencodefont times-italic texbase encoding reencodefont times-bold texbase encoding reencodefont helvetica texbase encoding reencodefont helvetica cmsy texbase encoding reencodefont helvetica-bold end endprolog beginsetup feature resolution dpi texdict begin papersize letter endsetup page bop gathering ell creating comm unities grid douglas thain john bent andrea paci dusseau remzi paci dusseau miron livn computer sciences depar tment univ ersity wisconsin madison est yton street madison abstra grid applications demanding heduler bring jobs data close oximity der satisfy thr oughy put scalability policy equir ements systems accomy plish making jobs data mobile opose system jobs data meet binding xey cution stor sites ether communities whic participate wide-ar system elationships participants community xpr essed classad ame work extensions ame work comy munity member xpr ess indir ect elations demonstr ate implementation communities impr ving formance high-ener physics simulation inter national distrib uted system intr oduction grid applications demanding applicay tions elds high-ener physics high-throughput access wide selection data les chosen repositoy ries measured petabytes due lar number users size data distances olv online access data repositories scalable cient lar numbers jobs systems solv problems generally allen camps data job job data approaches uni ersally applicable suf fer scalability proby lem netw ork storage capacities limits number replicas made number jobs replica propose balance sho figure local area ecution sites band communities share research supported part 
nsf cony tracts itri eiai asa arc contract ncc permission mak digital hard copies part ork personal classroom granted fee pro vided copies made distrib uted pro commercial adv antage copies bear notice full citation rst page cop republish post serv ers redistrib ute lists requires prior speci permission fee ember den cop yright beginspecial llx lly urx ury rwi setspecial begindocument community eps ps-adobeepsf- title stdin creator transfigexe fig dev version patchlevel creationdate tue jul thain coral wisc douglas thain orientation portrait boundingbox pages beginsetup endsetup magnification endcomments psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end endprolog psbegin setmiterlimit clip polyline slw col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline col shd col polyline clippath clip col arrowhead setgray col arrowhead setgray col polyline slw col slw ellipse drawellipse col ellipse drawellipse col polyline col polyline col slw ellipse drawellipse col helvetica-narrow-bold scf infn col slw ellipse drawellipse col ellipse drawellipse col polyline col polyline col polyline slw clippath clip col arrowhead setgray col arrowhead setgray col polyline slw col slw ellipse drawellipse col helvetica-narrow-bold scf col polyline slw clippath clip col arrowhead setgray col arrowhead setgray col psend enddocument endspecial figur communities data locally-determined physical limits comy munity hosts storage appliance serv data locally xisting wide-area replication system scheduler mak number informed choices jobs requesting data communities staged data staged comy munity job balance point ratio supportable jobs replicas depends properties apy plication data storage vices netw orks order structure communities participants xpress relationships themselv relations direct job require machine cpu indirect job require machine storage vice particuy lar dataset demonstrate classad frame ork additions indirection press relationships communities traditionally constructed distrib uted lesystems require special pri vile ges deplo con gure present uilding blocks permit construction communities unpri vile ged user -le softw uilding blocks communicate state eop page bop beginspecial llx lly urx ury rwi setspecial begindocument mechanism eps ps-adobeepsf- title stdin creator transfigexe fig dev version patchlevel creationdate tue jul thain coral wisc douglas thain orientation portrait boundingbox pages beginsetup endsetup magnification endcomments psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind reencdict dict reencode reencdict begin newcodesandnames exch newfontname exch basefontname exch basefontdict basefontname findfont newfont basefontdict maxlength dict basefontdict exch dup fid dup encoding exch dup length array copy newfont roll put exch newfont roll put ifelse pop pop ifelse forall newfont fontname newfontname put newcodesandnames aload pop newfont encoding exch notdef put newcodesandnames length idiv newfont encoding roll put repeat newfontname newfont definefont pop end isovec grave acute circumflex tilde macron breve dotaccent dieresis ring cedilla hungarumlaut ogonek caron dotlessi space exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot endash registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute 
ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis times-roman times-roman-iso isovec reencode drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end endprolog psbegin setmiterlimit clip slw ellipse drawellipse col ellipse drawellipse col polyline col polyline col polyline slw arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat col times-roman-iso scf device col times-roman-iso scf discovery col times-roman-iso scf system col polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat col times-roman-iso scf discovery col times-roman-iso scf system col times-roman-iso scf replica col slw ellipse drawellipse col ellipse drawellipse col polyline col polyline col ellipse drawellipse col ellipse drawellipse col polyline col polyline col ellipse drawellipse col ellipse drawellipse col polyline col polyline col ellipse drawellipse col ellipse drawellipse col polyline slw clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col arrowhead setgray col polyline slw col polyline slw clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat col polyline clippath clip col arrowhead setgray col arrowhead setgray col polyline clippath clip col arrowhead setgray col arrowhead setgray col polyline clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col times-roman-iso scf short-haul col times-roman-iso scf col times-roman-iso scf col times-roman-iso scf appliance col times-roman-iso scf storage col times-roman-iso scf long-haul col times-roman-iso scf execution col times-roman-iso scf site col times-roman-iso scf job col times-roman-iso scf agent col times-roman-iso scf system col times-roman-iso scf cpu col times-roman-iso scf information col times-roman-iso scf placement col times-roman-iso scf distributed col times-roman-iso scf repository col times-roman-iso scf discovery col psend enddocument endspecial figur model condor distrib uted batch system places jobs appropriately address matter selecting policies communities policies ern size communities contents storage vices decisions relocate jobs place policies wholly dependent particulars indi vidual applications physy ical netw ork capacity number ailable cpus lik hope ork mechanisms enable study policies demonstrate feasibility model applying high-ener physics simulation run international grid constructing communities seny sible policies kno wledge application demonstrate mark impro ement simulation capacity communities building communities community consists eral cpus gather storage vice programs ecuting cpus eny couraged required community dey vice storing retrie ving data sharing vice similar applications reduce consumption widey area resources communities ect physical administray boundaries number cpus fecti ely serv storage vice limited connecting nety ork load fered running programs users admitted community depend membership soy cial structures amiliar form community distrib uted system shared members orkgroup sort community semi-permanent require special pri ile ges coordinated softw par ticipants contrast services fered grid intended xible users applications loads change communiy ties set recon gured torn permit agile deplo yment communities constructed uilding blocks applied mal users special pri vile ges accomplish emplo storage appliances interposition agents sho figure stor appliance serv meeting place community storage appliance frequently concei specialized hardw vice general-purpose computer equipped softw serv equally storage appliance appliance speaks number protoy cols allo members community select protocol situation xample applicay tion selecting elements database ne-grained block-access protocol con ersely application processing lar amounts sequential data choose streaming protocol standard applications rarely speak protocols bra users write appliy cations ork systems xists lar body programs written problem solv interposition ents agent small piece softw inserts applicay tion nati operating system agent responsible con erting program standard operations suity actions community ith agent place unmodi applications run grid vironment disco ering communities computational grid community resources change arning vironment proy grams rich methods nding communities meet deter mine membership community ecution resources community order bring inside actions dif ferent form disco ery refer cpu disco ery vice disco ery replica disco ery figure sho form disco ery community ecution cpu disco ery performed cpu proper architecture operating system ecution vice disco ery performed membership community ecution replica disco ery performed locate items job comy munity replica disco ery important area research recent grid forts vice disco ery closely related subtly dif ferent frequently emplo yed selfy con guring systems jini locate storage human-interf ace vices mobile softw hardw ould lik brie comment dif ference replica disco ery answers question data local stor wher replica management sysy tems track arious copies datasets spread storage vices grid dataset rey trie replica management system nds suitable remote cop requestor vice disco ery answers question wher loy cal stor vice ecuting jobs disco vice fer bandwidth storage space inputs outputs temporary les replica disco ery system locate remote data vice disco ery sysy tem locate place put incoming data caller members community vice disco ery systems comple belo communities simply ving ery eop page bop ecution site eststor propery points storage appliance approach simple fecti comple systems imagined cution site eral storage appliances polic restrictions xample vice allo access members administrati group case vice disco ery system query aily vices return nearest vice accepts job indirection critical feature disco ery system addition querying direct properties vices user request chain relations xample user request cpu storage vice dataset user rst stor age vices request set cpus set situation change withy user kno wledge user submit request xpressing chain indirection language needed xpress dif ferent rey lations scheduling polic management systems concrete represent properties requirements preferences olv community classad language uniquely suited task expressing communities classads classads condor system describe properties requirements preferences particiy pants distrib uted computing system classads named classi adv ertisements found wspapers multiple parties publish requests service fers serv well-kno place single classad list attrib ute alue pairs aly ues simple atoms strings inte gers comple xpressions referring potential matches figures sho xample job machine represented language describes cer tain simple properties machine mentions cpu operating system job mentions ecutable wner requirements potential match machine accept jobs wned particy ular user job accept 
machines running correct operating system unlik wspaper condor pro vides central matchy making service pairs fers requests suitable match found parties informed indi vidually responsible contacting accomy plishing ork process kno bi-later matc hmaky ing xtensi ely raman uild communities add participant match storage appliance sho figure incoming job requests cpu places indirect requirements storage classad representing cpu decides storage referenced figure sho job speci indirect requir ements eld states accept job eststor hascmsdata true eststor aluated conte potential cpu cpu simply point nearest storage vice address unique classads schemay free single distinct beginspecial llx lly urx ury rwi setspecial begindocument match eps ps-adobeepsf- title stdin creator transfigexe fig dev version patchlevel creationdate tue jul thain coral wisc douglas thain orientation portrait boundingbox pages beginsetup endsetup magnification endcomments psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end endprolog psbegin setmiterlimit clip slw ellipse drawellipse col ellipse drawellipse col polyline col polyline col slw ellipse drawellipse col slw ellipse drawellipse col polyline slw col polyline col polyline slw arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat col polyline slw clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col polyline col polyline clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col helvetica-narrow scf col helvetica-narrow scf col helvetica-narrow scf cpu col helvetica-narrow scf job col helvetica-narrow scf neareststorage col helvetica-narrow scf col helvetica-narrow scf requirements col helvetica-narrow scf lookup col helvetica-narrow-bold scf matchmaker col helvetica-narrow-bold scf cpu col helvetica-narrow-bold scf job col helvetica-narrow-bold scf storage col helvetica-narrow scf store col helvetica-narrow scf col helvetica-narrow-bold scf match col psend enddocument endspecial figur matchmaking refer ences ype job gett ype machine cmd sim owner thain requirements opsys linux neareststorage hascmsdata figur classad ype machine gett ype job opsys linux requirements owner thain neareststorage turk ype storage figur machine classad ype storage turk hascmsdata rue cmsdatap ath cmsdata figur storage classad eop page bop eststor property set constraints identify unique storage classad sho figure rest xpression aluated conte referred-to classad contained job aluates follo neareststorage hascmsdata true neareststorage cmspath cmsdata neareststorage turkey contents storage appliance change simply sends updated state matchmak dataset added vice jobs require match community dataset remo jobs longer match information matchmak necessar ily stale state cpu storage appliance change match made sides responsibility erifying requirements satis claiming protocol follo wing successful match olicies adding indirection job storage user freed wher jobs run user simply state needed order ecute jobs state storage vices jobs run user polic policies xpressed submit time classad language job boolean requir ements xpression determines machines suitable ecution sites aluates rue ecution site accepted othy erwise rejected inte ger xpression rank alue potential matches eral machines requir ements aluates rue machine highest rank chosen ith xpressions control jobs data ait arri xample user job site dataset xpress requirements neareststorage hascmsdata hand user kno ving job xpensi operation require stay community requirements neareststorage turkey wisc simply efer run local community require rank local community ten requirements neareststorage hascmsdata rank neareststorage turkey wisc beginspecial llx lly urx ury rwi setspecial begindocument implementation eps ps-adobeepsf- title stdin creator transfigexe fig dev version patchlevel creationdate tue jul thain coral wisc douglas thain orientation portrait boundingbox pages beginsetup endsetup magnification endcomments psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch 
exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end endprolog psbegin setmiterlimit clip slw ellipse drawellipse col ellipse drawellipse col polyline col polyline col ellipse drawellipse col ellipse drawellipse col polyline slw clippath clip col arrowhead setgray col polyline slw col polyline slw clippath clip col arrowhead setgray col polyline clippath clip col arrowhead setgray col polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat col polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat col polyline clippath clip col arrowhead setgray col arrowhead setgray col polyline clippath clip col arrowhead setgray col arrowhead setgray col times-roman scf execution col times-roman scf site col times-roman scf job col times-roman scf system col times-roman scf pfs col times-roman scf matchmaking col times-roman scf attribute col times-roman scf attribute col times-roman scf chirp col times-roman scf nest col times-roman scf nearest col times-roman scf hascmsdata col times-roman scf neareststorage col times-roman scf classad col psend enddocument endspecial figur implementation machines machines user ecute ywhere remote local cop ailable eliminate requir ements statement abo complicated information included pression set polic migration permitted xample job required ecute community xcept night netw ork traf wer requirements neareststorage turkey wisc clockhour implement tion uilt prototype concepts cony dor distrib uted batch system condor pro vides cpu scheduling system classad frame ork interposiy tion agent pluggable file system attach jobs local storage appliance implemented softw called nest vices suf ciently general purpose put indi vidually systems nest softw creating general-purpose storage appliances commodity computers special pri vile ges externally supports ariety netw ork protocols allo ing applications choose interact storage made gridftp chirp pro vides strong authentication high-throughput transfers ariety techniques multiple tcp streams nati nest proy tocol pro vides simple rpc-lik partialle access single tcp connection gridftp liny gua anca communicating grid services long-haul connections chirp short-haul partialle access require erhead tcp connection ery data operation pfs interposition agent constructed bypass pfs adapts gac applications storage sysy tems mounting application vie system special pri vile ges ernel-le rey quired number standard netw ork protocols including gridftp chirp supported xample pfs loaded unmodi unix programs interact nest running turkey wisc eop page bop chirp turkey wisc file system cpu selection vice parameters application condor allo classad property job ecution site iny serted program vironment ariables guments run time macro-e xpanding xpressions ginning dollar signs xample arguments chirp neareststorage input data condor understands ecutable consist single submit pfs-enabled application condor resort trick submitting self-e xtracting archi application pfs script properly tak indirection step omitting application archi modifying script fetch ecutable comy munity pfs technique belo retrie common ecutable local appliance finally noted abo users classads prepared handle stale match suppose stale informay tion job match community longer needed dataset pfs disco found error performs nearest nest simply passing ror application incorrect ould lik ely xit error message forcing user ually understand error resubmit job correct action tak pfs application xit abnor mally kill process signal condor interprets signal ecution aborted re-queue job ecution attempt performance demonstrate implementation chosen amine simulation component cms xperiment performed cern lar xperiment documented users italy united states mak hea application condor pools istituto nazionale fisica nucleare infn uniy ersity isconsin gan assuming role scientist infn wishes ecute lar number instances simulay tion infn pool equipped air number cpus competition users pool limits thirty additional cpus eraged xplored deplo yment comy munities order solv problem pplication wed perspecti system cms simy ulation orks follo reads input eral follo wing instructions reads ariety les database directory database pro vided apy plication consists mixture input les data les libraries source les user concei ably determine xact set database les needed run simulation xperience care citing cost analysis xpensi dealing data les needed tri vially predictable input sak application assume arbitrary simulation run access entire directory trimmed libraries source database yieldy ing directory directories symy bolic links les chose sample run simulation input reads total input les database directory generates output les ecutable compresses netw ork transfer mips machine local storage sample runs seconds simulation ecutable directly submitted system self-e xtracting archi pfs script submitted ecution site script wnloaded simulation ecutable approy priate storage appliance guments sample run representati real cms higher cpu ratio real run ypically simulation runs eral hours eral minutes chosen shorter run reasons primarily ant push elope system open condor applications greater demands secy ondarily ant consume xcessi amounts resources ould allocated ard real simuy lations progress vir onment condor pools infn emy plo yed running simulations pool con gured distinct community infn condor pool consisted cpus ailable time processing wer arious cpus ranged mips ailable memory ranged cpus physically spread country arious dey partments institution orkstation pro viding mips memory established bologna storage appliance infn community ariety nety orks ranging connected ecuy tion sites storage appliance condor pool consisted cpus reserv reserv cpus pro vided mips memory identical machine established storage appliance community reserv machines connected appliance dedicated ethernet switch communities connected public inter net bandwidth ailable path aried latenc measur ements gan assuming ecutables data les stored orkstation infn orky station installed instance condor submitting jobs instance nest serv input data pro vide output space ving collection site site reproducing symbolic links important archi size swells eop page bop beginspecial llx lly urx ury rwi rhi setspecial begindocument graphs italy eps ps-adobeepsf- title italy eps creator gnuplot patchlevel creationdate tue jul documentfonts atend boundingbox orientation portrait endcomments gnudict dict gnudict begin color false solid false gnulinewidth userlinewidth gnulinewidth vshift mul hpt vpt hpt hpt vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke 
userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke userlinewidth setlinewidth ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc copy moveto copy vpt arc closepath fill vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy copy moveto vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc bind setdash copy vpt arc closepath fill vpt arc closepath bind rec newpath roll moveto index rlineto exch rlineto neg rlineto closepath bind square dup rec bind bsquare vpt exch vpt exch vpt square bind setdash copy moveto vpt rlineto bsquare bind setdash copy vpt square fill bsquare bind setdash copy exch vpt exch vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt square fill bsquare bind setdash copy copy vpt square fill exch vpt exch vpt vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy vpt vpt square fill bsquare bind setdash copy vpt vpt vpt rec fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt square fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy exch vpt exch vpt square fill bsquare bind setdash copy bsquare fill bsquare bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind diae stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke boxe stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke triue stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tride stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pente stroke setdash gsave translate hpt rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow ltb currentpoint gsave translate rotate jobs 
completed cshow grestore elapsed time cshow infn local rshow currentpoint stroke stroke grestore end showpage trailer documentfonts helvetica enddocument endspecial beginspecial llx lly urx ury rwi rhi setspecial begindocument graphs italy conc eps ps-adobeepsf- title italy conc eps creator gnuplot patchlevel creationdate tue jul documentfonts atend boundingbox orientation portrait endcomments gnudict dict gnudict begin color false solid false gnulinewidth userlinewidth gnulinewidth vshift mul hpt vpt hpt hpt vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke userlinewidth setlinewidth ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc copy moveto copy vpt arc closepath fill vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy copy moveto vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc bind setdash copy vpt arc closepath fill vpt arc closepath bind rec newpath roll moveto index rlineto exch rlineto neg rlineto closepath bind square dup rec bind bsquare vpt exch vpt exch vpt square bind setdash copy moveto vpt rlineto bsquare bind setdash copy vpt square fill bsquare bind setdash copy exch vpt exch vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt square fill bsquare bind setdash copy copy vpt square fill exch vpt exch vpt vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy vpt vpt square fill bsquare bind setdash copy vpt vpt vpt rec fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt square fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy exch vpt exch vpt square fill bsquare bind setdash copy bsquare fill bsquare bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind diae stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke boxe stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke triue stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tride stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pente stroke setdash gsave translate hpt rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray 
fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow ltb currentpoint gsave translate rotate number cpus allocated cshow grestore elapsed time cshow infn local rshow bridging information gap storage protocol stacks timothy denehy andrea arpaci-dusseau remzi arpaci-dusseau department computer sciences wisconsin madison ftedenehy dusseau remzig wisc abstract functionality performance innovations file systems storage systems proceeded largely independently past years result information gap information designed implemented result high cost maintenance poor performance duplication features limitations functionality bridge gap introduce evaluate division labor storage system file system develop enhanced storage layer exposed raid raid reveals information file systems built specifically raid exports parallelism failure-isolation boundaries storage layer tracks performance failure characteristics fine-grained basis advantage information made raid develop informed log-structured file system lfs lfs extension standard logstructured file system lfs altered advantage performance failure information exposed raid experiments reveal prototype implementation yields benefits management flexibility reliability performance storage system small increase file system complexity lfs raid incorporate disks system on-the-fly dynamically balance workloads disks system user control file replication delay replication files increased performance functionality difficult impossible implement traditional division labor file systems storage introduction chasm exists world file storage management hierarchical file system directories byte-accessible files norm years internals file systems underlying storage systems evolved substantially improving performance functionality file systems approaches developed improve performance including read-optimized inode file placement logging writes improved meta-data update methods scalable internal data structures off-line reorganization strategies techniques developed assumption file system run single traditional disk recently storage systems received attention smart disks improve read write performance block remapping techniques o-intensive workloads multiple-disk storage systems studied research community achieved success storage industry high-end storage systems provide illusion single fast disk unsuspecting file systems internally manage parallelism redundancy optimize performance capacity analogous file systems storage systems developed single ffs-like file system mind file systems parallel disk systems substantial separate result information gap file system understand true nature storage system runs storage system comprehend semantic relations blocks stores addition unaware state tracks optimizations performs gap arose historical source hardware software boundary file systems traditionally expected block-based read write interface storage interface similar single disk exports advent hardware-based raid systems storage vendors advantage freedom innovate interface developed high-performance high-capacity systems appeared single large fast disk file system software modifications required host operating system file systems continued operate correctly spite fact optimized single-disk system case ignorance bliss arrangement simple worked boundary file system storage system changing migrating softwarestructuring technique interface necessitated hardware software raid drivers platforms advent networkattached storage client-side striping software replace hardware-based raid systems software-based raids attractive due low cost linux-based system incurs cost machine disks term arrangement file system layer top software storage layer storage protocol stack akin networking protocol stacks prominent communication networks similarities layering simplify system design potentially cost performance crucial difference exists layers comprise network protocol stacks derived design architects carefully deciding specific element storage protocol stack developed single coherent manner end result poor performance potential duplication implementation limitations functionality performance suffer model file system storage layer accurate layout optimizations work single traditional disk logical-block physical-block mapping unknown feature duplication potential pitfall log-structured file system layered top disk array performs logging duplicating work increasing system complexity unnecessarily finally functionality limited pieces information live layer system storage system blocks constitute file perform per-file operations block longer live file deletion optimize system ways knowledge time ripe re-examine division labor file system storage system layers attempt understand structure storage protocol stack specifically piece storage functionality understand easily effectively implemented problem germane time move network-attached storage proposed higher-level disk interfaces paper step goal exploring single point spectrum designs bridge file system storage system information gap develop evaluate division labor file system storage realignment storage layer exposes parallelism failure isolation boundaries part full file systems built on-line performance failure characteristics call layer exposed raid layer raid advantage information provided raid introduce informed lfs lfs enhancement log-structured file system combining performance failure information presented raid file-system specific knowledge lfs flexible manageable traditional file system deliver higher performance availability adding disk lfs on-line easily accomplished lfs accounts potential heterogeneity introduced disk dynamically balances load disks system rates lfs increases flexibility storage enabling user control redundancy per-file basis implements lazy mirroring defer replication time potentially increasing performance system slight decrease reliability crucial lfs raid implementation aforementioned benefits significant increase complexity maintainability storage protocol stack careful design functionality mentioned implemented increase code size compared traditional system lfs raid panacea find managing redundancy file system onerous requiring careful placement inodes data blocks ensure efficient operation failure extending traditional file system structure support enhanced functionality lfs arduous task redesign age-old vnode layer support informed file systems warranted rest paper structured begin discussion related work section section give overview approach describe raid lfs sections section present evaluation system present discussion section future work section conclude section related work part motivation informing file system nature storage system reminiscent work berkeley fast file system ffs ffs early demonstration benefits low-level understanding disk technology colocating correlated inodes data blocks performance improved compared unix file system work goal multidisk storage systems mind file system base decisions reliablyobtained information characteristics storage relying assumptions hold time seek costs dominate rotational costs roselli discuss file system storage system gap talk file system fingerprinting solution enrich interface file systems storage systems giving storage system information blocks related blocks accessed future approach storage system information file system collected presumes storage layer make good information potential problem approach require agreement set interfaces cooperating storage vendors file-system implementors benefits low-level knowledge disk characteristics found schindler recent work track-aligned extents authors explore range performance improvements allocating accessing data disktrack boundaries avoiding rotational latency track-crossing overheads single-disk setting contrast raid exposes disk boundaries raid file systems detailed lower-level information future interesting investigate benefits lower-level knowledge specifics raid-based storage system network appliance pioneered ideas discuss work file server appliances development wafl write-anywhere file layout technique hitz hint information hidden inside raid layer advantage file system ensure writes raidlayer occur full-stripe-sized units avoid small-write penalty manifests raidand raidsystems step formalizing raid layer showing traditional file system easily modified advantage information provided raid demonstrating broader range optimizations attainable framework volume managers long ease management storage multiple devices raid layer simply type volume manager exposes information file 
systems specifically on-line performance failure information raid built presupposition single mounted file system utilize multiple volumes data volume managers assume one-to-one mapping mounted file system volume volume manager similar raid pool driver volume manager sans sub-pool concept file system group related data work gfs file system sub-pools separate journaled meta-data normal user data exposing disk storage system file system extension arguments made engler kaashoek authors argue software abstractions made operating systems fundamentally problematic high-level limit power functionality authors advocate solution exposing hardware features user missing argument minimalism observation hardware abstractions users operating systems change apropos data storage abstraction put raid systems high-level raid breaks revealing information hidden file system distributed file systems zebra xfs manage disk system individually manner similar lfs systems traditional storage management techniques raidstriping advantage potential possibilities raid layer makes future hope extend ideas distributed arena direct comparison recently nasd object interface introduced higher-level data repository sanbased distributed file systems interface advanced functionality storage layer raid designed functionality file system earlier work datamesh proposes sophisticated interfaces network-attached storage informed approach similar large body work parallel file systems parallel file systems expose disk parallelism application file system manage control redundancy parallel file system proposed work computation parity put user control user avoid well-known performance penalty raidand raidunder small writes overview sections present design implementation raid lfs primary goal designing system exploit information made raid allowing lfs implement functionality difficult impossible achieve traditional layering aim increase ease storage management performance multiple heterogeneous disks functionality meet demands diverse set applications primary goal implementing raid facilitate information provided raid simplest non-informed legacy file systems built top raid primary goal implementing lfs minimize impact transforming file system utilize storage interface require re-design vnode layer ruled mandate file systems changed order function system implementation effort integrate lfs highly localized modular fashion fewer lines code changed question addressed decision modify lfs traditional popular ffs-like journaling file system reason chose lfs natural flexibility data placement lfs modern write storage system write-anywhere systems provide extra level indirection writes location storage medium exploit aspect lfs part implementation mind number implementation techniques general applied file systems hope investigate future interested general lfs file system performance issues consult work rosenblum ousterhout subsequent research seltzer software developed context netbsd operating system raid implemented set hooks lower-level blockdriver calls detail section lfs implemented extending netbsd version lfs based original lfs bsd unix detail section chose netbsd version lfs stable solid implementation raid describe raid storage interface consists major components segmented address space exposes parallelism storage system file system functions inform file system dynamic state storage system mirror pairmirror pair linear address space blocks region region figure raid configuration diagram depicts raid configuration disks combined mirrored pair regions half size total address space presented client file system region layout performed mirror hidden file system segmented address space traditional raid array presents storage subsystem file system linear array blocks underneath true complexity raid scheme hidden file systems interact raid systems reading writing blocks keeping desire minimize change preserve backwards compatibility raid linear array blocks read written basic interface expose information storage system file system address space segmented specifically organized series contiguous regions mapped directly single disk set disks region boundaries made file system desires four-disk storage system disk capable storing blocks address space raid presents segmented blocks throughn map disk blocksn map disk exposing information raid enables file system understand performance failure boundaries storage system sections file system advantage place data region intelligently potentially improving performance reliability aspects storage system raid region represent single disk region configured represent mirrored pair disks raidcollection region viewed configurable software-based raid entire raid address space single representation conglomeration raid subsystems scenario information hidden file system cross-region optimizations region exists raid configuration mirrored pairs shown figure allowing region represent single disk primary benefits region configured raid mirrored pair disks file system forced manage redundancy choose desired arrangement backwards compatibility raid configured single striped mirrored raidregion allowing unmodified file systems change dynamic information segmented address space exposes nature underlying disk system file system part full knowledge make intelligent decisions data placement replication raid layer exposes dynamic information state region file system raid distinguishes traditional volume managers pieces information needed file system desire performance information per-region basis raid layer tracks queue lengths current throughput levels makes pieces information file system historical tracking information left file system file system resilience region failures occur failures region tolerate raid presents information file system figure file system mirror pair tolerate single disk failure informed failure occurs file system action directing subsequent writes regions moving important data bad region reliable portions raid address space implementation current implementation raid implemented thin layer file system storage system order implement striped mirrored raidregion simply utilize standard software raid layer provided netbsd prototype raid layer completely generalized date current form require effort file system lfs utilize segmented address space built interposing vnode strategy call remap requests logical block number virtual address space presented raid physical disk number block offset issued underlying disk raid dynamic performance information collected monitoring current performance levels reads writes prototype region boundaries failure information performance levels throughput queue length tracked low-levels file system complete implementation make information ioctl interface raid device note focus primarily utilizing performance information paper lfs describe lfs file system current design major pieces additional functionality compared standard lfs on-line expandability storage system dynamic parallelism account performance heterogeneity flexible user-managed redundancy lazy mirroring writes sum total added features make system manageable administrator easily add disk worry configuration flexible users control replication occurs higher performance lfs delivers full bandwidth system heterogeneous configurations flexible mirroring avoids costs rigid redundancy schemes discussion focus case separates lfs raid traditional raid raid layer exposes disk storage system separate region lfs on-line expansion contraction design ability upgrade storage system incrementally crucial performance capacity demands site increase administrator add disks ideally addition simple perform single command issued administrator automatic addition disk detected hardware require down-time keeping availability storage high immediately make extra performance capacity disk older systems on-line expansion storage system add disk on-thefly case administrator unmount partition expand 
tool similar re-mount file system worse systems require file system built forcing administrator restore data tape modern volume managers on-line expansion file system support lfs design includes ability incorporate disks raid regions on-line single command file system complicated support necessitated layers system hardware supports hot-plug detection disks power-cycle lfs add disks time reduction data availability amount work administrator put expand system small contraction important removal region simple addition incorporate ability remove region fly file system configured non-redundant manner data lost difference lfs traditional system scenario lfs files deliver applications implementation on-line expansion contraction storage file system views regions added extant fully utilized region added system blocks disk made allocation file system immediately begin write data conversely region removed viewed fully allocated technique general applied file systems similar ideas specifically log-structured file system composed collection lfs segments natural expand capacity lfs adding free segments implement functionality newfs ilfs program creates expanded lfs segment table file system entries segment table record current state segment raid region added file system pertinent information added superblock additional portion segment table activated approach limits number regions added fixed number flexible growth segment table file expanded dynamic parallelism design problem introduced flexibility administrator growing system increased potential performance heterogeneity disk subsystem disk raid segment performance characteristics disks system case traditional striping raid schemes work assume disks run identical rates traditionally presence multiple disks hidden storage layer file system current systems handle disk performance heterogeneity storage layer file system information research community proposed schemes deal static disk heterogeneity solutions require careful tuning administrator van jacobsen notes experience shows configured misconfigured complicating issue delivered performance device change time result workload imbalances fail-stutter nature modern devices present correct operation degraded performance clients advanced heterogeneous data layout schemes utilized work dynamic shifts performance handle static dynamic performance differences disks include dynamic segment placement mechanism lfs segment logically written free space file system exploit writing segments raid regions proportion current rate performance exploiting dynamic state presented file system raid dynamically balance write load system account static dynamic heterogeneity disk subsystem note performance disks roughly equivalent dynamic scheme degenerate standard raidstriping segments disks style dynamic placement performed traditional storage system autoraid basic mechanisms place unduly adds complexity system file system storage system track blocks pushing dynamic segment placement file system complexity reduced file system tracks blocks file located implementation original version lfs allocates segments sequentially based availability words free segments treated equally manage parallelism disks lfs develop segment indirection technique specifically modify ilfs newseg routine invoke data placement strategy ilfs newseg routine find free segment write alter region aware informed segment-placement decision choosing disks accordance performance levels information provided raid load set regions balanced major advantage decision implement functionality ilfs newseg routine localizes knowledge multiple disks small portion file system vast majority code file system aware region boundaries disk address space remains unchanged slight drawback decision region place segment made early segment written performance level disk segment fills significant placement decision potentially poor practice found performance problem flexible redundancy design typically redundancy implemented one-size-fits-all manner single raid scheme autoraid applied blocks storage system file system typically involved aware details data replication storage layer traditional approach limiting semantic information file system smart users applications exploited improve performance utilize capacity lfs explore management redundancy strictly file system managing redundancy file system greater flexibility control users current design users applications select file made redundant mirrored file mirrored users pay cost terms performance capacity file mirrored performance increases writes file capacity saved chances losing file increased turning redundancy well-suited temporary files files easily regenerated swap files lfs performs replication accounting system files users physical blocks contrast traditional file system mounted top advanced storage system autoraid users charged based logical capacity true usage storage depends access patterns usage frequency redundancy schemes implemented raid storage system notion file exists scheme easily implemented traditionally-layered system storage system wholly unaware blocks constitute file receive input user blocks replicate file system block block inode inode file file figure crossed pointer problem figure illustrates problem separate file means redundancy specifically element file inode data block replicated single lost disk make difficult find data block due extra requirement block pointer chain block live file inode number mirror inode consist single data block block disk crashes find data block copy exists remaining working disk storage system altered functionality realized future interesting investigate range policies top redundancy mechanisms automatically apply redundancy strategies class file akin elephant file system segregates files versioning techniques implementation accomplish goal per-file redundancy decided utilize separate unique meta-data original redundant files approach natural file system require on-disk data structures implementation straight-forward scheme assigns inode numbers original files odd inode numbers redundant copies method advantages original redundant files unique inodes data blocks distributed arbitrarily disks constraints allowing redundancy combination file system features number lfs inodes unlimited written log inode map stored regular file expanded prime disadvantage approach limits redundancy copy easily extended n-way mirroring scheme reserving i-numbers file problem introduced decision utilize separate inodes track primary mirrored copy file refer crossed pointer problem figure illustrates difficulty arise simply requiring component file inode indirect blocks data blocks replicated sufficient guarantee data recovered easily single disk failure ensure data block reachable disk failure block reachable implies pointer chain exists figure file inode number replicated inode number inode located disk data block mirror copy file inode disk data block primary copy file disk fails data block easily recovered inode surviving disk points data block failed disk file systems fatal flaw data block unrecoverable lfs performance issue extra information found segment summary blocks full recovery disk crash mandate full scan disk recover data blocks number remedies problem perform explicit replication inode pointer-carrying structures indirect blocks doubly-indirect blocks require on-disk format change inefficient usage disk space inode indirect block logical copies file system simpler approach divide conquer disks system divided sets writing redundant file disk lfs decides set primary copy redundant copy set pointers cross set guarantee single failure harm fact tolerate number failures disks set finally incorporating redundancy lfs presents difficult implementation challenge replicate data inodes file 
system re-writing routine creates modifies data disk develop apply recursive vnode invocation ease task embellish lfs vnode operations short recursive tail routine invoked recursively arguments routine operating i-number primary copy data file designated redundancy user instance file created ilfs create recursive call ilfs create create redundant file recursion broken call perform identical operation redundant file lazy mirroring design user-controlled replication users control replication occurs shown previous work potential benefits arise allowing flexible control redundant copies made parity updated delaying parity updates shown beneficial raidschemes avoid small-write problem reduce load mirrored schemes implementing feature file system level user decide window vulnerability file losing data files tolerable note enhancements difficult implement traditional system information required resides file system raid necessitating non-trivial lfs incorporate lazy mirroring usercontrolled replication scheme users designate file non-replicated immediately replicated lazily replicated choosing lazy replica user increase chance data loss improved performance lazy mirroring improve performance reasons delaying file replication file system reduce load burst traffic defer work replication period lower system load file written disk deleted replication occurs cost replication removed systems buffer files memory short period time seconds file lifetimes recently shown longer average scenario common previously thought implementation lazy mirroring implemented lfs embellishment file-system cleaner files designated lazy replicas extra bit set segment usage table indicating status cleaner scans segment finds blocks replicated simply performs replication directly making place replicated blocks avoid crossed pointer problem associates mirrored inode replication complete bit cleared file system replicates files -minute delay future set directly user application evaluation section present evaluation raid lfs experiments performed intelbased physical memory main processor -ghz intel pentium iii xeon system houses rpm seagate seq write seq read rand write rand read throughput access pattern baseline performance slow disksfast disks figure baseline performance comparison figure plots performance lfs raid sequential writes sequential reads random writes random reads tests run disks varying disks slow disks fast cases requests generated tests size total data-set size cheetah disks refer fast disks rpm seagate barracuda disks slow disks fast disks deliver data roughly slow disks approximately apiece experiments perform trials show average standard deviation experiments compare performance lfs raid standard raidstriping stripe sizes chosen maximize performance raidgiven workload hand making comparison fair slightly unfair lfs raid baseline performance experiment demonstrate baseline performance lfs raid top homogeneous storage configurations slow disks fast disks experiment consists sequential write sequential read random write random read phases based patterns generated bonnie iozone benchmarks perform experiment demonstrate unexpected overhead implementation scales higher-performance disks effectively figure sequential write sequential read random writes perform excellently achieving high bandwidth disk configurations surprisingly log-based file system random reads perform poorly achieving roughly slow disks fast disks line expect disks typical raid configuration throughput amount written performance expansion disk added disk added disk added figure storage expansion graph plots performance lfs storage expansion experiment begins lfs writing single disk time written disk brought on-line lfs immediately begins writing increased performance disk expansion accomplished simple command adds disk region file system time on-line expansion demonstrate performance system writes disks added system on-line experiment disks present expansion stresses software infrastructure hardware capabilities figure plots performance sequential writes time disks added system x-axis amount data written disk shown y-axis plots rate recent committed disk graph lfs immediately starts disks write traffic added system read traffic continue directed original disks older data lfs cleaner redistribute existing data newly-added disks explicitly cleaning explored possibility dynamic parallelism explore ability lfs place segments dynamically regions based current performance characteristics system order demonstrate ability lfs react static dynamic performance differences devices reasons performance variation drives disks added faster older unexpected dynamic performance variations due bad-block remapping hot spots workload uncommon lead performance random writes perform similarly due nature lfs throughput heterogeneity configuration fast disks slow disks performance static heterogeneity lfs exraid ffs ccd figure static storage heterogeneity figure plots performance lfs versus ffs ccd standard raidstriping series disk configurations x-axis number fast slow disks varied implies fast disks slow adjusting segments written dynamically lfs raid deliver full bandwidth disks contrast standard striping performs rate slowest disk system test written disk heterogeneity disks ability expand disk system on-line shown induces workload imbalance read traffic directed newly-added disks cleaner reorganized data disks system experiment static dynamic performance variations subsection figure shows results static heterogeneity test sequential write performance lfs dynamic segment placement scheme plotted ffs top netbsd concatenated disk driver ccd configured stripe data raidfashion experiments data written disks x-axis increase number slow disks system extreme left disks fast slow middle heterogeneous configurations figure writing segments dynamically proportion delivered disk performance lfs raid deliver full bandwidth underlying storage system applications performance degrades gracefully slow disks replace fast storage system raidstriping performs rate slowest disk performs poorly heterogeneous configuration perform misconfiguration test experiment configure storage system utilize partitions disk emulating misconfiguration administrator similar spirit tests performed brown patterson disk system appears separate disks case lfs raid throughput amount written performance dynamic heterogeneity lfs exraid ffs ccd figure dynamic storage heterogeneity figure plots performance lfs raid ffs ccd dynamic performance variation experiment performance single disk temporarily degraded faulty disk delays requests fixed time reducing throughput disk adaptively writing data disks lfs raid dynamic segment placement adjust imbalance deliver higher throughput writes data disk standard striping delivers dynamic segment striping lfs successfully balance load disks case properly assigning load partition accidentally over-burdened disk final heterogeneity experiment introduce artificial performance fault storage system consisting fast disks order confirm load balancing works face dynamic performance variations figure shows performance write lfs raid dynamic segment placement ffs ccd raidstriping case single disk exhibits performance degradation data written kernel-based utility temporarily delay completed requests disks delay effect reducing throughput impaired disk returned normal operation additional data written figure lfs raid job tolerating fluctuations induced phase experiment improving performance factor compared ffs ccd flexible redundancy redundancy experiment verify operation system face failure figure plots performance set processes performing random reads redundant files lfs initially bandwidth disks utilized balancing read load mirrored copies data throughput amount read performance failure disk failed disk failed figure storage failure figure 
plots random read performance set mirrored files disks lfs labeled points graph disk offline performance decreases lfs longer balance read load replicas note lfs raid survive single disk failure failure lfs raid tolerate loss disk set experiment progresses disk failure simulated disabling reads disks lfs continues providing data replicas performance reduced demonstrate flexibility per-file redundancy redundancy managed file system total files written concurrently system consisting fast disks percentage files mirrored increased x-axis results shown figure expected net throughput system decreases linearly files mirrored mirrored throughput roughly halved per-file redundancy users pay users file redundant performance cost replication paid write performance write reflects full bandwidth underlying disks lazy mirroring final experiment demonstrate performance characteristics lazy mirroring figure plots write performance set lazily mirrored files delay seconds cleaner begins replicating data normal file system traffic suffers small decline performance default replication delay system minutes length abbreviated delay reduce time experiments figure potential benefits lazy mirroring potential costs lazily mirrored files deleted replication bethroughput percent files written redundantly cost redundancy figure per-file redundancy figure plots performance writes separate files percent files mirrored increases files mirrored net bandwidth system drops roughly half peak rate expected peak bandwidth achieved lower previous experiments due increased number files subsequent meta-data operations experiment written disk gins full throughput storage layer realized lazily mirrored files deleted replication system incurs extra penalty files read back disk replicated affect subsequent file system traffic lazy mirroring carefully systems highly bursty traffic idle time lazy replicas created files easily distinguishable short-lived discussion implementing lfs raid concerned pushing functionality file system code unmanageably complex primary goals minimize code complexity achieve goal integrating major pieces functionality additional lines code increase original size lfs implementation additional code roughly half due redundancy management design standpoint find managing redundancy file system benefits difficulties solve crossed-pointer problem applied divide-andconquer technique placing primary copy file sets mirror enable fast operation failure solution limits data placement flexibility file assigned set subsequent writes file written set limitation affects performance heterogeneous configuthroughput time performance lazy redundancy lfs exraid cleaner figure lazy mirroring figure plots write performance set lazy redundant files lfs replication delay seconds peak performance achieved initial portion test performance reduced slightly cleaner begins replicating data write test completes cleaner continues replicate data background rations set significantly performance characteristics relax placement restrictions choosing disks constitute set per-file basis problem fundamental approach file-system management redundancy implementation standpoint file-system managed redundancy problematic vnode layer designed single underlying disk mind recursive invocation technique successful stretched limits current framework additions modifications code straightforward implement support file-system managed redundancy redesign vnode layer beneficial future work number avenues exist future research generally organizations storage protocol stack explored pieces functionality implemented trade-offs natural followon incorporate lower-level information raid main challenge exposing information file system find pieces information file system readily exploit file service today spans client server machines important functionality split machines portion traditional storage protocol stack reside clients portion reside servers researchers distributed file systems opposing points view systems zebra xfs letting clients work frangipani petal system places functionality storage servers cooperative approaches file system storage system found implementing redundancy file system vexing approach shared responsibility redundancy file system storage layer improvement storage layer file system block mirror block file system decide perform replication decide storage interface difficult convince storage vendors move tried-and-true standard scsi interface storage pragmatic approach treat raid layer gray box inferring characteristics exploiting file system modification underlying raid layer tools automatically extract low-level information disk drives dixtrac skippy steps goal extensions needed understand parallel aspects storage systems finally envision optimizations arrangement storage protocol stack exploring notion intelligent reconstruction basic idea simple disk region fails lfs duplicated data disk lfs begin reconstruction process key difference lfs reconstruct live data disk entire disk blindly storage system substantially lowering time perform operation fringe benefit intelligent reconstruction lfs give preference files reconstructing higher-priorityfiles increasing availability files failure imagine optimizations lfs cleaner data laid disk current performance characteristics access patterns meet subsequent potentially non-sequential reads applications similarly disks added cleaner run order lay older data disks cleaner reorganize data drives read performance presence heterogeneity drives similar work neefe generalized operate heterogeneous multi-disk setting conclusions terms abstractions block-level storage systems scsi successful disks hide low-level details file systems exact mechanics arm movement head positioning export simple performance model file systems optimize lampson interface combine simplicity flexibility high performance solving problem leaving rest client early single-disk systems balance struck perfectly storage systems evolved single drive raid multiple disks interface remained simple raid result system full misinformation file system longer accurate model disk behavior now-complex storage system good understanding expect file system raid lfs bridge information gap design presence multiple regions exposed directly file system enabling functionality paper explored implementation on-line expansion dynamic parallelism flexible redundancy lazy mirroring lfs implemented straight-forward manner file system increasing system manageability performance functionality maintaining reasonable level system complexity aspects lfs difficult impossible build traditional storage protocol stack highlighting importance implementing functionality correct layer system chosen single point design space storage protocol stacks arrangements preferable hope explored conclusion research division labor file storage systems proper division arrived design implementation experimentation historical artifact acknowledgements shepherd elizabeth shriver john bent nathan burnett brian forney florentina popovici muthian sivathanu anonymous reviewers excellent feedback work sponsored nsf ccrccr- ngsccr- itrand wisconsin alumni research foundation timothy denehy sponsored ndseg fellowship department defense anderson dahlin neefe patterson wang serverless network file systems proceedings acm symposium operating systems principles sosp pages copper mountain resort december arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october arpaci-dusseau arpaci-dusseau culler hellerstein patterson high-performance sorting networks workstations proceedings acm sigmod conference management data sigmod pages tucson arpaci-dusseau anderson treuhaft culler hellerstein patterson yelick cluster river making fast case common workshop input output parallel distributed systems iopads atlanta arpaci-dusseau arpaci-dusseau fail-stutter fault tolerance eighth workshop hot topics operating systems hotos viii pages schloss elmau germany bray bonnie file system benchmark http textuality bonnie brown patterson maintainability availability growth benchmarks case study software raid systems proceedings usenix annual technical conference pages san 
diego june comer internetworking tcp vol principles protocols architecture prentice hall london edition cormen kotz integrating theory practice parallel file systems proceedings dags symposium dartmouth institute advanced graduate studies pages hanover june cortes labarta extending heterogeneity raid level proceedings usenix annual technical conference boston june jonge kaashoek hsieh logical disk approach improving file systems proceedings acm symposium operating systems principles sosp pages asheville december engler kaashoek exterminate operating system abstractions workshop hot topics operating systems hotos orcas island english stepanov loge self-organizing disk controller proceedings usenix winter technical conference pages san francisco january gibson nagle amiri chang feinberg gobioff lee ozceri riedel rochberg zelenka file server scaling network-attached secure disks proceedings acm sigmetrics international conference measurement modeling computer systems pages seattle june hartman ousterhout zebra striped network file system proceedings acm symposium operating systems principles sosp pages asheville december hitz lau malcolm file system design nfs file server appliance proceedings usenix winter technical conference berkeley january huber elford reed chien blumenthal ppfs high performance portable parallel file system proceedings acm international conference supercomputing pages barcelona spain july jacobson kill internet ftp ftp lbl gov talks vj-webflame kilburn edwards lanigan summer one-level storage system ire transactions electronic computers ecapril lampson hints computer system design proceedings acm symposium operating system principles pages bretton woods december acm lee thekkath petal distributed virtual disks proceedings seventh conference architectural support programming languages operating systems asplos vii pages cambridge october matthews roselli costello wang anderson improving performance log-structured file systems adaptive methods proceedings acm symposium operating systems principles sosp pages saint-malo france october mckusick joy leffler fabry fast file system unix acm transactionson computer systems august nieuwejaar kotz galley parallel file system proceedings acm international conference supercomputing pages philadelphia acm press norcutt iozone filesystem benchmark http iozone patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod conference management data sigmod pages chicago june ritchie thompson unix time-sharing system comm assoc comp mach july roselli lorch anderson comparison file system workloads proceedings usenix annual technical conference pages san diego june roselli matthews anderson file system fingerprinting works-in-progress symposium operating systems design implementation osdi february rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february rosenthal evolving vnode interface proceedings usenix summer technical conference pages anaheim santos muntz performance analysis rio multimedia storage system heterogeneous disk configurations acm multimedia december santry feeley hutchinson veitch carton ofir deciding forget elephant file system proceedings acm symposium operating systems principles sosp pages kiawah island resort december savage wilkes afraid frequently redundant array independent disks proceedings usenix technical conference pages san diego january schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon schindler griffin lumb ganger trackaligned extents matching access patterns disk drive characteristics proceedings usenix conference file storage technologies fast monterey january seltzer bostic mckusick staelin implementation log-structured file system unix proceedings usenix winter technical conference pages san diego january seltzer smith balakrishnan chang mcmains padmanabhan file system logging versus clustering performance comparison proceedings usenix annual technical conference pages orleans january seltzer ganger mckusick smith soules stein journaling versus soft updates asynchronous meta-data protection file systems proceedings usenix annual technical conference pages san diego june stodolsky holland courtright gibson parity-logging disk arrays acm transactions computer systems august sweeney doucette anderson nishimoto peck scalability xfs file system proceedings usenix annual technical conference san diego january talagala arpaci-dusseau patterson microbenchmark-based extraction local global disk characteristics technical report csd- california berkeley teigland pool driver volume driver sans master thesis minnesota december teigland mauelshagen volume managers linux freenix track usenix annual technical conference boston june thekkath mann lee frangipani scalable distributed file system proceedings acm symposium operating systems principles sosp pages saint-malo france october http fsprogs sourceforge net ext html june van renesse masking overhead protocol layering proceedings acm sigcomm conference pages palo alto veritas http veritas june wang anderson patterson virtual logbased file systems programmable disk proceedings symposium operating systems design implementation osdi orleans february wilkes datamesh research project phase proceedings usenix file systems workshop pages wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february zimmermann ghandeharizadeh hera heterogeneous extension raid technical report usc-cs-tr southern california 
currentpoint stroke stroke grestore end showpage trailer documentfonts helvetica enddocument endspecial figur infn community gure details ecution batc jobs running infn community left-hand graph sho number jobs completed time progresses right-hand graph sho number cpus function time beginspecial llx lly urx ury rwi rhi setspecial begindocument graphs wisc eps ps-adobeepsf- title wisc eps creator gnuplot patchlevel creationdate tue jul documentfonts atend boundingbox orientation portrait endcomments gnudict dict gnudict begin color false solid false gnulinewidth userlinewidth gnulinewidth vshift mul hpt vpt hpt hpt vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke userlinewidth setlinewidth ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc copy moveto copy vpt arc closepath fill vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy copy moveto vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc bind setdash copy vpt arc closepath fill vpt arc closepath bind rec newpath roll moveto index rlineto exch rlineto neg rlineto closepath bind square dup rec bind bsquare vpt exch vpt exch vpt square bind setdash copy moveto vpt rlineto bsquare bind setdash copy vpt square fill bsquare bind setdash copy exch vpt exch vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt square fill bsquare bind setdash copy copy vpt square fill exch vpt exch vpt vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy vpt vpt square fill bsquare bind setdash copy vpt vpt vpt rec fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt square fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy exch vpt exch vpt square fill bsquare bind setdash copy bsquare fill bsquare bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke 
grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind diae stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke boxe stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke triue stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tride stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pente stroke setdash gsave translate hpt rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow ltb currentpoint gsave translate rotate jobs completed cshow grestore elapsed time cshow local rshow currentpoint stroke stage rshow currentpoint stroke remote rshow currentpoint stroke stroke grestore end showpage trailer documentfonts helvetica enddocument endspecial beginspecial llx lly urx ury rwi rhi setspecial begindocument graphs wisc conc eps ps-adobeepsf- title wisc conc eps creator gnuplot patchlevel creationdate tue jul documentfonts atend boundingbox orientation portrait endcomments gnudict dict gnudict begin color false solid false gnulinewidth userlinewidth gnulinewidth vshift mul hpt vpt hpt hpt vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke userlinewidth setlinewidth ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc copy moveto copy vpt arc closepath fill vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy copy moveto vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc bind setdash copy vpt arc closepath fill vpt arc closepath bind rec newpath roll moveto index rlineto exch rlineto neg rlineto closepath bind square dup rec bind bsquare vpt exch vpt exch vpt square bind setdash copy moveto vpt rlineto bsquare bind setdash copy vpt square fill bsquare bind setdash copy exch vpt exch vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt square fill bsquare bind setdash copy copy vpt square fill exch vpt exch vpt vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt 
exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy vpt vpt square fill bsquare bind setdash copy vpt vpt vpt rec fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt square fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy exch vpt exch vpt square fill bsquare bind setdash copy bsquare fill bsquare bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind diae stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke boxe stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke triue stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tride stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pente stroke setdash gsave translate hpt rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow ltb currentpoint gsave translate rotate number cpus allocated cshow grestore elapsed time cshow local rshow currentpoint stroke stage rshow currentpoint stroke remote rshow currentpoint stroke stroke grestore end showpage trailer documentfonts helvetica enddocument endspecial figur community gure details ecution batc jobs running community left-hand graph sho number jobs completed time progresses right-hand graph sho number cpus function time eac line represents dif erent discipline note anomalies remote discipline elapsed times seconds artifact number mac hines bandwidth storage appliance shared fairly jobs nish appro ximately time delay incurred jobs start complete anomalies present disciplines ell pronounced due decreased time ecutable input les beginspecial llx lly urx ury rwi rhi setspecial begindocument graphs eps ps-adobeepsf- title eps creator gnuplot patchlevel creationdate tue jul documentfonts atend boundingbox orientation portrait endcomments gnudict dict gnudict begin color false solid false gnulinewidth userlinewidth gnulinewidth vshift mul hpt vpt hpt hpt vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke userlinewidth setlinewidth ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc copy moveto copy vpt arc closepath fill vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt 
arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy copy moveto vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc bind setdash copy vpt arc closepath fill vpt arc closepath bind rec newpath roll moveto index rlineto exch rlineto neg rlineto closepath bind square dup rec bind bsquare vpt exch vpt exch vpt square bind setdash copy moveto vpt rlineto bsquare bind setdash copy vpt square fill bsquare bind setdash copy exch vpt exch vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt square fill bsquare bind setdash copy copy vpt square fill exch vpt exch vpt vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy vpt vpt square fill bsquare bind setdash copy vpt vpt vpt rec fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt square fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy exch vpt exch vpt square fill bsquare bind setdash copy bsquare fill bsquare bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind diae stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke boxe stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke triue stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tride stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pente stroke setdash gsave translate hpt rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow ltb currentpoint gsave translate rotate jobs completed cshow grestore elapsed time cshow infn local local rshow currentpoint stroke infn local stage rshow currentpoint stroke evolving rpc active storage muthian sivathanu andrea arpaci dusseau remzi arpaci dusseau department computer sciences wisconsin madison fmuthian dusseau remzig wisc abstract introduce scriptable rpc srpc rpc-based framework enables distributed system services advantage active components technology trends point world component system disk network interface memory substantial computational capabilities traditional methods building distributed services designed advantage architectures mandating wholesale change software base exploit powerful hardware contrast srpc direct simple migration infn path local traditional remote services rshow active environment demonstrate power exibility srpc framework series case studies focus active storage servers speci cally advantages approach srpc improves performance distributed servers reducing latency combining execution operations server srpc enables ready addition functionality powerful cache consistency models realized top server exports simple nfs-like interface srpc simpli construction distributed services operations dif cult coordinate client server co-executed server avoiding costly agreement crash-recovery protocols introduction remote procedure call rpc long standard implementing distributed services rpc simple extends well-known paradigm procedure call client server setting powerful serve substrate distributed services sun nfs development rpc changed functionality offers modernized versions rpc java rmi significantly alter basic rpc paradigm simply provide features language run-time context rpc stagnating architecture distributed systems changing rapidly technology trends point world active components commonplace intelligence form additional processing capabilities permission make digital hard copies part work personal classroom granted fee provided copies made distributed pro commercial advantage copies bear notice full citation rst page copy republish post servers redistribute lists requires prior speci permission fee asplos san jose california copyright acm found active disks smart network interfaces intelligent currentpoint stroke memories importance active storage potential greatly improve distributed storage services terms performance functionality simplicity design early research active storage demonstrated potential performance bene previous systems require programming environments target limited class applications parallel applications database primitives existing distributed services clear migration path coming active world paper present design implementation evaluation scriptable rpc srpc extensible framework developing active distributed services key difference srpc traditional rpc clients send scripts server implement server-side functionality srpc designed assist developers evolving traditional rpc-based services rst-class active services srpc shares features rpc automates service development process increase ease-of-use srpc automatically embeds script interpreter server providing safe execution environment client-generated scripts demonstrate primary bene srpc number case studies distributed system called scfs scfs improves performance combining operations server avoiding costs extra round-trip latencies scfs ready addition functionality evolving base system protocol enhanced virtual protocol speci cally scripts applied implement afs sprite cache consistency top base protocol simple nfs-like consistency finally scfs simple implement functionality stroke grestore complex end execute showpage reliably trailer documentfonts client helvetica server enddocument scfs endspecial directory update beginspecial operations llx performed lly script urx directly ury rwi server rhi obviate setspecial begindocument graphs multi-client conc coordination eps introducing ps-adobeepsf- scripting title conc server eps number creator issues gnuplot arise patchlevel concern creationdate tue safety client jul kernels documentfonts partially atend trusted boundingbox orientation induce portrait server endcomments crash gnudict dict accidentally gnudict begin malicious color false intent solid monopolize false resources performance gnulinewidth userlinewidth issue gnulinewidth script vshift interpretation overhead mul negate hpt advantages srpc vpt finally hpt ease-of-use hpt important vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke userlinewidth setlinewidth ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt 
closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt criterion language arc enable copy development short moveto copy powerful scripts vpt arc prototype closepath implementation srpc fill tcl vpt base arc scripting language bind similar languages exist setdash feel copy tcl moveto interesting copy choice vpt reasons arc closepath tcl addresses safety fill concerns vpt providing arc limited closepath execution bind environment ne-grained control setdash copy operations moveto script copy execute vpt arc closepath loops disabled fill vpt arc previous studies closepath bind tcl interpreter setdash thousand copy times slower moveto copy vpt recent arc versions closepath tcl interpreter fill vpt sophisticated arc closepath cient bind internal representations boost setdash performance copy time moveto ripe copy reexamining vpt strengths arc closepath weaknesses tcl fill performance vpt tcl arc fairly closepath high-level bind language ease-of-use setdash main copy advantages copy moveto vpt srpc arc effective closepath framework fill copy extending scfs moveto distributed copy service vpt performance arc closepath functionality enhancements fill readily designed vpt arc deployed closepath system framework case studies bind setdash copy moveto scripts copy vpt reduce arc latency closepath factor fill copy strengthen moveto consistency copy semantics vpt arc system closepath fill server vpt functionality arc readily embellished srpc framework closepath bind similar extension setdash methodology copy client-side moveto kernels copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc evaluation closepath tcl bind language extensibility setdash copy moveto powerful copy remaining vpt easy arc closepath complex fill extension requires vpt arc tens bind lines code setdash copy performance vpt tcl arc improved closepath warrant fill consideration vpt language arc closepath extension bind rec numerous safety newpath features roll moveto index rlineto sophisticated exch extensions rlineto afford neg rlineto slightest closepath overheads bind square specialized dup domain-speci rec language bind active bsquare storage vpt worth exch vpt investigating exch rest vpt square paper bind structured present setdash overview copy moveto srpc vpt system rlineto section bsquare describe bind experimental environment setdash including copy details vpt scfs square fill empirical bsquare methodology bind section section section setdash copy section exch vpt illustrate exch manner vpt srpc square fill bsquare improve bind performance functionality simplicity setdash copy active exch services vpt exch section vpt vpt perform in-depth analysis rec extension fill scripts bsquare tcl bind cover related work setdash section copy exch conclude vpt section exch overview vpt srpc vpt srpc square fill framework bsquare building bind active extensible distributed setdash services srpc copy extends copy vpt widely square fill exch understood vpt paradigm exch rpc vpt exible vpt scripting square capability fill clients bsquare bind harness execute customized extensions setdash copy server exch srpc vpt designed exch meet vpt goals vpt vpt important rec fill environment bsquare bind rst goal provide smooth setdash migration copy path exch vpt existing distributed services exch traditional vpt rpc-based vpt server vpt rec active fill copy vpt square fill bsquare bind server setdash goal copy vpt accomplished making vpt square process fill developing bsquare srpc-based bind service similar setdash developing copy vpt service vpt traditional vpt rpc rec paradigm fill automating bsquare bind steps setdash goal copy vpt ensure script vpt execution square overhead fill severe copy exch compared vpt traditional exch rpc vpt call square improve performance fill srpc bsquare caches bind scripts supports concurrency setdash copy cient vpt implementations vpt square performancesensitive commands fill copy srpc exch standard vpt library exch vpt goal vpt provide rec safe fill environment bsquare script bind execution choice tcl setdash scripting copy language exch enables vpt meet exch vpt goal vpt migration vpt path rec fill rst goal bsquare bind srpc enable developers setdash easily copy move exch vpt distributed services exch vpt traditional vpt rpc-based vpt servers rec fill powerful copy active vpt servers square fill srpc bsquare engineered bind backwardly compatible setdash rpc copy allowing exch unmodi vpt clients exch vpt send scripts vpt vpt server rec co-exist fill clients copy exch vpt altered exch vpt square functionality fill srpc bsquare automatically bind generates code interface setdash copy rpc bsquare server fill bsquare scripting bind language interpreter gsave traditional rpc translate developer rotate distributed stroke service grestore nes bind interface gsave server exports translate speci rotate interface stroke grestore interface bind nition language idl gsave interface translate nition rotate parsed stroke idl grestore compiler bind generate source code gsave translate client rotate server stubs stroke call grestore bind rpc library gsave developer translate implement rotate procedures stroke speci grestore bind interface gsave translate compiled rotate stroke automatically grestore generated bind stubs produce gsave distributed translate service developing active distributed rotate service srpc stroke involves grestore bind similar set gsave steps translate basic interface rotate exported stroke server grestore bind speci gsave idl functionality idl compiler augmented ways rpc procedure added interface called scriptexec takes parameters script data buffer returns data buffer result implementation scriptexec generated automatically idl compiler automatically generates tcl wrappers interface procedures client translate scripts rotate directly call stroke routines grestore bind simplify srpc programming gsave interpreter translate rotate server stroke commands grestore extract bind speci parameters gsave character translate buffer rotate pass stroke arguments grestore compiler bind generates code gsave initialize set translate tcl rotate interpreters stroke registers grestore interface bind procedures gsave interpreter increasing translate ease-ofuse rotate reducing stroke burden grestore programmers bind assist gsave programmers translate development rotate scripts stroke grestore additional bind pieces functionality gsave supported translate rotate srpc infrastructure stroke grestore bind scripts gsave maintain state translate rotate accessed stroke grestore scripts bind clients diae stroke script setdash store vpt state add hpt neg vpt script neg access hpt vpt state neg hpt state vpt hpt variables neg vpt uniquely named closepath stroke scripts boxe inadvertently stroke con setdash ict exch hpt exch current vpt srpc add implementation vpt neg responsibility hpt namespace management vpt rests hpt clients neg follow closepath pre-de stroke ned conventions triue clients easily access state variables stroke setdash piece vpt functionality mul add ability hpt neg server vpt invoke mul functionality hpt client mul perform hpt neg callback srpc vpt mul supports closepath allowing stroke client run tride rpc server stroke setdash high vpt performance mul order srpc hpt neg appealing vpt platform mul distributed hpt systems mul performance hpt neg comparable vpt mul traditional rpc closepath service stroke script pente interpretation imposes stroke overhead setdash time gsave script translate executed hpt potentially negating rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow ltb currentpoint gsave translate rotate number cpus allocated cshow grestore elapsed time cshow infn local local rshow bene executing storage-aware caching revisiting caching heterogeneous storage systems brian forney andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison bforney dusseau remzi wisc abstract modern storage environments composed variety devices performance characteristics paper explore storage-aware caching algorithms file buffer replacement algorithm explicitly accounts differences performance devices introduce family storageaware caching algorithms partition cache partition device algorithms set partition sizes dynamically balance work devices simulation show storageaware policies perform similarly landlord costaware algorithm previously shown perform web caching environments demonstrate partitions easily incorporated clock replacement algorithm increasing likelihood deploying cost-aware algorithms modern operating systems introduction modern computer systems interact broad diverse set storage devices including local disks remote file servers nfs afs archival storage tapes read-only media compact discs dvds storage sites accessible internet storage components introduced behaviors properties divergent today set devices disparate commonality pervades time access high compared cpu cache memory latencies due cost fetching blocks storage media caching blocks main memory reduces execution time individual applications increases system performance orders magnitude storage technology dramatically changed past decades important aspects caching architectures modern operating systems remained unchanged innovations mechanism including integration file cache virtual memory page cache copyon-write techniques software emulation bits change policy operating systems employing lru lru-like algorithms decide block replace problem lru related caching algorithms cost-oblivious blocks treated fetched identically performing devices re-fetched replacement cost blocks assumption increasingly problematic manifold device types correspondingly rich set performance characteristics simple block fetched local disk compared fetched remote highly contended file server case operating system prefer block file server heterogeneous environments file systems require caching algorithms aware replacement costs file blocks slowest device roughly determines throughput system storage-aware caching seeks balance work devices adjusting stream block requests heterogeneous environment storage-aware cache considers workload behavior device characteristics filter requests paper explore integration costaware algorithms operating system page cache simulation simulation accounts real-world factors integrated page cache simplicity design build previous work cost-aware caching web-cache theory communities demonstrating separate set partitioned algorithms effective simpler proposals research areas study set context network-attached disk system network-attached disks increasingly important storage paradigm present clients static dynamic forms performance heterogeneity algorithms develop general applied broader range storage devices main results show storageaware caching significantly performance robust cost-oblivious caching robust leading web-caching algorithm operating systems specific implementation develop evaluate version storage-aware caching extends commonly implemented clock algorithm rest paper organized section give overview algorithms investigate paper describe algorithm selecting partition sizes section section describes assumptions environment detail explains simulation framework simulation results section compare contrast work existing work section section future work finally conclude section algorithm overview section overview algorithmic space explore describe existing cost-aware algorithms basis comparison present caching algorithms based partitioning cache replacement cost existing cost-aware algorithms theoretical community studied cost-aware algorithms k-server problems restricted class k-server problems weighted caching closely related cost-aware caching landlord significant algorithm literature comparison landlord closely related leading web caching algorithm landlord combines replacement cost cache object size locality extending lru fifo include cost variable cache object sizes cache configured landlord lru describe lru version landlord associates cost object called object enters cache landlord sets retrieval cost object divided size object object eviction needed landlord finds object lowest removes ages remaining objects landlord ages pages decrementing remaining objects evicted object object cache landlord restores landlord degenerates strict lru values landlord attractive theoretical experimental properties shown theoretical analysis size cache objects landlord k-competitive size cache fixed object size cache landlord performs factor optimal off-line algorithm request sequences overview aggregate partitioned algorithms cost-aware algorithms literature place-anywhere place-anywhere algorithm characteristics blocks occupy logical location cache independent original source cost costs recorded page granularity advantage place-anywhere algorithms calculate single trade-off locality cost replacement time algorithms bias eviction pages low retrieval cost contrast place-anywhere algorithm aggregate partitioned algorithm divides cache logical partitions blocks logical partition device share replacement cost algorithm aggregates replacement cost function device performance aggregate partitioned algorithm benefits aggregation blocks cost metadata ways amount metadata reduced metadata closely reflects current replacement cost block device space overhead proportional number devices blocks replaced replacement cost low conversely place-anywhere algorithms record cost page brought cache cache large number pages common today place-anywhere algorithm susceptible inconsistent cost values aggregate partitioned algorithms avoid problem aggregating cost metadata per-device basis performance device cost metadata rarely inconsistent period time placeanywhere algorithm recognize change cost device propagate cost pages cache cost update requires significant number pages updated increasing overhead implementation complexity aggregate partitioned algorithms strive set relative size partition balance work devices define work balanced cumulative delay device period time equal balance work size partition reflects relative cost blocks simple efficient manner storage system slow disk fast disk cache divided partitions slow disk receiving larger partition describe precisely relative sizes configured section choose victim block storage-aware algorithm selects victim partition victim block partition victim partition chosen resulting size relative partitions maintains desired proportions individual victim partition selected replacement algorithm lru lfu fifo distinctions prior work virtual memory systems noted unified partitioned virtual memory systems traditional sense partitioned virtual memory systems distinguish file system pages virtual memory pages managed separately storage-aware algorithms explicitly distinguish file system pages virtual memory pages order balance work algorithms distinguish pages based device supplied page additionally storage-aware caching algorithms change size partitions dynamically partitioned virtual memory systems change size file system cache virtual memory partitions local global page replacement local page replacement eviction time considers processes isolation global page replacement applies replacement processes storage-aware algorithms make per-partition replacement decisions similar traditional notion local page replacement decisions based cost locality solely locality local page replacement schemes taxonomy aggregate partitioned algorithms work investigate taxonomy aggregate partitioned algorithms show dynamic aggregate partitioning needed taxonomy subsection basic approaches aggregate partitioning static dynamic static scheme ratio partitions selected one-time notion costs knowledge workload resulting miss rates cache size priori determine relative sizes lead balanced work dynamic partitioning needed ratio partition sizes adjusts requests monitored dynamic partitioning benefits dynamic partitioning adjust dynamic performance variations faults common modern devices dynamic partitioning react contention devices due hotspots workloads finally dynamic partitioning compensate fact performance ratios devices change function access patterns dynamic partitioning divided eager partitioning 
lazy partitioning eager partitioning partition sizes desired algorithm immediately reallocates pages cost information algorithm lazy partitioning scheme gradually reallocates pages demand desired size response workload eager partitioning simplifies choosing victim partition location page cost removing pages conversely lazy partitioning scheme removes pages partitions needed partition lazy partitioning block replace block long blocks replaced proper frequency maintain desired partition size ratios replacement explicitly choose victim partition investigate strategy based inverse lottery previously proposed resource allocation idea partition number tickets inverse proportion desired size replacement needed lottery held selecting random ticket partition holding ticket picked victim victim valuable page lazy partitioning algorithm allocates page logical partition selecting partition sizes main challenge partitioned approaches determining relative sizes partitions configured storage-aware caching viewed performing selective filtering requests devices assuming slowest device limits system throughput goal storage-aware caching set partition sizes equal amount work device formally device number cache misses multiplied average cost miss equal algorithmic details basic approach dynamic repartitioning algorithm algorithm storage-aware cache observes amount work performed device fixed interval past predicts relative sizes partitions adjusted work equal algorithm work metric cumulative delay period time delay related total number requests includes request service time variation device devices algorithm streaming accesses fit cache problematic algorithm detect type access algorithm measures time spent waiting device past device requests window size records wait time device wait times approximately equal current partition ratios deemed adequate remain wait times size partitions large wait times increased size partitions small wait times decreased ratio wait times devices considered simultaneously selecting amount increment decrement partition non-trivial search problem change partition size affects future miss rate presence dynamically changing workloads initial approach employ simplest algorithm found meet challenge find algorithm adjusts partition sizes quickly find proportions quickly algorithm overshoots correct proportions meet goals simultaneously approach aggressively increases size partition wait time device increasing reacts conservative manner algorithm makes observations wait time device epoch action based observation epoch begins device requests complete epochs cache repartitioned repartitioning occurs steps algorithm computes per-device wait time wait time devices epoch algorithm computes relative wait time partition dividing per-device wait time wait time algorithm determines partitions page consumers pages give consumer page consumers partitions relative wait time threshold threshold filter normal variations wait time due workload device characteristics page consumers found repartitioning stops epoch begins finally algorithm finds partitions below-average wait times called page suppliers reallocates pages consumers consumers reach desired size repartitioning cache algorithm classifies figure corrective actions repartitioning algorithm figure shows actions algorithm response states graph shows observation per-device wait time trend relative wait time time progresses dotted line shows wait time graph graphs actions state shown fixed clarity threshold constant multiplied wait time partition states corrective action change partition size states shown figure cool wait time threshold wait time normal operating regime corrective action needed cool partitions page suppliers page consumers warming wait time threshold increasing algorithm infers increasing wait time due workload device characteristics initially cache size increased pages base correction amount partition continues warm subsequent epochs increase cache size grows exponentially reclassification partition warming state restarts exponential correction cooling wait time threshold decreasing corrective action set epochs halted increase wait time partition started decline wait time algorithm acts conservatively cooling state change partition size aggressive approach continues increase cache size state over-correct unstable warm wait time threshold constant based experimental evidence partitions classified cool warming cooling constant wait time occur partition moves state small change partition size algorithm increases partition size step algorithm reallocates pages page suppliers page consumers algorithm biases collection pages partitions lowest relative wait times determine number pages removed page supplier algorithm computes inverse relative wait time irwt relative wait time partition sums inverse relative wait times finally number pages partition supply computed irwtj sum irwtsforsuppliers consumed pages note parameters algorithm window size threshold base increment amount set care large smooth wait time variations sample sufficient number requests determine accurately effect corrections found sufficient smoothing feedback small exponential correction found cache works practice threshold large filter normal device performance fluctuation seek time found detects wait time warrant correction fixed algorithm compute threshold dynamically statistical variance wait times sum variance threshold discuss adaptive approach plan investigate future modifying existing replacement algorithms desire cost-aware cache performs easily implemented modern operating systems attention paid make computationally efficient landlord priority queue efficiently find lowest cost object mesh common virtual memory hardware easy combine landlord existing code base modern operating systems including solaris variant clock page replacement policy unified page cache desire algorithm incorporated easily clock structure introduce extension clock takes partitions account partitioned-clock base algorithm partitioned-clock assumes page bit set page referenced victim page needed clock arm successive pages bit set clearing bits sweeps partitioned-clock page tracks partition number belongs page selected victim bit cleared partition number match partition number chosen replacement chosen lottery note additional bits single bit consistent variations clock examine dirty bits history multiple bits optimizations improve performance partitioned-clock approximation lazy partitions searching replacement pages belonging victim partition bits cleared clearing bits pages unnecessarily removes usage history separate clock hand partition improves performance helps maintain usage history partition previously lazy partitions simpler implement eager partitions ratio sizes dynamic focus clock algorithm applied lazy partitions version termed lazy clock inverse lottery scheduling pick victims partitions evaluation environment section describes methodology operations server srpc simple techniques improve performance caching concurrency standard library primitives performance initial versions tcl shown 
signi overhead overhead occurred line script re-interpreted execution cient repeated execution code recent versions tcl translate interpreted code cient internal form leverage behavior srpc identi scripts executed previously reuses cached procedures subsequent invocations arguments sending script invocation clients register scripts server back script passed server script arguments subsequent invocations caching mechanism advantage reducing size messages client server improving observed network latency reducing amount network traf case studies section quantify performance bene srpc script caching improve performance srpc framework executes multiple tcl interpreters concurrently multiple interpreters scripts execute parallel server greatly improving system throughput concurrent execution complicates development scripts discuss describing safety issues performance optimization srpc implement performance-sensitive operations inside srpc standard library directly script tcl supports calling functions written language providing functionality straightforward issue identify operations included standard library general operations popular scripts costly implement tcl current implementation srpc includes standard library routines manipulate data buffers search buffers string send messages create manage lists access shared script state acquire release locks importance routines enable scripts avoid touching data inside tcl ensuring data buffers solely manipulated substructure avoid primary source additional overhead implementing server routines directly tcl bypasses security issues scripting language anticipate trusted administrators add primitive routines safety goal srpc design ensure scripts server easily corrupt server state consume undue resources problem arises extensible operating systems research srpc arbitrary user applications insert code server kernel clients trust boundary relaxed boundary advantageous enforce limited execution context scripts fortunately tcl needed functionality required limit script actions safetcl extensions server control functions script call control constructs implemented tcl procedures prevent execution whileand loops ensure scripts terminate nite amount time scripts require iteration provide simple safe callback interface procedure executed nite number times complication safety model scripts manipulate buffer pointers directly ensure invalid memory generated srpc implements run-time checks inside wrapper standard-library routines pointers passed arguments run-time type checking automatically generated wrappers ensures argument addresses correspond correct type preventing illegal dereferencing arbitrary memory addresses additional level safety cost worthwhile complication arises due concurrency concurrent execution mandates locks scripts access shared state execute correctly locking introduces problems realm safe extensibility client misbehave release lock negatively impacting well-behaved clients prevent problem occurring srpc automatically releases locks acquired released executing script script completion safeguard restricts scope locks found burdensome limitation access control locks prohibiting misbehaving clients acquiring locks privy implemented functionality proc spritecb arg res state lock global variable global load cacheable flag set cache srpc load state state cache add client callback list set list srpc load state list set list srpc makelist srpc install state list srpc add list list args invoke read set rdarg scfs make rdarg arg rdoff set rdres scfs read rdarg extract components result set cnt scfs rdres getlen rdres set data scfs rdres getdata rdres pack state results result srpc putint res cacheoff cache srpc putint res cntoff cnt srpc memcpy res dataoff data cnt return expr cnt cachesz cntsize figure srpc script script performs read presence write-sharing scripts enforce spritely cache consistency augmenting stateless protocol stateful functionality involves handful tcl commands figure present srpc script script part sprite consistency implementation executed client reads marked uncacheable explored detail case study section rpc interface server exports read procedure idl compiler automatically generates tcl wrapper scfs read commands extract individual elds scfs rdres getdata make arguments type character buffer scfs make rdarg automatically generated type checking performed ensure script access invalid memory addresses examples standard library routines include srpc loadstate srpc putint script begins loading cacheable object interest set address client added object callback list script creates valid read argument data passed script accessed arg variable invokes read argument results read cacheable form result script packed result variable res returned caller evaluation environment evaluate srpc framework context distributed system scfs section begin presenting general overview scfs describe details experimental platform finally describe mechanism systematically increase network delay order understand performance srpc environments scripted file system scfs distributed systems built network-attached disks potential delivering high bandwidth additional cost servers evaluate bene srpc introduce scfs scripted distributed system networkattached storage base version scfs supports multiple clients single disk acts repository system data scfs exports hierarchical namespace applications performs basic caching multiple outstanding requests tolerate latency implements nfs-like weak cache consistency scheme paper demonstrate scripting capability provided srpc enhance performance functionality scfs prototype network-attached disk con gured export interfaces clients rst commonly object-based interface similar proposed gibson exported object namespace nonhierarchical distinguish directories normal les read write requests arbitrarily ne-grained object identi offset length blockbased interface explore capabilities srpc restricted legacy environment mode disk reads writes size clients communicate disk protocol similar nfs disk server maintaining state behalf clients slight difference nfs calls directory operations exist clients perform operations client runs in-kernel rpc server receive messages scripts executing disk experimental platform system runs testbed intel-based machines running linux operating system scfs clientside code developed kernel standard linux vnode interface mhz pentium iii memory ibm ultrastar lzx disk machines connected mbit ethernet gigabit ethernet experiments primarily mbit ethernet environment network-attached disk emulated exact capabilities match network-attached disk processor network-attached disk engineered low power consumption absolute performance reasonable approximation network-attached storage unit disks high-end processing capabilities rivaling cpu power commodity network emulation methodology potential performance bene active disk servers depend exact characteristics environment perceived network latency low smaller performance bene combining operations script contrast high-latency scenario wide-area dial-up link home performance bene larger study impact network performance scfs implemented framework increasing network latency controlled amount approach similar introduced martin study effects latency overhead bandwidth parallel applications speci cally delay packet server queues packet internally records time packet received thread server removes messages queue designated delay passed services experiments shown validate delay mechanism behaves desired performance enhancements achieve single logical task network system series dependent interactions client server required dependencies impose synchrony clientserver interactions operation initiated previous returned clients incur multiple network round-trips accomplish single logical task result signi performance loss high-latency networks severe server load scfs srpc framework group dependent operations script executed disk single network round-trip illustrate cacy scripting infrastructure case studies rst study combine client 
lookup operation dependent getattr read calls single script merge nfs-like consistency check read modi page similar http get-if-modi ed-since request avoid readmodify-write cycle sending partial write script server motivation discuss case studies rst examine effects server load perceived client latency network latency concern wide-area dial-up connections round-trip times milliseconds uncommon tightly-coupled cluster high-performance communication subsystem latency considerable factor due server load illustrate effects server load perceived round-trip time perform simple experiment experiment measure round-trip times observed single client communicating server small byte messages vary number competing clients continually sends stream large requests server competing processes perceived average round-trip time reasonable roughly gigabit ethernet network traf c-inducing competitors added perceived round-trip time client increases dramatically competing processes note effect strictly due queuing network interface server touch data cpu under-utilized problem illustrated obvious inspection overlooked design distributed systems clusters fact messages transmitted quickly idle system avoid convoy effect small messages queue large network interface promptly reach destination response time performance metric throughput server load easily transform low-latency network perceived authors discuss assumptions made implementation distributed cluster-based service cluster low-latency san latency wide-area internet means two-phase commits prohibitively expensive made similar assumptions design cluster-based systems page section average cost readdir getattr additional network delay performance combined read-getattr separate combined tcl uncached combined tcl cached combined figure combining operations read getattr gure shows performance combining read getattr operations single script gure plots average cost performing directory read subsequent attribute request increase perceived round-trip latency request x-axis separate line shows performance network round-trips required lines graph show performance combining operations server combined tcl uncached line shows tcl performance procedure installed request combined tcl cached line shows performance script pre-installed finally combined line baseline performance implementation script data point represents average trials variance shown low differently clients operation load experiments section evaluate performance scfs function network latency read getattr optimization rst case study illustrate performance bene combining directory read attributes directory disk object model basis scfs lookup client involves reading directory path search path component worst case path components local cache round-trip network operations required component path rst read directory page parent attributes child object initialize vfs inode scfs srpc infrastructure disk enables client send script reads directory page searches speci lename object performs getattr object script returns results read getattr calls client completes lookup operation path component network round-trip client system designed performs lookups components pathname single script avoids network round-trips approach integrate easily linux in-kernel framework evaluate trade-offs scripts read-getattr operation function network latency compare perceived latency implementations figure rst implementation labeled separate gure standard implementation synchronously issues separate requests rpc labeled combined tcl uncached tcl script combine operations script installed interpreter invocation labeled combined tcl cached considers case pre-installed script fourth implementation labeled combined combines operations language version serves baseline ideal combined performance utilized understand overhead scripting gure draw conclusions fast interpreted language approaches speeds combining read getattr operations single script leads lower overhead base implementation amount network latency caching tcl procedures greatly reduces cost operation removing half millisecond overhead operation finally higher latencies combining operations slow interpreter uncached tcl procedures strictly standard implementation note latencies higher end tightly-coupled cluster environment low dial-up link latencies milliseconds uncommon demonstrate utility read-getattr optimization realistic benchmark utilize postmark benchmark postmark system benchmark constructed mimic workload typical mail server consists create phase transaction phase les randomly created deleted read appended generate realistic workload make postmark benchmark separate create phase transaction phase present results transaction phase left unmodi creation phase warms cache arti cially speeds transaction phase change make results realistic layout directories default behavior postmark creates directories level directory hierarchy measurements reveal read-getattroptimization removes round-trip messages combining readandgetattr pairs combined read-getattrscript calls benchmark total messages simple optimization reduces number round-trip latencies incurred client read modi optimization case study illustrate scripting interface make nfs-style consistency checks cient nfs primitive form consistency periodically validating cached copy client server time validation threshold cached copy considered suspect read request suspect copy client sends getattr request server check changed cached changed client invalidates cached copy fetches pages server operations dependent client issue read knowing cached copy stale wastes network bandwidth re-fetch valid pages srpc framework operations merged single script getattr checks modi cation time higher speci modi cation time cached copy sends desired page attributes refer combined functionality read-if-modi ed-since operation srpc support average time file read percentage modified data read-if-modified-since delay separate combined tcl cached combined average time file read percentage modified data read-if-modified-since delay separate combined tcl cached combined figure nfs read-if-modi ed-since graphs plot performance ofgetattrfollowed conditional readof data data changed check graph top additional network latency graph bottom add xed network latency x-axis increase percentage les changed check data point average trials system performs logical task incurs fewer synchronous network round-trip delays figure shows performance read-if-modi ed-since compared standard getattr conditional read x-axis graphs vary percentage data modi read re-fetched server graph top plot performance assuming additional network delay graph bottom assume additional network delay compare performance standard implementation cached tcl script combined functionality implemented gure draw conclusions lowlatency environment illustrated graph top bene combination script small realized highperformance interpreter cached tcl implementation adds overhead higher-latency environment illustrated graph bottom large fraction les changed tcl implementation perform standard implementation greater average cost partial write additional network delay performance partial writes read-modify-write partial write tcl cached partial write figure partial writes gure shows performance performing synchronous partial write script reading data server modifying writing data server gure plots average cost performing synchronous -byte write increasing perceived latency request x-axis read-modifywrite line shows performance standard read-modify-write case lines show performance scripted approach partial write tcl cached line shows tcl performance script pre-installed partial write line baseline performance implementation script point average trials les optimizations combine operations limited circumstances overhead interpretation currentpoint stroke infn local stage rshow evaluating storage-aware caching specifically overview simulator describes simulated storage environments simulator developed trace-driven storage-system simulator study behavior storage-aware caching configured simulated environment single client connected sixteen network-attached storage devices simulator explore performance impact client workloads data layout caching algorithms network characteristics disk characteristics storage-system heterogeneity simulator driven workload client trace file trace file represents data block requests striped raidacross full set disks request specifies starting offset length data read write simulate system high demand closed workload model completion disk request immediately triggers request client local cache replacement policies focus investigation model time cache hit small real system dwarfed cost remote-block access time cache miss sum network transit time remote disk service time trace trace trace request distribution uniform exponential exponential disk distribution uniform uniform gaussian locality random random random request size 
working set size requests table characteristics synthetic traces table summarizes synthetic traces set experiments gaussian distribution disk standard deviation storage device model roughly matches ruemmler wilkes model cylinders seek time rotational delay bandwidth calculating transfer time request specifically disk request falls cylinder previous request model sequential seek rotational delay set transfer time determined bandwidth nonsequential requests rotational delay chosen uniformly random full rotation time seek time non-linear model depends cylinder distance current request previous request network model based loggp endpoint contention loggp designed model communication large parallel computers depends parameters message latency network endpoint overhead minimum time message sends seconds byte network number endpoints workloads fully understand impact storage-aware caching algorithms study sets workloads variety synthetic traces web server trace collected analyzed roselli simply refer roselli web server trace roselli trace synthetic workloads control request size distributions working set size locality distributions distribution request disks synthetic traces summarized table traces read traces variety request sizes stress small large read requests trace adds request imbalance disks roselli trace image server california berkeley january age bandwidth seek rotation years avg avg table aging ibm lzx model bandwidth seek rotation time family disks based ibm lzx manufactured progressively older years assume bandwidth improves factor year seek rotation time year image server ran web server postgres database stored images trace alternates large reads files database tables small reads writes storage-system characteristics goals configuring set disks simulated environment goal understand full sensitivity storage-aware caching algorithms device heterogeneity requires diverse range configurations goal understand algorithms perform realistic scenarios requires focused set tests meet goals simultaneously employ device aging performance-fault injection idea device aging choose base device case ibm lzx age performance range years collections disks create configurations key performance base disk free scaled inode fixed bitmap amount inode blocks component disk bandwidth segmentsfree seek data rotation block time bitmap scaled superblock structure expected yearly improvement historical data suggests year improvement bandwidth roughly year reduction seek time rotational latency realistic aggressive side table shows performance characteristics aged devices experiments note progressively older disks backwards aging newer disks based current year similar manner forward aging performance-fault injection dynamically throughput age slow disk years slow disk lru clock cache throughput number slow disks multiple slow disks lru clock cache figure performance lru clock caching figures show throughput storage system trace figure left varies age single disk x-axis figure increases number year disks system change performance drive experiment earlier represent disk stuttering absolute failure unexpected network traffic client drive sudden workload imbalance environment configuration section describes details simulator configuration configure network bottleneck system choose parameters similar ethernet set bandwidth future hope investigate network performance caching interact distributed storage systems configured simulator separately synthetic roselli traces synthetic traces choose sufficient number requests mitigate effects cold-start misses set client cache size roselli trace set cache size hit rate hit rate high requests disks heterogeneity device performance issue traces include disk layout file path information created simple layout policy layout policy assumes raidstriping policy lays blocks order access aged disks scenarios scenarios represent cases storage-system incrementally updated newer faster devices added time scenario single heterogeneous disk performance aged entire range years scenario groups heterogeneous disks group age age years relative size groups varied scenarios cover real-world situations provide insight common configurations scenario mimics stuttering disks increased workloads clients scenario closely incremental upgrades disk array incremental upgrades occur due cost constraints prohibit replacement entire array small number disks fail experiments section presents progression experiments demonstrating effectiveness storage-aware caching begin motivating cost-aware caching algorithms heterogeneous devices show partitioned approaches mask performance differences configuring fixed partition ratios correctly difficult static environment demonstrate mask performance heterogeneity adjusting ratio partition sizes on-line observations amount work performed device finally show partitioned approaches easily incorporated operating system replacement policies perform explore performance robustness trace web server motivating set experiments motivates storage-aware caching algorithms storage system heterogeneous devices figure shows throughput obtained trace common replacement policies cost-aware lru throughput age slow disk years static lru cache figure potential partitioned approaches slow disk aged shown x-axis approaches cache lru caching static partitioning cache disk performance trace figure clock caching graph left illustrates disks aged seek rotation time bandwidth decline throughput system drops dramatically performance benefit file cache decreases lru replacement throughput drops disks equally fast single disk performance -year disk similarly graph shows entire storage system runs rate slowest disk system throughput slow disk fast disks poor slow disks contrast storage-aware caching algorithm mask performance slow disks allocating cache slow disks slow disk fewer requests handle harm performance system dramatically configuring partition sizes set experiments show partitioned caching algorithms potential mask heterogeneous performance care selecting ratio partition sizes begin examining static partitioning algorithm simply named static figure show performance static trace experiments ratio partition sizes statically set directly proportional ratio expected service time disk trace request size directly compute expected transfer time disk function seek time rotation delay peak bandwidth graph static throughput partition ratio trace figure sensitivity static partitioning partition ratios workload graph shows performance workloads run disks twoyear disk experiment varies ratio slow disk partition fast disk partitions x-axis lower lines requests vary ratio requests slow disk versus ratio partition strategy significantly improves performance relative cost-oblivious algorithms lru static performs priori request size per-disk miss rate function cache size real world information advance difficulty correctly configuring static partition strategy illustrated figure experiment examine single storage configuration slow disk years older disks x-axis graph varies ratio partition sizes slow disk disks system greater slow disk correspondingly larger partition lines graph correspond workloads optimal partition size ratios top line workload examined verify highest throughput workload approximately matches shown figure two-year disk lines distribution requests disks changed slow disk receives ten times requests disks graph shows workloads optimal partition ratio currentpoint stroke currentpoint stroke infn local remote rshow currentpoint stroke currentpoint stroke stroke grestore end showpage trailer documentfonts helvetica enddocument endspecial figur communities gure details ecution batc jobs running simultaneously communities lefty hand graph sho number jobs completed time progresses right-hand graph sho number cpus function time eac line represents dif erent discipline anomalous behavior infn local remote lines due phenomenon igure eop page bop beginspecial llx lly urx ury rwi rhi setspecial begindocument graphs latency eps ps-adobeepsf- title latency eps creator gnuplot patchlevel creationdate tue jul documentfonts atend boundingbox orientation portrait endcomments gnudict dict gnudict begin color true solid true gnu gnulinewidth userlinewidth gnulinewidth vshift mul hpt vpt hpt hpt vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke gnu setlinewidth 
ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc copy moveto copy vpt arc closepath fill vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy copy moveto vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc bind setdash copy vpt arc closepath fill vpt arc closepath bind rec newpath roll moveto index rlineto exch rlineto neg rlineto closepath bind square dup rec bind bsquare vpt exch vpt exch vpt square bind setdash copy moveto vpt rlineto bsquare bind setdash copy vpt square fill bsquare bind setdash copy exch vpt exch vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt square fill bsquare bind setdash copy copy vpt square fill exch vpt exch vpt vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy vpt vpt square fill bsquare bind setdash copy vpt vpt vpt rec fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt square fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy exch vpt exch vpt square fill bsquare bind setdash copy bsquare fill bsquare bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind diae stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke boxe stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke triue stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tride stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pente stroke setdash gsave translate hpt rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate remote rshow grestore currentpoint gsave translate rotate stage rshow grestore currentpoint gsave translate rotate local rshow grestore currentpoint 
gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate remote rshow grestore currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate stage rshow grestore currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate local rshow grestore ltb currentpoint gsave translate rotate time secs cshow grestore stroke grestore end showpage trailer documentfonts helvetica enddocument endspecial figur erall completion ime graph sho ery dominant factor higher performance interpreter worth implementing kinds features partial write optimization writes size page problematic traditional systems partial-page write translates read-modify-write cycle read relevant page cache modi cation affected portion page write complete update read-modify-write cycle occurs blockbased systems export read write operations page granularity srpc framework avoid read-modifywrite 
cycle send data written script performs partial write server removing synchronous page-sized read critical path figure displays performance server-side execution partial-write compared standard read-modify-write cycle gure avoiding synchronous page read great bene ecution time simulations eac con guration values turnaround time user perspectiv beginspecial llx lly urx ury rwi rhi setspecial begindocument graphs latency eps ps-adobeepsf- title latency eps creator gnuplot patchlevel creationdate tue jul documentfonts atend boundingbox orientation portrait endcomments gnudict dict gnudict begin color true solid true gnu gnulinewidth userlinewidth gnulinewidth vshift mul hpt vpt hpt hpt vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke gnu setlinewidth ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc copy moveto copy vpt arc closepath fill vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy copy moveto vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc bind setdash copy vpt arc closepath fill vpt arc closepath bind rec newpath roll moveto index rlineto exch rlineto neg rlineto closepath bind square dup rec bind bsquare vpt exch vpt exch vpt square bind setdash copy moveto vpt rlineto bsquare bind setdash copy vpt square fill bsquare bind setdash copy exch vpt exch vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt square fill bsquare bind setdash copy copy vpt square fill exch vpt exch vpt vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy vpt vpt square fill bsquare bind setdash copy vpt vpt vpt rec fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt square fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy exch vpt exch vpt square fill bsquare bind setdash copy bsquare fill bsquare bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind diae stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke boxe stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg 
closepath stroke triue stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tride stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pente stroke setdash gsave translate hpt rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate remote rshow grestore currentpoint gsave translate rotate stage rshow grestore currentpoint gsave translate rotate local rshow grestore currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate remote rshow grestore currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate stage rshow grestore currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate local rshow grestore ltb currentpoint gsave translate rotate time secs cshow grestore stroke grestore end showpage trailer documentfonts helvetica enddocument endspecial figur ninety-fi cent completion ime graph sho percent completion time simulations eac con guration values response time user perspectiv beginspecial llx lly urx ury rwi rhi setspecial begindocument graphs throughput eps ps-adobeepsf- title throughput eps creator gnuplot patchlevel creationdate tue jul documentfonts atend boundingbox orientation portrait endcomments gnudict dict gnudict begin color true solid true gnu gnulinewidth userlinewidth gnulinewidth vshift mul hpt vpt hpt hpt vpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show dup vpt mul vpt exch hpt mul hpt exch hpt hpt mul vpt vpt mul color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke userlinewidth mul setlinewidth stroke userlinewidth div setlinewidth dup gnulinewidth mul userlinewidth exch mul udl exch stroke gnu setlinewidth ltb lta udl mul udl mul setdash setrgbcolor pnt stroke setdash gsave setlinecap stroke grestore dia stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke pnt pls stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke box stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke pnt crs stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke triu stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt star copy pls crs boxf stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath fill triuf stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill trid stroke setdash copy vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pnt tridf stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath fill diaf stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath fill pent stroke setdash copy gsave translate hpt rotate hpt repeat closepath stroke grestore pnt pentf stroke setdash gsave translate hpt rotate hpt repeat closepath fill grestore circle stroke setdash copy hpt arc stroke pnt circlef stroke setdash hpt arc fill setdash copy moveto vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc copy moveto copy vpt arc closepath fill vpt arc bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy copy moveto vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill copy moveto copy vpt arc closepath fill vpt arc closepath bind setdash copy moveto copy vpt arc closepath fill vpt arc bind setdash copy vpt arc closepath fill vpt arc closepath bind rec newpath roll moveto index rlineto exch rlineto neg rlineto closepath bind square dup rec bind bsquare vpt exch vpt exch vpt square bind setdash copy moveto vpt rlineto bsquare bind setdash copy vpt square fill bsquare bind setdash copy exch vpt exch vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt square fill bsquare bind setdash copy copy vpt square fill exch vpt exch vpt vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy vpt vpt square fill bsquare bind setdash copy vpt vpt vpt rec fill bsquare bind setdash 
copy vpt vpt square fill copy exch vpt exch vpt square fill bsquare bind setdash copy vpt vpt square fill copy exch vpt exch vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy vpt square fill bsquare bind setdash copy exch vpt exch vpt vpt vpt rec fill copy exch vpt exch vpt square fill bsquare bind setdash copy bsquare fill bsquare bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind gsave translate rotate stroke grestore bind diae stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke boxe stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke triue stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tride stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke pente stroke setdash gsave translate hpt rotate hpt repeat closepath stroke grestore circe stroke setdash hpt arc stroke opaque gsave closepath setgray fill grestore setgray closepath diaw stroke setdash vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt opaque stroke boxw stroke setdash exch hpt exch vpt add vpt neg hpt vpt hpt neg opaque stroke triuw stroke setdash vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke tridw stroke setdash vpt mul hpt neg vpt mul hpt mul hpt neg vpt mul opaque stroke pentw stroke setdash gsave translate hpt rotate hpt repeat opaque stroke grestore circw stroke setdash hpt arc opaque stroke boxfill gsave rec setgray fill grestore end endprolog gnudict begin gsave translate scale setgray newpath helvetica findfont scalefont setfont ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate remote rshow grestore currentpoint gsave translate rotate stage rshow grestore currentpoint gsave translate rotate local rshow grestore currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate remote rshow grestore currentpoint gsave translate rotate infn local rshow grestore currentpoint gsave translate rotate stage rshow grestore ratio top workload currentpoint gsave translate ratio rotate infn bottom local workload rshow grestore performance currentpoint gsave workload varies translate greatly rotate partition local ratio rshow performance grestore ltb workload varies currentpoint gsave translate throughput rotate age time slow secs disk cshow years trace grestore lazy lru eager lru landlord lru cache throughput age slow disk years trace lazy lru eager lru landlord lru cache figure dynamic partitioning algorithms figure shows stroke performance grestore eager end lru lazy showpage lru trailer landlord documentfonts helvetica disk enddocument aged endspecial left graph figur trace graph erage trace cpu approach consumption select partition ratios dynamically 
function workload disk performance graph partitioning sho balance work set erage experiments cpu shows time dynamically consumed adjusting jobs size eac partition algorithms con balance guration amount work performed disk values effectively hide heterogeneity cient classes resources dynamic partitioning eager system partitioning lazy partitioning perspectiv lazy partitioning inverse lottery scheduling benchmark pick victim capacity partitions replacement infn time pool eager lazy submitted lru simulation partitions jobs simplicity completed refer sho approach figure eager lru approach run lazy number lru experiments ailable investigate machines trace trace uctuy ates realistic evaluation continuing ine understood vitable workload property parameters figure compares distrib uted performance system eager lru iny lazy lru olving storage-aware hundreds algorithms lru users landlord changing left-most minds graph figure machines examine workload ertheless uniform mak number requests steady progress disks roughly setup job throughput lru degrades ery dramatically performance seconds slow disk aged xplored specifically throughput drops feasibility approximately man eager lru lazy lru aily maintain cpus throughput system slow disk ith aged specifically cpus performance reserv algorithms similar lru disks submitted speed jobs ten-year-old disk pool mask impact dif ferent con slow disk guy throughput rations results graph sho figure shows challenges figure non-uniform number requests disks case interestingly labelled remote disks jobs identical performed cost-aware algorithms perform lru appliance workload infn popular disks suffer lar contention ger queueing number delays make blocks cpus disks run costly fetch aster monitoring replacement cost jobs cost-aware algorithms devote cony cache strained popular disks ery small balance load ailable bandwidth disks previous address workload situation performance benefits deplo cost-aware yed caching improve nest disks aged pool -year disk eager switch lru lru differ reserv factor cpus comparing performance cpus eager lru lazy updated lru landlord adv sees ertise themselv performance members algorithms similar identical community graph shows jobs difference eager submitted lru performance robust cony lazy straint lru landlord run lazy lru devotes entire cache slow disk cms eager lru data continues allocate small amount ailable cache fast disks machines immediately repartitioning satis eager lru aggravates efforts requirement find good partition satisfy size trace manually clock-based staged replacement noted necy section essary operating data systems clock appliance algorithm instructed clock cost-aware adv ertise section evaluate contents lazy procedure partitioned algorithm roughly called lazy seconds clock practical virtual memory jobs page replacement algorithm run traces completed compare sho lazy clock clock experimental results stage found figures case accounting figure lazy clock performs desired lazy clock greater proportion cache slower devices devices requests lazy clock mask performance differences time speed transfer slow disk degrades significantly stage case imbalanced workload mar lazy clock ginally begins aster throughput approximately remote case disks identical degrades future slow ecutions disk ould full -years tak adv older antage throughput age slow disk already-transferred years data trace lazy clock run clock sho cache throughput loy cal age slow case disk years trace lazy clock fourth con guration measured sho figure con guration combined stage remote models performed clock stage database concurrently allo cache figure clock-based replacement algorithms figure shows wing performance jobs lazy clock clock ecute disk aged remote workloads idea investigated staging figure throughput operation number ould slow disks complete trace lazy clock jobs clock cache access figure clock-based data multiple locally disks figure shows performance lazy clock bandwidth clock number remote disks serv age years increased trace shared stage workload operation left graph jobs figure throughput compares jobs favorably nished landlord lazy lru stage figure completed figure shows additionally lazy clock due gracefully masks increasing number bandwidth two-year contention disks jobs clock affected nished heterogeneity performance slo lazy wly clock slowly degrades performance match remote clock con system guration homogeneous note two-year disks performance fairly close loy experience cal community shown smaller base correction size ecutable devices database homogeneous les remove fetched discrepancy dynamic local performance storage evaluate appliance tolerance performance faults processy show speci partitioned input caching algorithms les react syncronoulsy fetched relative performance storage storage devices appliance cases effectively submission landlord site experiments output begin les cluster homogeneous disks deli trace ered inject performance fault finally disks made disk simulated time communities seconds approximately concert half results simulation performance sho fault effect figure slowing disk factor infn local graph figure remote show case eager lru jobs adjusts partition run ratios change performance communities performing partitions initially equal appliance performance fault window submitting host disk requests passed number observation algorithm cpus observes waiting time disk significantly high higher bandwidth average waiting constraints time limited partition disk performance increased small amount infn partitions local stage disks case jobs decreased run number cache entries infn algorithm community continues measuring data wait time staged disk increasing partition size abo disk wait stage times completed approximately equal end time-line shows run correct partition wherey ratio opon found quickly lar number graph figure cpus summarize nished results comparing performance remaining landlord jobs eager yielding lru clock lazy increase clock plot performance throughput eop page workload bop finally performance fault occurs data disk disks ailable disks simultaneously community number affected disks run small relative jobs total number ould disks system aggregating match replacement-cost information community beneficial specifically eager lru sho achieves throughput infn approximately local performance local fault case landlord maintains lazy aluation clock performs finally aluate costoblivious clock arious algorithm performs con gurations number faulty points disks increases vie users generally concerned partition ratio simulation erall time seconds single comy fault pletion injection time disk fault injected disks orkload eager lru system landlord lazy operators clock figure performance geny erally dynamic concerned faults cluster initially cient homogeneous disks performance resources fault time seconds slows disk factor graph left performance fault occurs single disk show partition sizes chosen eager consumed lru algorithm user graph perspecti performance fault summarized occurs figure disks graph cases sho trace completion time throughput job age slow disk cony years lru-based guration algorithms lru general landlord applying eager lru cpus lazy lru run yields aster cache results throughput age slow disk years lar clock-based ger algorithms numbers clock lazy cpus aily pro vide mar ginal impro ement remotely localized yields aster results figures clock sho cache figure web server workload con guration figure shows completes performance lruand lar clock-based algorithms fraction run file jobs system trace quickly web server providing art images results erall lru-based completion algorithms graph left side delayed clock-based algorithms small number graph jobs results change eager lru mask ery performance faults end landlord ecution groups disks compare similar performance con characteristics gurations correction algorithm disy detect garding severity contrib utions heterogeneity making smaller long corrections tail needed xamining adaptive threshold completion time real-world performance ninetyn conclude percent experiments examination jobs sho partitioned algorithms figure xamined jobs long tails disco ered distinct sources delay cases jobs starv input phase enter computation phase competition decreased jobs late run victed ecution sites wners returning orkstations jobs simply longer ecution times due competition local users cpu memory netw ork capacity problem starv ation suggests xamiy nation airness storage appliance problems dif cult address eliminated tightly-controlled vironment -present feature lar ge-scale grid computing lar computation performed resources partially shared lik ely recei interference performance users long tail pre ented ecuting multiple copies jobs number outstanding number cpus ailable operator perspecti summarized figure graph sho erage cpu consumption job con guration gure arri viding aly located cpu time number jobs run 
cient con gurations olv localized remote pro vides impro ement completion time holds cpus idle aiting yielding poor cienc performance con guration parameters runs xample stage cases pro vide impro ement time transy fer datasets ecution time jobs performing remote details ecution surprising figures remote cases incur eral dray matic delays frequenc job completion drops drasy tically ected drops cpu allocation cases occurred lar numbers jobs pre viously contending completed xamy ination submitter log sho condor start jobs quickly completed due erhead re-transferring self-e xtracting archi ery wly started job alley viated cache ecution site major obstacle throughput application rela ted ork man simple distrib uted systems mak centraly ized serv connect jobs data canonical xample netw ork file system nfs anay logue grid computing condor remote system call acility running job performs remote procedure calls back ginating computer central-serv models limited scalability number clients limited aggre gate bandwidth pro vided central serv web performance workload indi web server vidual received clients modest number requests limited trace shorter bandwidth synthetic latenc traces partitioned algorithms netw ork partially penalized reliability shortness trace system decreases move partition sizes number netw initial state orks similar participants experiments increases investigate aging single disk results shown figure expected cost-oblivious algorithms show sharp drop performance age slow disk increases eral lru systems performance address falls dif peak culties performance cop age ying range data realistic range falls aged site job years clock ecution shows similar slightly andre dramatic file decline expected sysy adaptive tem algorithms afs show robust performance scale performance degrades lar ger lazy client serv lru eager ratio lru landlord nfs lazy analogue lru performs grid poorly computing eager lru glob landlord lazy lru gass poor system interaction repartitioning algorithm les devotes entire fetched cache slow disk disy trib disks uted homogeneous repositories eager lru rst distributes pages evenly stored pages locally gradually distribution disk ages lazy longer clock referenced shows hierarchical small data decrease grids performance pand idea trees sharp drop serv ers slow disk replicate data years production drop site due jobs significant data change partition ratios orthogonal lazy clock strongly quesy favors tion slow disk age data located weak preference age note performance landlord decreases age system matches increases data trace jobs bimodal distribution data request sizes due type postgres table reads resource interleaved man small web applications server reads writes require introduce anomalous disco behavior based ery experiments data shown due space constraints arbitrary performance types dynamic resources partitioning algorithms sensitive base replica correction management amount system experiment figure eep track fixed base correction amount data range slow disk locations ages storage base correction resource amount starts broy small increases srb disk pulls ages man performance improves pieces matches base pro cost-oblivious vide algorithm homogeneous coherent vie system adaptive multiple base correction replication amount sites needed performance arrangement related work work communities cost-aware caching occurred ery similar web cache database communities shared web web cache proxy community cache extensively studied cost-aware web caching clients addition document size particy ular location option choosing proxy included run algorithms lar web caching body work differs research storage-aware caching ways ailable performance softy wide area varies general resource common disco storage systems ery web caching projects document caching iny clude differs jini fixed-size replica blocks catalogs storage systems snmp finally web caching replacement cost web recent page peer strongly -to-peer correlated sharing replacement costs proy tocols pages broadcast napster disks continuously deliver gnutella data clients adv asymmetric link antage broadcast schedule classad frame ork condor meet client unique client ability inte met grate resource broadcast disco schedule ery client cache strives scheduling manage classads cache contents mask non-ideal broadcast resource schedule disco knowledge ery broadcast schedule eral probability conte access cache manages contents algorithm generalizes lru storage-aware caching differs ways partitions cache 
pages device xts broadcast azhkudai disks page describe device classads granularity track replacement costs match broadcast jobs disks assume storage infrequently vices changing broadcast model schedule replica storage-aware manager caching react rst consulted frequent disco workload device list performance recently researchers ailable studied allocation repliy pages cas classes matchmaking prefetching performed compiler-controlled memory management resizeable file storage buffer caches vice prefetching page job allocation occurs submitted applications hinted ecution unhinted bound compiler-controlled disco memory management ered compiler vice application memory usage assumed information operating system global distrib replacement policies ution hints replicas reintegrating elements change local page replacement global lookup page basne replacement finally nelson work describe resizeable file buffer caches classads evaluates tradeoff xecution file domains buffer caches virtual memory model system loaded ecution work sites bind areas themselv closely related checkpoint work serv ers directly jobs address storage write device checkpoints heterogeneity future work nearest eop storage-aware caching page increases bop storage system ailable performance serv robustness adapting performance differences xpress devices polic areas controlling improvement application domain migrate addition study checkpoint real image implementation contrib partitioning ution algorithm presented classads significant introduce limitations indirection sophisticated informed model cost-benefit jobs algorithms xpress constraints limitations storage linear relationship vices assumption cache size aly hit rate reliance ecution proper values site window declare size base increment binding amount storage threshold limitation storage evident referred considers access patterns locality working member set larger cache match intuitively algorithm recognize instances promised increasing xclusi cache size ely decrease wait time requesting job general framework contrast storageaware caching existing cost-oblivious policies gang-matc manage individual hing partitions classads studied framework approach raman modularity primary strength allo existing non-cache multiple aware policies entities lru clock xclusi mru ely eelru promised minimal effort xample work concentrated non-cooperative arrangement client caching combination ganization cooperative caching limited number cost-aware caching licenses lead run performance robustness proprietary softw disk arrays individual cache sizes case small fourth gangmatching storage-aware caching match licenses applied machines lowpower jobs environments storage-aware ensure caching licensing agreements extended include power violated retrieval cost ariety devices research higher entures power xploring accessed storage vices frequently arious stay names low-power mode longer asd frequently acti finally caching disks algorithms affected flash prefetching ibp layout decisions fer explore serv ers advantages tradeoffs integrated commercial prefetching layout endors caching decisions netapp light device emc heterogeneity previous caching fer prefetching stor work homogeneous age environments serv shown benefits integration benefit extends heterogenous environments conclusions diverse characteristics modern storage devices time ripe re-investigate caching algorithms optimize performance task ers hardw package making nest easily deplo yable softw apy pliance speaks protocols costaware suitable cache grid control computing blocks cached run amount special work performed pri vile storage device roughly wide equal ariety paper mechanisms presented family uilding cost-aware caching interposition algorithms agents based notion proposed explicitly including partitioning system call cache size intercepy tion partition configured static relinking directly binary corresponds writing relative cost usefulness data emulation partition approaches xisting interf advantages ace partitions aggregate replacement-cost making information bypass entries cache due reducing amount information erhead tracked ability allowing recent cost information special pri blocks vile ges device conclusion important virtual communities partition approach natural structures easily implemented localizing clock applicay replacement tion policy increasing likelihood grid adoption real binding cpus systems acknowledgements storage members wisconsin ganizations network disks ect research group physical helpful reality discussions contributions paper comments iny crease florentina popovici performance provided ibm applications lzx disk profile utilization information simulations systems leslie users cheung wrote layout ability code xpress berkeley relations trace experiments omer zaki particy contributed ipants early versions community work comments anonymous reviewers indirect relations tireless allo shepherding jeff chase user greatly improved xpress quality requirements paper condor storage distributed execution system cpu run simulations members classad frame condor ork project todd tannenbaum xtensions supported condor indirection work sponsored nsf well-suited describing ccrccr- managing itrand wisconsin alumni communities research foundation emplo ying acharya eral alonso general-purpose franklin uilding blocks zdonik broadcast disks cony data dor management nest asymmetric communications environments pfs proceedings acm sigmod demonstrated international easy conference management dey plo data san yment jose communities pages special acm pri press vile acharya ges franklin deplo ying zdonik reasonable disseminationbased data con delivery guration broadcast disks ieee impro personal communications december throughput alexandrov high-ener ionescu physics schauser simulation scheiman loggp incorporating long messages eral enues future ork con guration communities left huy man ratio cpus storage appliy ance depends fered loads physical constraints vision higher -le softw recon gure comy munities deplo ying remo ving storage appliances logp load model step closer realistic static model set parallel computation communities papers user annual acm symposium parallel dif algorithms cult architectures santa choose barbara june polic jobs pages acm press data apple computer vice corporation idisk ersa http itools mac mechanisms admit arpaci-dusseau possibilities arpaci-dusseau bent forney select muthukrishnan trigger popovici zaki manageable storage current adaptation staging wind mechanism proceedings allo ieee int complete symposium cluster transy computing fer grid ccgrid data pages les future arpaci-dusseau ould lik arpaci-dusseau fail-stutter fault tolerance estigate workshop dif hot ferent topics caching operating policies systems hotos schloss allo elmau germany ner babaoglu granularity joy data converting transfer swap-based system paging instance architecture les lacking page-referenced bits dataset proceedings demand fetched acm symposium cached operating system principles local storage pages pacific grove apy pliance december bertoni similar understanding solaris con filesystems guration paging tested technical report tr- sun jobs microsystems ecute remotely cao felten complete karlin stage implementation dataset performance integrated case application-controlled file found caching prefetching performance disk scheduling acm ery transactions computer due systems bandwidth november contention cao irani cost-aware ecuting proxy jobs caching algorithms usenix stage symposium operation internet technologies systems proceedings monterey california december sharing pages berkeley suf usa ciently high carley demand ganger nagle mems-based integrated-circuit mass-storage systems communications acm caching outperform staging data finally concentrated problems deli ering input data forts condor research group kangaroo address problems reliably ving outy put data distant destination data ement asyncronously allo remotely ecuting jobs acate ecute machines quickly combination kany garoo communities ould address grid applications ginning end ckno wledgements ould lik vladimir litvin assistance advice cms softw aolo mazzanti fer ing dedicated nest machine generally making infn condor pool ailable albert ale xandro maximilian ibel klaus schauser chris scheiman ufo personal global system based user -le xtensions operating system ansactions computer systems pages august bill allcock joe bester john bresnahan ann cherv enak ian oster carl esselman sam meder eronika nefedo darc quesnel ste ueck secure cient data transport replica management high-performance data-intensi computing submitted illiam allcock ann cherv enak ian oster carl esselman charles salisb ury ste ueck data grid ards architecture distrib uted management analysis lar scienti datasets ournal network computer applications anderson ocum chase case fer serv ers oceedings ieee orkshop hot opics oper ating systems april baru moore rajasekar sdsc storage resource brok oceedings cascon oronto canada jim basne miron aolo mazzanti utilizing widely distrib uted computational resources ciently ecution domains submitted computer physics communications john bent andrea arpaci-dusseau remzi arpaci-dusseau miron nest project http nestproject joseph bester ian oster carl esselman jean edesco ste ueck gass data ement access service wide area computing systems oceedings sixth orkshop input output allel distrib uted systems pages eop page bop andre birrell bruce jay nelson implementing remote procedure calls ansactions computer systems februrary case fedor schof fstall vin simple netw ork management protocol request comments internet engineering task force emc corporation http emc garth gibson vid nagle khalil amiri chang eugene feinber ard gobiof chen lee berend ozceri erik riedel vid rochber case netw 
ork-attached secure disks echnical report cmu-cs- carne gie-mellon uni ersity gnutella http gnutella hitz storage netw orking appliance echnical report netw ork appliance ard kazar menees nichols satyanarayanan sidebotham est scale performance distrib uted system ansactions computer systmes february galen hunt doug brubacher detours binary interception win functions echnical report msr-tr- microsoft research february netw ork appliance http netapp michael jones interposition agents ransparently interposing user code system interf ace oceedings symposium oper ating systems principles pages litzk remote unix turning idle workstations cycle serv ers oceedings usenix summer conf pages michael litzk miron matthe mutka condor hunter idle orkstations oceedings international confer ence distrib uted computing systems pages napster http napster druschel aenepoel flash cient portable web serv oceedings usenix hnical confer ence plank beck asif moore olski internet backplane protocol storage netw ork oceedings network stor symposium rajesh raman matc hmaking ame works distrib uted resour mana ement phd thesis uni ersity isconsin october rajesh raman miron marvin solomon matchmaking distrib uted resource management high throughput computing oceedings venth ieee international symposium high erformance distrib uted computing july rajesh raman miron marvin solomon resource management multilateral matchmaking oceedings ninth ieee symposium high erformance distrib uted computing pages pittsb august riedel gibson acti disks remote ecution netw ork-attached storage echnical report cmu-cs- carne gie-mellon uni ersity asad samar heinz stockinger grid data management pilot iasted international confer ence appliaed informatics february russel sandber vid goldber ste kleiman dan alsh bob yon design implementation sun netw ork lesystem oceedings november chrobak karloff payne vishwanathan results server problems proceedings annual acmsiam symposium discrete algorithms soda pages san francisco usa jan cortes labarta extending heterogeneity raid level usenix annual technical conference june demke brown mowry taming memory hogs compiler-inserted releases manage physical memory intelligently proceedings symposium operating systems design implementation osdipages berkeley october grochowski ibm leadership disk stroage technology ibm corporation howard kazar menees nichols satyanarayanan sidebotham west scale performance distributed file system acm application baio system calls buffer cache manager device drivers baio slave kernel user-level operation completes baio asynchronously returns control user transactions baio computer directly interacts systems device-driver february baio jin initiates bestavros operation popularity-aware greedydual-size buffer-cache algorithms application initiates web access proceedings operations initiate international bypassing conference distributed buffer-cache computing device systems driver intimates icdcs april completions kelly baio chan slave jamin baio slave intimates mackie-mason completion biased replacement application policies disk web caches differential quality-ofservice aggregate user fourth international web caching workshop san diego california march april kubiatowicz bindel eaton chen geels gummadi rhea weimer wells weatherspoon zhao oceanstore architecture global-scale persistent storage proceedings ninth international conference architectural support programming languages operating systems asplos november manasse mcgeoch sleator competitive algorithms on-line problems proceedings twentieth annual acm symposium theory computing chicago illinois pages york usa nelson welch ousterhout caching sprite network file system acm transactions computer systems february nelson virtual memory file system technical report compaq computer corporation nyberg barclay cvetanovic gray lomet alphasort risc machine sort acm sigmod conference patterson gibson ginting stodolsky zelenka informed prefetching caching proceedings fifteenth acm symposium operating systems principles pages copper mountain december acm press pro softnet corporation ibackup http ibackup rashid tevanian young golub baron black bolosky chew machine-independent virtual memory management paged uniprocessor multiprocessor architectures proceedings international conference architectural support programming languages operating systems asplos pages palo alto october association computing machinery ieee rizzo vicisano replacement policies proxy cache ieee acm transactions networking roselli lorch anderson comparison file system workloads proceedings usenix annual technical conference usenixpages berkeley june ruemmler wilkes introduction disk drive modeling ieee computer march sandberg design implementation sun network file system proceedings usenix summer conference pages berkeley usa june usenix association sanford greier yang olyha narayan hoffnagle alt melcher one-megapixel reflective spatial light modulator system holographic storage ibm journal research development smaragdakis kaplan wilson eelru simple effective adaptive page replacement proceedings acm sigmetrics international conference measurement modeling computing systems sigmetricsvolume sigmetrics performance evaluation review pages york acm press sullivan seltzer isolation flexibility resource management framework central servers proceedings usenix annual technical conference san diego california infiniband trade association http infinibandta june tomkins patterson gibson informed multiprocess prefetching caching proceedings acm sigmetrics conference measurement modeling computer systems pages acm press june vahdat anderson dahlin belani culler eastham yoshikawa webos operating system services wide area applications proceedings seventh symposium 
high performance distributed computing july waldspurger weihl lottery scheduling flexible proportional-share resource management proceedings usenix symposium operating systems design implementation nov wooster abrams proxy caching estimates page load delays proceedings international conference april young k-server dual loose competitiveness paging algorithmica june young on-line file caching proceedings ninth annual acm-siam symposium discrete algorithms balitmore january pages acm press 
summer usenix confer ece pages douglas thain jim basne se-chang son miron kangaroo approach data ement grid oceedings enth ieee symposium high erformance distrib uted computing san francisco california august douglas thain miron pluggable file system http random access performance buffered working set size baio read kaio read raw read baio write kaio write raw write additional network delay avoiding excessive data movement read-modifywrite cycle pays dividends performing single round-trip factor reduced latency easily achieved evaluate utility partial-write optimization realistic benchmark setting addition postmark benchmark investigate traf savings debit-credit benchmark tpc-b benchmark intended model workload database server manages bank transactions measurements reveal partial-write script reduces bandwidth considerably postmark debit-credit benchmarks postmark total message traf bytes reduced roughly debit-credit benchmark savings dramatic full traf removed reason substantial reductions network bandwidth straightforward benchmarks perform small writes avoiding page-level data transmissions required readmodify-write cycle network load considerably reduced discussion case studies power combine arbitrary operations server helps overcome limitations exported rpc interface enabling clients build customized performance optimizations important bene approach arises server-side srpc designer distributed service focus simpler task providing highly-tuned primitives allowing clients compose primitives full scope required functionality noted srpc optimize performance network systems ways case studies presented speci cally client performs predictable series dependent operations server incurs multiple network round-trips operations combined single script additional case system ensure set writes reach disk xed order crash recovery traditional system client ensure ordering perform write synchronously label type synchronous operation false synchrony client synchronous operations enforce order ensure operation reached stable storage srpc framework false synchrony avoided client perform writes asynchronously guaranteed writes reach disk desired order functionality enhancements traditional servers implement single xed protocol size solution limits functionality clients expect server exible approach wrongly assumes single protocol meets requirements clients respect les consistency semantics client system implement strongly constrained protocol interface exported server server exports nfs-like interface restricts clients weak level consistency server stronger consistency model forces clients incur consequent overhead srpc clients enhance physical protocol provided server implement enhanced virtual protocols srpc enable clients implement sophisticated consistency semantics top nfs-like physical protocol case studies implement afs sprite consistency semantics cases scfs interface remains existing clients nfs-like semantics continue operate smoothly key feature examples demonstration framework state easily added previously stateless protocols nfs earlier work spritely nfs demonstrated capabilities rewriting server client extensively note consistency semantics functionality enhancement scripts utilized implement object-based disk interface top block-based server hinted section average time close client callbacks broken afs close script overhead tcl-loop broadcast serial std lib broadcast serial std lib broadcast parallel figure afs close script overhead average cost executing afs close dirty script shown number callbacks broken increases afs consistency afs write-on-close consistency model clients consistent image open close operation open client installs callback server reads entire local disk cache subsequent reads writes performed local copy closed client writes back modi server client stores modi version back server callbacks broken clients invalidate cached copies forcing fetch server time open server actively involved ensuring afs consistency server exports xed nfs protocol support afs semantics srpc infrastructure disk implementing afs consistency semantics feasible servers track state variables live invocation single script afs relevant state disk object callback list list client machines cached scripts required afs open afs close dirty open client sends afs open script installs client address per-object callback list client reads object standard read interface caches local disk modi closed client client sends afs close dirty script server script loads callback list object invokes send rpc list library routine send callback break listed clients performance consistency model dif cult measure present time takes execute afs close dirty script number callbacks broken increased figure plots performance implementations script rst labeled tcl-loop broadcast serial script sends message synchronously clients callback list case labeled std lib broadcast serial tcl script makes single call standard library routine synchronously issues rpc callbacks clients performance improves version due fewer number crossings tcl boundary finally case labeled std lib broadcast parallel multiple threads standard library issue callexperiment avg read cost overhead direct read tcl cached table read write-sharing overhead average cost executing sprite read callback script shown rst row table labeled direct read shows cost reading page synchronously serves lower bound execution time rows table show cost executing tcl implementations script establishing overhead reads experience write-sharing experiment read cost calculated average reads occur large copy back requests asynchronously issuing rpc callbacks parallel improves performance slightly experiment demonstrates performance bene including primitives standard library sprite consistency sprite stronger consistency model afs semantics referred perfect consistency close approximation unix local system semantics sprite model clients cache les long write sharing write sharing occurs client open opened write mode write-sharing occurs sprite turns caching clients send reads directly server finding write-shared requires server track state unmodi nfs-based system major design concern implementing sprite semantics scfs ensure reads writes slowed common case write sharing occurs executing scripts negative performance impact script part read write operation meet goal developed design object state variables read callback list list clients open cached reading writers list tracks clients open writing designating cacheable on-going write-sharing client state believes non-cacheable read request client sends sprite read callback script sprite read callback script checks cacheable set script adds address client read callback list returned client client mark state local inode cacheable subsequent reads scripted issued normal rpc read requests write sharing overhead paid scripting client opens write mode client sends sprite write open script script sends invalidate rpc members read callback list marks non-cacheable adds address writers list object registered writer client marks cacheable local inode in-memory cache satisfy read requests client closes sends sprite write close script disk removes client writers list marks cacheable writers list empty registered writers subsequent scripted-reads experiment avg update cost overhead base tcl cached table directory update script overhead average cost executing directory update script shown tcl implementations compared version concurrency control experiment object created inserted directory tcl implementations directory information server contrast base entry shows performance updating directory directly concurrency protocol case directory page written server update clients notice cacheable status cache overhead scripts reading shown table direct read entry shows average cost read copy assuming write-sharing case experiment read takes roughly entry shows cost executing 
version sprite read callback script adds roughly overhead finally tcl version script runs approximately slowly non-scripted read experiment importance calling sprite read callback script discussion general ability extend interface server scripts expands types functionality client systems implement case studies shown functionality requires state object server brie discuss examples stateful scripts implement scfs functionality client system implement ne-grained copy-onwrite system state required track byte ranges object copied script required client reads writes write script transparently redirects write copied version object read script directs read version object imagine optimizations similar sprite case study avoid invoking scripts read write operation clients associate arbitrary type meta-data virtual meta-data interesting piece extensible meta-data general access control list acl provide exible sharing permission bits provided server system read write operation client send script check credentials user fully ensure clients bypass protection check simply calling existing rpcbased read write calls permission bits disabled potential security hole illustrates general principle scripts assume cooperation set mutuallytrusting clients client call scripts enforce sprite consistency semantics clients desired behavior simplicity enhancements srpc arbitrary operations grouped executed server greatly simpli implementation atomic sets operations isolated respect read partial afs sprite directory operation attr modi write open close read callback write open write close update sec sec sec sec sec sec arithmetic ops control list ops state mgmt type checking library locks communication native calls total lines table tcl functional breakdown table categorizes static operation counts script script minimum maximal path costs shown left-most column presents categories arithmetic operations control statements list operations create add iterate state management stateful protocols type checking library searches copies utility functions locks lock unlock communication extra rpcs mandated rpc reply native calls calls raw rpc-exported functions total bottom column lists total number lines script note number lower higher sum previous operations cases statements accounted separately end brace simple assignment statements cases line consist multiple statements arguments math expressions script identi column header section number concurrent operations clients demonstrate case study srpc simplify implementation seemingly complex distributed concurrency problem concurrent directory updates disk object model directories considered equivalent objects disk directory operations create delete translate reads writes server create client rst reads directory page inserts directory entry pertaining vacant slot writes page back proper concurrency control simultaneous creates directory clients lead lost create scfs ensure directory readmodify-write sequence performed atomically traditional server common ensure atomicity distributed locks client rst acquires lock directory object performs read-modify-write nally unlocks directory approach result sub-optimal performance due multiple network roundtrip operations required phases importantly makes system signi cantly complex speci cally server track locks multiple client machines handle distributed failure scenarios client crashing momentarily losing network connectivity holding lock srpc framework greatly simpli implementation atomic operations co-locating server operations distributed machines concurrent directory update case study client sends script disk acquires in-memory lock server performs read-modify-write releases srpc reduce complex distributed concurrency problem simpler challenge ensuring mutual exclusion threads server address space table shows performance tcl implementation directory update compared cost simply sending directory page server approach provide concurrency control represents cost simply writing page perform directory update table overhead simple concurrent directory update satisfactory providing functionality dif culties encountered implementing robust three-phase protocol discussion case study brie illustrated srpc simplify client server code centralized script server simplify functionality cases traditional distributed algorithms required multiupdate atomic transactions natural provide scripting framework transactional capabilities mandate additional functionality srpc standard library including ability roll back perform crash recovery future plan investigate utility transactional support srpc framework analysis tcl section explore costs script execution tcl environment provide detailed accounting scripts implemented including functional cost breakdowns end discussion ndings functional breakdown table shows breakdown tcl commands scripts case studies grouped categories arithmetic operations control statements statements list operations number scripts lists basic data structure state management routines saving restoring longlived server state type checking ensure illegal memory dereferences occur library routines utility functions copies string searches locks communication single reply mandated rpc native calls rpc-exported routines table make number general observations line column total number lines script observe scripts implement powerful functionality small amount code scripts lines code regime ranging low high -line range low end afs open afs close dirty scripts simply manage state required track clients les open partial write script performs server-side read-modify-write expected manner complex script sprite write open script straight-forward lines consist simple state list management routines learn table scripts broken constituent commands scripts controlow decisions complex sprite write open sprite write close scripts statements largely composed straight-line code scripts require state afs sprite consistency scripts tcl command count consists retrieving state manipulating form list operations storing state finally type checking library operations comprise substantial component scripts cost breakdown functional breakdown instructive timebased analysis dif cult pinpoint location bottlenecks garner insight instrumented scripts case studies allowing collect detailed information time spent scripts figure presents results investigation gure make number observations scripts invocation overhead accounts substantial portion time execute scripts time consists statements set-up relevant environment script call tcl eval invoke script percentage varies scripts invocation overhead fairly constant varying detailed instrumentation reveals cost roughly two-thirds attributed tcl eval call type checking buffer pointers library commands combine signi amount time scripts current system type check requires call tcl substructure calls expensive future versions cost reduced batching type checks library commands routines primarily called data copy routines manipulate input parameters construct return results overheads dif cult avoid additional communication expensive dwar costs effect observed afs close dirty script experiment breaks single callback client cached copy relevant cost communication script dominates costs finally native routines account reasonable amount time scripts unlike components bar higher percentage native portion bar portion represents direct calls underlying service real work script performs native portion read-if-modi ed-since optimization consists getattr conditional read functions copy data perform type checking pure overhead discussion small code size demonstrated case studies arguments scripting approach extensibility small code segments easier write maintain fewer lines code implies fewer bugs leading cost breakdown tcl scripts time invocation math list ops state mgmt type check library locks comm native read-getattr read-if-mod partial-write afs open afs close sprite 
read sprite open sprite close dir update figure tcl cost breakdown graph depicts percentage time spent script typical scenario bar represents single script labeled x-axis broken categories based operational breakdown table additional item breakdown invocation cost time spent infrastructure tcl script control statements low cost accounted graph absolute execution times script read-getattr read-if-modi ed-since partial-write afs open afs close sprite read callback sprite write open sprite write close directory update measurements ect average runs robust reliable systems experience brought downsides scripting performance conscious tcl programming dif cult analogous process language environments costs arise unexpected sources making dif cult programmers optimize code simple math expression set expr executes roughly pentium-based platforms slight variant set expr extra spaces executes factor slower speci case parsing single argument passed exprcommand faster passing separate arguments cases found subtle differences programming style lead non-trivial differences performance general problem illustrated dif culty programming top system high-level tcl interpreter complex virtual machine dif cult process programming high-performance makes times slower expected related work active gathering storage active storage creating forms communities existing grid literature douglas previous thain work john bent andrea context arpaci-dusseau remzi programming environments arpaci-dusseau miron existing livny rpc-based computer services sciences easily department earliest work wisconsin found madison database west dayton literature street researchers madison sought exploit abstract processing grid capability applications disk demanding arm increase database schedulers performance bring recent jobs efforts data active storage close proximity termed active order disks satisfy studied independently throughput scalability acharya riedel policy requirements acharya systems proposed accomplish specialized stream-based making programming jobs model data parallel mobile applications propose system jobs data meet binding execution storage sites communities participate wide-area system relationships participants community expressed classad framework extensions framework community members express indirect relations demonstrate implementation communities improving performance key high-energy physics simulation international distributed system introduction grid applications demanding applications fields high-energy physics high-throughput access wide selection data files chosen repositories measured petabytes due large number users size data distances involved online access data repositories scalable efficient large numbers jobs systems solve problems generally fallen camps move data job move job data approaches universally applicable suffer scalability problem network storage capacities limits number replicas made number jobs replica propose balance shown figure local area execution sites band communities share research supported part nsf contracts itrand eiaand nasa arc contract ncc permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee november denver copyright acm acm infn figure communities data locally-determined physical limits community hosts storage appliance serve data locally existing wide-area replication system scheduler make number informed choices jobs requesting data moved communities staged data staged community job balance point fixed ratio supportable jobs replicas depends properties application data storage devices networks order structure communities participants express relationships relations direct job require machine cpu indirect job require machine storage device dataset demonstrate classad framework additions indirection express relationships communities traditionally constructed distributed filesystems require special privileges deploy configure present building blocks permit construction communities unprivileged user-level software building blocks communicate state device discovery system discovery system replica short-haul appliance storage long-haul execution site job agent system cpu information placement distributed repository discovery figure model condor distributed batch system places jobs appropriately address matter selecting policies communities policies govern size communities contents storage devices decisions relocate jobs place policies wholly dependent particulars individual applications physical network capacity number cpus hope work mechanisms enable study policies demonstrate feasibility model applying key high-energy physics simulation run international grid constructing communities policies knowledge application demonstrate marked improvement simulation capacity communities building communities community consists cpus gather storage device programs executing cpus encouraged required community device storing retrieving data sharing device similar applications reduce consumption widearea resources communities reflect physical administrative boundaries number cpus effectively served storage device limited connecting network load offered running programs users admitted community depend membership social structures familiar form community distributed file system shared members workgroup sort community semi-permanent require special privileges coordinated software participants contrast services offered grid intended flexible users applications loads change communities set reconfigured torn permit agile deployment communities constructed building blocks applied normal users special privileges accomplish sequential access employ performance storage appliances interposition agents shown buffered figure storage working appliance set serves size meeting place baio community read storage kaio appliance read raw frequently read conceived baio write specialized kaio hardware write raw device write general-purpose computer equipped software serve equally storage appliance appliance speaks number protocols members community select protocol situation application selecting elements database fine-grained block-access protocol conversely application processing large amounts sequential data choose streaming protocol standard applications rarely speak protocols brave users rewrite applications work systems exists random large body programs access wisc performance buffered rewritten problem working condor solved set size interposition pfs agents agent douglas small thain piece baio read software miron ext inserts read kaio read baio write application bypass ext write native tool kaio operating write system agent uilding responsible split converting program ecution standard systems operations oceedings suitable actions community ninth ieee agent symposium place unmodified high applications run grid erformance distrib environment discovering uted communities computing computational pages grid community resources pittsb change warning august environment programs rich douglas methods thain finding communities miron meet multiple bypass determine interposition membership agents community distrib execution uted computing find resources ournal community cluster order computing bring inside actions sudharsan form azhkudai discovery ste refer cpu ueck discovery device discovery ian replica oster discovery figure shows replica form selection discovery fits glob data community grid execution cpu discovery oceedings performed find cpu international proper orkshop architecture operating system data models execution databases device discovery cluster performed find grid membership community execution replica sudharshan discovery performed azhkudai locate ste items job ueck community ian replica discovery oster important replica area selection research recent grid glob efforts data device grid discovery closely related subtly jim aldo jini architecture netw frequently ork-centric employed computing selfconfiguring communications systems jini locate storage human-interface devices mobile software hardware briefly comment difference replica discovery answers question data local storage replica management systems track copies datasets spread storage devices grid dataset retrieved replica management system finds suitable remote copy requestor device discovery answers question local storage device executing jobs discover device offer bandwidth storage space inputs outputs temporary files replica discovery system locate remote data device discovery system locate place put incoming data caller members community find device discovery systems complex define communities simply giving execution site neareststorage propery points storage appliance approach simple effective complex systems imagined execution site storage appliances policy restrictions device access members administrative group case device discovery system query devices return nearest device accepts job indirection critical feature discovery system addition querying direct properties devices user request chain relations user request cpu storage device dataset user storage devices request set cpus set situation change user knowledge user submit request expressing chain indirection language needed express relations scheduling policy management systems concrete represent properties requirements preferences involved community classad language uniquely suited task expressing communities classads classads condor system describe properties requirements preferences participants distributed computing system classads named classified advertisements found newspapers multiple parties publish requests service offers serve well-known place single classad list attribute pairs values simple atoms strings integers complex expressions referring potential matches figures shows job machine represented language describes simple properties machine mentions cpu operating system job mentions executable owner requirements potential match machine accept jobs owned user job accept machines running correct operating system unlike newspaper condor central matchmaking service pairs offers requests suitable match found parties informed individually responsible contacting accomplishing work process bi-lateral matchmaking extensively raman build communities add participant match storage appliance shown figure incoming job requests cpu places indirect requirements storage classad representing cpu decides storage referenced figure shows job specifies indirect requirements field states model applications re-partitioned host disk portions disk runs disklet small piece java code lters data per-record granularity riedel studied parallel applications focusing scan-intensive codes applications partitioned host disks disk runs small portion code lter requests reduce total bandwidth host active disk systems effective supporting variety user-level parallel applications developing general distributed service recently amiri introduced abacus object-oriented framework developing active storage systems abacus similar srpc authors developed distributed object storage system top abacus demonstrated performance bene abacus differs distributed object store built scratch distributed object environment code exists user-level abacus well-integrated kernel mount abacusbased system system calls redirected inside kernel user-level proxy inef cient main strengths abacus approach work dynamically migrated client server depending system workload characteristics similar adaptive framework utilized srpc extensibility srpc related long line work extensible systems pioneered systems spin exokernel vino systems sought enable extensibility operating systems seek enable extensibility rpcbased services lessons learned systems apply srpc techniques vino survive misbehaving kernel extensions directly applicable framework slice virtual service extends services client side interposition introducing client-side packet lters slice build virtual service top existing protocols nfs transparently system clients slice interposition srpc server-side scripting complimentary approaches slice adding activity client srpc adding server suggested utility scripting languages extensible systems direct found choices operating system authors suggest tcl-like scripting language extensions argue exibility safety provided interpreted languages outweigh potential performance loss hypothesis topics investigate paper similarly swarm scalable storage system sends tcl scripts servers order read write data authors state swarm makes feature debugging rpc realm rpc aware system highly similar srpc recent work area concentrates increasing performance exibility rpc substrate reducing code size automatically-generated stubs excellent found work flick exible infrastructure building optimizing rpc layer main goal flick separate cient stub generation speci interface-de nition language idl underlying communication layer work scriptable rpc extended flick framework conclusions current technology trends expect core building blocks future systems signi processing capabilities imperative future distributed services ability effectively leverage active components paper introduced srpc scriptable rpc layer enables system developers migrate existing distributed services active servers designed srpc meet goals essential environment srpc designed provide smooth migration path existing distributed services traditional rpc-based server active server goal accomplished making process developing srpc-based service similar developing service traditional rpc paradigm automating steps enhanced idl compiler srpc engineered high performance srpc caches scripts support concurrent script execution key operations implemented directly efciency srpc targets safe extensibility tcl base scripting language crucial factor meeting goal number case studies demonstrated general bene scfs traditional rpc-based system shown srpc improve client performance scripting client merge operations dependencies single operation client disk reducing number network round-trips demonstrated srpc enables functionality easily integrated system cases original designers foresee bene functionality cases clients desire functionality les finally shown scripts permit operations co-located disk distributed multiple clients acquiring releasing locks avoiding complex code crash recovery distributed failure scenarios evaluation tcl tcl enables development short powerful scripts complex case studies required thirty lines tcl code performance tcl past tcl system extensions scenarios higher performance required specialized domain-speci language active disks worth investigating desirable feature language predictable cost model allowing programmers optimize code direct obvious manner future interesting examine srpc context multiple network-attached disks single server active framework disks communicate cooperate directly implementing advanced features snap-shots lazy redundancy key challenge system provide proper primitives distributed coordination server-side scripts removing burden implementing complex distributed systems protocols ideal storage system future simple collection srpc-enabled disks base primitives distributed computation srpc standard library higherlevel le-system functionality built top exible cient scripting substrate acknowledgments venkateshwaran venkataramani work project early stages skepticism led nement ideas members wind research group input ideas presentation paper csclass lively feedback finally anonymous reviewers excellent thoughtful suggestions greatly improved content paper work sponsored nsf ccrccr- ngsccr- itrand wisconsin alumni research foundation acharya uysal saltz active disks proceedings conference architectural support programming languages operating systems asplos viii san jose october amiri petrou ganger gibson dynamic function placement data-intensive cluster computing proceedings usenix annual technical conference pages june anderson chase vahdat interposed request routing scalable network storage transactions computer systems tocs february berners-lee fielding nielsen gettys mogul hypertext transfer protocol http technical report internet engineering task force january bershad savage przemyslaw pardyak fiuczynski becker chambers eggers extensibility safety performance spin operating system proceedings acm symposium operating systems principles december birrell nelson implementing remote procedure calls acm transactions computer systems february boden cohen felderman kulawik seitz seizovic myrinet gigabitper-second local-area network ieee micro february campbell tan choices objectoriented multimedia operating system workshop hot topics operating systems hotos-v orcas island chen bershad impact operating system structure memory system performance proceedings acm symposium operating systems principles sosp pages asheville december dahlin wang anderson patterson cooperative caching remote client memory improve file system performance proceedings usenix symposium operating systems design implementation 
pages november davis principles software development mcgrawhill denehy arpaci-dusseau arpacidusseau bridging information gap storage protocol stacks proceedings usenix annual technical conference usenix pages monterey june dewitt hawthorn performance evaluation data base machine architectures proceedings seventh annual conference large data bases vldb pages eide frei ford lepreau lindstrom flick flexible optimizing idl compiler pldi las vegas june engler kaashoek toole exokernel operating system architecture application-level resource management proceedings acm symposium operating systems principles december fiuczynski martin bershad culler spine operating system intelligent network adapters technical report tr- washington department computer science engineering august gibson nagle amiri butler chang gobioff hardin riedel rochberg zelenka cost-effective high-bandwidth storage architecture proceedings conference architectural support programming languages operating systems asplos viii october gibson nagle amiri chang feinberg gobioff lee ozceri riedel rochberg zelenka file server scaling network-attached secure disks proceedings acm sigmetrics international conference measurement modeling computer systems pages seattle june gibson nagle amiri chang gobioff riedel rochberg zelenka filesystems network-attached secure disks technical report cmu-cs- carnegie-mellon gokhale schmidt measuring performance corba internet inter-orb protocol atm technical report wucs- washington louis gray storage bricks arrived invited talk usenix conference file storage technologies fast gribble brewer hellerstein culler scalable distributed data structures internet service construction proceedings fourth symposium operating systems design implementation osdi san diego october hartman murdock spalink swarm scalable storage system proceedings ieee international conference distributed computing systems icdcs austin texas june howard kazar menees nichols satyanarayanan sidebotham west scale performance distributed file system acm transactions computer systems tocs february katcher postmark file system benchmark technical report trnetwork appliance october kistler satyanarayanan disconnected operation coda file system acm transactions computer systems tocs february lee thekkath petal distributed virtual disks proceedings seventh conference architectural support programming languages operating systems asplos vii pages cambridge october lowell chen free transactions rio vista proceedings acm symposium operating systems principles sosp pages saintmalo france october mai paaske jayasena dally horowitz smart memories modular recon gurable architecture proceedings annual international symposium computer architecture pages june martin vahdat culler anderson effects communication latency overhead bandwidth cluster architecture proceedings annual international symposium computer architecture pages denver colorado june acm sigarch ieee computer society tcca muthitacharoen chen mazi eres lowbandwidth network file system proceedings acm symposium operating systems principles sosppages accept job banff neareststorage canada october nelson welch ousterhout caching sprite network file system acm transactions computer systems february nester philippsen haumacher cient rmi java proceedings acm java grande conference san francisco california june malley proebsting montz usc universal stub compiler proceedings conference hascmsdata communications true architectures protocols neareststorage evaluated applications sigcomm london august context ousterhout tcl potential embedable cpu command language cpu proceedings simply point usenix nearest association storage winter device address conference unique patterson classads anderson cardwell schemafree fromm single keeton distinct kozyrakis thomas adad yelick cpujob intelligent neareststorage ram iram requirements chips 
lookup matchmaker cpujob storage store match figure matchmaking type job targettype machine cmd sim exe owner thain requirements opsys linux neareststorage hascmsdata figure job classad type machine targettype job raven opsys linux requirements owner thain neareststorage turkey type storage figure machine classad type storage turkey hascmsdata true cmsdatapath cmsdata figure storage classad neareststorage property set constraints identify unique storage classad shown figure rest expression evaluated context referred-to classad contained job evaluates neareststorage hascmsdata true neareststorage cmspath cmsdata neareststorage turkey contents storage appliance change simply sends updated state matchmaker dataset added device jobs require match community dataset removed jobs longer match information matchmaker necessarily stale state cpu storage appliance change match made sides responsibility verifying requirements satisfied claiming protocol successful match policies adding level indirection job storage user freed jobs run user simply state needed order execute jobs state storage devices jobs run user policy policies expressed submit time classad language job boolean requirements expression determines machines suitable execution sites evaluates true execution site accepted rejected integer expression rank potential matches machines requirements evaluates true machine highest rank chosen expressions control jobs move data wait arrive user job move site dataset express requirements neareststorage hascmsdata hand user moving job expensive operation require stay community requirements neareststorage turkey wisc simply prefers run local community require ranks local community ten requirements neareststorage hascmsdata rank neareststorage turkey wisc execution site job system pfsmatchmaking attributeattribute chirp nest nearest hascmsdata neareststorage classad figure implementation machines machines user execute remote local copy eliminate requirements statement complicated information included expression set policy migration permitted job required execute community night network traffic lower requirements neareststorage turkey wisc clockhour clockhour implementation built prototype concepts condor distributed batch system condor cpu scheduling system classad framework interposition agent pluggable file system attach jobs local storage appliance implemented software called nest devices sufficiently general purpose put individually systems nest software creating general-purpose storage appliances commodity computers special privileges externally supports variety network protocols allowing applications choose interact storage made gridftp chirp strong authentication high-throughput transfers variety techniques multiple tcp streams native nest protocol simple rpc-like partial-file access single tcp connection gridftp lingua franca communicating grid services long-haul connections chirp short-haul partial-file access require overhead tcp connection data operation pfs interposition agent constructed bypass pfs adapts legacy applications storage systems mounting jia application view ang file system surv special privileges web kernel-level caching required schemes number standard network protocols including gridftp chirp internet supported pfs computer loaded communication unmodified unix vie programs interact nest running october turkey wisc chirp white turkey wisc grimsha file system nguyen-t cpu uong selection grid-based file device access parameters gion application condor model classad property oceedings job execution site ieee inserted symposium program high environment erformance variables distrib arguments uted run systems time macro-expanding august expressions beginning dollar signs eong arguments chirp neareststorage wes input data condor kille understands lightweight executable directory consist access single protocol file submit request pfs-enabled comments application condor internet resort engineering task force march ictor zandy barton miller miron process hijacking trick oceedings submitting self-extracting archive ieee application international pfs symposium script invoke high properly erformance distrib level uted indirection computing step eop omitting application trailer archive end userdict modifying end-hook script end-hook fetch eof 
executable remember compute ieee international solid-state circuits conference san francisco february riedel gibson faloutsos active storage large-scale data mining multimedia proc international conference large databases vldb august romer lee voelker wolman wong baer bershad levy structure performance interpreters proceedings seventh international conference architectural support programming languages operating systems pages cambridge massachusetts october acm sigarch sigops sigplan seltzer endo small smith dealing disaster surviving misbehaved kernel extensions proceedings usenix symposium operating systems design implementation october small seltzer comparison extension technologies proceedings usenix annual community technical conference january srinivasan pfs mogul spritely technique nfs experiments retrieve common cache-consistency executable protocols local proceedings appliance twelfth finally acm symposium noted operating systems principles users pages classads acm december prepared order handle stale match thekkath suppose stale mann information job match lee frangipani scalable distributed file system proceedings community longer acm symposium needed operating dataset systems pfs principles discover sosp file pages found saint-malo error france performs october transaction nearest processing nest council simply tpc passing benchmark error standard speci application cation incorrect revision technical report von eicken basu exit buch error vogels message u-net forcing user-level user network interface manually understand parallel error distributed resubmit computing job proceedings correct fifteenth action acm symposium pfs operating systems application principles exit pages abnormally kill copper process signal mountain resort condor usa interprets von signal eicken culler execution aborted goldstein re-queue schauser job active messages execution attempt performance mechanism demonstrate integrated communication implementation computation chosen proceedings examine simulation component cms experiment performed cern large experiment documented users italy united states make heavy application condor pools istituto nazionale fisica nucleare infn wisconsin began assuming role annual symposium computer scientist architecture infn gold wishes coast australia execute large number welsh instances culler simulation infn pool equipped achieving robust scalable cluster java lcr workshop languages compilers run-time systems scalable computers rochester 
fair number cpus competition users pool limits thirty additional cpus leveraged explored deployment communities order solve problem application viewed perspective system cms simulation works reads input file instructions reads variety files database directory database provided application consists mixture input files data files libraries source files user conceivably determine exact set database files needed run simulation experience care citing cost analysis expensive dealing data files needed trivially predictable input sake application assume arbitrary simulation run access entire directory trimmed libraries source database yielding directory directories symbolic links files chose sample run simulation input file reads total input files database directory generates output files executable compresses network transfer mips machine local storage sample runs seconds simulation executable directly submitted system self-extracting archive pfs script submitted execution site script downloaded simulation executable storage appliance invoked arguments sample run representative real cms higher cpu ratio real run typically simulation runs hours minutes chosen shorter run reasons primarily push envelope system open condor applications greater demands secondarily consume excessive amounts resources allocated real simulations progress environment condor pools infn employed running simulations pool configured distinct community infn condor pool consisted cpus time processing power cpus ranged mips memory ranged cpus physically spread country departments institution workstation providing mips memory established bologna storage appliance infn community variety networks ranging connected execution sites storage appliance condor pool consisted cpus reserved reserved cpus provided mips memory identical machine established storage appliance community reserved machines connected appliance dedicated ethernet switch communities connected public internet bandwidth path varied latency measurements began assuming executables data files stored workstation infn workstation installed instance condor submitting jobs instance nest serve input data provide output space moving collection site site reproducing symbolic links important archive size swells jobs completed elapsed time infn local number cpus allocated elapsed time infn local figure infn community figure details execution batch jobs running infn community left-hand graph shows number jobs completed time progresses right-hand graph shows number cpus function time jobs completed elapsed time local stage remote number cpus allocated elapsed time local stage remote figure community figure details execution batch jobs running community left-hand graph shows number jobs completed time progresses right-hand graph shows number cpus function time line represents discipline note anomalies remote discipline elapsed times seconds artifact number machines bandwidth storage appliance shared fairly jobs finish approximately time delay incurred jobs start complete anomalies present disciplines pronounced due decreased time fetch executable input files jobs completed elapsed time infn local local infn local stage infn local remote number cpus allocated elapsed time infn local local infn local stage infn local 
remote figure communities figure details execution batch jobs running simultaneously communities lefthand graph shows number jobs completed time progresses right-hand graph shows number cpus function time line represents discipline anomalous behavior infn local remote lines due phenomenon figure infn local remote stage local infn local remote infn local stage infn local local time secs figure completion time graph shows execution time simulations configuration lower values turnaround time user perspective infn local remote stage local infn local remote infn local stage infn local local time secs figure ninety-five percent completion time graph shows percent completion time simulations configuration lower values response time user perspective infn local remote stage local infn local remote infn local stage infn local local time secs figure average cpu consumption graph shows average cpu time consumed jobs configuration lower values efficient resources system perspective benchmark capacity infn pool submitted simulation jobs completed shown figure run number machines fluctuates inevitable property distributed system involving hundreds users changing minds machines make steady progress roughly job seconds explored feasibility cpus cpus reserved submitted jobs pool configurations results shown figure case labelled remote jobs performed appliance infn larger number cpus run faster jobs constrained small bandwidth address situation deployed nest pool switch reserved cpus cpus updated advertise members community jobs submitted constraint run cms data machines immediately satisfied requirement satisfy manually staged data appliance instructed advertise contents procedure roughly seconds jobs run completed shown stage case accounting time transfer stage case marginally faster remote case future executions advantage already-transferred data run shown local case fourth configuration measured shown figure configuration combined stage remote models performed stage database concurrently allowing jobs execute remote idea staging operation complete jobs access data locally bandwidth remote server shared stage operation jobs jobs finished stage completed additionally due bandwidth contention jobs finished slowly remote configuration note local community executable database files fetched local storage appliance processspecific input files syncronoulsy fetched storage appliance submission site output files delivered finally made communities concert results shown figure infn local remote case jobs run communities performing appliance submitting host number cpus high bandwidth constraints limited performance infn local stage case jobs run infn community data staged stage completed end run whereopon large number cpus finished remaining jobs yielding increase performance finally data community run jobs match community shown infn local local case evaluation evaluate configurations points view users generally concerned completion time workload system operators generally concerned efficient resources consumed user perspective summarized figure graph shows completion time job configuration general applying cpus run yields faster results larger numbers cpus provide marginal improvement remotely localized yields faster results figures show configuration completes large fraction jobs quickly completion delayed small number jobs end execution compare configurations disregarding contributions long tail examining completion time ninety-five percent jobs shown figure examined jobs long tails discovered distinct sources delay cases jobs starved input phase enter computation phase competition decreased jobs late run evicted execution sites owners returning workstations jobs simply longer execution times due competition local users cpu memory network capacity problem starvation suggests examination fairness storage appliance problems difficult address eliminated tightly-controlled environment ever-present feature large-scale grid computing large computation performed resources partially shared receive interference performance users long tail prevented executing multiple copies jobs number outstanding number cpus operator perspective summarized figure graph shows average cpu consumption job configuration figure arrived dividing allocated cpu time number jobs run efficient configurations involve localized remote improvement completion time holds cpus idle waiting yielding poor efficiency performance configuration parameters runs stage cases provide improvement time transfer datasets execution time jobs performing remote details execution surprising figures remote cases incur dramatic delays frequency job completion drops drastically reflected drops cpu allocation cases occurred large numbers jobs previously contending completed examination submitter logfile shows condor start jobs quickly completed due overhead re-transferring self-extracting archive newly started job alleviated cache execution site major obstacle throughput application related work simple distributed systems make centralized server connect jobs data canonical network file system nfs analogue grid computing condor remote system call facility running job performs remote procedure calls back orginating computer central-server models limited scalability number clients limited aggregate bandwidth provided central server performance individual clients limited bandwidth latency network reliability system decreases number networks participants increases systems address difficulties copying data site job execution andrew file system afs scale larger client server ratio nfs analogue grid computing globus gass system files fetched distributed repositories stored locally longer referenced hierarchical data grids expand idea trees servers replicate data production site jobs data moved orthogonal question data located note system matches data jobs data type resource applications require discovery data arbitrary types resources replica management system track data locations storage resource broker srb pulls pieces provide coherent view multiple replication sites arrangement communities similar shared web proxy cache web clients fixed location option choosing proxy run large body research software general resource discovery projects include jini replica catalogs ldap snmp recent peer-to-peer file sharing protocols napster gnutella advantage classad framework condor unique ability integrate resource discovery scheduling classads resource discovery contexts vazhkudai describe classads match jobs storage devices model replica manager consulted discover list replicas matchmaking performed find storage device job submitted execution bound discovered device assumed distribution replicas change lookup basney describe classads execution domains model execution sites bind checkpoint servers jobs write checkpoints nearest server express policy controlling migrate checkpoint image contribution classads introduce indirection model jobs express constraints storage devices execution site declare binding storage storage referred member match promised exclusively requesting job contrast gang-matching classads raman multiple entities exclusively promised arrangement organization limited number licenses run proprietary software case gangmatching match licenses machines jobs ensure licensing agreements violated variety research ventures exploring storage devices names nasd active disks flash ibp buffer servers commercial vendors netapp emc offer storage servers hardware package making nest easily deployable software appliance speaks protocols suitable grid computing run special privilege wide variety mechanisms building interposition agents proposed including system call interception static relinking binary rewriting emulation existing interface making bypass due low overhead ability special privileges conclusion communities natural structures localizing application 
grid binding cpus storage organizations reflect physical reality increase performance applications utilization systems users ability express relations participants community indirect relations user express requirements storage cpu classad framework extensions indirection well-suited describing managing communities employing general-purpose building blocks condor nest pfs demonstrated easy deployment communities special privileges deploying reasonable configuration improved throughput high-energy physics simulation avenues future work configuration communities left human ratio cpus storage appliance depends offered loads physical constraints envision higher-level software reconfigure communities deploying removing storage appliances load static set communities user find difficult choose policy jobs move data vice versa mechanisms admit possibilities select trigger moves current staging mechanism complete transfer data files future investigate caching policies finer granularity data transfer instance files dataset demand fetched cached local storage appliance similar configuration tested jobs execute remotely complete stage dataset case found performance low due bandwidth contention executing jobs stage operation level file sharing sufficiently high demand caching outperform staging data finally concentrated problems delivering input data efforts condor research group kangaroo address problems reliably moving output data distant destination data movement asyncronously remotely executing jobs vacate execute machines quickly combination kangaroo communities address grid applications beginning end acknowledgements vladimir litvin assistance advice cms software paolo mazzanti offering dedicated nest machine generally making infn condor pool albert alexandrov maximilian ibel klaus schauser chris scheiman ufo personal global file system based user-level extensions operating system acm transactions computer systems pages august bill allcock joe bester john bresnahan ann chervenak ian foster carl kesselman sam meder veronika nefedova darcy quesnel steven tuecke secure efficient data transport replica management high-performance data-intensive computing submitted william allcock ann chervenak ian foster carl kesselman charles salisbury steve tuecke data grid architecture distributed management analysis large scientific datasets journal network computer applications anderson yocum chase case buffer servers proceedings ieee workshop hot topics operating systems hotos april baru moore rajasekar wan sdsc storage resource broker proceedings cascon toronto canada jim basney miron livny paolo mazzanti utilizing widely distributed computational resources efficiently execution domains submitted computer physics communications john bent andrea arpaci-dusseau remzi arpaci-dusseau miron livny nest project http nestproject joseph bester ian foster carl kesselman jean tedesco steven tuecke gass data movement access service wide area computing systems proceedings sixth workshop input output parallel distributed systems pages andrew birrell bruce jay nelson implementing remote procedure calls acm transactions computer systems februrary case fedor schoffstall davin simple network management protocol request comments internet engineering task force emc corporation http emc garth gibson david nagle khalil amiri fay chang eugene feinberg howard gobioff chen lee berend ozceri erik riedel david rochberg case network-attached secure disks technical report cmu-cs- carnegie-mellon gnutella http gnutella wego hitz storage networking appliance technical report network appliance howard kazar menees nichols satyanarayanan sidebotham west scale performance distributed file system acm transactions computer systmes february galen hunt doug brubacher detours binary interception win functions technical report msr-tr- microsoft research february network appliance http netapp michael jones interposition agents transparently interposing user code system interface proceedings acm symposium operating systems principles pages litzkow 
remote unix turning idle workstations cycle servers proceedings usenix summer conf pages michael litzkow miron livny matthew mutka condor hunter idle workstations proceedings international conference distributed computing systems pages napster http napster pai druschel zwaenepoel flash efficient portable web server proceedings usenix technical conference plank beck elwasif moore swany wolski internet backplane protocol storage network proceedings network storage symposium rajesh raman matchmaking frameworks distributed resource management phd thesis wisconsin october rajesh raman miron livny marvin solomon matchmaking distributed resource management high throughput computing proceedings seventh ieee international symposium high performance distributed computing july rajesh raman miron livny marvin solomon resource management fail-stutter fault tolerance remzi arpaci-dusseau andrea arpaci-dusseau department computer sciences wisconsin madison abstract traditional fault models present system designers extremes byzantine fault model general difficult apply fail-stop fault model easier employ accurately capture modern device behavior address gap introduce concept fail-stutter fault tolerance realistic tractable fault model accounts absolute failure range performance failures common modern components systems built fail-stutter model perform highly reliable easier manage deployed introduction dealing failure large-scale systems remains challenging problem designing systems form backbone internet services databases storage systems account possibility likelihood components cease operate correctly handles failures determines system performance availability manageability traditionally systems built fault models extreme byzantine failure model lamport component exhibit arbitrary malicious behavior involving collusion faulty components assumptions contexts security make difficult reason system behavior extreme tractable pragmatic approach exists fail-stop model limited approach defined schneider response failure component state permits components detect failure occurred stops component working component fails components immediately made aware problem byzantine model general difficult apply problem fail-stop model simple account modern device behavior model realistic tractable fail-stop model good starting point model enhanced order account complex behaviors modern components main reason enhancement order increasing complexity modern systems latest pentium million transistors future hardware promises complexity advent intelligent devices software code bases mature code size increases complexity linux kernel source increased factor ten increasing complexity directly affects component behavior complex components behave simple predictable ways identical disks made manufacturer receiving input stream necessarily deliver performance disks purveyor erratic performance discuss document similar behavior observed hardware software components systems built fail-stop illusion prone poor performance deployed performing working perfectly failing deliver good performance single component behave expected vulnerable systems make static parallelism assuming components perform identically striping raid techniques perform disk system delivers identical performance performance single disk consistently lower rest performance entire storage system tracks single slow disk parallel-performance assumptions common parallel databases search engines parallel applications account modern device behavior model fault behavior model account components fail perform erratically term unexpected low performance component performance fault introduce fail-stutter fault model extension fail-stop model takes performance faults account focus fail-stutter model component performance fail-stutter model building systems manageable reliable allowing plug-and-play operation incremental growth worry-free replacement workload modification fail-stutter fault tolerant systems decrease human intervention increase manageability diversity system design enabled reliability improved finally fail-stutter fault tolerant systems deliver consistent performance improves availability paper build case fail-stutter fault tolerance examination literature discuss fail-stutter model benefits review related work conclude erratic behavior systems section examine literature document places performance faults occur note list illustrative means exhaustive survey find device behavior increasingly difficult understand predict cases erratic performance detected investigated discovered hinting high complexity modern systems interestingly performance variations research papers well-controlled laboratory settings running single application homogeneous hardware speculate component behavior lesscontrolled real-world environments worse hardware begin investigation performance faults caused hardware focus important hardware components processors caches disks network switches case increasing complexity component time led richer set performance characteristics processors caches fault masking processors fault masking increase yield allowing slightly flawed chip result chips characteristics sold identical viking series processors sun examined authors measure cache size set viking processors micro-benchmark single ssis base case graphs reveal effective size level cache direct-mapped specifications suggest level-one data cache size -way set associativity chips produced portions caches turned produced times study measured application performance vikings finding performance differences pa-risc fault-masking cache schneider reports cache mechanism maps bad lines improve yield fault-masking present modern processors vaxhad -way set associative cache turn sets failure detected similarly vaxhad directmapped cache shut cache fault finally univac ability shut portions cache faults prediction fetch logic processor prediction instruction fetch logic complex parts processor performance characteristics sun ultrasparc-i studied kushman finds implementation next-field predictors fetching logic grouping logic branch-prediction logic lead unexpected run-time behavior programs simple code snippets shown exhibit nondeterministic performance program executed processor identical conditions run times vary factor kushman discovered anomalies anomalies remains unknown replacement policy hardware cache replacement policies lead unexpected performance work replicated fault-tolerance bressoud schneider find tlb replacement policy processors non-deterministic identical series location-references tlb-insert operations processors running primary backup virtual machines lead tlb contents reason non-determinism surprised numerous engineers disks fault masking disks perform degree fault masking documented simple bandwidth experiment shows differing performance -rpm seagate hawk drives disks deliver sequential reads disk delivered lesser-performing disk times block faults devices author hypothesizes scsi bad-block remappings transparent users file systems culprit bad-block remapping technique early operating systems univac series record tracks disk faulty avoid subsequent writes disk timeouts disks tend exhibit sporadic failures study -disk farm -month period reveals largest source errors system scsi timeouts parity problems scsi timeouts parity errors make errors network errors removed figure rises error instances examining data ascertain timeout parity error occurs roughly times day average errors lead scsi bus resets affecting performance disks degraded scsi chain similarly intermittent disk failures encountered bolosky noticed disks video file server off-line random intervals short periods time apparently due thermal recalibrations geometry previous discussions focus performance fluctuations devices performance differential present single disk documented disks multiple zones performance zones differing factor static examples disks treated identically disks layouts performance characteristics unknown careful research uncover performance problems work external sorting rivera chien encounter disk performance irregularities machines cluster tested revealed slower performance excluded subsequent experiments study ibm vesta parallel file system reveals results shown measurements obtained typically unloaded system cases small variance measurements cases variance significant cases typically cluster measurements gave near-peak results measurements spread widely low peak performance network switches deadlock switches complex internal mechanisms problematic performance behavior author describes recurring network deadlock myrinet switch deadlock results structure communication software waiting long packets form logical message deadlockdetection hardware triggers begins deadlock recovery process halting switch traffic seconds unfairness switches behave unfairly high load load myrinet switch routes receive preference result nodes disfavored links slower sender fully capable receiving data link rate work unfairness resulted slowdown global adaptive data transfer flow control networks internal flowcontrol mechanisms lead unexpected performance problems brewer kuszmaul show effects slow receivers performance all-to-all transposes cmdata network study receiver falls messages accumulate network excessive 
network contention reducing transpose performance factor software unexpected performance arises due hardware peculiars behavior important software agent common culprit operating system management decisions supporting complex abstractions lead unexpected performance surprises manner component exhibit poor performance occurs application time problem acute memory swaps data disk over-extended operating systems virtual machines page mapping chen bershad shown virtual-memory mapping decisions reduce application performance virtually machines today physical addresses cache tag cache small page offset cache tag allocation pages memory affect cache-miss rate file layout simple experiment demonstrates file system layout lead non-identical performance identical disks file systems sequential file read performance aged file systems varies factor file systems empty file systems recreated afresh sequential file read performance identical drives cluster background operations work fault-tolerant distributed hash table gribble find untimely garbage collection node fall mirror replicated update result machine over-saturates bottleneck background operations common systems including cleaners log-structured file systems salvagers heuristically repair inconsistencies databases interference applications memory bank conflicts work scalar-vector memory interference authors show perturbations vector stream reduce memory system efficiency factor memory hogs recent paper brown mowry show effect out-of-core application interactive jobs response time interactive job multilateral matchmaking proceedings ninth ieee symposium high performance distributed computing pages pittsburgh august riedel gibson active disks remote execution network-attached storage technical report cmu-cs- carnegie-mellon asad samar heinz stockinger grid data management pilot iasted international conference appliaed informatics february russel sandberg david goldberg steve kleiman dan walsh bob lyon design implementation sun network filesystem proceedings summer usenix conferece pages douglas thain jim basney se-chang son miron livny kangaroo approach data movement grid proceedings tenth ieee symposium high performance distributed computing san francisco california august douglas thain miron livny pluggable file system http wisc condor pfs douglas thain miron livny bypass tool building split execution systems proceedings ninth ieee symposium high performance distributed computing pages pittsburg august douglas thain miron livny multiple bypass interposition agents distributed computing journal cluster computing sudharsan vazhkudai steve tuecke ian foster replica selection globus data grid proceedings international workshop data models databases clusters grid sudharshan vazhkudai steven tuecke ps-adobecreator dvipsk copyright radical eye software title hpca dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic courier endcomments dvipscommandline dvips hpca ian hpca foster dvipsparameters replica dpi selection comments removed globus dvipssource data tex grid output jim beginprocset tex waldo pro texdict jini dict architecture texdict begin network-centric bind computing communications exch translate acm isls jia false wang vsize survey mul web caching hsize mul schemes landplus false internet acm rigin computer isls communication landplus review ifelse concat october white resolution div grimshaw vresolution div neg nguyen-tuong scale grid-based isls file landplus access vresolution legion div vsize model mul exch proceedings resolution div ieee hsize symposium mul ifelse high performance resolution distributed vresolution systems vsize div august add mul yeong matrix howes currentmatrix dup dup round abs kille round lightweight forall directory round access exch protocol round request exch setmatrix comments landscape internet isls true engineering task manualfeed force statusdict march manualfeed victor true put zandy barton copies copies miller fmat miron livny process fbb hijacking proceedings ctr df-tail ieee international dict symposium begin high fonttype performance fontmatrix distributed fntrx computing 
fontbbox fbb string base array bitmaps buildchar charbuilder encoding end dup foo setfont array shown copy cvx load times worse put ctr competing memory-intensive fntrx process fmat df-tail memory dfs resources div cpu hogs fntrx similarly interference neg cpu df-tail resources leads pop dup unexpected definefont slowdowns setfont ch-width sorting ch-data dup study length performance now-sort ch-height ch-data sensitive dup length disturbances ch-xoff requires ch-data dedicated dup system length achieve peak ch-yoff results ch-data dup length node excess cpu ch-dx load ch-data reduces dup global length sorting performance ch-image factor ch-data dup type summary stringtype ctr documented ctr cases ctr add components exhibit unexpected performance hardware software charbuilder components increase save roll complexity dup base index perform internal error correction fault masking bitmaps performance characteristics ch-data depending pop load ctr usage ch-dx ch-xoff ch-yoff behave ch-height ch-xoff nondeterministically ch-width note add ch-yoff short-term performance setcachedevice ch-width fluctuations ch-height occur true randomly ch-xoff components ch-yoff ch-image imagemask harmful restore slowdowns dup type long-lived stringtype occur base subset ctr put components bitmaps types ctr faults dup handled dup length traditional dup methods index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore showpage userdict eop-hook eop-hook start userdict start-hook start-hook pop vresolution resolution div dvimag array string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail incorporated model component behavior fail-stutter fault tolerance section discuss topics central fail-stutter model fully formalized model outline number issues resolved order cover discuss potential benefits utilizing fail-stutter model fail-stutter model discuss issues central developing failstutter model focus main differences rmoveto fail-stop model separation performance faults correctness faults notification components presence performance rmoveto fault roll system bos performance save specifications eos restore component separation end endprocset performance faults beginprocset texps correctness pro faults texdict begin findfont dup fail-stutter model length add distinguish dict begin classes index fid faults absolute index uniqueid correctness faults pop pop performance ifelse faults forall index scenarios roll exec exch manner roll vresolution deal resolution div correctness mul faults neg total metrics disk exch processor dict begin failure encoding utilize exch dup fail-stop type model integertype schneider pop considers pop component dup faulty pop ifelse behavior fontmatrix longer div consistent metrics div specification ifelse forall response metrics metrics correctness currentdict failure end component index currentdict state end definefont permits roll components makefont setfont detect load cvx failure obliqueslant component dup stops sin operating cos div addition neg slantfont index mul fail-stutter add model extendfont incorporate roll notion mul exch performance failure reencodefont encoding combined exch end completes endprocset fail-stutter beginprocset model special pro texdict component begin sdict considered dict performance-faulty sdict absolutely failed begin defined specialdefaults performance hsc vsc performance ang specification clip rwiseen separation false performance rhiseen false correctness letter faults note crucial model legal scaleunit gained hscale utilizing scaleunit div performance-faulty hsc components vscale cases scaleunit devices div vsc perform hsize large clip fraction vsize expected rate clip components clip behave clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury treating magscale true absolutely failed end components macsetup leads userdict large waste userdict system resources type dicttype difficulty userdict begin addressed length occurs add maxlength component responds dup arbitrarily length slowly add dict request copy case end performance begin fault letter note blurred legal correctness txpose fault mtx distinguish defaultmatrix dtransform cases atan model newpath include clippath mark performance transform threshold itransform moveto definition transform itransform correctness lineto fault roll transform disk request roll takes transform longer roll seconds transform service itransform roll absolutely itransform roll failed performance itransform faults roll fill curveto closepath rest pathforall newpath regime counttomark array device astore working xdf pop notification put components major departure courier fnt invertflag fail-stop model paintblack txpose pxs pys scale ppr components aload pop por informed noflips pop performance neg failures pop occur scale xflip yflip reasons pop neg erratic performance occur frequently distributing information overly expensive performance failure perspective component manifest failure caused bad network link component persistently performance-faulty system export information component performance state allowing agents system readily learn react performance-faulty constituents performance specifications difficulty arises rotate defining scale ppr fail-stutter model ppr arriving neg neg performance ppr specification ppr components neg system neg ideally xflip yflip fail-stutter pop model neg present pop system rotate ppr designer ppr trade-off neg neg extreme model yflip xflip component performance ppr neg simple ppr neg disk noflips delivers pop bandwidth pop rotate scale simpler xflip yflip model pop pop performance rotate faults occur scale ppr ppr performance neg deviates neg ppr expected ppr level neg neg assumptions xflip yflip made system pop designer pop rotate allowed ppr flexibility ppr neg drawing neg attention yflip fact xflip devices pop perform pop rotate expected ppr designer ppr neg good neg model ifelse scaleby performance ppr faults aload occur pop roll long add div roll add div environment copy component dup scale specific neg strongly influence neg system pop built pop react showpage restore failures end normalscale sketch resolution div fail-stutter model vresolution div neg scale employed magscale simple dvimag dup scale setgray assumptions psfts performance faults div specifically starttexfig psf scenarios savedstate save order userdict increasingly maxlength realistic dict performance begin magscale assumptions true normalscale omit currentpoint details psf ury complete psfts psf designs urx hope psfts psf illustrate lly psfts psf fail-stutter llx model psfts psf utilized psfts enable psf psfts robust system currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div construction psf assume ury workload showpage consists erasepage writing copypage data blocks parallel macsetup set doclip psf llx disks psf lly data psf urx encoded psf ury disks currentpoint roll newpath raidfashion copy roll pair moveto disks roll treated lineto lineto raidmirrored lineto pair closepath clip data newpath blocks moveto striped endtexfig end psf mirrors savedstate restore raidin beginspecial sdict scenario begin specialsave save fail-stop gsave model normalscale assuming currentpoint naively specialdefaults count performance ocount faults dcount countdictstack occur setspecial absolute clip failures newpath accounted moveto handled rlineto rlineto absolute neg failure rlineto occurs closepath clip single disk hsc vsc detected scale ang operation rotate continues rwiseen rwi urx llx reconstruction div initiated rhiseen rhi hot ury spare lly disks div dup ifelse mirror-pair scale fail llx operation neg lly neg halted performance faults considered design pair disk number blocks write performance fault occurs pairs time write storage determined slow pair assuming disk-pairs write disk-pair write perceived throughput reduced rhiseen scenario rhi ury addition lly absolute div faults dup scale llx performance neg faults lly neg static ifelse nature clip newpath llx assume lly moveto performance urx lly mirror-pair lineto urx ury stable lineto llx time ury lineto closepath clip uniform showpage disks erasepage copypage design newpath compensate endspecial count difference ocount option pop repeat gauge countdictstack performance dcount end disk repeat grestore specialsave installation restore end defspecial ratios sdict stripe begin data fedspecial proportionally end lineto mirror-pairs rlineto rcurveto pair disks savex perform currentpoint similarly savey rate setlinecap newpath mirror stroke savex determined savey moveto rate fil slowest fill disk savex savey moveto single slow ellipse disk endangle system startangle correctly yrad gauges xrad performance write savematrix throughput matrix increases currentmatrix xrad yrad scale startangle disk endangle arc perform savematrix setmatrix expected end time endprocset performance texdict tracks slow disk begin hpca finally dvi start scenario general times-roman performance faults include disks perform arbitrary rates time design option continually gauge performance write blocks mirrorpairs proportion current rates note approach increases amount bookkeeping proportions change time controller times-roman record block written times-bold increasing complexity create system robust times-roman deliver full bandwidth wide range performance faults benefits fail-stutter important consideration introducing model component behavior effect systems utilized model systems reliable manageable systems built tolerate fail-stop failures manageability times-bold manageability fail-stutter fault tolerant system fail-stop system reasons fail-stutter fault tolerance enables true plug-and-play system administrator adds component system times-italic performance additional involvement operator true futz system system incrementally grown allowing newer faster components added adding faster components times-roman incrementally scale system handled naturally older components simply performance-faulty versions administrators longer stockpile components courier anticipation discontinuation finally workloads imbalances bring introduced system fear imbalances handled performance-fault tolerance mechanisms times-bold cases human intervention reduced increasing times-roman manageability van jacobson experience shows configured misconfigured removing times-italic intricate tuning problems caused times-bold misconfiguration eradicated availability gray reuter define availability fraction offered load processed times-roman acceptable response times system utilizes fail-stop model deliver poor times-roman performance end endprolog single beginsetup performance feature failure resolution dpi performance texdict begin meet endsetup threshold page availability bop decreases contrast microbenchmark-b system ase takes performance extraction failures local account global deliver disk consistent high performance characteristics increasing nisha availability alagala reliability remzi fail-stutter model arpaci-dusseau improve vid system reliability atterson computer ways science design diversity vision desirable uni property large-scale systems including components ersity california berkele makes abstract manufacturers problems obtaining occur timely collection accur identical ate components information suffer identical design flaw low-le avoided vel gray har reuter acteristics state design diversity disk akin drives belt esents suspenders belts oblem suspenders system system design handles performance implementation faults naturally alike works paper parts esents reliability collection enhanced thr detection disk micr performance obenc anomalies hmarks erratic whic performance early combine indicator impending empirically failure xtr related act work experience ele vant o-intensive subset application disk geometry programming clusters performance convinced par erratic ameters performance norm cient large-scale systems accur ate manner equiring system priori support information building robust drive programs measur needed began work river benc programming hmarks environment mechanisms 
utilization enable consistent high performance spite erratic performance underlying components focusing disks river handle absolute correctness faults integrated fashion relying retry-after-failure checkpointrestart package river requires applications completely rewritten enable performance robustness situations researchers realized model fault behavior simple fail-stop earliest aware shasha turek work slow-down failures authors design algorithm runs transactions correctly presence failures simply issuing processes work reconciling properly avoid work replication authors assume behavior occur due network congestion processes slowed workload interference assume fail-stop model disks dewitt gray label periodic performance fluctuations hardware interference characterize nature problems realize potential impact parallel operations birman recent work bimodal multicast addresses issue nodes stutter context multicast-based applications birman solution change semantics multicast absolute delivery requirements probabilistic gracefully degrade nodes begin perform poorly networking literature replete examples adaptation design variable performance prime tcp similar techniques employed development adaptive fail-stutter fault-tolerant algorithms conclusions systems built assuming components identical component behavior static unchanging nature component works assumptions dangerous increasing complexity computer systems hints future components behave differently behave dynamic oft-changing large range normal operation falls binary extremes working working utilizing fail-stutter model systems manageable reliable work deployed real world challenges remain fail-stutter model formalized models component behavior developed requiring measurement existing systems analytical development adaptive algorithms cope difficult class failures designed analyzed implemented tested true costs building system discerned approaches evaluated step direction exploring construction fail-stutter-tolerant storage wisconsin network disks wind project investigating adaptive software techniques central building robust manageable storage systems encourage fail-stutter model endeavors acknowledgements people comments earlier versions paper david patterson jim gray david culler joseph hellerstein eric anderson noah treuhaft john bent tim denehy brian forney florentina popovici muthian sivathanu anonymous reviewers thoughtful suggestions work sponsored nsf ccrand nsf ccrreferences acharya uysal saltz active disks asplos viii san jose oct arpaci dusseau vahdat process management network workstations http berkeley remzi -final arpaci-dusseau arpaci-dusseau wisconsin network disks project http wisc wind arpaci-dusseau arpaci-dusseau bent forney muthukrishnan popovici zaki manageable storage adaptation wind ieee int symposium cluster computing grid ccgrid arpaci-dusseau arpaci-dusseau culler hellerstein patterson searching sorting record experiences tuning now-sort spdt aug arpaci-dusseau performance availability networks workstations phd thesis california berkeley arpaci-dusseau anderson treuhaft culler hellerstein patterson yelick cluster river making fast case common iopads birman hayden ozkasap xiao bidiu minsky bimodal multicast tocs bolosky iii draves fitzgerald gibson jones levi myhrvold rashid tiger video fileserver technical report microsoft research bressoud schneider hypervisor-based fault tolerance sosp dec brewer inktomi web search engine invited talk sigmod brewer kuszmaul good performance cmdata network proceedings international parallel processing symposium cancun mexico april brown mowry taming memory hogs compiler-inserted releases manage physical memory intelligently osdi san diego october chen bershad impact operating system structure memory system performance proceedings acm symposium operating systems principles pages december corbett feitelson vesta parallel file system acm transactions computer systems august dewitt ghandeharizadeh schneider bricker hsaio rasmussen gamma database machine project ieee transactions knowledge data engineering march dewitt gray parallel database systems future high-performance database systems communications acm june fox gribble chawathe brewer gauthier cluster-based scalable network services sosp pages saint-malo france oct gray reuter transaction processing concepts techniques morgan kaufmann gribble brewer hellerstein culler scalable distributed data structures internet service construction osdi san diego october intel intel pentium architecture product briefing home page http developer intel design pentium prodbref january jacobson congestion avoidance control proceedings acm sigcomm pages august jacobson kill internet ftp ftp lbl gov talks vjwebflame kushman performance nonmonotonocities case study ultrasparc processor master thesis massachussets institute technology boston lamport shostak pease byzantine generals problem acm transactions programming languages systems july meter observing effects multi-zone disks proceedings usenix conference jan patterson anderson cardwell fromm keeton kozyrakis thomas yelick intelligent ram iram chips remember compute ieee international solid-state circuits conference san francisco february patterson gibson katz case redundant arrays inexpensive disks raid sigmod pages chicago june acm press raghavan hayes scalar-vector memory interference vector computers international conference parallel processing pages charles august rivera chien high speed disk-to-disk sort windows cluster running hpvm submitted pulication rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february satyanarayanan digest hotos vii http rice conferences hotos digest march schneider implementing fault-tolerant services state machine approach tutorial acm computing surveys december schneider personal communication february scott burkhart kumar blumberg ranson four-way superscalar pa-risc processors hewlettpackard journal august shasha turek fail-stop wait-free serializability resiliency presence slow-down failures technical report computer science department nyu september siewiorek swarz reliable computer systems design evaluation peters edition talagala patterson analysis error behaviour large storage system ipps workshop fault tolerance parallel distributed systems 
linearly-increased stride glean spectrum low-le vel details including head-switc cylinder switc times factoring otational fects bandwidth benc 
hmark xtr acts zone disks vealing viously eferr linear model zone bandwidth accur ate quadr atic model seek gener ated completing trio benc hmarks data collected oad class modern disks including scsi ide simulated drives intr oduction theories fundamental data remains mary leakey sustained inno ation hard-dri industry spurred incredible adv ances disk technology perfor mance capacity bene ted bandwidth increasing sixty percent year capacity gro wing rate disk dri industry quickly dri appears market ery twelv months due rapid olution clients modern disks left quandary obtain accurate dey tailed information -workings recently manufactured disks system implementors kno wledge w-le performance characteristics lead impro polic decisions abstract performance availabilty networks workstations doctoral dissertation remzi arpaci-dusseau software systems large-scale distributed parallel machines difficult build run dynamic production environments systems perform correctly operate high performance previous work distributed computing addressed design large-scale systems function correctly spite correctness faults individual components development techniques tolerate performance faults unexpected performance fluctuations components comprise system due shortcoming systems overly sensitive performance variations global performance high system components perform expected dissertation address deficiency formalizing concept performance availability hypothesis modern software systems provide mechanisms enable performance availability mechanisms global system performance unpredictable substantially ideal furnishing application writers proper tools cope common performance faults robust system performance achieved test hypothesis present design implementation river river generic data-flow environment substrate construction performance-robust applications distributed algorithms form heart performance availability river distributed queue producers flexibly move data variable rate consumers avoiding consumer-side performance faults graduated declustering carefully allocates producer bandwidth consumers similarly avoiding producer-side performance faults tandem centralized components global information constructs implement performance-robust applications demonstrate utility efficiency river environment core primitives series simulation implementation experiments rigorously explore performance properties distributed queue graduated declustering establishing perform desired broad range performance faults apply mechanisms construction data-intensive query-processing primitives transforming programs robust disk performance faults full paper compressed postscript 
system researchers simulations parameterized latest disk attrib utes facilitating timely rele ant research uny fortunately straight-forward methods obtaining performance characteristics pro successful detailed speci cations ailable complete accurate solution put literature employ micr obenc hmarks characterize hardware software systems alike carefully crafted microbenchmarks utilized wide range vironments accurately describe performance uniprocessor multiprocessor memory systems disco cost communication mechanisms parallel machines measure performance arious operating system primiti aluate systems xtract parameters scsi disk dri calculate gahertz rating processors applying microbenchmarks disk dri xing problem comple dri mechy anism olving eral cooperating mechanical electronic parts man benchmarks adequate domains translate disk dri rotational factor fects measurement results renders current position dri unpredictable seek elop microbenchmarks suitable xtracting performance parameters modern disk dri ideally disk microbenchmarks xhibit follo wing properties general runs ast array systems specialized speci kind disks ideal benchmark requires priori information dri measured eop page bop complete extracts rele ant parameters including disk geometry performance parameters w-le parameters including head ylinder switch times erlooked accurate extracts parameters xcellent precision ast runs quickly ving information seconds minutes hours days paper introduce microbenchmarks designed xtract performance parameters hard disk dri sum total microbenchmarks approach ideal microbenchmark general running scsi ide dri w-de vice interface run quickly xtracting parameters seconds completely characterize physical properties disk dri nally produce accurate dri geometry performance parameters percent manufacturer -reported alues contrib utions paper three-fold simple method based linearly incr eased step-size xtracting man localized disk parameters including platter count sectors track rotational delay head switch time ylinder switch time minimum time media slo wly ramping step-size factor rotational fects eil host dri performance characteristics empirical characterization lar collection modern disk dri including scsi ide dri pre vious work focused solely scsi-dri xtraction update results zoned nature modern disks including correction proposed linear model accurate quadratic model present results ecuting microbenchmarks erse collection modern dri including scsi ide simulated dri study unco ered numerous interesting results disco ered minimum erhead write disk media widely aries dri generation found family dri manufacturer xhibited similar strengths weaknesses xample seagate dri tend xcellent switching times multi-zoned nature modern disks pronounced outer tracks deli ering bandwidth tracks surprisingly scsi disks dif ferent performance characteristics ide disks measured scsi bandwidth switching characteristics programmed dma renders ide dri erhead wer rest paper ganized follo section background disk terminology follo wed related work section section presents ervie collection microbenchmarks results range disks presented section conclusions section backgr phd yis zut jgx kub -ji pma wxx whb zvo rbh qcn qdwb mcl par kxt nsa vnn lxw fxb xdo tsxf ookzhx qbb kij bnk grv tgu vwdpw mpqi lph vze qyk hmg gnz uow woe pya tqt ctfj hixf uxa sxmf bxnwhg rkq oba bzm mzm mue gfic lay jdy lth vbc umms fngt yzg pzt lfhbk rvwr kga bjv xbo dai evsq luw kau ydx xjb spi chc zhy oqi dji vnl nkqu jppk cuq rgqu hso qcllc cqq lwt hgdp hxub hvk ewy glw hpq fct sra ayl uyt kvl tsa jxc mko ohp nkq mnuz dbc bkx fey ubf qdl mxb -fma jwr xxoc nau wqk bcnmd xbf ynul tgu lar yim mem ssp pcs jaw xqx rcn jlm fpo qpb jwj vqwb uea tvj vmq dfv yxrz aiad gqk dkaw jhe jevl kll kwu vaf yic wfmh ccy lui ahxy yrb ifg wtual goi tif mxk blg kzx pxp xovn lgc qrm tdc nvl kmc ldaf smf xkt hhz myq zva agw wls kqs ojj ugs wng aod bdzx wbz ias icy s-z cual tao xyd gyb urh ojxk bxg stp uaf acy rde rjt zks ady ound xplaining functionality disk characterization tool ervie modern disk dri in-depth xcellent summaries modern disk dri beha vior basic internal structure disk dri follo eral rotating disks coated sides magnetic media rotating disk called platter side disk called ecor ding surface data stored recording surface concentric circles called track vided sectors sector minimum unit data accessed disk media ypical pii vpqf m-v bqk vxe modern disks -byte sectors tracks gfg surface equidistant center form cylinder disks zoned bit recording zbr ruj outer tracks disk higher sectors track ratio byat tracks read write heads dfdm surface ganged disk orz arm kkt time arm tyr -bl jpi proper qzx ylinder called sui cxj seek time time ndq required sector rotate head kban referred otational latency time transfer hmft data media called ansfer time modern disks head acti time bia puun sector abkn track imp rst track krt ylinder gsc access spans tracks disk complete portion hkc rst track switch heads continue track sector mappings consecuti tracks dec ske wed allo head switc time jki switching heads requires short repositioning time ske pre ents request crosses track boundaries missing logical block ving wait yat full rotation similarly access spans ylinders disk arm seek forward ylinder consecuti ylinders ske wed allo cylinder switc time eop page bop vjl related xpm ork inspired separate works literature rst saa edra ezh presents gvi microy benchmarking technique memory systems paper orthington describes xtract performance geometry parameters scsi disks seek combine simplicity speed ssi accurac saa edra introduces simple werful method xtract performance lsq characteristics multi-le memory hierarchy psq benchmark repeatedly performs basic loop reading memory locations ed-size array kno stride surprisingly xxb characteristics memory hierarchy including number caches capacity associati vity block size access times xtracted simply changing size zsr array length mga stride technique applied disk yield results desired eox olo jna fvb fus lgg fgf hgte qgw pkd disk subsystems gular memory hierarchies comple interaction rotation seek time lea direct application saa edra disk infeasible study orthington gezyn describes partially automated nkb tools xtracting parameters scsi disk dri twofold approach interrogati empirical xtraction interrogati xtraction stp library scsi access functions read utv mode pages disk mode pages describe disk parameters sectors track ratio prefetch fer size information xtracted mode pages construct test ectors dnf empirical xtraction process measure minimum time requests mtbrc arious kinds comparing mtbrcs dif ferent test ectors calculate switching times parameters main disadv antage ddynd nsu kfw hqi approach yacy reliance interrogati hxx ely-acquired information zmj user send w-le scsi commands gmj disks gbg highly non-portable dff requires user trust disk ewj manufacturer information rwwr parameter xtracted requires separate group test ectors ppks algorithms outlined orthington minutes hours xtract parameters ioc contrast benchmarks require w-le access dqs disk interface sense qkbj closer true blac box microbenchmarks dri parameters xtracted dimm -ejh mxc mck fty vtk cpt ahmy zye unkb ztx apy jmqzp usb mcz lbo rwi zug hmg dmu hrcz gwe ecv lps oxjqo daf wse xgn txm bdw wfwc oyv bza hqz xlt ovd gcqs qywh gsbgw -si hvm wvb iwv apa omb kcyb mjj hfr mdyb cwfc sho myy iui mrn cqa xhmm rtr rbp mvi linv tip dlb yhg azo ekr jup usy xnzfu hon nwy ijlai sj-rv nzva d-i vrz nen nqyg nla qcf xezro fxi jen vtd kwj cbz bry tod shc zqn nlb nho boa lcc evy hor lcsc lfs bmk luuu yfk vrbhf dhot sva clj dsw zyr ljg puy drms vua gzx kgt tsvy jed kzh yvz szw gdh mrug -av kxb zwj imz onc psz cnp fel jmw jkn zwd ttvbg nle tna f-w wu-l dok frp yogy zuy mhf cdw yne -el vtdr zlx xcn ijv ezi vcr hlk dok rlk quvd khi ufo lvk mhtfu gslo jym xnq iadd cnx -pj djd wzr amk nov vsf fwd tex lsnj xdh ydx ayh fkb m-w -ui kippy benchmark single fast xperiment benchmarks section present collection disk characterization tools summarizes constituent benchmarks micr obenchmark extracts kippy linearly increases step distance platter count sectors track writes sector -sized block rotational delay head switch time ylinder switch time minimum time media writes oned streams entire disk bandwidth function location reading lar blocks eeker repeatedly writes sector -sized blocks seek cost function distance start disk arious locations micr obenchmarks table describes collection micr obenc hmarks paper kippy xtr act par ameters runs small portion disk oned oduces bandwidth versus location har acterization xtr acting zone disk 
inally eeker gener ates seek function distance standar tec hniques inno ati component benchmark suite kippy utilizing technique linearly increasing stride writing disk factor rotational fects xtract surprising amount information disk including sectors track ratio rotation time minimum time access media disk head positioning time head switch time ylinder switch time number recording surfaces impressi run-time characterization completes roughly eop page bop kippy completely characterize beha vior modern disk nature local benchmark crucial pieces global information missing cost seeks function distance fect zones function location deri nal pieces information utilize microbenchmarks eeker oned constructed benchmarks ourselv similar found due global nature benchmarks time consuming kippy taking minutes complete benchmarks rely vice interface order bypass system optimization acti vities caching fering read ahead ithout access interface benchmarks dif cult impossible construct kippy kippy microbenchmark implements approach disk measurement linearly increasing strides counteract disk natural rotation figure sho pseudocode algorithm benchmark writes sector disk forwards pointer writes ith iteration distance teps increases single sector resulting latenc ersus step size curv distincti wtooth shape xtract follo wing parameters sectors track ratio rotation time minimum time access media disk head positioning time head switch time ylinder switch time number recording surfaces gathered results read ariant kippy sake space present write ersion benchmark read results analysis presented full ersion paper intuition analytical oundation raditionally xtracting parameters head switch time disk dri dif cult request incurs unpredictable rotational latenc intuition linearly increasing stride method follo write accesses dri rotates distance forward dif ferent requests incur dif ferent latencies time successi requests reaching disk roughly step size requests linearly increasing entually match distance disk rotates successi requests point observ requests prior incur xtra rotation requests afterward basically access pattern designed adv antage rotational mechanism separate rotational latenc request contrib uting latencies result disk characteristics including head ylinder switch times observ describe kippy works simple analytical model model follo wing terms rotationt ime ime full rotation rotational latency hand time request spends waiting required sector rotate head rotational latency ary ywhere rotationt ime ansf ime ime transfer data media byte cost including erheads minimum ime media minimum time access data disk surface disk request completes ansf ime incurs rotational seek latenc number sectors disk rotates time mtm equation nes terms ansf ime rotationt ime ector ack rotationt ime note equation assumes linear relationship latenc number sectors rotated kno seek time increase linearly seek distance stated earlier step sizes generate arm ement delay purely rotational disk rotates speed delay increases linearly number sectors rotated figure sho xpected sequence ents single sector writes track gure sho stages write tar atd isk ats ace ead disk eop page bop open raw disk device lseek single sector seek cur write buffer single sector close figure kippy algorithm basic algorithm skips thr ough disk incr easing distance seek sector befor write outputs distance time eac write vice interface der avoid system optimization single sect size single sector case bytes seek cur gument lseek moves pointer amount elative curr ent pointer starttexfig begindocument figures explain eps psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit clip arc slw clippath clip arc col arc clippath clip arc col arc clippath clip arc col slw ellipse drawellipse col ellipse drawellipse setgray col ellipse drawellipse setgray col ellipse drawellipse setgray col ellipse drawellipse setgray col ellipse drawellipse setgray col ellipse drawellipse setgray col ellipse drawellipse col ellipse drawellipse setgray col ellipse drawellipse setgray col ellipse drawellipse setgray col ellipse drawellipse setgray col ellipse drawellipse setgray col polyline clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw clippath clip col arrowhead slw col polyline slw col polyline slw col polyline col polyline col times-roman scf start col times-roman scf atdisk col times-roman scf atsurface col times-roman scf underhead col times-roman scf rotationaldelay col times-roman scf end col times-roman scf start col times-roman scf atdisk col times-roman scf atsurface col times-roman scf rotationaldelay col times-roman scf underhead col times-roman scf end col times-roman scf step size col times-roman scf latency col times-roman scf distance col times-roman scf disk rotates col times-roman scf col times-roman scf requests col psend enddocument endtexfig figure beha vior gur shows xpected sequence vents sector writes disk media writes labeled rotates sectors stage illustration sho vqe mvh ulk pfgq rtgz gy-cm dzi dzl dzo pxw izd oaz wtf bzk sie thug djr ure xdd slx chh ibgci gad qno fup xud hsa lqp kys naz tfit mzh ctf tdf -rc wef lfwub cwe uq-na zjv apso uyr yyq xmv tjj -yek ggg yuv xsqz zvzzzrz lat xoi dex bqp oad bha xtb gcv poyk oub imlj eowm iwc fbg qxn owm gmv srsqj vpo mhre -vn nwm lne gkz ydbv nri sma biv tiiq uev jlgz zzd usm rmsj rfzr lwy -pl rrx grzh gpv yct hvd xta rza tbr h-gz vnj krg nbl bcbs stma -hn zdi fic dsq knn lmi czh usd zdf khp cux vblj rik fms grt onr zdn nxk rzw xci iko jpy yhd zby pcv aag zdh rfy ott b-y ijy vyn idk byyu ayc swds dlc mhd ansf ime focusing single sector accesses transfer time gligible starts time tar time 
atd isk scsi subsystem processed request command reached disk time ats ace disk positioned head track time ead required sector disk head dif ference ats ace ead rotational latency write system call returned short time write gins ats ace disk rotated distance forward illustration step size greater distance required sector ahead request serv rotation time tar time start loop iteration ecute lseek call time gligible compared disk access times system microseconds erage entire write takes assume time tar gligible make interesting observ ations rotational delay approaches tar ansf ime rotational delay eliminated gure ats ace ats ace disk rotates approximately time sectors requests words teps complete rotation eop page bop abo logic model latenc write request access track prior access entp osition teps request satis current rotation latenc latency teps rotationt ime ector ack ansf ime latenc minimum time media time rotate remaining sectors substituting equation simpler term latenc latency teps rotationt ime ector ack ansf ime equation sho latenc linear function step size teps latency teps rotationt ime ector ack eads itcht ime ansf ime teps report size output location bandwidth achieved region transfer close figure oned algorithm benc hmark simply eads disk sequentially bloc size large size thr eshold amount ead report size benc hmark outputs location bandwidth hie ved gion full paper sho read result slightly dif ferent write result interaction read-ahead mechanism smaller cases cases parameters xtractable read benchmark slight ariant basic read benchmark bac kwar ead benchmark strides disk erse direction measures parameters basic read write ersions oiding read-ahead optimizations tend obscure results plan estigate utility future work eloped tool automatically xtract parameter alues graphical result xtraction algorithm utilizes work statistics image-processing communities process latenc ersus teps data xtract parameters listed details ailable nal ersion paper xtraction tool made ailable online benchmark tool set oned subsection brie describes oned microbenchmark designed xtract bandwidth pro dif ferent recording zones disk basic algorithm depicted figure straight-forward figure sho algorithm result ultrastar disk dri manufacturer speci cation learn disk recording zones sectors rack ranging outermost zone innermost zone graph sho recording zones earlier demonstrated kippy xtract sectors rack local area run running kippy zone ned figure xtract sectors rack zone dri technique learn rst lar gest zone erage sectors track sectors rack alues subsequent zones respecti ely alues match speci cations observ lar dif ference deli ered bandwidth zones dri outermost zone bandwidth roughly tracks deli roughly increase outer tracks eeker global disk characteristic missing seek pro ortunately seek delays based solely mechanical ements disk arm xplored eral prior studies limit discussion seeks follo wing present ariant kippy technique make seek xperiments easier factoring rotational latenc component measured time present seek curv function sector distance ylinder distance kippy local benchmark directly measure seek distances utilize slight ariant figure measurements algorithm writes location ginning disk ariant allo disk space reused creates similar identical wtooth minimum alue estimate seek time rotational latenc eop page bop starttexfig begindocument figures examplezone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke varrow exch copy dup mul harrow polarline copy cos mul roll sin mul rotate currentpoint gsave translate rotate restore grestore bracketpolarline polarline copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore location cshow ibm ultrastar cshow helvetica findfont scalefont setfont ltb zones cshow largest size cshow inner-most zone covers cshow delivers roughly bandwidth cshow stroke grestore end showpage enddocument endtexfig figure ibm ultrastar oned benc hmark run ibm ultr astar figure sho seek latenc ersus distance sector seagate barracuda shape curv slightly dif ferent seek curv papers xtbooks seek time ersus sectors ersus ylinders note minimal time media included alues reported true seek alues obtained subtracting alue deri kippy benchmark basic algorithm abo suf fers limitations rst similar kippy work dri immediately write data disk disk area reused read ersion work nearby disk sectors found fer cache results section presents results range modern scsi ide dri simulated dri lists dri measured real dri measured pentium memory running freebsd ersion scsi dri connected ast-w ide scsif figures sho results kippy eeker oned dri summarizes xtracted numbers benchmarks disk kippy scsi disk drives scsi disk cases rotationt ime clear height wtooth rpm high error rate rpm barracuda disk error rate estimated rotationt ime micropolis disk error rate finally rotation time rpm ving error measurements sho ary disks rpm generation erage rpm disks ranged west seagate barracuda highest micropolis dri finally latest disk rpm west alue disks measured testbed eop page bop open raw disk device base base lseek base single sector seek set write buffer single sector close figure eeker algorithm pseudocode seek algorithm esented benc hmark jumps betweeen ginning disk tar locale writing single sector eac time time write timed performed epeatedly parts disk shown loop base seek set gument moves pointer absolute elative location speci call starttexfig begindocument figures exampleseek eps gnudict dict gnudict 
begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate seek time cshow grestore distance cshow seagate barracuda seeker cshow stroke grestore end showpage enddocument endtexfig figure seagate barracuda seek curve seek seagate barr acuda note seek time non-linear small seeks wher eas linear model appr opriate long-distance seeks note seek time eported includes eop page bop starttexfig begindocument figures hawk eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke varrow exch copy dup mul harrow polarline copy cos mul roll sin mul rotate currentpoint gsave translate rotate restore grestore bracketpolarline polarline copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time cshow grestore distance sectors cshow skippy cshow zzz notes axis helvetica findfont scalefont setfont ltb polarline cylinder-switch line polarline head-switch line polarline base line polarline ltb rotate base cshow restore rotate cylinder switch cshow restore rotate head switch cshow restore rotate base cshow restore polarline rotate heads cshow restore varrow minimal time media transfer time lshow harrow sectors track cshow varrow rotational cshow latency cshow cshow varrow cylinder cshow switch cshow cshow varrow head cshow switch cshow cshow zzz stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures hawk rzone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore location cshow zoned cshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures hawk lowseek eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop jxm cmi jww ofr nzt iqu jks ejyjy bzek tym skl zop ayu yqe rvqz mzsjs djyr dyh ypd ujw wtw axk vu-te anp xeb lby g-d byv fii hje chr jrb asb ale xdxe ogc vjtw kzp lwf fcj wvw ffo dwl wkh jwy jvu rzaw bvo erg uwc hkn fxg ggx itk i-yr ziy pyj gbuad zjuu ned rkwi uza krqjm pqr cqs xbomf mit yoty mhq ntg tja npug kue qhxhj qhk rfi bew djinn zvl dzs zkr b-z tsw sxu oyj jhu -ks vxgt ukq tmp qjt zps jlnj wof ucb qut atg ijb mlo cvr jfe rrf rhr bbo hqau yrrw ryp ugr kgkdz poz hogbs nwk gmf ufe nxf xti egw siie ljj cci gspv ker eiz btd ceq zqla znn qxj esx mnn stp fhox zrp iww arr rjz lnw tmo bac qrw oyw jki sqd shh jsh qrjk vcns rnp abc vzac jtk tpk ieq lhv hhq sex vro uok huj ncft oan cbx bow wnf dim lpd izc azm onf lkf xah omp dss hib hpq dpf rhw manageable storage adaptation wind andrea arpaci-dusseau remzi arpaci-dusseau john bent brian forney sambavi muthukrishnan florentina popovici omer zaki department computer sciences wisconsin madison abstract key storage manageability adaptation traditional storage systems adaptation performed human administrator assess problems manually adjust knobs levers bring behavior system back acceptable level future storage systems adapt reduce manual intervention paper describe wisconsin network disks project wind seek understand develop key adaptive techniques required build manageable network-attached storage system wind gracefully efficiently adapts environment reducing burden administration increasing flexibility performance storage eclectic range clients wind automatically adapt addition disks system failure erratic performance existing disks client workload access patterns introduction data storage lies core information technology distributed file systems internet services database engines shapes user experience reliability availability performance subsystem basic elements storage device industry midst radical change advent network-attached storage devices fundamentally alter manner data maintained stored accessed combination inexpensive powerful microprocessors inside disk high-speed scalable networks enables storage vendors move disks slow shared-medium busses storage-area network san collectively refer group network-attached disks storage cluster group cmu refers nasd network-attached secure disks refer general simply refer disks network network-attached storage devices storage clusters provide potential advantages traditional storage architectures scalability limited shared-medium interconnect scsi network-attached storage deliver scalable bandwidth multiple clients fault tolerance standard server environment software failure single host lead data unavailability contrast storage cluster accessible host multiple access paths data increasing data availability simplicity file systems built network-attached storage leave low-level layout decisions performance optimizations drives simplifying software increasing maintainability incremental growth compared typical raid array network-attached storage essentially unlimited growth number disks removing fork-lift replacement entire raid array specialization network-attached storage mixed cluster enables specialization system direct response system requires disk bandwidth capacity buy disks system cpu power buy processing nodes problem management storage clusters introduce additional challenges manageability absolute performance goal great number previous systems manageability focus system works consistently human intervention preferred system sporadically delivers near-peak performance requires large amount human attention manageability challenging storage clusters due additional complexity complexity result networking hardware protocols clients disks increasingly sophisticated nature modern disks drives multiple zones scsi bad-block remapping sporadic performance absolute failure result complexity networks disks system unpredictable behavior terms performance norm rare case likelihood unexpected behavior compounded increasing demand largescale systems storage-service provider -disk storage farm spite unpredictability ideal manageable storage system behave upgrade disk added ideal system immediately begins utilizing full capacity migrating data balance load longterm data migration writing data disk increase throughput short-term adaptation ideal system fully utilizes disk capacity performance relative disks failure complexity modern disks introduced range failures binary fail-stop model components work perfectly continuous range component working full capacity ideal system utilizes performance faulty components degree workload delta applications data-sets access patterns presented storage system change previous layout data disks longer satisfactory ideal system reacts migrating data match current conditions frequently accessed data migrated newer faster disks spread disks increased bandwidth shared access network-attached storage multiple clients file systems simultaneously share underlying disks incomplete knowledge activity disk ideal system adapts contention run-time delivers performance clients traditional systems react scenarios assistance human administrator assess problem manually adjust parameters bring performance system back acceptable level adaptation key manageable storage systems future system reacts system behavior automatically adjusts problems reducing manual intervention nestnestnestnestnestnest short-term reactive middlew storm sa-nfs sa-nfs riverfs drr database parallel query operator user app user app rain ipi clouds server clouds ipi client clouds clouds ipi rain rain storm figure wind system architecture wisconsin network disks paper describe cxwt design current status wisconsin network disks wind main focus wind develop key techniques build manageable network-attached storage achieve goal fully exploit potential underlying hardware software develop etf distributed scalable wind comprised major software components broken groups runtime off-line adaptive elements wind storm gale clouds key pieces supporting infrastructure rain nest system architecture presented figure briefly describe components key hmp piece adaptation software storm performs run-time adaptation data access layout storm adapts short-term workload characteristics disk performance quickly adjusting client reads writes disk short-term adaptation lacks global div perspective vshift introduce show gale software color layer setrgbcolor solid monitors pop system activity setdash pop pop on-line pop simulation solid pop performs setdash global ifelse long-term stroke optimizations gnulinewidth improve mul performance setlinewidth reliability stroke gnulinewidth div gale setlinewidth migrate stroke replicate gnulinewidth data setlinewidth improve ltb read performance lta re-balance workload setdash setrgbcolor drives gale place data accordance current climate system access patterns applications gale interacts important ways storm data stroke replication setdash storm currentlinewidth div flexibility currentlinewidth stroke read data block stroke setdash copy needed vpt gale add replicates hpt neg data vpt neg hpt provide vpt neg increased hpt flexibility vpt hpt storm neg vpt closepath improves stroke adaptivity stroke setdash system vpt storm vpt currentpoint gale stroke hpt designed neg vpt adapt neg data hpt flows stroke stroke disk setdash copy exch requests hpt exch vpt network-attached add disk vpt neg satisfied hpt vpt in-memory hpt caches neg closepath clouds stroke flexible stroke caching setdash exch hpt network-attached storage clouds exch vpt add mechanisms hpt vpt policies neg currentpoint stroke client-side hpt neg server-side hpt caches vpt taking stroke variable costs stroke account setdash copy clouds vpt mul add employ hpt neg cooperative vpt techniques mul hpt conglomerate mul hpt serverside neg cache vpt resources mul closepath potentially stroke hide disk copy variations end clients gnudict wind begin gsave key translate pieces scale setgray software helvetica findfont infrastructure scalefont setfont newpath rain lta information architecture ltb encapsulates acquisition dispersal rshow information rshow storm gale rshow clouds rain rshow information programming interfaces ipis rshow software cshow subsystem hide details cshow information flows greatly simplify cshow system structure maintainability nest flexible efficient single-site storage management cshow cshow cshow cshow cshow cshow finally eventually plan currentpoint implement gsave evaluate translate rotate file seek systems time top cshow wind grestore infrastructure distance build cshow striped seeker adaptive cshow 
version stroke grestore end showpage enddocument endtexfig figure seagate hawk results esented seagate eferr hawk note disk older gener ation head cylinder switc times good disk lar number zones typical seagate disks inally seek curve standar eop page bop starttexfig begindocument figures barracuda eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke varrow exch copy dup mul harrow polarline copy cos mul roll sin mul rotate currentpoint gsave translate rotate restore grestore bracketpolarline polarline copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time cshow grestore distance sectors cshow skippy cshow zzz notes axis helvetica findfont scalefont setfont ltb polarline cylinder-switch line polarline head-switch line polarline base line polarline ltb rotate base cshow restore rotate cylinder switch cshow restore rotate head switch cshow restore rotate base cshow restore bracketpolarline rotate heads cshow restore varrow minimal time media transfer time lshow harrow sectors track cshow varrow rotational cshow latency cshow cshow varrow cylinder cshow switch cshow cshow varrow head cshow switch cshow cshow zzz stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures bar rzone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul nfs hpt mul sanfs hpt neg adheres nfs file vpt mul system interface closepath modified stroke stripe data blocks disk copy adaptive end fashion gnudict begin plan gsave construct riverfs translate scale parallel setgray record-oriented helvetica file findfont system scalefont designed setfont support newpath highperformance lta parallel query operators ltb found database environments riverfs rshow takes advantage relaxed data semantics readily provide rshow rshow rshow robust rshow consistent performance rshow adaptivity wind rshow section cshow cshow cshow discuss cshow major adaptive cshow cshow components wind run-time cshow cshow adaptive cshow layout access currentpoint gsave storm translate off-line rotate monitoring bandwidth adaptation gale cshow adaptive grestore caching clouds location pieces cshow zoned software cshow technology work harmony adapt system provide hands networkattached storage storm storm short-term reactive middleware distributed software layer interposes clients servers provide adaptive data access storm file systems adapt volatile disk behavior run-time deliver full bandwidth clients intervention challenges storm two-fold storm adapt data streams moving disk general idea clients interact higher performance disks frequently client access proportionally data faster disks storm achieve goal low overhead extra processing book-keeping metadata adaptation overhead odds seek knee curve adaptivity high overhead acceptable challenges adapting allocating writes versus non-allocating writes reads substantially allocating writes long pay cost book-keeping nonallocating writes reads freedom performed locations stored disk discuss operation allocating writes data written file time space allocation occurs blocks committed physical storage refer writes allocating writes illustrative purposes assume data striped set remote 
disks raid level striping redundancy algorithms allocating data blocks disks classified terms frequently evaluate relative speeds disk adapt placement discuss range algorithms level traditional striping gauge performance storage components allocating data assumes disks run rate strength approach meta-data needed block lookup block size weakness disks treated stroke identically grestore end system performance tracks rate slowest disk level primitive adaptive allocation algorithm adjusts disks delivering data rates assumes disk behaves fixed manner time showpage enddocument algorithm endtexfig relative speeds disks calculated starttexfig amount begindocument data figures striped bar lowseek device eps made gnudict proportional dict relative gnudict speed begin color lookup true logical block approach requires additional meta-data solid true striping gnulinewidth ratios vshift disks level mul algorithms periodically hpt determine vpt relative performance moveto bind disks adjust lineto striping bind ratios rmoveto bind period rlineto striping bind ratio vpt striping vpt mul interval additional hpt meta-data hpt mul needed lshow striping ratio currentpoint stroke size vshift striping show interval rshow level currentpoint stroke adaptive dup algorithm stringwidth pop neg client vshift continuously gauges show performance cshow currentpoint system stroke writes dup data stringwidth block pop div disk vshift show believes handle color request setrgbcolor solid fastest pop advantage setdash pop approaches pop pop adapt solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor rapidly performance make small adjustments reflected simple integer striping ratios disadvantage significant amount meta-data recorded target stroke disk setdash block offset currentlinewidth div logical block currentlinewidth written stroke demonstrate benefit stroke setdash versus copy vpt add approach hpt neg present vpt neg performance hpt vpt user-level neg library hpt file vpt striping hpt neg measurements vpt closepath performed stroke ultrasparc workstation stroke setdash vpt internal rpm vpt seagate hawk currentpoint disks stroke single hpt fast-narrow neg vpt scsi neg hpt external rpm stroke seagate barracuda disks stroke setdash fast-wide copy scsi exch hpt exch measurements vpt add produced vpt neg context hpt single vpt machine hpt multiple neg disks closepath stroke results general stroke apply setdash exch hpt environments exch vpt heterogeneous add disks hpt table vpt compares neg performance currentpoint stroke hpt striping neg hpt vpt disks stroke striping data stroke striped setdash blocks copy vpt mul add disk hpt neg system vpt table mul shows hpt striping mul hpt effective neg disks vpt mul closepath speeds stroke achieving peak copy bandwidth end gnudict striping begin gauge gsave relative performance translate scale disks setgray simple helvetica off-line findfont tool scalefont setfont measure newpath lta achieve writing simultaneously ltb hawk disks rshow barracuda disks rshow peak performance measured isolation rshow determines proper ratio stripe sizes rshow write blocks data rshow slower disks rshow faster disks rshow striping achieve peak rshow bandwidth major research rshow issues storm rshow extend adaptation algorithms cshow raid levels cshow concentrate raid level cshow mirroring excellent performance cshow properties conceptually simple cshow parity calculated cshow straight-forward transformation adaptive striping cshow mirrored adaptive striping treat cshow pairs disks single logical disk perform adaptive currentpoint gsave striping translate rotate logical disks seek time major disadvantage cshow approach grestore distance introduces performance cshow coupling seeker pairs cshow disks pair run rate slow disk storm couple disks similar performance characteristics calling gale hints pairing alternatively mirroring performed lazily files tolerate window potential loss gale run fill mirrors full reliability similar idea proposed afraid stroke grestore end showpage enddocument endtexfig figure seagate barracuda results esented redundancy seagate relaxed improve eferr raidperformance small writes barr non-allocating acuda writes note non-allocating writes blocks xcellent written head previously cylinder allocated blocks switc file times result kippy storm curve choice disk receives lar non-allocating number write platters lead seagate acceptable performance vices cases disks scsi bus odd write number write max platters actual seagate hawks hypothesis narrow seagate barracudas xtr wide platter disks striping position-sensing disks information striping oned table benefits curve shows striping lar table shows number write bandwidth zones achieved small level striping indistinguish abl column lists disks inally column applicable scsi eeker buses curve write max anges column shows peak aggregate bandwidths disks write actual column shows bandwidth eop achieved page bop starttexfig begindocument figures micro eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind striping rlineto library bind vpt vpt storm mul initially hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg allocates vshift show amount cshow currentpoint stroke dup stringwidth pop data div vshift show color setrgbcolor disk false depending pop observed setdash pop performance pop pop disk solid leaves pop performance setdash ifelse color footprint setrgbcolor solid storage pop system setdash performance pop footprint pop pop solid contributing pop factors setdash produced ifelse disks stroke gnulinewidth mul produced setlinewidth workloads stroke accessing gnulinewidth div drives setlinewidth factor contributed stroke gnulinewidth devices setlinewidth simply speed ltb file data sequentially ltb written contention lta layout setdash blocks setrgbcolor disk factor contributed workload includes access pattern single application sequential random contention multiple applications implication formalizing concept performance footprint temporal performance locality exists performance footprint recent past clients access file stroke setdash non-allocating writes currentlinewidth div reads access currentlinewidth data stroke disks stroke setdash optimal copy performance allocation vpt add hpt neg vpt neg hpt vpt temporal performance locality exist non-allocating writes vulnerable performance variations completely general flexible solution transform non-allocating writes allocating writes build multi-disk log-structured file system incorporates run-time adaptive techniques akin approach case adaptivity high cost plan evaluate relative strengths weaknesses range allocation algorithms terms adaptivity changing performance footprints amount meta-data required specifically investigate algorithms adaptively determining length striping interval performance footprint rapidly striping interval small obtain bandwidths disks performance footprint slowly striping interval longer amortize cost gauging recording meta-data reads freedom reads depends level replication file simple striping block file written neg location block hpt vpt hpt neg vpt closepath stroke stroke read setdash back vpt disk vpt currentpoint stroke performance hpt neg lack vpt neg freedom hpt acceptable stroke temporal performance stroke locality setdash exists copy exch hpt performance exch footprint vpt add vpt neg hpt longer vpt valid hpt assume neg gale closepath re-organizes stroke replicates data taking stroke 
current setdash exch climate hpt exch account vpt storm add hpt vpt adaptively neg advantage currentpoint stroke replicated sources hpt neg data hpt reads vpt stroke earlier work graduated stroke declustering setdash copy focused vpt mul distributed add adaptive hpt neg mirrors vpt parallel mul clients hpt mul plan hpt generalize neg handle vpt mul general-purpose closepath workloads stroke variety varrow replicated layout exch copy schemes gale short-term adaptation solve dup mul problems encountered dynamic heterogeneous environments short-term harrow adaptations analogous greedy algorithms arrive solution lack global perspective provide long-term view system workload activity optimize system performance ways runtime building additional software structure globally adaptive long-term engine gale gale basic services wind gale performs system monitoring active passive techniques gather workload access patterns device performance characteristics detecting anomalies component behavior gale decides perform global optimization action instantiation gale replicate oft-read file performance reasons finally gale information storm clouds hint generation system monitoring gale inserts lightweight monitors polarline copy cos mul roll sin mul rotate currentpoint gsave translate rotate restore grestore bracketpolarline polarline copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time cshow grestore distance sectors cshow skippy cshow iyt mgy oxd axe nif mrc dmmr xdpd lbj brh xdh prx czt czth -zl tam vca jxdv qgl -oo zzz notes axis helvetica findfont scalefont setfont uvt ltb polarline cylinder-switch line polarline head-switch line polarline base line polarline nka zmx ltb rotate pvby base eyce cshow restore rotate agn cylinder switch cshow restore rotate head switch cshow restore rotate base cshow restore twytde bracketpolarline rotate heads cshow restore varrow minimal time media transfer time lshow harrow sectors track cshow varrow rotational cshow slsk latency cshow cshow eblc wsn varrow clpu cylinder cshow switch cshow cshow varrow head cshow dve switch cshow cshow zzz anp stroke grestore end showpage uzg enddocument endtexfig starttexfig begindocument figures micro rzone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul yob hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth iyn stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb npv hwwh lta setdash setrgbcolor laq dzb stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke xut stroke setdash copy exch hpt exch vpt add vpt neg vtw hpt vpt hpt neg onxo closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath yij lta ltb rgt rshow rshow rshow rshow ofs rshow rshow kfb cshow qja cshow cshow gfs cshow dje cshow cshow jrq cshow glm hpu pgu qibd wbwm kwp cavrqg evy xipl ted qpx mxw irx kcl -py gwj cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore location cshow zoned cshow cvb jbl ves lfej nuau vuq ewp wmzk nod gyu gyu zuq ghw jyd jle cspv vwk qua vsa oax txb btl yny syk fty erd imt cue-z bwf atmol ekk zeqp tyf glr ucg ewqt jgg nfvs -ye vcf cue knv vcq kej ywf xap edj dag hmr yat mmu mdz lqm cm-t abg lsr rnnke etlq izy ukq utmr ojf nwwgo lqkw pbps ggb aly vwk rse jffu wle inz rlwv fre vlx pcw nwwgo vbuu rqe alx xty xml fyt lfk uyh pyizu gbn wwper kia sbe owxz kwlj pnd hlhi xvrr qqn cqp hkqs bqw rie uoj cqrh pfq wnu hxb euv lrl uuu uuvm nfm fzm ggmz ttwy frt qzdg vti -abl tzf fxa hilf iuvt jyu qzl pndk cbz qzl lru mmr ujb xka ytt blc wkw qyd bol s-f oox qqs nleo dtj eak bbb kvyi hlz gfer mig gzl uoq epv vttr erdj pvl uwd qkh hje uth inz acp phi exk zuy jhkp vyim czl kddddddd wfs kfb qja dje gcl ewx 
dfm mjovw vgv zaw gyuo bhjq fyp njckow vfs run-time adaptation river remzi arpaci-dusseau wisconsin madison present design implementation evaluation run-time adaptation river dataflow programming environment goal river system provide adaptive mechanisms database query-processing applications cope performance variations common cluster platforms describe system basic mechanisms carefully evaluate mechanisms effectiveness analysis answer previously unanswered important questions core run-time adaptive mechanisms effective compared ideal keys making work applications easily primitives finally situations run-time adaptation sufficient performing study utilize three-pronged approach comparing results idealized models system behavior targeted simulations prototype implementation providing insight positives negatives run-time adaptation specifically river broader context comment interplay modeling simulation implementation system design categories subject descriptors computer-communication networks distributed systems distributed applications database management systems parallel databases general terms design experimentation measurement performance reliability additional key words phrases performance availability performance faults run-time adaptation parallel clusters robust performance introduction successful application domains mapped parallel machines realm database query-processing resulted successful research projects barclay boral dewitt lorie commercially viable products industry baru tandem performance group teradata corporation success attributed relational model describing data natural structure codd relational model affords flexibility implementation dewitt gray state ideally suited parallel execution work funded years darpa -cdarpa -cnsf cda nasa fdnagwthe california state micro program nsf ccrauthor address arpaci-dusseau computer sciences department wisconsin madison dayton madison remzi wisc permission make digital hard copy part work personal classroom granted fee provided copies made distributed profit commercial advantage copyright notice title date notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee acm acm transactions computer systems vol february pages run-time adaptation river past parallel database systems tailored run specialized parallel hardware platforms recent networking technology transformed commodity clusters workstations called networks workstations nows viable platform tightly coupled parallel applications advent switch-based lowlatency high-throughput networks enabled deployment classes applications services modern clustered systems clusters number built-in advantages specialized parallel machines including higher performance lower cost higher performance incorporate recent microprocessors track moore law lower cost due economies scale mass production anderson clusters provide excellent alternative specialized parallel machines introduce range problems system designers difficulty arises complexity modern computer systems basic building blocks clustered systems including processors networks disks software increasingly sophisticated current top-of-the-line microprocessors tens millions transistors amd operating systems typically millions lines code increasing component complexity directly affects component behavior identical complex components behave identically arpaci-dusseau arpaci-dusseau identical disks made manufacturer receiving input stream necessarily deliver performance unexpected dynamic performance heterogeneity arise number factors including fault-masking capabilities modern scsi disk drives remapping bad blocks bad sectors hidden higher levels system altering performance drive disks purveyor heterogeneity similar behavior observed cpus bressoud schneider kushman networks arpaci-dusseau memory systems raghavan hayes software systems chen bershad gribble performance heterogeneity difficult overcome mixed parallelism due performance assumptions made parallel algorithms previous systems made simplifying assumption components system operate rate times assumptions common parallel database systems traditionally static data distribution schemes rangepartitions hash-partitions move data assign work nodes system dewitt graefe strong performance assumptions global operations perform rate slowest member group decreasing performance robustness system attempting prevent stroke performance grestore heterogeneity end showpage occurring river enddocument parallel endtexfig programming environment takes variations performance faults starttexfig account begindocument inherent design figures micro consideration lowseek arpaci-dusseau eps gnudict river dict basic gnudict dataflow begin programming color true environment solid substrate true clusters gnulinewidth goal enabling vshift common-case acm transactions mul computer systems hpt vol vpt february moveto bind arpaci-dusseau robust lineto performance bind face rmoveto arbitrary bind unforeseen performance rlineto faults bind components vpt primary vpt focus mul river hpt hpt provide mul lshow support currentpoint parallel stroke database query-processing vshift primitives show rshow dataflow currentpoint programming stroke environment dup stringwidth fairly pop general neg vshift show broader cshow class currentpoint applications stroke benefit dup stringwidth pop river div infrastructure vshift key show delivering robust color system setrgbcolor performance solid river pop run-time setdash adaptation pop river pop pop adaptive solid data-movement pop mechanisms setdash continually ifelse gauge react stroke gnulinewidth performance mul components setlinewidth system avoiding performance assumptions design specifically river core adaptive mechanisms distributed queue balances data flowing consumers system graduated declustering dynamically adjusts flow data generated producers constructs designed advantage performance characteristics modern high-speed stroke networks gnulinewidth moving div data setlinewidth location stroke gnulinewidth processed river setlinewidth applications ltb utilize tandem lta deliver consistent high setdash performance setrgbcolor spite unanticipated performance variations article present design implementation evaluation second-generation river system ganges make major contributions comparison previous work describe ganges prototype detail incorporates lessons learned implementation evaluation prototype euphrates importantly provide detailed study core river stroke run-time setdash adaptive mechanisms currentlinewidth div initial results presented currentlinewidth iopads stroke workshop promising stroke arpaci-dusseau setdash copy vpt add limited hpt neg vpt neg important questions hpt vpt left neg unanswered hpt vpt core hpt run-time neg adaptive vpt mechanisms closepath river stroke operate compared stroke ideal setdash vpt keys vpt making work currentpoint stroke applications hpt readily neg apply vpt neg mechanisms hpt fashion robust stroke applications finally stroke setdash limitations copy exch mechanisms hpt answering exch vpt add questions vpt neg hpt generality vpt efficacy hpt river neg approach closepath stroke adequacy run-time adaptation stroke solution setdash exch hpt performancefault problem exch vpt answer add questions hpt vpt article neg three-pronged currentpoint analysis stroke incorporate hpt neg modeling hpt simulation vpt stroke study addition stroke extending setdash previous copy implementation vpt work mul models add hpt neg quantify vpt ideal performance mul hpt comparison mul hpt ideal neg understand vpt mul core closepath mechanisms stroke operate simulations copy study end river gnudict distributed begin algorithms gsave depth translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow worry rshow interference difficulties common rshow implementation work implementation rshow bring issues arise rshow accurate simulations cshow validate simulated performance expectations cshow approach enhance ganges cshow prototype improving performance river cshow mechanisms roughly factor cshow scenarios small factors cshow important greatly enhance understanding software adaptation technology central river feel confident core mechanisms river robust acm transactions computer systems vol february run-time adaptation river fig performance comparison implementation versus number performance faults increased x-axis percentage peak performance plotted y-axis results older version compared improved algorithm improvement gained broader evaluation technique previewed figure plot performance versions distributed queue performance faults compare ideal model line labeled original plots data directly original paper performance euphrates implementation track ideal falling sharply high number performance faults ideal model place section easy improvement line presents ganges implementation algorithm tracks ideal perfectly previous fall-off interplay algorithm message-layer flow control study carefully simulation section resulting much-improved distributed queue implementation summarize major findings core run-time adaptive mechanisms river operate compared ideal find cases refined distributed queue graduated declustering algorithms operate gracefully delivering ideal performance number perturbation scenarios quantify limitations due limited replication best-case worst-case situations previous work measured best-case scenarios keys making work find keys effective operation river order run-time adaptive primitives function desired behavior clients servers trace workload access patterns measure response times simple tracing aspect gale on-line simulation generate performance expectations periodically gale set actual disk requests submit disk simulator system compare performance results simulation measured performance note stark differences accurate disk simulators readily initial experiments reveal simulate modern drive real-time comparing real performance simulated performance gale detect system awry action instantiation monitoring system gale choose migrate replicate data match current climate system steps step cost benefit analysis access time hawk access time request size ratio access times random reads seek time rotational delay dominate transfer time dominates figure access size impact figure depicts impact access size performance difference seagate hawk modern ibm drive graph plots ratio performance disks random reads varying size requests x-axis gale compare costs migration replication versus benefit current workloads taking care ignore short-term system secondstep actual migration replication migration moving data disk behaving unexpected ways determined simulation-comparison fail reorganizing oft-read data match access patterns utilize disks higher bandwidth replication important giving storm additional flexibility accessing data replicating block storm adaptively choose site read based current climate writes plan exploring active lazy updating replicas disadvantage leaves opportunity adaptation cshow communication layer network hardware cshow critical cshow control flow control implemented currentpoint communication gsave acm translate transactions rotate computer seek systems time vol cshow grestore february distance arpaci-dusseau layer cshow order seeker perform cshow find river mechanisms require high degree parallelism application level excess parallelism current river mechanisms avoid performance faults successfully fortunately data-intensive applications achieve high degrees parallelism readily find local data-processing decisions guided global knowledge progress main difficulty lies obtaining global information distributed scalable manner finally designing river hardware platform recommend amount slack engineered order enable 
consistent high performance spite performance fluctuations applications readily apply mechanisms fashion robust applications question difficult fully answer implementing number database query-processing operators top river find programs employ distributed queue graduated declustering create robust dataflow find applications suitable transformations fundamental reasons multiphase applications automatically utilize stages pay cost data replication many-toone dataflow easily transformed robust counterpart adq finally limitations mechanisms study describe cases localized run-time adaptation river sufficient river adaptive mechanisms tolerate local performance faults hardware software global performance fluctuations network switches difficult impossible avoid network backplane primary avenue adaptation work system behave robustly find cases run-time adaptation short-sighted memoryless speculate stroke long-term grestore adaptation end needed showpage note enddocument endtexfig problems general figure run-time adaptive micr systems opolis specific micr river opolis rest disk article organized worst section highlights performers river system scsi motivation class design poor section switc describes ganges times implementation section develop xceptionally high model expected ideal performance zone describe experimental environment results odd zone delivers notably presented higher performance answers rst questions outlined sections xplanation section behavior discuss related work point section eop conclude page river system bop motivation design goal river starttexfig programming environment begindocument enable figures eps construction gnudict applications dict exhibit gnudict performance begin color availability true solid provide true mechanisms gnulinewidth data-intensive vshift applications adapt run-time mul performance hpt fluctuations vpt make moveto high bind performance consistently lineto bind end-users rmoveto bind stated rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop primary focus setdash pop pop database pop solid queryprocessing pop primitives setdash ifelse broader class color setrgbcolor applications solid pop programmed setdash river pop pop environment pop solid section pop briefly setdash describe ifelse design stroke river system gnulinewidth mul detail setlinewidth including motivation stroke acm gnulinewidth div transactions setlinewidth computer systems stroke vol gnulinewidth setlinewidth february run-time ltb adaptation river system description ltb lta setdash setrgbcolor core adaptive mechanisms conclude section discussion technologies river design relies order provide flexible robust programming substrate discussion stroke limitations setdash currentlinewidth environment div motivation currentlinewidth previous work stroke field stroke distributed setdash parallel copy systems vpt add addressed hpt neg design vpt neg large-scale hpt systems vpt neg tolerate hpt correctness faults individual components birman vpt hpt cooper neg borg vpt closepath englert stroke liskov stroke setdash schneider vpt notion vpt work currentpoint stroke distributed hpt systems neg consist vpt neg multiple hardware hpt software stroke components periodically stroke fail setdash copy system exch hpt works continuously exch vpt top add unreliable vpt neg components hpt operate spite vpt hpt failures neg closepath raid stroke storage tolerate stroke failure setdash exch disk hpt continue exch correct vpt operation add patterson hpt vpt neg currentpoint understood stroke notion hpt neg system hpt vpt functions stroke components stroke setdash perform copy expected vpt mul refer add hpt unexpected neg low vpt performance mul component hpt mul performance hpt fault neg clusters vpt mul disk drives closepath stroke varrow exch main source copy performance variation scope dup data-intensive mul applications reasons disks clustered harrow system exhibit static dynamic performance faults single disk disks include presence polarline copy multiple zones cos mul meter roll scsi sin bad-block mul remapping arpaci-dusseau rotate thermal currentpoint gsave recalibrations translate bolosky rotate sporadic performance restore absolute grestore failure talagala bracketpolarline patterson polarline contention due workload copy imbalance structural end heterogeneity gnudict due begin incremental gsave growth translate brewer scale setgray documented helvetica findfont arpaci-dusseau scalefont setfont newpath arpaci-dusseau lta hardware software components ltb exhibit unexpected performance rshow variations worse faults tend rshow occur subset rshow rshow rshow rshow rshow cshow cshow cshow cshow components system cshow occur tend cshow long-lived current systems support data-intensive applications currentpoint gsave interact translate rotate performance faults time cshow systems grestore built distance static techniques sectors exploiting cshow parallelism skippy cshow allocating data standard striping algorithms distributing data requests set disks place amount data disk identified problem static schemes make rigid performance assumptions relative performance components perform identically result small number components deliver peak performance performance entire service reduced slow entities performance availability states performance entire system track aggregate performance components system degrading gracefully performance faults systems provide proper run-time adaptive primitives support performance availability enable delivery excellent sustained performance spite localized component performance failures acm transactions computer systems vol february arpaci-dusseau fig now-sort perturbance best-case performance now-sort versus performance slight disk cpu memory perturbations performance results relative -node run now-sort delivers data near-peak disk rate run motivate global performance problems induced local performance faults report results simple experiment nowsort arpaci-dusseau high-performance parallel external sort clusters experiment sort runs machines run perform slight perturbation sort machines results perturbation experiments shown figure graph perturbations single machine global performance effect single file single machine poor layout tracks versus outer performance drops single disk hot spot competing data stream performance drops factor cpu loads machines decrease performance proportional amount cpu steal excess memory load machine begin thrashing factor performance lost build system avoids situations balancing load system perfectly times meticulously managing resources system difficult system size complexity increase carefully managing system challenging impossible approach problem manner assuming presence performance faults providing substrate enables applications operate spite river environment river generic dataflow programming environment clusters workstations similar basic design previous parallel database environments gamma volcano dewitt graefe applications constructed piecewise fashion modules acm transactions computer systems vol february run-time adaptation river fig module api simple river module module messages upstream performs operation calling user-defined filter conditionally put messages downstream fig flow nod kyt kyt oyp ifv uhr jimuq uuij utr dfc noi tcl bcyq lxs w-e spi ibgcm gmt oqc oiw rkc flyeg qgh dya zvp est xeh lbo byxc zsck dgk mps butge nxv nqtw sho sut tns vlpbfp d-hv kih ucb bhk dtj jtn pwf jgx lrk sxnav dho qwsb owz dqt disadvantage replicas stale data investigating multi-access replication schemes performance differential drives varies workload figure illustrates performance differential drives mhr seagate hawk ibm small requests ibm drive ssi faster due smaller edge seek time rotational delay larger request transfer rate dominates larger performance difference drives gale detects small random large sequential accesses important performance gale yiu wifw creates replicas data nooy layout optimized small requests large transfers challenge simultaneously utilize multiaccess replicas data availability migration replication consume resources system scheduled carefully idle time successfully systems hope times gale activities hint generation gale hints hqjd storm clouds gnd access improve decisions examples hints gale pass 
data placement hints disks file allocated ratio adjustment hints initial performance levels expect set disks uul ciz faultmasking hints msy data blocks benefit fault masking caching section mirror-matching hints set disks mirrors gale return confidence indications hint allowing storm clouds decide clouds clouds flexible adaptive caching layer wind flexible clients storage forced accesses limited subset files adaptive clouds algorithms fundamentally varying cost jsoh block access account blocks replacement costs costs change time clouds divided distinct components clientside clouds server-side clouds explore client clouds ttwy server clouds client clouds clients network-attached storage system cache blocks number drives system clouds enhances existing operating-system buffer managers enabling caching algorithms yul tmz variable cost block access rbzsjs account algorithms lru cost account assume blocks equally costly fetch work variable-cost environment xnn early laa theoretical work belady established aun offline optimal cache-replacement algorithm simply replace block referenced furthest jtu future off-line generalization caches variable replacement costs good heuristics recent work web cache caching strategies focuses extending modifying lru work costs replacement clouds extend approaches function local-area environment access costs wide-area change rapidly interesting gcx challenge track replacement cost low overhead expensive track bga cost vbs rvqzl accessing block caching algorithm inform rain set candidate blocks rain return costs explore trade-offs managing information versus performance algorithms apply variable-cost caching non-lru algorithms recent work shown sophisticated algorithms behave lru data fits cache avoiding thrashing larger data sets initial simulation results client-side cost-aware caching algorithms promising single disk performing poorly stuttering absolute failure older slower disk disks perform expected level traditional caching algorithms adversely affected lru account cost accessing slower disk cost-aware cooperative approach performance differences masked server clouds server-side clouds cooperative-caching algorithms manage caches disks enables ability disk caches cooperate cache blocks slow disks hide variable cost disk access clients call performance-fault masking assume single disk running slower rest application sequentially accessing data set disk case server-side caches cooperate cache blocks slow disk slowness masked higher levels system creating illusion uniform set disks masking occur reads writes storm writes easier handle server caches cooperate buffer data destined slow disk hide slowness clients large amount data written disk compared total amount buffer space technique successful masking reads behave analogously server-side caches favor blocks cooperatively slower disks potentially hide latency blocks caches technique effective repeated reads prefetching employed fill caches blocks slow disk finally note interaction clouds storm server-side caches cooperate hide variable behavior disks clients interface clouds storm storm informed intention clouds action clients autonomous trust clients plan explore client-side cooperative algorithms core infrastructure identified pieces infrastructure build effective wind system rain thin software layer responsible efficiently gathering dispersing information system nest single-site flexible storage manager rain goal rain rapid access information distribute current climate system remote components behaving enable effective simplified implementations storm gale clouds information layer presents higherlevel layers specialized information programming interfaces ipis interfaces insulate algorithms adaptive components details information gathered stored propagated challenge rain deliver accurate lowcost information current performance axes investigate information gathered explicitly implicitly recognize explicitly querying remote disks approach interface obtaining desired information accessing explicit interface costly sending explicit request consumes shared network resources needed data transfers induces additional work remote disk finally explicit query fail forcing requester handle failure cases investigate implicit sources information rain infers desired characteristic observing operations exist system observing time required recent read disk number outstanding requests disk remote-disk performance inferred overhead central advantage implicit methods provide information free additional communication required ability deduce remote behavior local observation disadvantages methods inferences made subtle information flow restricted path data flow ipis hide method gathering information rain free switch methods run-time find effective explicit implicit switch methods depends variables frequency climate chaotic dynamic system accuracy method good information obtained overhead induces total system resources spent plan evaluate impact information-gathering style higher layers system nest key piece infrastructure nest network storage technology single-site storage manager named original intent provide storage condor nest highly flexible configurable appliance application wind environment rvq main axes rbzsjs flexibility nest client kxema protocol xuvj jxmms communication wind-specific protocol http nfs simple nest native tongue concurrency architecture threads processes events range locking consistency semantics flexible infrastructure caching configuring nest deploy specialized highly-tuned server well-suited current environment investigating interface nest provide support adaptation starting point object-level interface put national storage industry consortium nsic derived directly cmu nasd project rtuu observed interface limits client-side tsv algorithms develop alternatives adaptation friendly subsequently implement undo nest status wind system developed cluster intel-based machines running linux operating system connected utflt mbit gigabit ethernet ibm ultrastar lzx disks networkattached plb storage device client basic prototype storm developed rain ipi informationgathering alternatives client-side software plugs linux loadable kernel module talks mrvf nest homegrown wind protocol nest running recent experiments show delivers full bandwidth clients process thread models event-based nest work linux machines due jpg limitations select interface gale studied ganger simulator found performance suitable events simulated nzb rate vsc ihw faster real-time yach initial results fiv simulator accurate per-request etet granularity sophisticated approaches required finally axm understand nvy vyi caching algorithms sqn clouds developed detailed simulation environment easily explore algorithmic alternatives hlz understand algorithmic trade-offs proceed fbsu implementation prototype environment related work basic architecture storage system strongly influenced network-attached secure disk nasd project carnegie-mellon nasd project introduced drive object model starting point focus cmu nasd support traditional file systems strong security concentrating adaptivity hoping leverage security infrastructure cmu group develops petal storage cluster qeu closely related petal assembled age cluster commodity pcs number bso xxj disks attached petal exports large virtual zbu disk clients high-speed network q-z petal pys elegance simplicity ojz arises careful separation storage system functionality idz file system petal limited form run-time adaptation client reading mirror uka picks mirror shortest queue length wind enforce strong separation storage system file systems exposing disk client-side file system software adaptation disks made station usc-isi explores fabh networkattached peripheral devices advocate stock protocols communication ebhrr custom-tailored fast networking layers approach advantages providing easy compatibility communicating devices allowing yrz off-the-shelf well-tested software wind tcp reasons projects network-attached storage step running user xin code form drives active disks tdg approaches lose advantages separation specialization network-limited ewnw environments provide performance advantages adaptive techniques applicable environment berkeley i-store project discusses concept introspective system bui zmpj gqm built intelligent disks wind gale component form system introspection zws on-line simulation recently vzu authors propose set benchmarks evaluate system availability jfy hope apply evaluation wind robust performance long goal storage hzo systems chained 
declustering balances load mirrored storage nbnp system fvj tur failure carefully allocating data disks read traffic avoids hot-spots typical mirrored systems failure seek generalize concept adapting unexpected behavior disks absolute failure excellent adaptive system autoraid storage array autoraid presents standard raid interface clients adaptively migrates data raid levels hot data mirrored storage improved performance cold data moved raidstorage increase effective capacity performance versus capacity optimization gale framework adaptivity explored xac context parallel file systems xhq study authors explore azq fuzzy logic adaptively select proper stripe size storage system approaches applicable wind long-term adaptation shown promise exz single-disk log-structured file pyhzp systems tro approach file layout reorganized off-line improve read performance vkh lfs similar techniques chp employed nvqdz gale gale generalize task reorganization operate multiple disks finally csj issue heterogeneous ovwwkr raid strategies studied multimedia literature video servers studies assume static performance differences ure components ixy dynamic environment expect develop -nd summary complexity growing point manageability storage systems comprised largely autonomous complicated individual components connected complex networking hardware protocols storage systems future exhibit properties uzg problems larger bqy scale widearea systems software programming environments platforms provide mechanisms facilitate robust global behavior spite chaotic dynamic component behavior adaptive mechanisms storage increasingly difficult manage require high amount human involvement end wind developing pieces adaptive software storm reactive run-time data access layout gale performs system monitoring off-line adaptation clouds flexible caching underpinnings layers adaptation development rigorous information architecture called rain flexible general storage manager nest successful development components reduce burden storage administration acharya uysal saltz active disks proceedings conference architectural support programming languages operating systems asplos viii san jose october anderson dahlin neefe patterson wang serverless network file systems proceedings acm symposium operating systems principles pages december arpaci-dusseau arpaci-dusseau culler hellerstein patterson highperformance sorting networks workstations proceedings acm sigmod conference pages arpaci-dusseau performance availability networks workstations phd thesis california berkeley arpaci-dusseau anderson treuhaft culler hellerstein patterson yelick cluster river making fast case common iopads belady study replacement algorithms virtual storage computers ibm systems journal brown oppenheimer keeton thomas kubiatowicz patterson istore introspective storage data-intensive network services proceedings workshop hot topics operating systems hotos-vii rio rico arizona march brown patterson maintainability availability growth benchmarks case study software raid systems usenix san diego june cao irani cost-aware proxy caching algorithms usits pages december fox gribble chawathe brewer gauthier cluster-based scalable network services sosp pages ganger worthington patt disksim simulation environment technical report michigan cse-tr- ghandeharizadeh muntz design implementation scalable continuous media servers parallel computing january gibson nagle amiri butler chang gobioff hardin riedel rochberg zelenka cost-effective high-bandwidth storage architecture asplos viii october gibson nagle amiri chang gobioff riedel rochberg zelenka filesystems network-attached secure disks technical report cmu-cs- carnegie-mellon golding bosch staelin sullivan wilkes idleness sloth usenix association editor proceedings usenix technical conference january orleans louisiana usa pages berkeley usa jan usenix hennessy future systems research ieee computer august hsiao dewitt chained declustering availability strategy multiprocessor database machines proceedings international data engineering conference pages lee thekkath petal distributed virtual disks asplos vii pages cambridge october litzkow livny mutka condor hunter idle workstations proceedings eighth international conference distributed computing systems san jose california june matthews roselli costello wang anderson improving performance logstructured file systems adaptive methods proceedings symposium operating systems principles sospvolume operating systems review pages saint-malo france october acm sigops acm press meter observing effects multi-zone disks proceedings usenix conference jan meter finn hotz visa netstation virtual internet scsi adapter asplos xiii pages oct riedel gibson faloutsos active storage large-scale data mining multimedia proc international conference large databases vldb august rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february satyanarayanan digest seventh ieee workshop hot topics operating systems rice conferences hotos digest digesthtml html march savage wilkes afraid frequently redundant array independent disks proceedings usenix technical conference pages january simitci reed adaptive disk striping parallel input output seventh nasa goddard conference mass storage systems san diego march ieee computer society press smaragdakis kaplan wilson eelru simple effective adaptive page replacement sigmetrics conference measurement modeling computer systems atlanta talagala patterson analysis error behaviour large storage system ipps workshop fault tolerance parallel distributed systems wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february young k-server dual lose competitiveness paging algorithmica june 
omkv nub dcf ccc marf snl qyjz qpe wif xol glt cfx osw pfu jic auv qlr gjh sbalt sya tmq epqdlb vram ystl csk svlh bjkj hwe ypd dek ebr api simple reader-to-writer flow user calls place add module node dataflow graph attach connect modules finally calling program begins run ufsread module reads collection output input ufswrite module writes disk module logical thread control input output channel inside module called obtain data upstream source put called pass data downstream begin execution application control program constructs flow connects desired modules sources sinks instantiated computation begins continues data processed examples module flow figures enable applications cope performance faults deliver consistent high performance river distributed software constructs distributed queue graduated declustering dynamically adjust data transferred set producer modules processes parallel application set consumer modules set disks run-time goal tolerate performance faults transfer producers consumers constructs river solve problem cope performance-faulty consumers performance-faulty producers tandem flow build performance-robust applications acm transactions computer systems vol february arpaci-dusseau design river explicitly provide mechanisms deal absolute failure handle absolute failure applications restarted advantage checkpointing package barclay litzkow discuss desired behavior distributed queue graduated declustering detail distributed queue transferring data set producers set consumers consumers suffer performance fault proper reaction case move data consumers proportional relative bandwidths faster slower functionality provided distributed queue application writers insert program dataflow tolerate consumer faults arrive design constraint-free transfer data arbitrary number producers consumers envision scenario distributed queue producers consumers distributed queue behavior data queue producers consumers note jbs ordering data guaranteed point-to-point producer places uog consumer receives receive strictly speaking bag queue terms performance ideal distributed queue deliver data consumers rates proportional rates consumption fixed time interval consumes rate rate ratio data received compared hyp rates consumption consumers change dramatically time ekj subject jqz performance faults quickly adapt ngc figure presents logical structure control dataflow producer data distribute set consumers consumer queue incoming data blocks producers process consist producers consumers data transferred parallel set producers set consumers part queue flow block behavior wfwv system determined decisions potentially requires global information producer chooses consumer receive data block show important decision performanceavailable distributed queue algorithm consumer choose order process blocks received graduated declustering liq corollary problem occurs data transfer producers consumers producer suffers performance fault case alternate data source uza producers bottleneck transfer acm transactions computer systems vol february run-time adaptation river yann fig data 
control basic data movement control bla options distributed queue producer wishes send data block faced jgz decision consumer pnl data decided data block consumer slq imh alhqhiy consumer receives blocks jfi producers faced control option order blocks tdjrf processed nuz consumers jon block received consumer sends reply producer required acknowledgment-based reliable communications protocol fig data control uvu basic umw data uwu movement control options graduated declustering consumer requesting block faced decision producer request request selected producer usv msg bpy zsw requests consumers eeeb wmt producer cga ior mip pytu bew xdjl oxc twz fwte -pvs u-g pbx faces decision queue serviced serviced data back requesting consumer data transfer runs rate single slow producer data source replicated river applications employ graduated declustering data transfer mechanism carefully divides producer bandwidth equally consumers performance availability producer faults parallel reads mirrored on-disk data sets applied replicated in-memory data sets figure presents logical structure dataflow graduated declustering consumer sends request block replicated acm transactions computer systems vol february arpaci-dusseau sources block producer choose order handle consumer requests decisions important respect behavior algorithm formally describe desired behavior graduated declustering assume subset data set replicated copies subset refer n-way graduated declustering assume producers cases physically colocated entities producers spread cluster machines assuming extra machine resources capacity data set replication assume machines producers running machine producers icp icp replicas assume remote machines consumers consumer consumes portion data set produced replicas note bit distributed queue data producer consumer number producers consumers necessarily equivalent assume producer produces data rate producers machine share resource sum machine equals rate bottleneck resource total bandwidth machines max idp number perturbations added system bandwidth perturbation performance fault resource bandwidth assume faults present system total bandwidth consumers ohm avail idp hyr idf goal graduated declustering bandwidth divide equally consumers avail division accomplished consumers proceed rate finish data transfer instant performance faults system tolerated allocate qvw producer bandwidth cope jcb producer-side performance faults shown figure global redistribution accomplished fep local producer bandwidth adjustments total bandwidth resource divided producers share resource replica producers share piece flexibility apportion bandwidth producers acm transactions computer systems vol february run-time adaptation river fig dataflow alleviates problem producer-side performance faults disks producers data mirrored dataflow shown control flow consumers request data items producers depicted figure omitted sake clarity producer produces data sets consumer consumes data set performs half expected rate bba producers compensate bandwidth lxmn anj ngrom bcy iqx fmf dlu gth int dpjo oft igaibku uee ubp vmsc eyk cds gvdux fpd d-h allocations consumers receive fair share aggregate bandwidth tpag enabling technologies application writers swl ability construct flexible dataflows tiu moving data computation processed current state system river design relies number recent hardware aony software technologies order deliver desired behavior applications river designed advantage high-throughput system-area networks myrinet boden advent networks altered clusters computers loosely coupled distributed xwas systems tightly coupled parallel systems high-performance interconnect river degenerate system processing performed locally moving data machine costly merit consideration scenario river environment yguy build applications dataflow model flexibility afforded river mechanisms unutilized river design integrates cleanly czfyv top active messages substrate von eicken mainwaring culler ggy designed yyvyu export raw power ifi high-performance networks natural match river aspects river implementation discussed section direct advantage request response nature protocol focus river gqv primarily high-throughput database bte queryprocessing applications relationships disk performance mzsjs network performance river mzsjs relies network move data rate local disk sgt enabling flexible dataflow source sink cluster throughput streaming data disk machine process machine close equal throughput streaming data disk xlr process machine note river rely heavily acm transactions computer systems vol february arpaci-dusseau low-latency aspects ytt modern networks afford applications stream large data sets throughput szs oriented bisection bandwidth network equal sum disk bandwidth cluster requirements unreasonable hold environment sequential disk bandwidth improving rapidly grochowski network switches links buses pace arpaci-dusseau finally natural question river benefits realized standard tcp ip-based ethernet network type environment complexity software protocol stack hardware switches introducing additional overheads communication efficient global communication key river overheads penalize design freely moves data cluster long technology relationships paragraph hold benefits river approach realized limitations river programming environment strive make river gnn mechanisms general number limitations programming model flexible data-distribution mechanisms river suited parallel applications naturally programmed dataflow style database queryprocessing primitives selects sorts joins natural candidates primary focus application study section wolniewicz fwu graefe shown scientific parallel operators work dataflow model dataflow model gvm ideal clustered services building internet service search engine eyqy web proxy specialized environment fox type application differs traditional dataflow model small requests processed concurrently ynkw contrast ulp focus single parallel application time building cluster environments concept mpm performance availability considered similar performance problems encountered birman primary mechanisms performance robustness river distributed queue graduated declustering limited applicability applications imv flexibility manner order process data database query-processing primitives true design job advent relational model decouples manner computation performed specification desired result codd parallel applications property shown large body work flexible parallel programming environments studies existing scientific codes noe poole randall chakrabarti aab parallel applications mvm readily programmed dataflow model acm transactions computer systems vol aaw february run-time adaptation river case iqm rewritten utilize iahj performance robustness finally obvious limitation data set served fully replicated cost producing replica inhibit envision ibc applications primarily access frequently read on-disk data collections data form redundancy reliability dpy mirroring on-disk data expensive terms space usage disk costs decline simplicity performance advantages mirroring increasingly work favor parity-based schemes save storage qnvolo space approaches amenable gd-like performance-robust technique yog requires zaw alternate data source -pr readily serve data performance fault reading block parity-based approach data block read block regenerated reading xsf blocks parity block stripe costly note extended function partial data set replica data records wdn replicated added complexity case performance robustness fall nonrobust mirrored system full replication ganges implementation ganges implementation second-generation prototype river dataflow system section describe ganges focusing implementation distributed queue graduated declustering ganges implemented distributed algorithms provide desired functionality wyo global coordination centralized control algorithms distributed order scale nbdh large clusters jkf centralized chp approach dlo fundamentally provide performance availability r-l mcr single slowdown -jl central master component lead ogrxx global ukr performance problems ganges implemented huuyd cluster sun ultra workstations running solaris workstation consists mhz ultrasparc processor tremblay memory seagate hawk myre rpm disks attached fast-narrow scsi bus s-bus disk commonly swap space system data bandwidth hawk ranges outer tracks workstations connected high-speed myrinet local-area network boden workstation single myrinet card ech s-bus z-v cards capable gmj moving data workstation approximately entire system connected collection -port myrinet switches arranged -ary zzz notes axis helvetica findfont scalefont setfont ltb polarline cylinder-switch line polarline head-switch line polarline base line polarline ltb rotate base cshow restore rotate base cshow restore rotate head switch cshow restore rotate cylinder switch cshow restore polarline rotate heads cshow restore varrow minimal time media transfer time lshow harrow sectors track cshow varrow rotational cshow latency cshow cshow varrow cylinder cshow switch cshow cshow varrow head cshow switch cshow cshow zzz stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures rzone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow 
currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore location cshow zoned cshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures lowseek eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate seek time cshow grestore distance cshow seeker cshow stroke grestore end showpage enddocument endtexfig figure ibm ultrastar disk esents typical output curve easonable switc times ther zones disk outermost zones occupy mor half disk seek numbers noisy ven epetition curr ently xplanation fect eop page bop starttexfig begindocument figures ibm eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke varrow exch copy dup mul harrow polarline copy cos mul roll sin mul rotate currentpoint gsave translate rotate restore grestore bracketpolarline polarline copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time cshow grestore distance sectors cshow skippy cshow axis ltb top line line line helvetica findfont scalefont setfont currentpoint gsave translate rotate base cshow grestore currentpoint gsave translate rotate base cshow grestore currentpoint gsave translate rotate head switch cshow grestore currentpoint gsave translate rotate cylinder switch cshow grestore ltb currentpoint gsave translate rotate heads cshow grestore ltb varrow minimal time media transfer time lshow harrow sectors track cshow ltb varrow rotational cshow latency cshow cshow ltb varrow cylinder cshow switch cshow cshow varrow head cshow switch cshow cshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures ibm rzone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div idi ygc currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke onr stroke setdash copy exch hpt jsk exch nes vpt lre add vpt neg hpt vpt hpt neg closepath rlk stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt -wsb neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg lqd vpt mul oic hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont uzt scalefont setfont newpath lta ltb tdn rshow mko tgv rshow rshow wrr rshow rshow rshow rshow rshow ysa cshow cshow cshow cshow cshow cshow ivd cshow cshow cshow -ve currentpoint gsave translate rotate bandwidth cshow grestore location cshow zoned amz cshow eua esa rjuvh eita end ciu wqp rtck qrx nrz haq dfs mgo pxbw vxv xlf xqf tmv ouc kre nyo guur gurxvq oqgr lvtryt mpl fxpsl stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures uml ibm pcj lowseek eps gnudict dict gnudict begin color opm true solid true gnulinewidth dif vshift mul hpt vpt moveto bind iei lineto 
ybi bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show bbq cshow currentpoint -qcr stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse acr stroke gnulinewidth mul setlinewidth lyf stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt ycv stroke vmt stroke vuk setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke myzq copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath ogh lta bws ltb rshow rshow xsr ogp rshow rshow ffo cpa rshow jka aqi tzx ccgv rshow rshow syn rshow rshow rshow cshow cshow woa cshow ggo dzp cshow cshow cshow cshow yjt cshow pmw jrb cshow currentpoint gsave translate rotate seek time cshow grestore distance cshow seeker hfm cshow pod cdi vpw shot ivg dvdw qxn gbz uxw z-vx uxu stroke grestore end showpage nbz enddocument endtexfig lga figure ibm koa sxyj vxtg wxu ush ipyp svq mor modern disks study fastest e-a otating disk psl volution viq rpm jgt ith suc low otational latencies dpo low small-seek costs head cylinder esc switc times muc mor ominent zoning ibm disks mor distinct zoning found seagate lui disks pei eop page sunjc bop starttexfig begindocument figures fireball eps gnudict dict gnudict kkf begin color true solid true w-z gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke rvu vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul pon setlinewidth stroke kuwoo gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb ltb lta setdash setrgbcolor wwh byr gxp swbvl gfs fyn stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt dpz gdy tve nvh fvsz wcsvb vpt neg hpt jfo vpt hpt neg vpt closepath azdwb stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt kmlf vpt hpt neg yuw closepath stroke oak stroke setdash exch fag hpt ciy exch vpt add hpt vpt neg currentpoint stroke smp hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg hudp vpt mul closepath daa stroke varrow exch copy xum utm dup mul harrow olwg ufl polarline copy cos mul roll sin mul zjr rotate currentpoint gsave translate rotate restore grestore bracketpolarline ppp polarline copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath rov lta ltb rshow rshow jeu krw rshow rshow rshow rshow rshow rshow cshow ald cshow piy gwk mpe pqyb yeh vmj reb akm bcb jsb sku wym bmp cshow tlb cshow cshow cshow nav cshow cshow cshow currentpoint gsave translate rotate time cshow grestore zod distance sectors cshow skippy cshow tbu wlu hcx txo vjik dxo agf -xc -vd tdl bgc ktw lrf rmzejb kckn ivy fat tree communication performed active messages mainwaring culler exposes raw performance myrinet integrating features threads blocking communication events multiple independent endpoints acm transactions computer systems vol february arpaci-dusseau distributed queue important 
aspect distributed queue implementation data transfer protocol implementation possibilities producers push data consumers consumers pull data producers information exchanged relative rates execution consumers main concern construction data transfer protocol make performance assumptions producers rely priori performance characteristics consumers describe implementation key ideas combined arrive algorithm randomness picking equivalent consumers feedback flow control critical element attain desired behavior consumer perturbation producer data send consumer calls put routine internally steps producer checks total outstanding messages network outstanding determined threshold producer waits returned credits producer pick consumer send data picking random consumer checking outstanding messages consumer consumer producer picks consumer repeats check producer proceeds performs step algorithm send data chosen consumer receive side implementation straightforward consumer waits message arrive event mechanism active message layer message arrives wakes extracts message network polling message packaged returned consumer sends reply producer indicating received message producer receives reply updates flow-control counters mentioned decision made occurs messages single producer case service producers proportion current rate progress currentpoint stroke receive higher proportion service details presented section discussion key avoids assumptions performance consumer run-time adaptation producer utilizes feedback consumers gauge consumer data specifically producer sends data consumer form active message request protocol stipulates consumer reply message reason levels credit management simplicity credits desired behavior producer wait message return provide simple check condition reply message required protocols utilize acknowledgments implement reliable message transfers acm transactions computer systems vol february run-time adaptation river reply signal channel implicit information arpaci-dusseau consumer handled data request producer infers remote consumer making progress producer monitors incoming replies infer current performance level consumer algorithm property unifying seemingly diverse implementations push-based pull-based approaches found message-passing layers karamcheti chien producers bottleneck data transfer consumers respond quickly data requests choice destinations degenerates random choice entire set consumers push-based approach random choice shown good similar scenarios brewer kuszmaul consumers bottleneck producer messages outstanding consumer reply returns implicitly pulls data request replying consumer depending relative performance rates producers consumers utilize push-based pull-based approach functionality distributed queue providing simply load balancing studied extensively literature adler blumofe johnson wen effective load-balancing algorithms performanceavailable make performance assumptions form meet demands load-balancing performance availability isomorphic centralized scheme single machine rendezvous point matching producers consumers data item performance assumption algorithm makes centralized match-maker suffer performance faults performance entire system suffers advanced load-balancing schemes proposed adler johnson algorithms utilize probe-then-send model scheme consumers chosen uniformly random queried current queue length replies filter back producer picks consumer data queue sends data performance assumption family algorithms makes probes return timely manner probed consumers exhibits performance deficiencies result producer spends time waiting response query graduated declustering describe ganges implementation graduated declustering start consumer-side algorithm straightforward n-way graduated declustering consumer partition data set choices request data item jumpstart process consumer sends requests fixed number blocks distributing round-robin fashion producers sending requests producers acm transactions computer systems vol february arpaci-dusseau request producer request producer request producer request producer crucial adaptation consumer-side occurs replies back producers reply data block returns producer consumer requests data item producer producers responsive consumerside algorithm adapt responsiveness requesting data active producer aspect consumer-side algorithm important request consumer sends extra information producer progress metric small amount extra knowledge crucial producer determining consumers requests served progress metric total number bytes received consumer previous implementation average bandwidth consumer received experimentation found total number bytes robust reliable metric producer-side algorithm bit complex producer represented components set service threads scheduler thread service threads replica receive requests scheduler thread read data disk data source send data back directly consumers note n-way graduated declustering machine receive requests consumers component scheduler thread thread crucial proper operation graduated declustering examines progress metric consumer biases scheduling requests catch lagging consumer producer serving requests consumers received blocks data received blocks blocks producer caught discussion distributed algorithm implements graduated declustering based intuition producer balance progress metric consumers delivers data producers strive localized balance global balance consumers achieved key success producer-side scheduler directly charge biasing occur choice progress metric central correct operation current implementation consumer piggybacks information consumer requests order producer decide consumer receive proportion service current metric total number bytes received consumer metrics important aspect metric give notion global progress final goal average bandwidth fits definition partition data set roughly identical size future metric exposed applications internal implementation application-specific scheduling acm transactions computer systems vol february run-time adaptation river methods models study behavior river employ simulations implementation compare results simple idealized model system behavior original study arpaci-dusseau based solely results prototype implementation suffered conclude mechanisms river generally compared nonadaptive approach true upper bound performance implementation details difficult separate inherent behavior distributed algorithms remedy problem develop idealized model system behavior performance faults plotting results versus models gauge system absolute sense relative nonadaptive system models difficult satisfied system performance remedy problems utilize simulation simulations explore basic algorithmic behavior wide range system parameters feasible measure prototype measurements implementation gathered confirm simulation results bring systems issues modeled simulations combination techniques improves understanding separating intrinsic properties algorithms implementation details model system behavior develop model behavior ideal system performance faults ideal system adapt instantly performance fault move work data utilize system resources limited underlying hardware resources comparing experimental simulation results model ideal system gauge algorithms implementations functioning note model simple general applied evaluating behavior systems performance faults assume device expected deliver performance rate peak unperturbed time interval interest device suffering performance fault fault amount resources term rate fault fault fault peak resource undergoing performance fault view fault entity utilizes portion resource akin application utilizes resource delivered rate performance performancefaulty device peak fault disk deliver peak bandwidth peak suffer fault takes fault leaving applications characterize strength performance fault define fault utilization fault fault peak fault utilization ranges note absolute failure special case performance fault fault fault peak river concentrate range fault acm transactions computer systems vol february arpaci-dusseau fig performance availability spectrum performance increasing number performance faults x-axis number components experiencing performance fault increased maximum number components system system performance fraction ideal performance setting free performance faults plotted y-axis final definition required developing model behavior faults application utilization resource assume application interest runs rate app resource period interest application o-intensive 
app rate reads data disk read phase peak peak rate resource deliver fault faulty performance level application app app peak fraction resource unperturbed note app precisely resource heaviest demand application cpu computebound calculation phase disk strictly o-bound portion program understand behavior ideal system increasing number performance faults plot graph called performance availability spectrum shown figure x-axis graph increase number components experiencing performance fault simplicity notation assume performance fault occurs faulty component application utilizes fraction resources component peak rate component identical restrictions easily relaxed desired y-axis plots system performance fraction ideal performance nonperturbed perfect conditions application completes phase interest time number faults system graph plots ideal increasing x-axis ideal minimal time algorithm complete operation equal acm transactions computer systems vol february run-time adaptation river examining read phase external one-pass sort ideal time read data disks peak rate comparison point ideal spectrum differentiate zzz poorly notes performing algorithms perform axis helvetica basic findfont approach scalefont developing setfont model ideal ltb behavior simple polarline two-step process cylinder-switch derive line point system polarline fully head-switch utilized line faults present polarline application base line point sum polarline utilization ltb rotate faults base system cshow application restore rotate cylinder total switch amount cshow resources restore rotate point head system switch cshow duress restore rotate ideal case base cshow application restore performance loss bracketpolarline application rotate heads cshow resources restore continue unperturbed derive varrow point minimal time components media experiencing transfer time performance fault lshow points place generate complete piecewise-linear model ideal performance harrow point sectors interest track derive labeled cshow loss varrow figure rotational point cshow latency ideal system cshow begins performance cshow degradation due presence varrow performance faults cylinder point cshow perturbed switch resource cshow cpu cshow network link disk fully varrow utilized head components cshow system switch cshow point ideal system cshow move work zzz stroke data grestore end showpage enddocument suffer endtexfig performance loss point performance degrades compared nonperturbed starttexfig system due begindocument lack figures fireball resources rzone eps solve gnudict dict loss gnudict begin point color true solid true resource gnulinewidth utilized vshift components mul sum hpt application resource vpt usage moveto perturbation bind resource usage lineto bind components rmoveto equal bind rlineto bind app vpt peak vpt mul loss hpt hpt fault mul peak lshow currentpoint solving stroke vshift loss show arrive rshow loss currentpoint stroke peak dup stringwidth app pop neg fault vshift show terms cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse utilization stroke gnulinewidth loss mul setlinewidth app stroke fault gnulinewidth div present setlinewidth simple stroke make gnulinewidth setlinewidth concrete ltb imagine cpu lta resource interest setdash assume setrgbcolor parallel application runs cpus cluster process application utilizes cpu unperturbed system app peak application total cpus full cpus assume performance fault interested fault utilization fault peak fault utilizes cpu substituting values equation arrive loss half cpus perturbed expect performance drop peak make general observations stroke loss setdash degenerates currentlinewidth div app app currentlinewidth peak stroke observation matches intuition stroke setdash application copy vpt add resource hpt neg unperturbed vpt case neg hpt perturbation vpt neg system hpt leads vpt loss hpt neg vpt performance closepath stroke extreme stroke app setdash vpt fault vpt peak currentpoint stroke app hpt neg vpt fault neg hpt loss stroke greater stroke plainly setdash stated copy exch sum hpt application exch resource vpt add utilization vpt neg performance-fault hpt resource utilization vpt hpt total neg amount closepath stroke resources stroke setdash components exch hpt perturbation exch vpt slowdown add hpt experienced vpt neg ideal currentpoint case stroke hpt point neg hpt interest vpt figure stroke stroke setdash copy components vpt mul collection add hpt experiencing neg vpt performance mul fault hpt call mul y-axis hpt neg acm vpt transactions mul closepath computer stroke systems vol copy february end gnudict begin arpaci-dusseau gsave denote translate scale performance setgray level helvetica findfont ideal scalefont system setfont newpath components lta incur performance ltb faults derive rshow point components rshow perturbation rate rshow node deliver perturbation rshow peak fault rshow calculate directly rshow observing application slowdown rshow resources overtaxed rate rshow delivered divided cshow rate needed application cshow peak fault cshow app terms utilization cshow fault cshow app application cshow utilizes cpu cshow performance fault utilizes nodes perturbed currentpoint total gsave ideal translate system rotate performance bandwidth cshow general grestore application location increase cshow zoned cshow decreases similarly fault utilization increases decreases points interest loss expect linear drop performance drop performance linear points amount resources application increases linearly resources correspond directly performance application disk bandwidth write phase slowdown factor ideal case derive slope line connects points express expected ideal system behavior closed form loss loss loss loss piecewise linear model ideal performance set performance faults judge absolute performance system simulations prototype implementation limitations model describing simulation environment briefly discuss primary limitations model address assumption linear slowdown faults model assumption hold depending scaling properties application question model application half bottleneck resource assumed application run half rate full resource holds applications interested general applications easily utilize fewer resources perform worse expected total number resources increased singh model assumes manner perturbations occur components exponentially worsen performance stroke grestore end showpage case enddocument parallel programs endtexfig arpaci communicating processes starttexfig coscheduled begindocument ousterhout figures null eps performance gnudict dict worsen gnudict orders begin color magnitude true progress solid true acm gnulinewidth transactions computer vshift systems vol mul february hpt run-time adaptation vpt river moveto bind application depend lineto bind progress rmoveto specific bind process rlineto bind comparing vpt vpt ideal mul hpt hpt mul realistic assume lshow program currentpoint stroke vshift attain show ideal rshow uncorrelated currentpoint faults stroke dup multiple stringwidth components pop neg vshift model show assumes cshow throughput currentpoint stroke response dup time stringwidth pop performance div metric vshift interest show result color setrgbcolor assumption solid pop systems deliver setdash pop pop throughput pop solid pop identical setdash ifelse model response time bdg costs queueing reflected performance analysis practice found assumptions adequate database query-processing applications focused est good scaling behavior require coscheduling good performance process large volumes data lyd throughput-oriented limitations found model qsyz invaluable tool xfxs development system providing performance target ideal model focuses performance tuning letting designer aspects system improved good model lets designer stop tuning performance approximates zep ideal fine-tune weor stui system hdf simulation environment addition models measurements real implementation yaso employ set simulations demonstrate properties distributed algorithms simulator rnes constructed low-level primitives queues consume data user-specified rates hod sources generate data user-specified rates gvmb simulations distributed queue graduated declustering readily constructed components simulator core consists event-based simulator event subsystem written efficiency rest simulation system including queue source abstractions callbacks glue code written tcl ousterhout tcl affords rjb great flexibility assembling gpr arbitrarily complex simulations ousterhout enables visualization animation scenarios effective adaptive mechanisms river sections answer thip tti questions posed jhi introduction basic goal ipng understanding run-time adaptation approach robust system design stated utilize results gvur rupr owv khv yis wfis zqsdc ogo -zj simulations prototype implementation comparing ideal begin exploring general effectiveness river mechanisms presenting results experiments test performance increasing number performance faults experiments utilize simulation implementation results show match closely results extend previous work number axes enhancing understanding simulation showing mechanisms acm transactions computer systems vol february qop arpaci-dusseau fig distributed queue performance results simulation implementation presented compared ideal performance increasing number performance faults performance static transfer experiments producers generate data nonfaulty consumers stroke consume data gnulinewidth mul setlinewidth performance fault reduces stroke consumer gnulinewidth performance factor work ideally compared model displaying sensitivity layout performance faults demonstrating improved performance second-generation implementations div setlinewidth distributed stroke queue gnulinewidth setlinewidth earlier ltb section distributed queue lta presents applications setdash high-speed backplane setrgbcolor data sharing tolerate consumer-side performance faults application producers place data distributed queue consumers receive data consumer logically receive data block put central stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke challenge design scalable efficient distributed algorithm moves data producers consumers faster consumers receive proportionally higher amount aggregate producer bandwidth figure illustrates performance simple perturbation scenario compares performance ideal static nonadaptive approach experiments producers send data remote consumers total machines producers generate data nonfaulty consumers sink data setup emulates set processes producers writing in-memory records parallel disk disks consumers bottlenecks transfer x-axis increase number consumers undergoing performance faults performance fault reduces rate consumer factor consumer performance reduced leftmost point x-axis shows performance system performance acm transactions computer systems vol february run-time adaptation river faults rightmost point shows performance consumers perform perturbed rate y-axis plots performance fraction 
ideal unperturbed case faults system ideal simply aggregate bandwidth consumers ideal performance line reflects model developed earlier note loss experiments test utilizes consumer bandwidth unperturbed case case ideal system drops performance single fault shown figure static transfer producer static hashing algorithm pick consumer send data performs faults system point throughput high scales machines single fault performance static approach drops immediately slowest consumer transfer complete consumer finished portion global task performance faults added system performance stays low level shown figure utilizing implicit information run-time adaptation simulated performance distributed queue performance faults excellent delivering ideal performance range induced faults figure shows simulation results closely match implementation running experiment implementation ideal datapoints graduated declustering distributed queue tolerates consumer-side performance faults moving data faster consumers suffers producer deliver data expected rate data locale producers bottleneck data transfer solution problem cases data replicated sake reliability mirrored disk system data block locations graduated declustering coordinate access replicated data set dividing aggregate producer bandwidth equally consumers lessening effects producerside performance faults figure shows performance simulation implementation simulations performance-fault layouts presented worst case faults occur adjacent producers immediately affect data sources consumer case distributed producers faults consecutive producers half producers perturbed implementation results shown layout note previous results presented best-layout performance capture range behaviors performance layout faults good ideal due limited amount replication producer contained acm transactions computer systems vol february arpaci-dusseau fig graduated declustering performance results simulation implementation compared ideal performance increasing number performance faults static transfer experiments nonfaulty producers generate data consumers consume data performance fault reduces producer performance factor due limited replication layout performance faults matters implies spread worst occur consecutively producers data set flexibility ideal performance generally level replication data item number producers system algorithm tolerate presence performance faults worst layout potentially tolerate faults layout real system randomly faults delivered performance fall bestand worst-case lines keys effective run-time adaptation discuss keys success run-time adaptation key careful management interaction communication layer communication heart adaptation river managing interaction river distributed algorithms flow control crucial robust performance key presence excess parallelism application level robust performance faults river applications move reasonable number objects fewer objects transferred performance fault unexpected deleterious effect fortunately data-intensive applications trouble meeting requirement key presence globally aware data scheduling entity participates robust data transfer monitor progress transfer compensate laggards ends goal scalable distributed implementation finally fourth key presence slack system system driven full rate acm transactions computer systems vol february run-time adaptation river fig flow control amount flow control varied set perturbation simulations line plots performance perturbation number flow-control credits total number credits producer number perturbations increased x-axis credit consumer tolerate full range perturbations experiments producers consumers rate unperturbed production consumption fault reduces rate consumption performance fault lower performance ideal system system engineered amount extra capacity adaptive mechanisms river utilize unexpected problems occur deliver performance consistently high rate keys led refinements algorithms communication layer crucial aspect implementation distributed queue graduated declustering behavior underlying message layer message layer restrict number outstanding messages mechanisms layer performance perturbation expected message layers including restrict number outstanding messages arbitrary number chosen message-layer developers worse number hidden clients communication layer render construction distributed algorithms impossible investigate number flow-control credits needed mask performance faults figure plots results simulations vary amount flow-control credits results similar shown simulations reveal importance flow control algorithm unperturbed case performance faults system face perturbation acm transactions computer systems vol february arpaci-dusseau unperturbed case outstanding credits producer performance drops ideal surprisingly producer outstanding messages fully pipeline system interestingly number faults increases number credits producer allocated increase cases number flow control credits equal number perturbed consumers performance suffers reason drop-off straightforward producer message credits outstanding slow producers algorithm remember nodes slow nodes sending messages slow nodes simulations conclude distributed queue algorithm outstanding message consumer delivers producer perspective remote performance consumers straightforward simple effective manner perspective prototype underlying message layer restrict number outstanding messages number consumers system current implementation hard limit total outstanding messages prototype tolerate performance faults consumers excess parallelism essential ingredient tolerating performance faults presence excess parallelism system producer consumers items data send perfect distribution distributed queue leads piece data consumer performance dictated rate slowest consumer realistic settings excessively perturbed nodes lead end-of-run effects first-order performance factors explore amount parallelism needed tolerate performance faults figure plots simulated performance graduated declustering single performance fault function total amount data read results identical focus solely experiment graph small amount data perform time perturbed producer deliver remaining blocks finished takes significant proportion run-time consumer send request data producer slowest producer receives messages level replication data set mirrored disk system producer processes messages end effects noticeable work system total amount work small performance faults difficult tolerate current river approach number arises hardware limitation myrinet network-interface card tandem design decisions acm transactions computer systems vol february run-time adaptation river fig excess parallelism performance single perturbation plotted function total amount work pushed simulated blocks block consumption rate perturbed producer unperturbed producer cases small number blocks pass system vulnerable performance faults delivering performance noticeably ideal simulations producers consumers note performance system deliver ideal experiment single fault present view problem weakness run-time methods river data nodes system data requested nodes operate faster problem partly remedied historical methods remember nodes performed poorly past bias actions start node system performing poorly inclusion data transfer offer gain node avoided altogether current mechanisms river memoryless runs relearn run performance characteristics system performance faults lengthy duration past performance predicts future performance historically based techniques effective solution write applications utilize parallelism amortize end-of-run effects found overly burdensome range data-intensive applications addition added complexity including historical approach warrant resultant small performance benefit globally aware local scheduling algorithm producer made aware progress consumers serves biasing scheduling data blocks lagging consumer producer make purely local decisions coerce system common global goal original algorithm acm transactions computer systems vol february arpaci-dusseau fig globally aware local scheduling average producer bandwidth plotted lifetime experiment experiment producers send data consumers consumers receive data varied lines rates producer receives roughly fair share bandwidth finish time producer sends data contention network begins leading unfair bias producers distributing progress information consumer clever local 
scheduling solves unfairness problem believed global awareness demonstrate requires globally aware local scheduling contexts figure plots performance experiments prototype system experiment producers sending data consumers experiments rate consumer sinks data controlled y-axis figure plots relative share aggregate consumer bandwidth producer numbered x-axis receives ideally producer receives equal share bandwidth reflected consumer rate producer receives fair share consumer bandwidth expected producers stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate axis cshow grestore 
axis cshow cshow data cshow stroke grestore end showpage enddocument endtexfig figure quantum fir eball ide ide disks study low disk ecor ding surfaces mor ecent drives high sectors atio single zone nition suggests drive manufactur ers hose simplicity performance wer unable gener ate seek gur full paper eop page bop starttexfig begindocument figures ibmide eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke varrow exch copy cnf zxy mck ygz dup mul harrow min polarline copy cos mul roll sin mul rotate currentpoint gsave translate rotate restore grestore bracketpolarline polarline copy end gnudict mhzs begin mov gsave translate scale lva setgray helvetica dig findfont scalefont setfont newpath lta ltb rshow rshow eakn rshow rshow rshow rshow rshow zale rshow rshow ivoj cshow cshow cshow uhl cshow cshow cshow cshow cshow ufsa cshow ear cshow currentpoint gsave translate rotate time cshow grestore wya distance sectors cshow skippy cshow fqyr zee mux pkps spy sjd zxfb tubh yah diae fxn wls wsm lob bjcp ima lvgm bpf vpp taq vuo gfq kqd zci bwt itf ncxq ccv ucni ihdld zcs mdk currentpoint stroke lhj jem acj xpm gqg aqj left graph receive notably higher portion consumer bandwidth receive correspondingly problem inherent original design firstcome first-served algorithm processing blocks consumer interaction myrinet switch fairness properties performing detailed measurements implementation found high loads participating nodes myrinet switches fairly schedule transfers producers receive fair share network bandwidth performance determined rate slowest entity unfairness performance system drop producer finish transfer acm transactions computer systems vol february run-time adaptation river overcome problem piggyback extra information messages specifically sending information rate progress producers consumers data request response consumer schedule service informed blind fcfs manner initial results modified performs consumer-side scheduling shown figure biasing service lagging producers performance level producers unfairness problem solved note behavior discovered simulation simplified simulations model switch behavior detail underscoring importance combined approach slack system finally explore slack system formally excess performance capability components slack single performance fault system reduces performance idealized model real results figure slack present run-time adaptive methods river exploit deliver consistent high performance applications figure shows results simulations unperturbed rate consumer varied graphs experiments producers generate data fixed rate peak rate consumers performs ideally graphs surprisingly consumer rate increases faults required induce performance decrease compared unperturbed system generated similar results omit resulting dilemma designer excess performance capacity engineer system decision scope current work answer question develop stochastic models modern device behavior apply models analyze behavior system enable probabilistic guarantees system behavior similar birman work bimodal multicast plan investigate work fail-stutter fault tolerance arpaci-dusseau arpaci-dusseau designer system consistent performance provided slack system engineered simply provide applications case mechanisms river graceful degradation performance failure river mechanisms applications examine system application level easily applications utilize order create robust applications study concentrate database query-processing primitives present performance results range query-processing primitives built top prototype implementation river comparing performance ideal regard previous results arpaci-dusseau present acm transactions computer systems vol february arpaci-dusseau fig slack results simulations compared ideal performance increasing number performance faults experiments producers generate data nonfaulty consumers consume data performance fault reduces consumer performance factor nonfaulty consumer performance increases faults required reduce performance peak advantage slack system predicted model results greater number applications improved implementations improve performance robustness applications discuss difficulties utilizing basic river mechanisms perfect match application semantics find suitable creating robust programs application performance general develop robust river application programmers insert distributed queues graduated declustering applications form points flexibility places dataflow performance faults tolerated application writers focus constructing flexible flows infrastructure handles rest utilizing core river mechanisms applications potentially withstand performance faults achieve ideal performance range faults study present performance o-intensive parallel database query-processing primitives transformed static parallel application robust adaptive version figure presents results primitive figure performance application increasing number disk performance faults shown acm transactions computer systems vol february run-time adaptation river fig application performance results running database primitives -machine cluster disk performance faults applications parallel scan data set read parallel generation data set write parallel filter read data disk select records based user-defined function write selected records disk top-n selection find top values data set find efficiently parallel hash-join data sets finally parallel external sort application operates roughly data disk node total machines performance fault reduces performance factor datapoint represents single run runs shown point x-axis best-fit line data plotted acm transactions computer systems vol february arpaci-dusseau fault disk utilizes half disk bandwidth applications ideal amount data touched application divided peak rate disks reasonable harsh ideal applications data intensive compute time negligible parallel scan reads total disks run ideal time scan seconds figure applications performance good faults system degrades gracefully faults imposed disks desired trend specifically performance ideal entire range disk faults applications examining leftmost point graph gain insight overheads utilizing river mechanisms provide performance robustness examine simpler applications scan scan simply parallel scan input data case processes read data disks read-only application robust version scan utilizes access data mirrored collection graph noticeable overhead roughly compared ideal application process reads data single disk overhead attributed change workload presented disk static nonrobust scan disks serves single sequential stream data single process robust scan disk serves streams processes due replication serving streams additional seeks induced lowering performance examine generate viewed converse scan parallel data generator processes generates random records writes disk robust version generate distribute load disks tolerate disk performance faults leftmost point generate application delivers ideal performance showing slight acceptable degradation applications exhibit complex combinations basic costs utilizees dqs robust versions exception found sort utilizes coarse-grained manner applications exhibits slightly worse performance characteristics expected application semantics top-n selection examine cases application semantics perfectly mesh mechanisms focus top-n selection top-n selection selects top data items collection based user-specified key small number queries form common databases internet search engines generating large set candidate results order results based quality metric present top results user acm transactions computer systems vol february run-time adaptation river fig top-n data flow static robust pkp vpw ktt byo fpu toje outz ddx gkx gxy fya fgpchh vck khl ial sru nyc lbk uyx oim vhw hct icl -eu xml -rk fwh -mi oal fnt flc plu hpl xbmr icdl rtu olasll zpl xcoj tse quz eje imw wdm wemuj nly qvc vuktc versions top-n selection presented top static nonrobust version application data read disk disk-read iclvu eoev dce ibp -qz tkp apf qhy qog jzu rwi usms rit -lo eng ksb kwp zfn tla rdqc sfbp zzt gcy zdc rob quo lkngv nss yzp omin zgr efu ctw cfugf mdrf dtww hyw uiqf hfi mws quj hff welt wwl bhi slj atw -lt lus vcl elaja qxg hui axy ldc awm pqm anv adh zzz notes axis helvetica findfont scalefont sal setfont cvk ind ltb polarline cylinder-switch line polarline head-switch line fsc polarline base line polarline ltb rotate base cshow restore rotate cylinder switch cshow restore rotate head switch cshow restore rotate base cshow restore bracketpolarline rotate heads cshow restore nvf varrow minimal time wix media transfer time lshow harrow sectors track cshow varrow rotational cshow latency cshow fqk cshow varrow cylinder cshow switch cshow cshow xlz -tf grt varrow head vfy cshow switch cshow jbtt dwbt dwbt cshow dwbt dwbt dwbt dwbt zzz stroke grestore end showpage enddocument endtexfig starttexfig 
begindocument figures ibmide rzone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore location cshow zoned cshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures ibmide lowseek eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate seek time cshow grestore distance cshow seeker cshow stroke grestore end showpage enddocument endtexfig figure ibm ide ide drive study mor ecent scsi drives ably lower bandwidth higher switc hing times eop page bop starttexfig begindocument figures dartmouth eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt modules currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch passed vpt sort add modules vpt neg buffer hpt vpt amount hpt data neg closepath generating stroke sorted run writing disk disk-write modules stroke setdash exch runs hpt generated exch 
data vpt add transformed hpt vpt set neg sorted currentpoint runs stroke hpt short neg final hpt phase vpt runs stroke merged stroke produce setdash top copy data vpt mul items add hpt user neg desires vpt mul data hpt merge mul hpt continued neg vpt sorted mul runs closepath stroke bottom diagram varrow depicts disk-robust first-phase top-n selection robust mechanisms employed tolerate read side performance faults disks sort modules tolerate performance faults write side figure presents basic dataflow top-n selection phase sorted runs generated exch copy reading entire data set sorting block dup time mul read memory writing sorted run harrow disk phase completes merging top records sorted runs final polarline result copy approach cos mul roll sin user mul request rotate currentpoint items gsave translate quickly supplied rotate continuing merge restore grestore challenge programmer bracketpolarline make polarline program robust disk copy performance faults end begin gnudict begin gsave phase translate figure scale shows setgray helvetica diskrobust version findfont scalefont phase setfont top-n newpath graduated lta declustering distributed queue ltb utilized order make phase rshow program robust utilizing replicated rshow data set producer faults easily handled rshow inserting immediately data rshow moved 
rshow faster sorters rates cshow limited cshow local disks fully disk-robust cshow phase generated results cshow figure confirm cshow note ways cshow implement top-n selection present currentpoint gsave translate rotate method acm time transactions cshow computer grestore systems distance vol sectors cshow february skippy cshow arpaci-dusseau find adding robustness merge phase program difficult reasons general apply applications order utilize replicate sorted runs written replication highlights general weakness run-time adaptive approach multiphase program pays high cost replicate data writing disk wishes subsequently avoid producer-faults read phase suited oft-read data sets replicated read times addition data merged single merge module prints final output module runs slowly reason application run slowly phase utilized single destination data applications dataflows similar minimize time spent portion dataflow weaknesses mind case application performance highly robust due amdahl law time spent phase large data sets disk greatly slowed phase application performance suffer unduly sorting present challenging operator external diskto-disk sorting general sorting good benchmark clustered systems stresses disk memory interconnect bandwidth section one-pass version sort two-pass sort consists multiple runs one-pass sort merge benefits information development control gray-box systems precedent andrea set arpaci-dusseau researchers department measure computer sciences performance sort wisconsin key madison values dusseau wisc uniform remzi distributions arpaci-dusseau assumption department implications computer sciences method distributing wisconsin keys madison local remzi buckets wisc abstract zzz processing modern nodes notes systems developers nonuniform distribution unable axis modify helvetica modify underlying findfont implementation operating scalefont perform system setfont sampling build phase ltb services sort polarline environment cylinder-switch advocate blelloch line gray-box dewitt techniques polarline head-switch treating operating line system gray-box polarline base recognizes line changing polarline restricts ltb rotate completely obviate base cshow information restore acquire rotate cylinder internal switch state cshow restore control rotate head impose switch cshow paper develop restore sampling rotate phase base cshow made restore robust polarline topmost diagram figure rotate presents heads flow cshow data restore standard version varrow minimal sort time media based transfer flow time now-sort lshow world-record breaking harrow parallel sorting sectors program track clusters arpaci-dusseau cshow varrow data rotational begin cshow unsorted parallel latency collection number disks data read disk node cshow disk read cshow investigate gray-box information control varrow layers icls cylinder determining cshow contents switch cshow le-cache controlling layout cshow les local disk limiting process varrow execution based memory gray-box icl sits client combination algorithmic knowledge observations module inferences garner information passed control range-partitioning module behavior gray-box partitioning system modules summarize perform set key-range techniques partitioning data helpful building gray-box partitioning icls module reads begun top organize bits gray toolbox record ease determine construction sorter module icls case studies record demonstrate sorter utility module gray-box received techniques implementing input sorts os-like data services begins modi streaming cation single disk line write module source code proceeds introduction modern write operating data systems disk large complex stream bodies preserving code order hundreds read-sort-write programmer-years phase repeats invested result data modifying operating transformed system series difcult sorted costly runs enhance impractical sort endeavor extreme disk-robustness utilize realistic view graduated researchers declustering noted distributed queue traditional operating shown systems bottommost rigid diagram acm transactions simply computer hardware systems masquerading vol software february viewing run-time operating adaptation system river immutable object fig sort dataflow odds data read bulk disk operating systems parallel research set seeks disk-read develop modules integrate ideas passed operating set systems range partitioners reduce partitioners orts segment required data change set sort large modules body key research investigated sort modules operating present system top fourth restructured keys sorter extensible fourth systems sorter functionalto symposium operating systems sort principles modules sosp received october large chunk chateau lake data louise banff fill canada memory permission make digital independently hard sort copies data part pass work disk-write personal module classroom output granted disk fee provided multipass copies sort phase made repeat distributed profit data commercial advantage sorted copies sorted bear runs notice facilitate robustness full disk citation performance faults page copy sort employ republish post graduated servers declustering redistribute distributed lists queue requires graduated prior declustering specific utilized permission fee transparently copyright transforms acm sort ity performance read-robust improvements sort easily added distributed tailored queue desires applications complex limitation data approaches sorted sorters require place data operating system distributed queue orts standard minimize modi cations require data altered randomly scattered minor disks essentially undoing requiring change work single sorting line performed code make slightly deployment distributed innovation queue utilized sorter commercial operating handing systems records problem distributed obvious queue hands non-technical hurdles distributed queue overcome entire persuade sorted run large company time load incorporate idea balancing occurs accepted single coarser vendor granularity open-source preserving base semantics wide-spread sort adoption innovations figure case unused previous applications operators run employ cross-platform graduated declustering existing disk interfaces read provide systems performance-robust parallel data transactional stream database program manages raw addition disk obtain distributed high queue performance complex implements figure optimized database-oriented observe system queue incentive sort modules system single diskwrite platform modules sort complicates modules passed database sorted source records code distributed queue rare idea incorporated programs widely application large range perform good ideas expected orphaned distributed queue algorithm remaining spread challenge records randomly disseminate research disks ideas undoing requiring work sort underlying projects distributed queue distributed sort computing modules addressed building key-range system partitioning services occurs top unmodi crucial commodity operating semantics systems sort removing acm approach transactions computer constricting systems vol seemingly sti implementation february functionality arpaci-dusseau thesis key-range partitioning paper change surprisingly correctness large class sort os-like services provided applications distributed queue modi cation position placement speci function cally properly slight modification acquire information made state distributed queue control handing behavior records unexpectedly powerful time ways explicit interfaces exist approach treated gray box general characteristics algorithms employed combining knowledge run-time distributed queue sort module passes large sorted chunks data distributed queue distributed queue adapts rate disks coarser observations granularity reacts commands queries services implemented term software layer interfaces gather information control gray-box system graybox information control layer gray-box icl icl residing clients applications graybox system presents clients traditional enhanced interfaces interfaces icl clients learn state underlying system data cache control behavior place les disk internally obtain information icl observe existing client interactions gray-box system insert probes system case combining observations statistical analyses priori knowledge behaves icl infer current state experienced programmers tend exploit knowledge behavior underlying system knowledge encapsulated icls techniques programmers gray-box systems step combining knowledge measurements observations technique commonly found microbenchmarks exists strong duality sort module received data sort divide ten chunks note slightly form output one-pass sort n-node sort generates sorted runs n-node sort produces runs number sorted runs sort modules hand distributed queue performance cost extra work sort perform files opened closed standard sort figure presents results perturbation experiment figure performance perturbation stable programs attribute directly coarser granularity load balancing disks runs balance disks single slightly faster disk end noticeably larger amount work general performance degrades gracefully expected absolute performance high primitives due extra amount per-run overhead managing runs extending river application domains concentration database query-processing primitives natural question arises generality river model types applications benefit mechanisms provided river environment application written river model general-purpose programming substrate question types applications easily naturally written river framework readily utilize adaptive mechanisms provided order achieve level performance robustness application domain benefit river environment parallel scientific codes wolniewicz graefe shown common scientific operators fit dataflow environment operators reengineered performance robustness manner similar database primitives common operation types applications matrix transpose poole assuming data begin end disk transpose structurally similar external sort routing data based key record floating-point routed final destination based location final output set slight difference input read memory sort read input stream sequential order transpose slight modifications made standard distributed queue accommodate acm transactions computer systems vol february run-time adaptation river read input stream row column staggered manner balance output load properly examples work river environment out-ofcore matrix vector matrix matrix multiplications applications great deal flexibility order process data elements multiplied amenable transformation performance-robust programs finally applications poole survey o-intensive scientific applications require strict ordering records written disk hinting suitability river environment poole applications excellent candidates river implementation experimentation good match limitations river run-time adaptation finally discuss scenarios run-time adaptive techniques river work situation myrinet switch deadlock showcases reliance river network performance-reliable medium note problem arose implementation highlighting experimentation real system scenario demonstrates inherent weakness run-time adaptation decisions made run-time lack global perspective data written disk current conditions laid properly access potentially conditions global performance faults problem present result peculiar switch behavior demonstrative general problem figure plots performance graduated declustering scale increasing number producers consumers x-axis plotting total throughput percentage peak y-axis case producers throttled produce data fast perturbations system figure performance excellent low scale coming close peak drops unexpectedly producers consumers involved careful instrumentation found poorly performing experiments performance fine period time suffered dramatic systemwide two-second pauses investigation symptom led conclusion myrinet switches deadlocking halting progress detected deadlock recovered fortunately assistance implementors library altered avoid problem experience illustrative library changed fragment messages smaller chunks fragmented switches observe fragment interarrival time erroneously assume delayed fragment implied deadlock deadlock recovery mode implementors installed fix fragmenting messages switches longer reason time-out acm transactions computer systems vol february arpaci-dusseau fig switch deadlock performance graduated declustering plotted scale cases switch deadlock occur graph number producers consumers covaried x-axis percent ideal performance plotted y-axis machines involved experiment deadlock occurs scale higher rates occur performance drops noticeably general point river method run-time 
adaptation relies global characteristics network network performing expected system tolerate producerand consumer-side performance faults global performance faults network global effect avoided mechanisms contrast localized performance faults network link contention link performance-failure naturally handled adaptive mechanisms river faults indicative design diversity gray reuter called architectural heterogeneity type heterogeneity avoids problems occur collection identical components suffers identical design flaw including components makes manufacturers system gray reuter state heterogeneity akin belt suspenders belts suspenders additional network graceful performance fail-over network avoided myrinet deadlock problem solutions costly local versus global perspective finally discuss potential general weakness run-time adaptation river scenario assume application writing records disk disks faster naturally allocate proportional amount data disks application reads acm transactions computer systems vol february run-time adaptation river data back disks obtain peak performance system performance characteristics disks changed previously high-performing disks longer high-performing read performance suffer data written disk performance footprint created time future state system longer matches footprint performance mismatch occurs delivered performance longer approaches ideal method ameliorate potential problem replication replicating data access potentially tolerate unanticipated performance fluctuations left question data sets replicate type adaptation rearranging data offline account current characteristics system broader scale run-time mechanisms river designed handle complementary offline adaptive techniques similar developed neefe matthews required provide complete solution view development techniques main goals future work related work river draws related work areas parallel databases parallel storage systems parallel file systems parallel programming environments discuss related work areas turn parallel databases large-scale operations common parallel database systems number parallel databases found literature including gamma dewitt volcano graefe digital rdb prototype barclay bubba copeland systems based techniques similar dataflow model river parallel queries directed graph connects sequential data operators gamma gamma parallel database system head cshow switch cshow cshow zzz stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures dartmouth rzone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore location cshow zoned cshow developed wisconsin dewitt initial prototype developed shared-nothing cluster vax processors main memory connected token-ring network machines identical hard drives attached dewitt basic partitioning techniques provided distribute data processors round-robin hash range user-specified key range assuming uniform distribution communication processors performed split table takes tuples sending processor distributes receiving processors aforementioned distribution styles contrast river data distribution techniques gamma make strong performance assumptions partitioning techniques total time completion stroke determined grestore end slowest showpage consumer enddocument group endtexfig network connects machines starttexfig shared begindocument medium figures dartmouth acm lowseek transactions eps gnudict computer dict systems gnudict vol begin color true solid february true arpaci-dusseau gnulinewidth case vshift token-ring network mul hpt aggregate network vpt bandwidth moveto bind scale lineto processors bind data rmoveto easily bind moved rlineto bind cluster vpt remote vpt mul consumption hpt hpt mul fundamental lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg tenets river vshift design show volcano cshow prominent currentpoint stroke parallel database dup system stringwidth pop div literature vshift volcano show color graefe setrgbcolor wolniewicz solid pop graefe setdash volcano pop pop pop construct solid called pop exchange setdash operator ifelse move stroke data gnulinewidth mul processors setlinewidth stroke similar gnulinewidth div gamma split setlinewidth table stroke gnulinewidth case setlinewidth gamma ltb contrast lta river volcano makes setdash solely setrgbcolor nonrobust distribution techniques hash-partitioning range-partitioning round-robin replication flexible distribution mechanism major difference volcano gamma models parallelism stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt gamma demand-driven approach sinks pull data add sources hpt request vpt neg messages currentpoint conversely stroke volcano hpt neg data-driven hpt vpt approach stroke data stroke eagerly setdash copy consumers vpt mul add hpt consumers neg vpt explicitly mul request hpt data mul hpt message-passing neg libraries vpt mul closepath issues stroke arise copy form pull-based end message gnudict begin layers versus gsave translate scale setgray helvetica findfont scalefont setfont newpath push-based lta karamcheti chien ltb conceptually similar gamma rshow parallel database rshow systems volcano intended rshow primarily shared-memory rshow machine early rshow prototypes ran rshow -processor sequent symmetry cshow shared-memory machine excellent cshow platform river-like cshow system interconnect performance cshow good digital cshow rdb work parallel-load cshow prototype digital rdb project currentpoint barclay gsave translate rotate describe seek time dataflow cshow execution environment grestore distance connections cshow producers seeker cshow consumers stroke grestore end showpage enddocument endtexfig figure simulated dartmouth simulator accur ately simulates disk gener ation high otational latency switc times minimal time media true disks ther zone entir disk inally seek gular matc hes formula utilized authors xactly note data simulator muc cleaner eal-world disks eop page bop starttexfig begindocument figures michigan eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor false pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke varrow exch copy dup mul harrow polarline copy cos mul roll sin mul rotate currentpoint gsave translate rotate restore grestore bracketpolarline polarline copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow microbenchmarks gray-box techniques icls require underlying components benchmarked con gure internal thresholds parameters understanding behavior icls requires understanding behavior icls reveal surprising behavior microbenchmark paper explore challenges building graybox icls developing studying services rst le-cache content detector fccd determines contents cache applications re-order operations rst access data cache service functionality similar proposed modi cations layout detector controller fldc discerns controls layout blocks disk applications schedule accesses reduce seek time memory-based admission controller mac detects amount memory multi-programmed system limits number contending processes cases anticipate modifying applications interfaces provided icls show cases unmodi applications icls obtain bene demonstrate utility icls simple benchmarks real applications cases observe substantial performance improvements relative versions applications information control underlying cases improve performance order magnitude limitations gray-box approach discuss fundamental advantage building services icl library examples middleware distributed environment service receive wide-spread adoption related advantage approach icls easy port demonstrate relative ease icl porting running codes erent unix platforms cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time cshow grestore distance sectors cshow skippy cshow zzz notes axis helvetica findfont scalefont setfont ltb polarline cylinder-switch line polarline head-switch line polarline base line polarline ltb rotate base cshow restore rotate cylinder switch cshow restore rotate head switch cshow restore rotate base cshow restore polarline rotate heads cshow restore varrow minimal time media transfer time lshow harrow sectors track cshow varrow rotational cshow latency cshow cshow varrow cylinder cshow switch cshow cshow varrow head cshow switch cshow cshow zzz stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures michigan rzone eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind 
vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore location cshow zoned cshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures michigan lowseek eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate seek time cshow grestore distance cshow seeker cshow stroke grestore end showpage enddocument endtexfig figure dec simulated data disksim mic higan disk simulator esented disk mor modern dartmouth simulator show mor ealistic behavior zone uninter esting seek curve xpected eop page bop model ear interface capacity dimensions rpm rotational recording latency surfaces seagate scsi seagate scsi barracuda micropolis scsi ibm ultrastar scsi ibm scsi quantum fireball ide ibm-dtt ide simulated dec simulated phd maker nks edt zpei ggg x-m mqti urt puu sfm ixd gvtf okp tgx djb tlq dus nfaz whi ekz qas rvol ens tgx hfo msh cyl hxb euw tjs hso wop oug ooi pyx nxgc lhm bba kxl yju umt guvr str hsz olup data-flow rivers connect streams data stated river partitioning based split-table suo streams river split table fsyp suggests record inserted river river program split table pick wggg destination stream record river extracts field values record kzz compares values values split table pick wak destination stream split-table rangepartitioning hash partitioning round-robin replication atg input records sink ukf operators barclay vdd static techniques provide performance availability run rate slowest sink authors state nodes speeds amounts memory longer straight-forward distribute work evenly nodes barclay flexible method distribution found river addition parallel vli river takes advantage unordered record processing system xxb provide form run-time adaptation ibm smps fcn lindsey system shared data pools accessed multiple threads faster threads acquiring work lindsey refers access style straw model thread slurps data straw potentially rate acm transactions computer systems vol february qxtp run-time adaptation river implementing system natural smp simple lock-protected queue suffice modulo performance concerns river viewed distributed implementation concept parsets notion applying operations data set parallel explored parsets dewitt object-oriented database system application developer create function subsequently direct system apply objects xfg collection model computation great flexibility building performance robust system fkx data replicated robust access replicated rpq data storage parsets implementation processes function statically mxv data yy-b site dynamically balance load avoid ill-effects performance variations ncr teradata current commercial systems ncr teradata machine exclusively hashing partition work achieve parallelism good hash function effect dividing onnd work equally processors wsu providing consistent performance achieving good scaling properties wrdv jim gray teradata system performance bad worse consistency scalability goals nxrm system cost underlying hardware contrast zgg river attempts deliver performance jhx current configuration system stable performance river-based applications xny fluctuate eddies finally eddies adaptive dataflow environment ild built top river system avnur hellerstein eddies adaptive ideas river step reordering data operators on-thefly order achieve higher pnx levels performance specifically slw monitoring selection join predicates highly selective eddies adapt dataflow place highly selective operators npw reduce total amount work performed system storage systems raid redundant arrays inexpensive disks raids popular organize collections multiple fe-p disks gibson katz patterson zua idea simple aggregate vkv set less-expensive disks block-level interface dwy commonly amount storage circumvent pki failures variety redundancy mechanisms chen excellent survey striping commonly extract full aggregate jpj bandwidth multiple disks striping spreads blocks disks fixed round-robin pattern based logical address block simple evc striping breaks jah disks collection bbra runs slower rate expected performance simple striping classified performance fragile entity perform expected global performance match expectations performance assumptions made acm transactions computer systems vol february arpaci-dusseau disk zgq recent work addresses static performance heterogeneity raid systems cortes pzv labarta relative performance rates drives change qhl rtm zkh hbyi ucv dip yrf ifv performance problems occur petal petal distributed system exports vrx block-level interface lee thekkath assembled kimg group workstations dwn pcs multiple disks attached petal presents collection clients highly virtual disk place data main objective petal provide easily administrable high-performance storage gvd scalable mahs switch-based network petal systems provide form run-time adaptation similar spirit sof petal mirrors data disks set reads client directed multiple locations based load information petal skp simple dynamic algorithm client track number requests pending server sends xre read requests server b-v shorter queue length lee thekkath performs similar balancing additional element disk server services requests biased fashion optimizing global application progress glw petal load-balancing writes global operations striping suffer fate win traditional 
storage systems chained declustering chained declustering technique performs naive mirrored system failure present system hsiao ume dewitt typical mirrored pke systems dek replication naive blocks disk ued mirrored identically failure occurs surviving disk pair overloaded chained declustering avoids problem spreading replica blocks disks balancing load read-intensive workloads ways generalization chained declustering chained declustering works case absolute failure single disk works performance failure single disk active disks recent trend storage systems computation moved ciu disks acharya riedel active lqmv disk systems zxw perfect nreijd environment river problems encountered njs clusters caip encountered acharya ikw stream-based programming model similar dgu river dataflow model extending adaptive mechanisms straightforward fgr fuhs additional adaptation uen techniques required dynamic migration yuh computation host processor disks bjj depending current system load network xnh performance levels amiri parallel file systems turn attention large body work parallel file systems systems focused extracting high performance set uniform disks including ppfs huber bridge dibble acm transactions computer iby systems vol february run-time adaptation gyc river panda seamons winslett galley nieuwejaar kotz vesta corbett feitelson swift cabrera long cfs nitzberg sfs loverso sio specification bershad spiffi freedman qhc common features include scatter gather transfers asynchronous interfaces layout control prefetching lknb caching support client server ytd parallel lqf file drz systems stripe data iagu naively tpkh set disks subsystem flc undesirable performance properties shared file pointers interesting feature provided systems notion shared file pointer xix found cfs ssuy nitzberg spiffi freedman shared file pointer multiple processes machines access file concurrently consistent manner sharing local file pointer shared file pointers excellent performance properties group processes reading data yhf lqt collection faster processes read data providing coarse-grained load balancing application similar spirit shared-file pointers provide properties sequentially read files provide jva support load-balancing writes uat linux netbsd solaris implementations found overlapping set required lyj functionality vah gray-box icls begun formalize gray toolbox kcfuz odi common repository routines ease construction erent operating systems fast mbp platformspeci timers statistical routines envision toolbox grow icls developed sfrg similar spirit rgf interposition toolkit jones rest zvx paper organized begin azuw summarizing techniques building icls section discuss previous gray-box efy systems section section give overview mhcvv experimental environment cover icl case studies le-cache content detector layout detector controller memory-based admission controller describe beginnings gray toolbox section cover related work section conclude asi section gray-box techniques encapsulation helps simplify design large complex systems allowing system designers ignore unnecessary details simpli cation high cost viewing black mjti box make assumptions implementation xwa behavior internal state cakb speci interface uzi internal-state information acquired behavior controlled explicit mechanisms designed implementors interface provided information hidden control prevented practice systems black boxes savvy programmers idea component implemented gray box users knowledge acts speci uza interface jqpha knowledge toe-hold myd bwzfx gaining information state key controlling behavior note focus paper treatment uvviywm operating system gray box component ufm layer module objectbased system treated ejz section discuss techniques found developing case studies existing systems information techniques information internal state optimize system services applications scheduler activations key piece state information passed kernel user-level scheduling library number processors application running information threads library pev job dbj scheduling active threads summarize ways zhl determine internal state interface exists acquire mpt-p algorithmic knowledge developers interfacing knowledge dtn algorithms employed developer myz access source nrhw code internal rjx design apl documentation gzc simply familiarity enf common implementation techniques lru-like caching algorithmic vyjj knowledge exists levels detail extreme designer gnh caching performed system extreme hajm designer full understanding yij source code cost pmuhc hitting missing dhaad cache algorithmic knowledge il-l gray-box icl interact cient manner determining interact component general qfi knowledge behaves studied extensively theoretical work kva game theory decision zwo theory practical side exists tension optimizations makes icl portability algorithmic knowledge -tqy assumed optimizations make fewer systems assumptions apply monitor outputs algorithmic knowledge icl infer internal state improve quality exd inferences icl make found jqyi lfy combine knowledge observations output observed output speci interface pgx measurable characteristic external con interface covert jcb channel examples covert channels gray-box systems include elapsed time power consumed presence dropped messages outputs black-box observed make predictions infer behaves infer internal state powerful aspect gray-box techniques pze epf -weuf mvr combination observations algorithmic knowledge allowing designers build icls portable cient portable assume high-level algorithmic knowledge cient tuned speci platform observations infer current state algorithmic knowledge simplistic inaccurate icls built robust observations 
verify true state note icl observe inputs infer state models simulations drawback requires participation processes investigate icls assume jgm visibility inputs statistical methods infer internal state ijr icl wmy observe output correlated state ktr interest infer speci code path executed data item cached xzg observe response fast slow draw robust tsr inferences potentially noisy data advocate statistical methods jks microbenchmarks parameterize system icls system parameters order operate properly speed sequential disk access suite microbenchmarks icls jxm care executing benchmarks require dedicated system time run insert probes cases client ybn icl make cient tmk requests fsb icl observe ygs outputs icl insert probes speci requests generated solely observe resulting output probe icl generate requests desired inputs desired time desired context challenge probes describe case studies presence change state system refer heisenberg ect challenge probes add signi overhead system cases adding probes icl improve hsu application adt performance prefetching disk blocks control techniques responsibility icl control ways speci existing interfaces ufv assume designer icl level algorithmic knowledge control algorithmic knowledge perform actions side-e ects mfrz operations read interface afs khz icl read single byte prefetch entire server describe techniques hffovu exerting control move system state inferring information arbitrary omz unknown state cult state control technique icls move system simpler state easier gauge contents mlkbp page cache periodically ushes ict monitors models subsequent activity reinforce behavior feedback wzt application icl interactions strongly determined behavior icl icl reinforce desired behavior controlling manner ybr behaves gok contents cache determined order accesses icl direct client interactions make cache contents sug predictable tace repeated access icl erent runs erent applications act positive feedback stabilizing system behavior previous gray-box approaches disk illustrate collective fer techniques advanced brie parallel file survey systems literature higher-level interfaces systems data assume collective exploit gray-box kotz knowledge referred rst disk-directed examine microbenchmarks similar concept assume knowledge system test examine existing systems expressed two-phase choudhary dbn original paper gray-box kotz found techniques tcp scientific congestion codes control show implicit tremendous improvement coscheduling aggregating manners requests note shipping services underlying developed system implementors nodes schedule modify rhg existing part vie system requests microbenchmarks applications noticeably increase obtain performance detailed delivered characteristics underlying bandwidth hardware systems interfaces microbenchmarks requests made developed exploit returned gray-box knowledge specific consumers load user infer balanced characteristics consumers dynamically measuring completion time solve memory performance accesses problems erent patterns common clustered determine systems parameters panda memory systems discussed panda hierarchy kuo nding greatest seamons common divisor winslett deals execution explicitly time performance erent heterogeneity expressions solutions determine processor limited cycle time deals measuring access heterogeneity time disk carefully writes designed reads requests left low-level unbalanced characteristics previous disk write geometry perfectly inferred balanced load gray-box icls disks bear similarity access pattern microbenchmarks number approach important ways priori static microbenchmarks measurement acquire disk information performance calculate control system microbenchmarks gather static lay information component characteristics data disks current state performance microbenchmarks write run controlled environment system microbenchmarks properly arbitrarily long time run react make inferences tcp congestion ubj control goal tcp ucnf congestion control algorithm round distributed clients measurement send data contrast river amounts applications lzq make decisions dynamically state imp congestion drive viewing performance network handle gray-box performance clients combine run-time general parallel knowledge distributed programming network environments behaves finally measurements parallel kvb ongoing programming communication environments lrqkdn infer exploited current benefits state run-time adaptation network examples include congestion cilk blumofe knowledge lazy threads tcp goldstein implicit coscheduling manners multipol acm knowledge transactions message dropped computer systems congestion vol dest scheduled send february msg symmetric arpaci-dusseau performance chakrabarti impact outputs time systems ack dynamically arrives balance load arrival consumers requests order reported zzqmc facilitate progress programming process highly time irregular response finegrained statistics parallel applications cilk variance cilk linear randall regression parallel exponential programming avg environment designed paired-sample sign parallel test machines benchmarks parallelism attained round-trip time spawning extremely probes lightweight threads allowing users state express arbitrarily required complex parallel benchmarks control constructs slow load-balancing convergence achieved feedback cilk routers work drop stealing msgs processor signal work react examines observations processor zgjl table work queue summary picked gray-box uniformly techniques random steals existing work systems network drops packets conceptually stealing work congestion work clients queue observe similar load existing balancing communication acknowledged infer cilk congestion implementation exists tuned routers thread-level work network stealing turn aimed control ptn high-performance data sending movement rate contribution clients note dropping packets cilk system congestion authors occurs ihi proven misbehaving clients cilk uqq work-stealing scheduler identi achieves space observing -je time communication unresponsive bounds gray-box control constant factor optimal tcp multipol congestion multipol control algorithm run-time support labeled irregular black-box applications scheme distributed data structures due focus hiding assumption communication latency packet loss asynchrony caused chakrabarti congestion load svs balancing provided gray-box scheme distributed fact task queue recognizing wen gray-box similar knowledge design led implementation problems linda linda environments shared wireless globally setting addressable tuple-space dropped message parallel sld programs longer carriero gelernter congestion applications due perform simply atomic actions lossy tuple-space medium inserting result tuples unmodi tcp ehk querying congestion space control find algorithm records mlx behave attributes tuple space similar wireless settings general correctly identifying gray-box generality knowledge model high performance problems distributed environments avoided implicit shown coscheduling difficult time-shared achieve ne-grain bal parallel jobs reliable achieve multicast acceptable finally performance birman communicating processes encountered similar scheduled problems simultaneously performance implicit faulty nodes coscheduling technique research reliable achieving multicasting coordinated multiprocess work scheduling alter modifying guarantee provided multicast infrastructure implicit absolute guarantee coscheduling combines probabilistic gray-box knowledge avoid communication ill-effects interacts stuttering scheduling remote nodes node pursue observations similar on-going goals communication parallel exploit job application speci flexibility cally obtain hard-wired robust algorithm performance conclusions process heart waiting river system response run-time adaptation component system statically trusts performance component node constantly gauges performance data transfers allocates data requests nodes proportion perceived performance built philosophy mind demonstrated article robust data-transfer mechanisms delivering ideal performance range perturbation scenarios acm transactions computer systems vol february run-time adaptation river keys run-time adaptation derived interaction communication layer utmost importance number flow control credits provided scale size system excess parallelism needed order overcome potential problems extremely poorly performing components performance dictated slow component system local data processing guided global knowledge progress property found fourth final slack needed run-time adaptive methods deliver peak performance presence small number performance faults slack system remains open question applications built river framework make primitives order robust disk performance faults suite database query-processing primitives run ideal broad range disk performance faults applications perfectly met system demonstrated top-n query external sort uncovered weaknesses river approach run-time adaptive methods rely strongly network backplane adaptation entire network function properly switches deadlock performance match expectations cases run-time adaptation short-sighted plan investigate complementary long-term adaptation order eventually build fully adaptive system methodological point view combination modeling simulation implementation crucial understanding system behavior simulations study isolation well-controlled setting allowing focus important properties flow control understanding algorithms behave second-generation implementation distributed algorithms proceeded ease implementation find limitations system arise simplified simulations underscoring importance building working prototype simple models gauge absolute performance faults understanding performance complex adaptive system made easier understands potential ideal acknowledgments eric anderson noah treuhaft contributed ideas implementation river system andrea arpaci-dusseau excellent aspects work dave patterson david culler joe hellerstein made substantial contributions ideas presented article jim gray excellent feedback direction advice finally anonymous referees careful feedback greatly improved substance style article acm transactions computer systems vol february arpaci-dusseau acharya uysal saltz active disks proceedings eighth conference architectural support programming languages operating systems asplos viii san jose calif adler chakrabarti mitzenmacher rasmussen parallel randomized load balancing proceedings annual acm symposium theory computing stoc acm york amd amd athlon processor architecture amd amiri petrou ganger gibson dynamic function placement dataintensive cluster computing proceedings usenix annual technical conference san diego anderson culler patterson team case networks workstations ieee micro february arpaci dusseau vahdat liu anderson patterson interaction parallel sequential workloads network workstations proceedings acm sigmetrics international conference measurement modeling computer systems ottawa arpaci-dusseau implicit coscheduling coordinated scheduling implicit information distributed system acm trans comput syst tocs august arpaci-dusseau arpaci-dusseau culler hellerstein patterson high-performance sorting networks workstations proceedings acm sigmod conference management data sigmod tucson arpaci-dusseau performance availability networks workstations phd thesis california berkeley arpaci-dusseau arpaci-dusseau fail-stutter fault 
tolerance proceedings eighth workshop hot topics operating systems hotos viii schloss elmau germany arpaci-dusseau anderson treuhaft culler hellerstein patterson yelick cluster river making fast case common proceedings workshop input output parallel distributed systems iopads atlanta arpaci-dusseau arpaci-dusseau culler hellerstein patterson architectural costs streaming comparison workstations clusters smps proceedings high-performance computer architecture hpca las vegas avnur hellerstein eddies continuously adaptive query processing proceedings acm sigmod conference management data sigmod dallas bal kaashoek tanenbaum orca language parallel programming distributed systems ieee trans softw eng march barclay barnes gray sundaresan loading databases dataflow parallelism sigmod record acm sig manage data dec baru fecteau goyal hsiao jhingran padmanabhan copeland wilson parallel edition ibm syst bershad black dewitt gibson peterson snir operating system support high-performance parallel systems tech rep ccsfscalable initiative caltech concurrent supercomputing facilities caltech birman cooper isis project real experience fault-tolerant programming system oper syst rev april birman hayden ozkasap xiao bidiu minsky bimodal multicast acm trans comput syst tocs blelloch leiserson maggs comparison sorting algorithms connection machine cmin proceedings symposium parallel algorithms architectures hilton head blumofe joerg kuszmaul leiserson randall zhou cilk efficient multithreaded runtime system proceedings symposium principles practice parallel programming santa barbara calif acm transactions computer systems vol february run-time adaptation river boden cohen felderman kulawik seitz seizovic myrinet gigabit-per-second local-area network ieee micro xouj knowledge receiving message remote process means remote feb process bolosky iii scheduled draves fitzgerald gibson jones recent past levi likewise myhrvold receiving rashid prompt response tiger request video means fileserver tech rep remote process microsoft research boral scheduled alexander clay infer copeland scheduling danforth state franklin remote nodes hart process smith simply observes valduriez message arrivals prototyping waiting bubba time highly manners parallel running database system low-importance ieee processes trans knowl data idle time eng feature march missing borg blau modern graetsch operating systems herrmann manners oberle fault functionality tolerance suspending unix low-importance acm jobs trans comput resource contention syst detected feb implemented bressoud modi schneider cation hypervisor-based fault manners tolerance proceedings gray-box fifteenth knowledge acm symposium process operating systems competing principles sosp copper degrades mountain resort progress colo brewer symmetrically inktomi web search engine invited combining talk knowledge proceedings acm measurements sigmod conference brewer progress kuszmaul low-importance process good manners performance infer cmdata low-importance network process proceedings suspended international authors parallel processing number symposium cancun cabrera long swift distributed disk striping provide high data rates comput syst fall carriero implementation tuple space phd thesis department computer science yale chakrabarti deprit jones krishnamurthy wen yelick multipol distributed data structure library tech rep csd- california berkeley july chen bershad impact operating system structure memory system performance proceedings fourteenth acm symposium operating simple systems statistical principles techniques sosp asheville chen lee calculating gibson expected level katz performance patterson uncontended raid environment highperformance reliable secondary required storage time acm frame comput surv order june choudhary hours bordawekar summary harry summarized krishnaiyer table ponnusamy singh services thakur touch number gray-box passion techniques parallel scalable revisit software input-output case tech studies rep sccsece dept npac services case center combine syracuse algorithmic knowledge september codd observations relational time model required data large existing shared data operations banks infer commun acm state june copeland system alexander boughter services keller data statistical placement techniques bubba run proceedings time acm priori sigmod international benchmarking conference management controlled data state acm addition chicago corbett techniques presented feitelson case vesta parallel studies file demonstrate system acm utility trans comput probing syst case august cortes studies labarta section extending explore heterogeneity raid icls level speci proceedings cally develop usenix annual experiment technical conference boston le-cache dewitt content gray detector parallel fccd database systems layout future detector high-performance controller database fldc memory-based admission systems commun controller mac due acm space june limitations dewitt describe gerber fccd graefe detail heytens kumar present subset muralikrishna issues gamma high fldc performance dataflow mac database machine tech section rep discuss trdept computer basic science problem univ icl wisconsin-madison addresses march dewitt gray-box ghandeharizadeh knowledge schneider explain performance analysis implementation perform gamma experiments database machine show sigmod record capabilities acm sig manage layer data discuss september limitations dewitt summary naughton gray-box shafer techniques venkataraman found parsets shown parallelizing oodbms table traversals implementation experiments performance run proceedings machine international intel conference pentium-iii parallel distributed processors information systems physical ieee memory computer society austin ibm lzx texas disks dewitt naughton machine schneider large amount parallel memory sorting stresses shared-nothing architecture icls probabilistic splitting determine proceedings contents international conference cache parallel distributed amount information systems miami memory beach acm transactions experiments computer performed systems top vol linux february arpaci-dusseau dibble evaluate scott gray-box libraries ellis netbsd bridge high-performance solaris file system fact parallel processors easily proceedings deploy icls eighth international conference platforms distributed computer systems san jose calif englert gray kocher shah benchmark nonstop sql release illustrates demonstrating near-linear speedup scaleup large databases proceedings acm sigmetrics conference measurement modeling computer systems boulder colo fox gribble chawathe brewer gauthier cluster-based scalable network services proceedings sixteenth acm major advantages gray-box approaches file-cache contents knowledge contents cache applications re-order data accesses potentially improve performance application repeatedly symposium accesses operating set systems principles les sosp saint-malo erent france freedman arguments burger grep dewitt arg system spiffi scalable parallel total file amount system data intel paragon exceeds ieee trans size parallel distrib cache syst operating nov system gelernter performs carriero lru-like chandran replacement chang case parallel performance programming improves dramatically linda proceedings application international rst conference processes parallel data processing icpp cache charles ill small gibson fraction redundant data disk arrays reliable fetched parallel secondary disk storage acm application distinguished dissertation access mit cached press data cambridge rst mass goldstein operates schauser lru culler worst-case mode fetching lazy threads data implementing fast disk parallel call run parallel distrib section describes comput gray-box august file-cache graefe content volcano defile-cache extensive content parallel file dataflow layout detector query processing system memory-based tech rep oregon graudate center june admission detector fccd controller graefe fldc controller encapsulation parallelism mac volcano query knowledge processing system lru-replacement sigmod record acm sig manage data june groups gray directory replacement processors algorithm infinitely fast storage free invited talk proceedings iopads gray reuter transaction processing concepts techniques morgan kaufmann san francisco gribble brewer hellerstein culler scalable distributed data structures internet service construction proceedings fourth symposium operating systems design implementation osdi san diego grochowski emerging trends data storage magnetic hard disk drives datatech sept hsiao dewitt chained declustering availability strategy multiprocessor database machines proceedings sixth international data engineering conference los angeles huber elford reed chien blumenthal ppfs high performance portable parallel file system proceedings ninth acm international conference supercomputing barcelona johnson designing distributed queue proceedings seventh ieee symposium parallel distributed processing san antonio tex karamcheti chien comparison architectural support messaging tmc cmand cray proceedings annual international symposium computer architecture santa margherita ligure italy katz gibson patterson disk system architectures high performance computing proc ieee dec kotz disk-directed mimd multiprocessors proceedings symposium operating systems design implementation monterey calif kuo winslett cho lee chen efficient input output scientific simulations proceedings sixth workshop input output parallel distributed systems acm press atlanta kushman performance nonmonotonocities case study ultrasparc processor thesis massachusetts institute technology boston lee thekkath petal distributed virtual disks proceedings seventh conference architectural support programming languages operating systems asplos vii cambridge mass lindsey smp intra-query parallelism udb database seminar berkeley acm transactions computer systems vol february run-time adaptation river liskov distributed programming argus commun acm march litzkow tannenbaum basney livny checkpoint migration unix processes condor distributed processing system tech rep wisconsinmadison computer sciences april lorie daudenarde hallmark stamos young adding intra-transaction parallelism existing dbms early experience ieee data eng newslett march loverso isman nanopoulos nesheim milne wheeler sfs parallel file system cmin proceedings summer usenix technical conference cincinnati mainwaring culler active message applications programming interface communication subsystem organization tech rep csd- california berkeley october matthews roselli costello wang anderson improving performance log-structured file systems adaptive methods proceedings sixteenth acm symposium operating systems principles sosp 
saint-malo france meter observing effects multi-zone disks proceedings usenix conference anaheim calif nieuwejaar kotz galley parallel file system proceedings tenth acm international conference supercomputing acm press philadelphia nitzberg performance ipsc concurrent file system tech rep rnd- nas systems division nasa ames december ousterhout scheduling techniques concurrent systems proceedings international conference distributed computing systems miami fort lauderdale ousterhout tcl embedable command language proceedings usenix association winter conference washington ousterhout toolkit based tcl language proceedings usenix association winter conference dallas patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod conference management data sigmod chicago patterson gibson katz case redundant arrays inexpensive disks raid sigmod record acm sig manage data sept poole preliminary survey intensive applications tech rep ccsfscalable initiative caltech concurrent supercomputing facilities caltech raghavan hayes scalar-vector memory interference vector computers proceedings international conference parallel processing charles ill randall cilk efficient multithreaded computing phd thesis massachusetts institute technology boston riedel gibson faloutsos active storage large-scale data mining multimedia proceedings vldb york schneider implementing fault-tolerant services state machine approach tutorial acm comput surv dec seamons winslett multidimensional array panda supercomput singh weber gupta splash stanford parallel applications sharedmemory comput arch news march talagala patterson analysis error behaviour large storage system proceedings ipps workshop fault tolerance parallel distributed systems san juan puerto rico tandem performance group benchmark nonstop sql debit credit transaction proceedings sigmod international conference management data chicago teradata corporation dbc data base computer system manual release teradata corporation document number acm transactions computer systems vol february arpaci-dusseau tremblay greenley normoyle design microarchitecture ultrasparc-i proc ieee dec von eicken basu buch vogels u-net user-level network interface parallel distributed computing proceedings fifteenth acm symposium operating systems principles copper mountain resort colo wen portable library support irregular applications phd thesis california berkeley tech rep ucb csd- wolniewicz graefe algebraic optimization computations scientific databases proceedings vldb dublin received october revised june accepted july acm transactions computer systems vol february 
disks disks years ange rpm rpm detailed speci cations ibm ultr astar disk drive table ele vant information wer gather disk drives on-line speci cation sheets drives xcepting simulated disks half height low espectively table describes simulated disk drives rst drive epr esents trial benc hmarks dartmouth disk drive simulator dec epr esents trial disksim simulator veloped mic higan assume operating system scsi erheads similar results sho ibm dri west erhead access media seagate barracuda dri interestingly seagate considerably older rpm dri ibm ultrastar micropolis dri measured dri employ zbr xtract sectors track ratio outermost zone dri roughly sectors track barracuda ultrastar micropolis finally compare head ylinder switch times graphs sho seagate barracuda dri west head ylinder switch times ylinder switch time comparable ultrastar older dri counting number head switches ylinder learn recording surfaces barracuda micropolis match speci cation data seagate dri odd number recording surfaces suggesting dedicate surface track follo wing mentioned ide disk drives figures sho write beha vior quantum ibm ide disks graphs sho caching acti vity wer step sizes fact appears dri write fer cache eral requests empties cache additional request reached beha vior entire result graph shift graphs slightly shifted measure rotational latenc height transition point measured rotationt ime quantum fireball error speci cation alue dri recording surfaces consistent disk speci cations quantum dri head switch time ylinder switch time measured rotation time ibm ide disk error compared speci cation sectors track ratio disk recording surfaces head switch time ylinder switch time disk alue alues bit scsi disks ects programmed eop page bop disk rotation mtm sectors heads head cylinder bandwidth seek ime switch switch outer max min rack ime ime seagate seagate barracuda micropolis ibm ultrastar ibm quantum fireball ibm-dtt sim dec sim extracted alues table lists locality app xtr groups acted i-nodes par data-blocks ameters outputs time eac read disk byte i-number drive time including write byte anges statistics sort cluster bandwidth sort discard seek outliers benchmarks curves measure seek note overhead memory values disk threshold probes seek read curve byte stat adjusted i-number write byte minimum page time state media refresh directory contents write rst ect make resident actual feedback seek order determines har access pattern acteristics table summary gray-box dma techniques case studies tector fccd common applications ide gauge dri contents cache impro act pursuit erhead gray-box fccd inspired recent cost work storage latency belo estimation descriptors sleds discussing discussed van achie meter gao bandwidth work van ide meter gao propose simulated interface drives returns figures predicted access times sho sections results interface dartmouth determine disk parts simulator disksim fast access based combination xperiments knowledge erify storage hierarchy kippy static technique estimates abstract architectural requirements scalability nas parallel benchmarks supercomputing frederick storage wong device richard latencies martin remzi main limitation arpaci-dusseau david work david requires modi cations culler linux present kernel study gather architectural requirements information scalability show nas parallel benchmarks great deal direct measurements utility simulations proposed identify 
system obtained modi cation operating system gray-box knowledge begin exploring algorithmic knowledge le-cache manager knowledge develop gray-box fccd extreme approach complete algorithmic knowledge le-cache manager access inputs extreme approach basic algorithmic knowledge combined observations outputs complete knowledge behavior le-cache page-replacement algorithm ability observe input model simulate pages cache approach complex inaccurate detailed model page-replacement algorithm order correctly simulate contents cache due interactions memory pages observe accesses memory accesses finally applications interested state le-cache provide inputs simulation single process obey rules knowledge accessed incomplete simulation inaccurate explore infer internal state le-cache observing outputs begin assuming coarsest level algorithmic knowledge cache les full page replaced order page hypothesis predict presence systems provide information contents cache mincore routine interface broadly relied part cache timing carefully selected le-cache probes probe read single byte page read returns quickly conclude probed page cache probe returns slowly page disk probes sparingly reasons probing page memory high cost time probe page essentially identical application access page disk probing page disk destructive state cache heisenberg ect probe page entire page brought cache page evicted selective probes relative cost low avoid changing state system probes accurately ect state cache goals inherently odds order probes successful presence page cache highly correlated presence pages nearby order correlation exist system tend adjacent pages cache evict ect occurs systems applications access les spatial locality page replacement algorithms designed mind operating system approximation lru clock algorithm tend evict matches disks factors xpected affect work scalability benchmark kno relevant distinct disk platforms cluster simulators workstations ccnuma sgi alues origin xtracted find benefit increased global measurements cache size match pronounced simulator applications disk offsets speci communication cations cost constructing simulated working set results profile benchmarks noticeably cleaner visualize improvement measurement computational efficiency results constant-problem-size scaling comparing find origin mpi simulation point-to-point results performance cluster mpi layer scalable disksim communication result load sho communication performance wnward applications spikes lower achieved wtooth microbenchmarks transition show communication protocols real disks dartmouth result suggesting mpi runtime library wer influential disksim communication performance simulates applications dri benchmark codes wide closely spectrum communication older requirements full dartmouth paper simulator pdf 
kmr fhn snf vdg ism pkv kspbt erz sqi wqj xsg lev lcw rrr iwo llfe pqs npx wwmx aft zqci hln pxp wtv m-n pnn gjyq phdthesis arpaciphd title performance availability tdd networks workstations author remzi arpaci-dusseau school california berkeley year 
nddfz qom cxt bnjp tfgi gcy egw cet oned dri kippy result accompanied oned result make eral general observ ations oned results older simulated dri wer ide dri sho recording zone ide dri implies dri manufacturers sacri performance simplicity achie bandwidth ide dri ect programmed dma scsi dri seagate dri noticeably nely zoned ibm micropolis dri finally disks multiple zones erall dif ference outer -track -track bandwidth ranges recent comprehensi discussion disk dri zoning beha vior observ relationship transfer rate disk position linear function single alue xamining zone results curv closer parabolic linear quadratic function form zone graph linear function fact tting linear quadratic functions data standard linear gression techniques learned quadratic function factor factor error simple linear linear xplored xtra adv antage required highest west bandwidth alues dri found quadratic alues factor linear alues fact cases quadratic alues linear alues factor model employed recommend usage quadratic simple construct 
linear model requiring data points matches pro les linear disks zones xact step function utilized disksim simulator makes xact characterization eop page bop eeker gures table sho seek latenc start dri areas function seek distance sectors seeks tenth disk seek latenc appears increase linearly sector distance seek latenc increases lar ger numbers ylinders close xamination data eals seeks reaching innermost zones latenc increase higher linear observ ibm seek result seek time increases rapidly sectors rack ratio decreases rapidly area requiring arm ement sector distance conclusions paper presents disk benchmarks kippy oned eeker xtract range parameters modern disk dri kippy illustrates approach measuring disks linearly increasing stride patterns technique xtensions lter rotational fect kinds disk measurements kno wledge present rst benchmark utilizes disk rotational mechanism characterizing disk defeat benchmarks run scsi dri ide dri disk simulators ealing numerous results modern disk dri minimum time access dri media ary widely dri generation seagate dri sho xcellent switching time characteristics ibm dri erall bandwidth results sho similarities dri made manufacturer odd number recording surfaces present seagate dri scsi dri older sho performance ide dri switching times bandwidth erhead ide reads writes wer impro ements linear areal density ected sectors track number recording surfaces measured dri modern dri higher sectors track ratio older dri number recording surfaces concurrently decreasing rotational latenc seek times decrease head-switch ylinder -switch times important xample switch times roughly rotation time percentages ibm simple models disk beha vior characterize disks seek rotation time longer full paper pro vide details kippy read write benchmarks future work includes xploration bac kwar ead ariant retains bene read benchmark oiding interaction read-ahead mechanism benchmarks xtraction tool measured data made ailable public website hope run benchmark contrib ute data acti archi disk characteristics refer ences remzi arpaci vid culler arvind krishnamurthy ste steinber kathy elick empirical aluation cra compiler perspecti abstract cluster river making fast case common iopads remzi arpaci-dusseau eric anderson noah treuhaft david culler joseph hellerstein david patterson katherine yelick introduce river data-flow programming environment substrate clusters computers river designed provide maximum performance common case face non-uniformities hardware software workload river based simple design features high-performance distributed queue storage redundancy mechanism called graduated declustering implemented number data-intensive applications river validate design near-ideal performance variety non-uniform performance scenarios full paper postscript 
awt rzm ayx xit annual international symposium computer hap hitectur iscap pages zfm june peter yfq chen vid atterson approach performance wnv aluation self-scaling benchmarks predicted performance oceedings sigmetrics confer kcq ence pages vid culler mjt lok gtks liu richard martin chad owen oshika logp performance assessment ast network interfaces ieee micr gre gory ganger bruce orthington ale att disksim simulation vironment ersion manual echnical report cse-tr- department electrical engineering iro computer science uni ersity michigan february cristina hristea daniel lenoski john een measuring memory hierarchy performance cache-coherent multiprocessors micro benchmarks super computing ggi san jose ember eop page xsk bop din ibm ultrastar a-s hardware functional speci cation models rpm ersion document number ibm storage products vision june ibm ibm disk dri agc speci cations http storage ibm kxb vid otz song bac wza sriram radhakrishnan detailed simulation model disk ize dri echnical report pcs-tr department computer science dartmouth colle july larry mcv carl staelin uput lmbench portable ools performance analysis qns oceedings inter usenix january plm rodne meter observing fects multi-zone disks oceedings gri usenix xdzv confer ence january micropolis micropolis disk dri speci cations http procom homepage tech quantum quantum disk dri speci cations http quantum chris ruemmler john ilkes introduction disk dri modeling ieee computer march rafael saa edra stockton gaines michael iqpf carlton characterizing performance space hpvz jgs shared-memory machines micro-benchmarks hot inter connects san jose august rafael saa edra-barrera cpu erformance evaluation execution ime ediction narr specy trum benc hmarking phd thesis berkele computer science vision february vid schwarderer andre ilson understanding subsystems adaptec press rst edition january seagate seagate disk dri speci cations http seagate carl staelin larry mcv mhz anatomy micro-benchmark oceedings usenix annual hnical confer ence pages berkele usa june usenix association bruce orthington gre ganger ale att john ilkes on-line extraction scsi disk dri arameters oceedings qehh llf sigmetrics confer ence pages eop trailer end userdict end-hook end-hook eof 
zan kcnd qdcbydi jqj nil xoub xxv tqm pages signi cantly long ydt chunks figure demonstrate relationship plotting correlation presence random page prediction unit contiguous region percentage unit ahk cache line designates erent access unit application random-access kus sequential-access access unit amount data application reads sequentially randomly picking yyh set test run ush cache run program accesses speci access unit query cache determine contents query contents cache sfg modi linux kernel return bit-map presence bits page graph prediction unit equal access size presence probed page highly correlated presence entire prediction unit prediction unit large relative access unit application corindeed interface existed platforms require gray-box fccd ydp correlation prediction unit size prediction units access size access size access mtq size figure probe correlation graph plots correlation oln presence single random page uoo prediction unit percentage unit cache size prediction -al unit increased x-axis bwu correlation plotted y-axis sets points plotted vary access pattern test program running test program explicit probe determines pages present cache accessed roughly size cache vza measurements times means standard deviations shown relation falls noticeably implementation section discuss ibvlot wzy fccd prediction unit lhu made smaller access unit desired implementation details envision common usage template applications fccd application speci qwq oyl set les interested reading library returns list offset length pairs data thinks wtuq cache based probes performs application information re-order accesses rst accessing pages memory applications examined modi cations straight-forward involved lines code provide method application fccd requiring modi cation users call utility gbp set les returns list les predicted access order implying grep foo replaced grep foo gbp -mem utilize data reordering single option gbp probe read data blocks probe order copying reads stdout ntc gbp -mem -out infile app unmodi application reads stdin utilize intrale re-ordering describe make inferences probes working library simple cient fco portable manner goal library work operating system performs replacement similar based time access underlying hardware technology parameters speed memory disks implementation address problems erentiate probe times cache cache amount data application access unit number teg pages state predicted single probe describe issues turn nvv cache-di vyw erentiation threshold conceptually determine probed page memory jgz erentiate time er-cache hit versus er-cache miss approach simple threshold time probe threshold fzm page considered cache greater page gdp considered disk library work variety platforms approach requires priori benchmarking kernel-to-user memory copy time storage subsystem painful erent types disks present arrived solution requires differentiation threshold sorting prediction units lfs time vvo required probe method simple robust erentiates entities multiple-level sort store memory disk tape case closest items accessed rst closest kzz access unit gray-box interface order accesses application previously read idu large sequential order read random order -dt amortize seek overhead reading arbitrary sets library return offset length pairs large length elds determine default access unit delivers near-peak performance disk performing simple microbenchmark platform found default qwi access unit works application access units obey boundaries fwa ensure records cross multiple access units advanced applications exact manner data returned passing list adjj offset length pairs prediction unit shown picking prediction unit smaller access unit application cient high prediction accuracy similarly fccd dxf tlz access size access unit simply set prediction unit access unit obtain reasonable predictor found performing probes access unit slightly robust prediction unit gray-box layer probes points default access unit measures time probe sorts access units total time probes overhead probes negligible measurements reveal probe time in-cache data realm microseconds milliseconds probe out-of-cache data amortized entire access time files smaller size probed found method choosing probe point prediction unit important approach select bytes predetermined sets process terminates probe phase access phase processes pnt probe le-cache time set probes return bad information indicating pages cache solution probe random byte prediction unit method robust runs added bene application probe cache repeatedly increased wdi con dence time file size single-file scan traditional gray-box worst-case disk ideal in-cache ideal out-of-cache figure single-file scan graph plots total access time repeated runs warm cache traditional linear scan gray-box scan gray-box scan fccd ascertain parts cache accesses accessing rest data point average runs includes standard deviation bars simple models plotted predicted worst-case time data retrieved disk predicted ideal data cache retrieved memory-copy rates data fetched disk experiments perform experiments demonstrate utility cacy gray-box fccd begin showing software obtains good performance reordering accesses single large reordering accesses les examine bene applications modi interfaces fastsort grep finally demonstrate techniques work erent unix-based operating systems single-file scan perform simple experiment modify scan single utilize library gray-box scan library probe state cache accesses rst pages library predicts in-cache rest result access pattern gray-box scan longer purely sequential scan sequentially accesses segments size directly determined access unit ect running application multiple times control technique positive feedback accessing access-unit sized chunks access-unit sized chunks present cache figure plots time access single varying size gray-box scan traditional linear scan experiment begin ushing cache running application times note graph similar spirit style graphs 
presented van meter gao text gure traditional scan ers large performance decrease size exceeds size cache point entire retrieved disk due lru-like page replacement algorithm gray-box scan consistently perform accesses disk frequently total amount performed proportional size minus size cache multiple-file scan applications easily modi process single arbitrary order exibly process set input les arbitrary order experiments shown due lack space utilize fccd determine ordering group les processing sequentially performance similar shown singlele scan application experiments set experiments incorporate gray-box library real applications rst examine versions grep rst unmodi standard gnu utility searches string set les version gb-grep modify grep internally reorder les speci command line gray-box library change straight-forward transforming lines code roughly lines version output gbp utility input unmodi grep grep foo gbp -mem figure shows time versions grep -mb text les warm cache time application normalized time unmodi version gray-box knowledge repeated runs access les order run rate disk gray-box version gb-grep runs factor faster data cache traditional grep combined gbp exhibits bene slight additional overhead incurred due extra fork exec redundant opens closes application fastsort highly tuned twopass disk-to-disk sort similar agarwal rst pass creates multiple sorted runs records size run determined records memory run reads records sorts keys writes sorted records disk pass reads sorted runs disk merges single sorted list writes nal output disk experiments sort roughly data -byte records report performance rst read phase simulate pipeline creating records sorting refresh cache contents run versions sort unmodi sort sort modi gray-box library unmodi sort gbp -mem -out input transformation traditional sort graybox version slightly involved grep application read parts single input erent order required replacing read code lines code adding probe phase main sorting loop lines note gbp informed -byte alignment restrictions sort returns chunks record-aligned figure shows performance read-phase versions gray-box versions substantially improve performance bene large grep erence occurs sort copies memory gray-box versions grep follow exact semantics grep output ordered erently semantics preserved output grep re-ordered application thrash outputting large number matches grep sort normalized execution time application application performance grep gb-grep grep gbp -mem fastsort gb-fastsort gbp -mem -out infile sort figure application performance performance grep fastsort shown leftmost bar group shows normalized performance unmodi application repeated runs roughly total data grep scans -mb les seconds average fastsort completes read-phase input seconds bar group shows relative improvement gray-box version application finally bar group gray-box command line tool unmodi application advantage gray-box knowledge data item reads eventually writes data disk contention memory read-only application grep pages heap pages write-bu ering purge parts input memory prematurely unmodi sort gbp -out input experiences bene extra copy data required operating system pipe mechanism copy palatable sort cpu acceptable situations multiple-platform tests demonstrate gray-box approach works range operating systems examine fccd linux netbsd solaris experiments compare performance microbenchmarks scan multile search measuring unmodi performance cold warm cache modi gray-box performance warm cache figure plots relative execution times normalized platform time cold-cache run platform actual times caption examining scan results rst linux repeated runs gray-box fccd exhibit signi improvement relative unmodi scan expected slightly surprised performance repeated scans -gb netbsd solaris linux solaris entire physical memory caching throwback early unix implementations netbsd xed amount memory caching case note recent overhaul netbsd netbsd repeated scan -gb runs near-disk rate gray-box knowledge illustrate bestcase gray-box performance netbsd report linux bsd solaris linux bsd solaris normalized execution time scan search multi-platform experiments traditional cold cache traditional warm cache gray-box warm cache solaris re-reads hit file cache figure multi-platform experiments gure plots performance repeated largele scans multile searches bars plotted runs experiment average time cold-cache warm-cache run traditional approach average time warm-cache gray-box run group bars normalized cold-cache time linux bsd solaris scans les seconds cold-cache case searches -mb les -mb les -mb les average seconds performance repeated -mb scans surprisingly solaris repeated scans warmcache perform gray-box knowledge case le-cache manager lrubased replacement algorithm single portion cache repeated accesses hit cache testing revealed portion solaris cache cult dislodge repeated scans erent les approach works benchmark solaris cache manager holds pages rst accessed persistently behavior implementors intended investigation warranted search benchmark demonstrates nonlru replacement policies bene gray-box techniques performing search match string set les match found cached gray-box search nish quickly traditional search mercy ordering speci user scenario similar grep experiment reported experiment set arbitrary manner con gure illustrates maximum bene graybox approach matching string located cached speci command-line figure shows unmodi search advantage cache searches les order nding match gray-box search nds match quickly cache discussion investigating multiple platforms revealed level algorithmic knowledge assumed fccd largely unix-based operating systems relying primarily measurements probes determine state cache requiring detailed knowledge study highlights duality gray-box systems microbenchmarks tend unveil inner-workings systems fccd panacea major limitation techniques limited heisenberg ect gauge presence small page size cache bringing entire cache fccd probe small les returns fake high probe-time analogous heisenberg ect arises distributed system afs reading single byte force fetch entire local disk cache file layout accessing les disk exact layout les strong ect performance section investigate treat le-system layout algorithm gray-box developing layout detector controller fldc fldc layer applications order accesses improved performance based probable layout disk discussed earlier applications re-order accesses time improve disk performance purposes discussion focus smallle accesses scans large les amortize arm-movement overheads obviate re-ordering gray-box knowledge information exact layout inode le-block disk application re-order accesses reduce seek time rotational delay superuser privileges knowledge le-system structures reconstruct exact layout les raw-disk reads information hidden users applications fortunately experienced programmers gray-box knowledge les allocated disk modern unix le-systems direct intellectual descendents berkeley fast file system ffs ffs attempts lay les subsequent read performance optimized basic premise blocks meta-data les directory accessed ffs place cylinder group consecutive cylinders disk based algorithmic knowledge ffs simple heuristic reduce seek time group set les directory access order access order matter directory clean le-system small les created directory creation order matches data-block layout disk determine creation order option creation time resolution creation time cient multiple les created simultaneously option inode number i-number probe stat system 
call account ects le-system aging attempt discover layout predictor arbitrary creations deletions follow control technique gray-box systems moving system state refreshing directory writing les directory order hypothesize system state i-number order highly correlated data-block layout note directory refreshed small les rst small les assigned rst i-nodes directory large les presence lower correlation i-numbering data layout assigned i-nodes data blocks impact implementation approach implementation layout detector controller straight-forward application wishes access set les calls fldc layer desired set les fldc layer performs stat returns les i-number sorted order note sorting i-number essentially obviates sort directory verify low-overhead performing stat measured operation requires milliseconds disk access fact accessing group les single directory rst calling stat accessing data improves performance slightly inodes data blocks located separate regions cylinder group control component fldc layer refresh directory requires steps create temporary directory level hierarchy sort les original directory size user-speci cation copy les original directory sorted order update access modi cation times match original les make time-dependent programs operate correctly delete directory rename temporary directory directory experiments explore bene fldc clean aged le-systems experiments examine simple microbenchmarks ensure data meta-data cache begin reporting performance newly created le-system operating system platforms examine total time read small les evenly divided directories erent access patterns random ordering les les sorted directory les sorted i-number figure shows sorting directory improves performance relative random order sorting i-number leads dramatic improvements factor linux netbsd factor solaris hypothesize solaris pack data blocks small les tightly issues atomicity refresh operation crash occurs delete midst rename envision nightly script directory signature patches problems implemented linux bsd solaris time platform sensitivity file ordering random sort directory sort i-number figure file ordering matters gure plots total access time scan -kb les split equally directories experiment varies platform order access random bar ects access time les random order trial sort directory bar rst groups les directory accesses nally sort i-number bar rst sorts collection les i-number reads bars ect average measurements standard deviations shown spends time rotation measure ects le-system aging fldc create series epochs epoch random les deleted les created experiment les directory compare performance application reads les random order versus i-number ordering figure plots time application function increasing epochs epoch explicitly refresh directory graph shows random ordering performs poorly expected i-number ordering performs excellently fresh directory degrades epoch i-number ordering random epochs performance worse fresh directory performance factor directory refreshed epoch i-number sorting returns performance original level composition applications utilize fldc layer utilize fccd layer modifying grep process les order probable layout disk passing gbp -file commandline unmodi grep improves performance manner similar speed-ups figure shown due space constraints similarity fccd fldc interfaces iqrl -qt fke zrt pao -jowf l-a cxq nuz fon qtd nmt fmr kza fdg gjl zacd mgw rbsz gsz mcis kjq ede rtn iki ueo npt ykjg btn cbp wjga ngk opv dgl fodh kdd o-lj hdxd fsw ogi jz-t gwp dkatlv mdyb gff mfx ylr leads natural question compose icls ordering les application rst access les cache access rest i-number ps-adobecreator dvipsk copyright radical eye software title iopads dvi pages pageorder ascend boundingbox documentfonts times-roman times-italic times-bold courier endcomments dvipscommandline dvips iopads-public iopads dvipsparameters dpi comments removed dvipssource tex output beginprocset tex pro texdict dict texdict begin bind exch translate isls false vsize mul hsize mul landplus false rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus ordering vresolution div vsize mul culty exch resolution approach div hsize mul fccd ifelse explicitly resolution identify vresolution vsize les div add cache mul matrix orders currentmatrix les dup dup probe round time reliably abs discern in-cache out-of-cache les apply standard statistical clustering time aging epoch round effects forall round aging exch random round sorted exch setmatrix i-number refresh landscape brings isls true performance back manualfeed excellent statusdict level manualfeed figure undoing ects true aging put gure copies plots copies total time fmat access -kb fbb les directory ctr linux df-tail platform dict upper begin line fonttype plots fontmatrix time fntrx access fontbbox les fbb random string order base array lower bitmaps line buildchar sorts charbuilder les encoding i-number end rst dup foo x-axis setfont array age copy cvx directory load increased put ctr epoch random les fntrx fmat deleted df-tail dfs div les created fntrx epochs neg directory df-tail refreshed pop copying dup definefont contents setfont temporary ch-width directory ch-data dup deleting length directory ch-height renaming ch-data dup temporary length directory probe times ch-xoff ch-data dup clustered length groups ch-yoff minimizing ch-data intragroup dup variance length maximizing intergroup ch-dx variance ch-data dup length form ch-image clusters ch-data dup clustering type algorithm stringtype ctr fast ctr rst ctr group add predicted cache charbuilder save roll dup base group index bitmaps predictions ch-data incorrect pop ctr les ch-dx ch-xoff ch-yoff disk ch-height group ch-xoff ch-width sorted add ch-yoff i-number setcachedevice ch-width incorporated ch-height approach true grep ch-xoff initial ch-yoff experiments ch-image imagemask performs restore rst dup accessing type les stringtype cache base picking ctr order put on-disk bitmaps accesses ctr provide dup avenue dup unmodi length applications dup index compose div put gbp put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop utility pop discussion eop restore limitation showpage gray-box userdict fldc eop-hook eop-hook highly start unix-centric userdict start-hook utilizes start-hook i-number pop vresolution resolution div dvimag array string dup index put cvn put div vsize div approach hsize show work rmat platforms bdot string rulex ruley ruley expose rulex low-level information statusdict begin current product implementation pop product work dup non-ffs-based length systems getinterval dup porting display exch prove getinterval cult pop false lfs ifelse false icl ifelse end gsave advantage scale rulex ruley knowledge false rmat writes bdot occur imagemask grestore gsave time lead rulex proximity ruley space scale false open rmat bdot question imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail rmoveto refresh rmoveto roll bos save eos restore end endprocset beginprocset directory texps pro simple texdict heuristic begin refresh findfont directory dup randomly length add dict accesses begin index refresh fid index important uniqueid directories nightly pop script pop ideally ifelse forall index ascertain roll exec exch roll vresolution resolution div mul neg metrics exch dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div ifelse forall metrics metrics i-number currentdict ordering end performing index currentdict end historical definefont tracking roll makefont perform setfont load refresh cvx additional danger obliqueslant dup sin cos div refresh neg operation slantfont index mul add applications extendfont i-number roll les mul exch directly reencodefont applications encoding active exch time end endprocset refresh beginprocset special cease pro operate texdict correctly safe refreshes invoked system start-up user guarantee processes running begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter memory-based note admission control legal virtual memory scaleunit systems hscale provide scaleunit div applications hsc vscale illusion scaleunit div vsc hsize unlimited amount clip memory vsize memory clip resources heavily clip clip overcommitted illusion hoffset breaks voffset system page angle parts ang memory swap rwi entire div processes rwi disk rwiseen true desire service ensures rhi running div processes rhi rhiseen actively true memory llx llx physically present lly lly section urx describe urx gray-box ury memory-based ury admission controller magscale true mac end limits macsetup userdict userdict type dicttype userdict begin length add maxlength total amount dup memory length add dict allocated copy end service begin letter components note legal control mac txpose ensures mtx defaultmatrix set dtransform processes atan allocate newpath clippath memory mark transform itransform moveto physically transform present itransform lineto admissioncontrol roll transform processes roll forced transform wait roll transform cient memory itransform roll itransform roll information mac itransform roll noties applications curveto closepath amount pathforall memory newpath counttomark applications array astore adjust xdf memory pop usage put operating multiple courier passes fnt mac invertflag atomically identi paintblack allocates txpose memory pxs avoid pys race scale ppr conditions aload gray-box pop knowledge por investigate approach noflips process pop neg independently determines pop scale xflip yflip pop neg rotate scale amount ppr ppr memory neg probing neg measuring ppr time ppr increasingly large neg memory neg accesses approach xflip naturally yflip leverages pop nition neg working set pop employed rotate ppr page-replacement algorithm ppr mac neg observes neg memory accessed triggering yflip replacement xflip technique ppr special conditions neg needed ppr account neg memory noflips erent pop competing pop processes rotate erent scale purposes xflip yflip heap stack pop cache pop rotate directly scale observe paging ppr activity ppr systems neg neg vmstat ppr observe time ppr order neg explore neg environments xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg limited interfaces ifelse basic scaleby algorithm ppr employed aload mac pop probe roll chunk add memory div page roll time add div sequential copy loops recording dup time scale neg page access neg note probes pop write pop page showpage copy-on-write restore end systems normalscale reads resolution force div pages vresolution allocated div rst neg loop scale magscale control dvimag technique dup moving scale system setgray state psfts directly infer accesses amount memory space access time include costs allocating zeroing div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx re-fetching psfts psf page lly psfts disk psf llx psfts psf loop psfts access psf psfts currentpoint psf page psf fast mac psf infers psf psf chunk urx memory psf llx div space psf pages psf psf selected ury psf replacement lly div accesses psf slow psf mac scale infers psf amount psf memory div large psf llx psf paged psf disk div psf probing ury progressively larger showpage chunks erasepage memory mac copypage determine amount space assumption algorithm rate probes access memory approximately matches macsetup access doclip rate psf llx psf lly psf application urx psf ury stable currentpoint working roll set newpath copy roll moveto competing roll processes lineto mac lineto lineto application closepath clip newpath moveto pages endtexfig end resident psf savedstate restore probes write beginspecial sdict single begin byte specialsave save page gsave moving normalscale currentpoint page specialdefaults count ocount application touches dcount pages countdictstack slowly setspecial result clip application newpath moveto allocated rlineto pages rlineto resident neg active rlineto competing closepath process clip make mac hsc slightly vsc scale aggressive ang rotate approach rwiseen rwi application urx llx rate div mac rhiseen rhi ury lly probe div pages dup order ifelse match scale llx rate neg subsequent lly access neg patterns rhiseen approach rhi ury cult lly cumbersome div dup scale approach llx neg lly mac neg assume ifelse memory clip newpath resident llx competing lly process moveto urx active working set lly result lineto urx ury cient lineto mac llx ury wait lineto closepath access clip page showpage determine erasepage paging copypage occurring newpath mac notices endspecial consecutive count slow ocount data pop points repeat rst countdictstack access dcount loop end predicts repeat increasing grestore specialsave restore working end set activated defspecial page sdict begin fedspecial end lineto rlineto rcurveto savex daemon size currentpoint exceed savey amount setlinecap newpath stroke suspicions savex savey moveto mac fil immediately fill skips savex savey loop moveto verify ellipse contents endangle startangle memory yrad implementation mac xrad savematrix low-level matrix interface currentmatrix applications xrad informed yrad scale startangle endangle memory arc speci savematrix cally mac 
setmatrix exports end interface dynamic endprocset memory texdict allocation alloc takes minimum begin iopads maximum dvi start multiple bytes allocate returns pointer allocated space actual number bytes allocated null pointer returned minimum amount memory application adapt memory requirements speci identical minimum maximum amounts exposing control information courier low level processes respond application-speci manner lack memory courier cases anticipate applications simply allocate memory times-bold previous invocation fails waiting period time naive interface applications times-italic deadlock applications allocate half memory allocate memory releasing initial memory complete classic solutions deadlock prevention times-roman allocating required memory releasing memory allocation fails solve problem future plan investigate higher-level interfaces hide complexity provide fair allocation competing processes times-italic times-roman times-roman times-roman end endprolog beginsetup feature resolution dpi texdict begin endsetup page bop cluster making ast case common remzi arpaci-dusseau eric anderson noah reuhaft vid culler joseph hellerstein vid atterson kathy elick computer science vision uni ersity california berkele abstract introduce river datao programming vironment substrate clusters computers ver designed provide maxy imum performance common case ven face nony uniformities hardware software workload ver based simple design features high-performance distrib uted queue storage redundancy mechanism called graduated declustering implemented number data-intensi applications ver alidate design -ideal performance ariety non-uniform performance scenarios intro duction scalable systems form basis highy performance computing market recent years manufactur ers found 
gro wth customer appetite capacity outstripping moore cluster systems component des ign today calab ta-intensi architectures frustrating aspect cluster systems common-case performance great deal worse reported peak performance discrepanc arises arious forms performance heter ogeneity clustered components simplest heterogeneity hardware cluster composed machines dif fering speeds capacities principle problem solv packaged clusters ibm spb nefarious heterogeneities software performance arise dynamically multitude sources une xpected operaty ing system acti vity une load placement discuss challenges implementing mac erentiating in-memory out-of-memory probe times incrementing heterogeneous mixture operations machines software heterogeney ity hard m-h control quickly time yqr surprisingly hardware heterogeneity non-tri vial kzag control xample ylinders disk bandwidth outer apparently identical disks dif vyh ferent bandwidths depending locations unused lyo mgsb bad disk blocks gie presented iop ads input output woa arallel disy trib uted systems atlanta geor gia attempting pre ent performance heterogeney ity designed system takes account eti inherent design consideration -hq paper describe okx river datao programming vironment substrate clusters goal pro vide lhm common-case maximal performance o-intensi applicay tions achie basic system mechanisms distrib uted queue balances work consumers system data layout access mechanism called aduy ated declustering dynamically adjusts load generated producers center design jaj high-performance implementation dqs udzsxg data qrp operators autonomously adapti rates time producer places data fast consumer takes data fast interposing dqs operators data load natuy rally balanced consumers running dif ferent rates adv antage simplicity lack global coordination required consumers change rate sguv autonomously time communicating clients result vly full-bandwidth balanced consumption qmi ailable bandy width naturally utilized times consumers avi set data complete qzs -simultaneously xpv tpn important aspect cuh xible rey dundant disk layout access mechanism called graduated declustering generalization mechanism proposed early parallel database systems allo task data oduction shared multiple producers xible fashion mirrors lar sequential collections disks dif gxt ferent producers xof data proy ducer multiple bandwidth data sets handling ensure produces share global bandwidth ailable collection result full-bandwidth balanced production ailable bandwidth utilized times uaj producers data set complete voa -simultaneously introducing describe programming model graphical interface composing proy grams mis based traditional datao dxr diagrams composed operators similar database query plans scienti yygl datao systems iny tuiti interface zqb xrd zpv vvo oduu fcg bwd mqq yih eog isa allo programmers focus applicationy speci logic xzmc transparently handles gei issues high-performance parallelism application demonstrate interface number datay intensi applications alidate perfor eop page bop kll starttexfig begindocument figs motivation eps gnudict dict gnudict nus begin color true solid true solid false gnu eqr gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift ojw show rshow currentpoint stroke dup stringwidth pop lvuv neg vshift show cshow currentpoint olk stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse color setrgbcolor solid pop setdash pop pop aka pop solid pop azg setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth stroke gnu setlinewidth ltb penq lta setdash setrgbcolor dfi rgm kep olj stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash jld zol ffw vpt vpt currentpoint mvrx stroke hpt neg vpt neg hpt stroke dpu stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt c-g neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg sglr hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath vsn lta ltb rshow rshow rshow rshow rshow rshow rshow currentpoint gsave translate rotate slowdown cshow grestore now-sort single anomaly cshow ltb helvetica findfont scalefont setfont now-sort cshow case cshow single disk cshow poor layout gzm unk cshow single disk cshow hot spot cshow single machine cshow light cpu cshow single machine cshow heavy cpu cshow single machine cshow memory load cshow stroke grestore end showpage enddocument endtexfig figure -sort wkp erturbance amount memory test iteration memory-di erentiation threshold determine paging memory disk occurring mac erentiate time write memory versus disk platform-independent manner unlike fccd collect probe times sort cluster times erentiate groups mac determine page-by-page basis probing reveals page memory approaches determining thresholds rst method values calculated simple microbenchmark run controlled environment advertised method microbenchmark run rst time mac contacted process measures time repeated accesses pages memory time non-resident page simply considered signi cantly larger erentiate paging scheduling activity found experimentally observing slow data points succession reliable indicator paging increment unit repeatedly accessing large amounts pages time-consuming mac probe substantially larger chunk memory iteration recovering large increment paging costly processes increase aggressive found good compromise initially increment search size conservative amount slowly double increment amount allocated memory found space xed maximum increment unit back completely original increment size problem detected analogous conservative tcp congestion-control scheme experiments linux platform extensively veri mac returns expected amount memory experiments show process allocates data accesses variety patterns mac reliably returns competing application applications repeatedly access allocated memory paging show mac behaves multiple competing processes simultaneously demanding application investigate copies fastsort sorting data sort adapt amount memory reading sorting writing sets records passes size pass memory determining number records memory complicated due fact linux shared virtual memory cache amount devoted virtual memory system records read written disk investigate traditional fastsort size pass speci command-line gb-fastsort modi mac icl gb-fastsort frees chunk memory allocating memory pass meshes interface deadlock minimum allocatable amount ensure arbitrarily small passes performed maximum equal total amount sorted gb-fastsort processes allocate memory simultaneously grab large chunks acquire minimum wait memory freed figure shows sorting extremely sensitive amount memory allocated pass overestimating amount severely increases amount time required complete workload perfect knowledge workload user determine amount correctly machine anticipate sorted pass processes paging passes paging signi slowdown compared runs robustness mac layer illustrated fact gb-fastsort exhibits paging activity read sort write phases experiments gb-fastsort average pass size close best-performing static version gb-fastsort time data sorted run gray-box sort performance write sort read overhead note gray-box version sort overhead component figure performance sort mac execute rst phase competing copies fastsort sorts million -byte records execute merge phase performance sensitive amount memory avoid contention disks process reads writes disk fth disk paging cache ushed test performance mac degrades rapidly memory allocated sorting pass size shown requires average minutes data point represents average experiments performs worse due alloc overhead signi approximately equal overheads present gb-fastsort designated overhead graph rst component time spent mac layer repeatedly probing memory increase number probed pages iteration operation proportional square number pages component time spent waiting memory compute-bound workload waiting time hidden increased throughput processes bound workload fastsort waiting time increases total time workload note performing admission control workload accounts improved performance write phase contention cache discussion mac important limitations implementation sensitive behavior underlying page-replacement process parameters mac tuned work linux interface assumes applications call pairs alloc free memory requirements change inform application memory call-backs cult programmers deal ciently ectively allocate memory application mac allocated memory malloc approach prevent thrashing competing application subsequently calls malloc amount larger memory gray toolbox support gray-box systems assembling collection tools operations performed frequently gray-box layers common operations implemented optimized implemented number utilities current toolbox imagine added time developers gain experience gray-box systems observing systems literature case studies tools building gray-box icls microbenchmarks con guration graybox icls require knowledge performance parameters underlying components amortize overheads set access unit le-cache content detector erentiate erent states determine page memory disk multiple icls parameters share information common repository microbenchmarks report performance numbers expected disk seek time expected disk bandwidth time allocate page time access page memory time access page disk common format persistent storage microbenchmark run performance suspected changed icl search desired information exist icl determine acquire information update common repository measuring output acquire information gray-box component icls studied measure time operations complete overhead obtaining elapsed time added operations important overhead low time operations complete quickly timer resolution issue provide fast timer speci current platform intel machines rdtsc instruction interpreting measurements observations output icl manipulate raw data infer current state found common data manipulations calculating simple statistics standard deviation median maximum minimum performing slightly sophisticated operations correlations clusters discarding outliers nally sorting due frequency important operations performed low time space overhead data collected time results continually monitored operations performed incrementally note douceur bolosky statistical sampler good candidate inclusion related work uential research projects investigated restructure operating systems extensible adopted systems solve problems incorporate functionality commercial operating systems restructured work investigated developers add functionality ways minimal interpositioning developers write code extensions invoked events cross interface boundaries implementing protected interposition agents requires small presence enhances number gray-box techniques applied speci cally interpositioning easily observe inputs outputs model simulate infer current state future plan investigate interpositioning gray-box icls disco virtual machine monitor modify run multiprocessor additional layer software inserted hardware multiple operating systems disco occasionally gray-box knowledge achieve desired information control disco developers irix enters low-power mode idle signal switch virtual processor finally visual proxies treat applications gray boxes changed insight gui-based applications ect internal state visual interface visual proxy snoop gui mirror internal state application visual proxy control application generating synthetic window events simulate user input conclusions systems longer developed isolation building local distributed service utilize interact software components control situation contrast past small group researchers implement operating system include compiler shell tools gray-box techniques 
building systems services live constraints gray-box icls encapsulate knowledge behavior observation statistical methods inference clients gain information state control behavior paper demonstrated utility gray-box techniques os-like services lecache content detector layout detector controller memory-based admission controller applications improve performance substantially icls source-code modi cation gray-box techniques broadly applicable local operating system distributed environments plan develop explore gray-box icls settings services developed gray-box approach revolutionary ideas require parts system remaining challenge determine types services implemented gray-box icl incorporated operating system acknowledgements bent burnett denehy forney popovici sivathanu anonymous reviewers shepherd monica lam excellent feedback work sponsored nsf ccrccr- itrand wisconsin alumni research foundation agarwal super scalar sort algorithm risc processors proceedings acm sigmod conference pages june anderson bershad lazowska levy scheduler activations ective kernel support user-level management parallelism acm transactions computer systems pages february arpaci culler krishnamurthy steinberg yelick empirical evaluation cray-t compiler perspective annual international symposium computer architecture iscapages june arpaci-dusseau implicit coscheduling coordinated scheduling implicit information distributed system acm transactions computer systems tocs aug babaoglu joy converting swap-based system paging architecture lacking pagereferenced bits proceedings acm symposium operating system principles pages paci grove december baker hartman kupfer shirri ousterhout measurements distributed file system proceedings acm symposium operating systems principles pages october balakrishnan padmanabhan seshan katz comparison mechanisms improving tcp performance wireless links ieee acm transactions networking december bershad savage sirer fiuczynski becker chambers eggers extensibility safety performance spin operating system proceedings acm symposium operating systems principles december blackwell girshick theory games statistical decisions john wiley sons york bugnion devine govil rosenblum disco running commodity operating systems scalable multiprocessors acm transactions computer systems november cranor parulkar uvm virtual memory system proceedings usenix annual technical conference monterey california june douceur bolosky progress-based regulating low-importance processes procedings acm symposium operating systems principles december druschel peterson hutchinson micro-kernel design decoupling modularity protection lipto proceedings international conference distributed computing systems pages june engler kaashoek exterminate operating system abstractions proceedings workshop hot topics operating systems engler kaashoek toole exokernel operating system architecture application-level resource management proceedings acm symposium operating systems principles december floyd jacobson random early detection gateways congestion avoidance ieee acm transactions networking aug ghormley petrou rodrigues anderson slic extensibility system commodity operating systems usenix annual technical conference pages june ghormley petrou rodrigues vahdat anderson global layer unix network workstations software practice experience july howard kazar menees nichols satyanarayanan sidebotham west scale performance distributed file system acm transactions computer systems february jacobson congestion avoidance control sigcomm symposium communications architectures protocols pages aug jain delay-based approach congestion avoidance interconnected heterogeneous computer networks technical report dec-trdigital equipment corporation april jones interposition agents transparently interposing user code system interface proceedings symposium operating systems principles pages december kocher jun erential power analysis advances cryptology crypto annual international cryptology conference lecture notes computer science pages lampson note con nement problem communications acm october lampson hints computer system design operating systems review october litzkow livny mutka condor hunter idle workstations proceedings international conference distributed computing systems pages june mckusick joy fabry fast file system unix acm transactions computer systems aug meter gao latency management storage systems osdi october ousterhout scheduling techniques concurrent systems international conference distributed computing systems pages pang carey livny memory-adaptive external sorting proceedings international conference large data bases aug ritchie thompson unix time-sharing system communications acm july rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february saavedra smith measuring cache tlb performance ect benchmark runtimes ieee transactions computers satyanarayanan flinn walker visual proxy exploiting customizations application source code acm operating systems review july seltzer endo small smith dealing disaster surviving misbehaved kernel extensions proceedings symposium operating system design implementation osdi smaragdakis kaplan wilson eelru simple ective adaptive page replacement sigmetrics conference measurement modeling computer systems atlanta smith seltzer file system aging proceedings sigmetrics conference seattle june smith seltzer comparison ffs disk allocation policies usenix annual technical conference pages staelin mcvoy mhz anatomy microbenchmark proceedings usenix annual technical conference pages berkeley usa june usenix association talagala arpaci-dusseau patterson microbenchmark-based extraction local global disk characteristics technical report csd- california berkeley von neumann morgenstern theory games economic behavior princeton press princeton jersey edition worthington ganger patt wilkes on-line extraction scsi disk drive parameters proceedings acm sigmetrics performance conference measurement modeling computer systems pages zeller gray adaptive hash join algorithm multiuser envronments proceedings international conference vldb pages 
inproceedings arpaci-dusseauetal -river title cluster river making fast case common author remzi arpaci-dusseau eric anderson noah treuhaft david culler joseph hellerstein dave patterson kathy yelick booktitle workshop input output parallel distributed systems iopads month year address atlanta georgia 
abstract searching sorting record experiences tuning now-sort appeared spdt andrea arpaci-dusseau remzi arpaci-dusseau david culler joseph hellerstein david patterson present experiences developing tuning performance now-sort parallel disk-to-disk sorting algorithm now-sort holds world records database-industry standard benchmarks critical tuning process setting expectations programmer tune stop found categories tools tools set expectations configure application hardware parameters visualization tools animate performance counters search tools track performance anomalies tools interact layers underlying software operating system applications leverage modern features threads memory-mapped postscript 
ps-adobecreator dvipsk copyright radical eye software title spdt dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic courier endcomments dvipscommandline dvips spdt spdt dvipsparameters dpi comments removed dvipssource tex output beginprocset tex pro texdict dict texdict begin bind exch translate isls false vsize mul hsize mul landplus false rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix dup dup round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding end dup foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop dup definefont setfont ch-width ch-data dup length ch-height ch-data dup length ch-xoff ch-data dup length ch-yoff ch-data dup length ch-dx ch-data dup length ch-image ch-data dup type stringtype ctr ctr ctr add charbuilder save roll dup base index bitmaps ch-data pop ctr ch-dx ch-xoff ch-yoff ch-height ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true ch-xoff ch-yoff ch-image imagemask restore dup type stringtype base ctr put bitmaps ctr dup dup length dup index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore showpage userdict eop-hook eop-hook start userdict start-hook start-hook pop vresolution resolution div dvimag array string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div ifelse forall metrics metrics currentdict end index currentdict end definefont roll makefont setfont load cvx obliqueslant dup sin cos div neg slantfont index mul add extendfont roll mul exch reencodefont encoding exch end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter note legal scaleunit hscale scaleunit div hsc vscale scaleunit div vsc hsize clip vsize clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform roll itransform roll itransform roll curveto closepath pathforall newpath counttomark array astore xdf pop put courier fnt invertflag paintblack txpose pxs pys scale ppr aload pop por noflips pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage copypage macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly aph neg depicts rhiseen rhi ury lly best-case div performance dup scale llx neg lly -sort neg versus ifelse clip performance newpath llx lly slight moveto disk urx lly cpu lineto urx ury memory lineto llx ury perturbay lineto tions closepath clip performance showpage erasepage esults copypage newpath elative endspecial count ocount -node pop repeat countdictstack dcount sort end whic repeat grestore delivers specialsave data restore end defspecial -peak sdict begin disk fedspecial ate end lineto rlineto thr oughout rcurveto savex run currentpoint savey mance setlinecap newpath system stroke savex savey cases moveto fil fill pro savex savey vides moveto ellipse -ideal endangle performance startangle yrad face xrad savematrix matrix ere currentmatrix performance xrad yrad perturbations scale motivation startangle endangle arc case savematrix study setmatrix end endprocset texdict moti ate begin problem spdt dvi performance start heterogeney ity perform simple xperiment -sort high-performance parallel times-italic xternal sort clusters periment sort runs machines run perform slight perturbation times-roman sort machines results courier perturbation xperiments sho figure graph perturbations single machine global performance fect single single machine poor layout tracks ersus outer erall performance drops percent single disk hot spot competing data stream performance drops factor cpu loads machines decrease performance proportional amount cpu steal finally memory load pushes machine page factor performance lost uild system oids situations balancing load system perfectly times meticulously managing resources system belie dif cult system size comy ple xity increase carefully managing system -impossible approaching problem dif ferent manner assuming presence formance faults pro viding times-roman substrate operate times-roman spite times-roman outline rest paper structured follo section times-bold describe design system current implemeny tation euphr ates section times-italic alidate performance properties dynamic infrastructure measurey ments distrib uted queues graduated declustering present initial application times-roman xperience section related work found section section present plans future work section conclude river system section describes times-roman design vironment current implementation times-bold euphr ates brie describe hardware times-roman software vironment present data model data stored accessed disk continue xplaining components programming model including details typical program constructed conclude discussion rdw soft environment prototype euphrates runs cluster ultra workstations connected myrinet localy area network workstation mhz ultray arc processor seagate rpm disks swap space common case memory solaris operating system machine modern multi-threaded unix communication performed acti messages generation communication layer designed distrib uted computing xposes performance myrinet pro viding support threads blocking communication ents multiple independent endpoints fast message laye support blocking communication ents require polling network interface recei messages boundless polling consumes cpu ycles uilding infrastructure data del single disk collections single disk data represented group on-disk records kno collection record set named elds arious types catalog informay tion meta-data system data accessed disk unor der collection unordered collections pro vide ordering constraints records collection application reading collection recei records arbitrary order subject optimizations system ordering desired application data accessed str eam stream ordered set records application writes collection disk stream write order preserv applications accessing collection directly 
recei records order euphrates implementation underlying solaris unix system ufs implement record collections read disk read directio enabled unb fered read disk mmap iny terface deli data disk rate sequential read access simple read interface directio leads double-b fering inside system undesirable applications writes disk write system call directio enabled implemented top ufs layout information ailable optimizations unordered collections impley mented disk manager implementation include disk manager top disk order xploit range scheduling optimizations enabled eop page bop starttexfig begindocument figs grad-decluster eps psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit clip times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh slw ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols times-roman scf rot colsh times-roman scf rot disk colsh times-roman scf rot colsh times-roman scf rot disk colsh polyline cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline cols polyline cols polyline cols polyline cols polyline cols polyline cols polyline cols polyline cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline cols polyline cols polyline cols polyline cols polyline cols polyline cols polyline cols polyline cols times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf perturbation colsh times-roman scf perturbation colsh times-roman scf clients perceive imbalance colsh times-roman scf bandwidth balanced clients colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf rot client colsh times-roman scf rot client colsh psend enddocument endtexfig figure graduated declustering diagr ams depict scenarios aduated declustering perturbation unperturbed disks deliver bandwidth perturbed disk delivers half left disk serving partitions clients perturbed half bandwidth application left unc hec ked esult clients eceive muc bandwidth clients bandwidths eac disk adjusted compensate perturbation case aduated desclustering ith adjustments eac client eceives 
equal shar bandwidth rallel collections applications system access data spread multiple disks facilitate pro vide abstraction par allel collection allo grouping set single-disk collections single logical entity parallel collection facility tracks parallel meta-data names physical locations single-disk collection form parallel collection desired ordering single-disk collections euphrates parallel collection meta-data stored nfs nfs pro vides consistenc guarantees uny der concurrent access parallel meta-data operations serialized single process application operations rare occur bey ing opened created performance bottleneck redundancy lar scale clusters presence data ailability straty important ithout data frequently una aily due disk machine failures applications increased data reliability ailability choose mirr single-disk collection disks housed dif ferent machines cluster interested xploiting redundant data cony tained mirrors impro consistenc application performance uilding earlier work authors introduced hained declustering insight chained declustering faily ure disk mirrored system read-only load balanced enly remaining working disks balance achie carefully-calculated distrib ution read requests mirror gments remaining disks generalize technique call aduated declustering order solv performance consistenc problem common case disks storing mirrored collection functional fer dif ferent bandy width time reasons enumerated earlier iny vidual reader traditional approaches mirroring ariations una oidable reader choose mirrored gment copy read entire ment ariations lead global slo wdo parallel programs slo clients complete fast remedy approach problem dif fer ently picking single disk read partition client fetch data ailable data mirrors illusy trated figure case data replicated disks disk disk client alternati ely send request block disk block disk disk responds request desired block solv problem graduy ated declustering pro vide client reading set collections equal portion bandwidth ailable application clients recei xpected bandwidth disk mirrors recei bandwidth mirror compensay tion implementation graduated declustering someho observ bandwidth dif ferences clients adjust bandwidth allocation appropriately euphrates implementation simple algoy rithm balance load urces disk mana dif ferent gments parallel collection continually recei feedback consumers total bandy width consumers recei ving performance inequity clients detected disk manager biy ases requests wards lagging client attempts balance rates readers progress xample result balancing sho right-side figure disks compensate pertur bation disk allocating bandwidth clients resulting bandwidths client properly balanced eop page bop module loop records process msg null operate message operate msg conditionally pass message downstream put msg completion return null figure module api simple river module module messages upstr eam performs oper ation calling user -de ned oper ate conditionally put messages downstr eam programming del pro vides generic data vironment applicay tions similar parallel database vironments oly cano applications constructed component-like fashion set modules module logical thread control input output channel ving simple xample lter module record single input channel applies function record function returns true puts data single output channel modules connected machine machine boundaries queues queue connects producers consumers pro vides ratey matching modules dynamically sending data faster consumers queues essential adjusting work distrib ution system gin ecution application master program constructs connects desired set modules source sink time single module cony nected queue instantiated master program computation gins continues data processed termination control returned master program river dules module basic unit programming modules operate records calling obtain records input channels calling put place output channels con enience refer set records ving system message logically module pro vided thread control one-input one-output module performs simple loop obtain records upstream channel operate records put pass records wnstream illustrated figure comple modules input output case input output number gument put non-blocking ersions interfaces ailable ability perform select operation waits speci set channels ready returns control user euphrates modules written classes current implementation module thread control bene dra wbacks main adv antage approach applications naturally lap computation data ement user freed urden carefully managing thread switches costly amortize cost modules pass data set records themselv relati ely lar chunks xperience complicated mody ules noticeable fashion felt inclusion comple fer management worth implementation fort queues queues connect multiple producers multiple consumers local machine distrib uted dif ferent machines cases construction queues modules messages transmitted producy ers consumers modules side local distrib uted queues obli vious type queue interact messages ywd khk gkz arbitrarily jgjc sysy tem depending run-time performance characteristics oyeiz constraints dynamic load balancing achie routing khpn messages faster consumers queues consumer lkv guee impro performance ordering relax queues multi-producer queue consumer recei arbitrary interlea ving messages producers ordering guarantee vided swq point-to-point producer places message queue message epy consumer recei messages recei recei wqm ordering pey xample retain owl ordering disk-resident stream attaching single consumer b-j single producer stream ordered property stream properly maintained implementation local queues data structures shared threads locking sigy nalling protocol euphrates implementation interesting takes dif ferent ors general case lightweight randomized credit-based scheme balance load consumers push-based algorithm producer tracks number outstanding messages consumer sends messages rany domly consumers messages outstanding threshold alue desired beha vior automatically sending records -mg nodes consuming higher rates implemented ciently -hr randomized algorithm adds -zero cpu qsy head top normal message transfer costs cases found load balancing pro vided lar ger -than-record size units xample sort module sorted input data pass entire sorted run disk write module order preserv xact xample section pro vide functionality implementation handed arbitrarily lar set records pully based algorithm consumers querying producers data balance load randomized push-based algorithm work case single bad decision costly guarantee pro vided ersion single consumer recei entire set records order load balancing occurs granularity lar potentially man unit handed eop page bop simple copy gtv program flow szs module whi instantiate module instances place ufsread file place ufswrite file attach yws read module write hjb attach jh-dj orx ski execute flow figure flow api simple eader writer tsz shown ufsread module eads collection output input ufswrite module whic writes disk flo construction ecute program vironment wjr modules eyzgq connected form graph data source mgk sink man intermediate stages dictated program phases olv instantiating construction operation tear -do construction master ogr speci global graph describing data including modules speci interconnection nleph construction phase cww complete zdy master program instantiates gfcz operation phase threads created machines necesy sary control passed modules data ksz gins tgj data sources system speci atn graph completion flo construction performed programmatically smj api pro vided graphically construction api simple add node graph place routine called module guments vvy xample read on-disk coly lection 
vlv programmer bhp ufsread module gument -rrt lename sho figure place returns module attach modules simple attach inter face interface graph edges gure simple copy formed read write jcf module xjej attached attaching modules places queue modules input output case user xtra guments attach routine input connect output finally instantiate interface pro vided starts threads performs attachments rlz waits snx completion asynchronous ersion rjf ailable description point restricted single-machine izy speci cation sake simplicity construct par allel ows multiple machines proy grammer nodes -vv place uri gup arious modules local distrib uted queues inserted program run spa wned nodes top system hlk simple remote uhu ecution mody ule internal kpy system wzu user add xtra guments attach routine rgd details remote cony nections producers consumers single -top distrib uted queue -toh distinct queues fully-connected graph euphrates implementation numerous languages program interface ailable found erly cumbersome re-compile codes simple change pro bde vide tcl perl interfaces allo wing rapid assembly scripting language finally rlq uilt graphical user interface gui data graphs oze similar spirit ioga jiev gui allo programmers select modules module liy brary dra data graph desired user ecute program generate construction code re-use gui allo ariables added program enabling user easily cony struct generic programs xample simple copy user choose input jui output collection names ariables generate general-purpose t-c copy program general found simpler mwt programmatic interface ug-prone discussion conclude section discussion system xpect gev typical programmer writing program nmr spend hov time programming indi vidual modules ulk iilk application code modules fhc modules system order construct lov imagine user community interested similar problem areas libraries standard modules ihh mos sjdx share tuned high performance achie ving parallelism straight-forward user construct script vkq gui tool stn nodes run system pfu spa modules gno multiple nodes easily generate desired connections queues local distrib vwc uted modules focus simply lcj enabling cony jrz struction high-performance parallel o-intensi applicay tions seek pro vide frame work uilding performance-rob ust programs system pro vides part solution transparently wfg application writers wmx graduated declustering algorithm enabling mirroring apy plications automatically -mm gain rob ustness read perturbations lld component pro vides formance rob ustness distrib uted queues iny serted xsd application writer cases place dqs depends program semantics dif cult xuk automate qzm decision general dqs easily inserted han embarassy ing parallelism cases heg producers place work mgc queue erb mms consumers work queue indi vidual rates addition dqs situations mme bit dif cult requires solid understanding application erall construction performance-rob ust fzpj applicay tions requires application writer construct ycn optimize sequential modules describe connect iny serting distrib uted queues spending programmer fort placement user gain rey turn scalable application runs face ariabley tpo rate kgg producers consumers tto well-designed application run high performance set chines highly arying performance characteristics eop page bop starttexfig zdw begindocument figs dq-scaleeps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto vgx bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse ahte stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb dfg lta nny setdash setrgbcolor bwb kxk okl stroke setdash currentlinewidth div ula currentlinewidth stroke fixb stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow ewc iad xbv m-ff krf ovg nev ivz qff vhx aej xas vxxqff frko zfx ehw bjj al-v zfmg nbm xtit jdf lgz rpq qeh wcm vnn lna uli vya enr qll zsd xcj prz rfk ozo olf pmxv xrb mwr uip vwm xzm xby mln wgn rzp rxm uvg yjeg xgx jgsk -bj fbj ongw legtni zdr mco xzp pfz aaq tpp snu zxa d-rnm wmx tzy yfd dnu rtoc bvwm yqi gacr rvji rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore nodes cshow distributed queue scaling cshow ltb currentpoint gsave translate rotate ideal cshow grestore currentpoint gsave translate rotate cshow grestore stroke grestore end showpage enddocument endtexfig figure distrib uted queue scaling xperiment scalability scrutiny run oducers ead data bloc disk put distrib uted queue sour ces pull data ideal line shows aggr bandwidth disk exp erimental alidation section perform xperiments alidate xpected performance properties system xplore absolute performance adaptability distrib uted queue performance queue crucial system primary mechanism pro viding load balancing distrib uted queue fecti balancing load consumers ving data faster consumers perform xperiments graduated declustering performance enhancement mirrored collections baly ancing work consumers distrib uted queues solv problem achie ving consistent perfor mance single producer slo performance system drops proportionally case important system oid producer hot-spot precisely transparently pro vides simple distrib uted algorithm adapt run-time perturbations data sources distributed queue erfo rmance absolute erfo rmance xplore scaling beha vior distrib uted queue rst xperiment follo wing set-up data read disks put distrib uted queue consumed cpu sinks scale results scaling xperiment sho figure graph eals scaling properties ideal disk capable deli ering disks xpect peak read bandwidth ith data ving achie percent peak distrib uted queue found scaling problems cluster size design aggressi algorithm producer sends data subset consumers performance writing disks sho scales equally starttexfig begindocument figs dq-perturb-read eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg 
vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent peak cshow grestore add stuff static cshow cshow helvetica findfont scalefont setfont performance cliff reached cshow single perturbation cshow helvetica findfont scalefont setfont add stuff cpu nodes perturbed cshow cpu consumer perturbation cshow stroke grestore end showpage enddocument endtexfig figure read erturbation gur shows cent peak performance hie ved consumer pertur bations added system ithout balance load acr oss unperturbed consumers performance ops single consumer slowed ith performance unaf fected lar number nodes perturbed cpu perturbation steals ocessor test consists oducers separ ate consumers erfo rmance erturbation xamine results consumers arbitrarily slo wer rest type perturbation arise dynamic load imbalance hot spots system due presence cpus disks dif ferent performance capabilities figure sho fect slo wing cpu consumers reading disks ithout work pre-allocated consumers single consumer slo perfor mance bad consumers slo wed labeled static static allocation gure inserted producers disks consumers data unperturbed consumers wing hot spots system cpus fully utilized unperturbed case noy ticeable performance drop-of perturbation consumers perturbed pre vious xperiment form parallel read xperiment parallel write xperiment place cpu sources generate records disks system results write xperiment sho figure static allocation beha poorly uny der slight perturbation case performance writing disks grades immediately perturbation gradually falling fact performance slightly worse static application disks perturbation immediy ate gradation disk bandwidth fully utilized gin unlike cpus read xperiment abo single disk system perturbed total bandwidth ailable reduced dif ference data unperturbed disks static application adapt demonstrated distrib uted queue desired properties balanc ing load amon nsu mer mirroring oducer data unique eop page bop starttexfig begindocument figs write-final eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent peak cshow grestore add stuff currentpoint gsave translate rotate cshow grestore static cshow helvetica findfont scalefont setfont performance cliff reached cshow single perturbation cshow graceful degradation cshow helvetica findfont scalefont setfont add stuff disk nodes perturbed cshow disk consumer perturation cshow stroke grestore end showpage enddocument endtexfig figure write erturbation gur shows fect disk perturbation writes dynamically adapts system test consists disks falling performance clif outes data wher bandwidth acefully ades case eac perturber continually performs sequential lar ge-bloc writes local disk stealing oughly half bandwidth collection records complete deli data consumers producers bottleneck system case streaming lar data sets slo wing single producer lead lar global slo wdo program complete slo producer nished producer problem xact problem graduated declustering attempts solv graduated declustering describe xperimental alidation graduated declustering implementation absolute performance beha vior perturbations xpected initial implementation absolute erfo rmance performance graduated declustering reads disk perturbation slightly worse non-mirrored case direct result design fetches data mirrors selecting single order ready adapt performance characteristics change multiple xing streams single disk slight cost seek occur streams increasing disk request size amortizes cost seek achie percent peak nony mirrored bandwidth figure writes disks incur problem erfo rmance erturbation real strengths read-intensi worky loads decision support data mining cases applications reading non-adapti mirroring system slo rate slo disk system ith system shifts bandwidth allocation disk consumer data recei data rate starttexfig begindocument figs grad-decluster-scale eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate aggregate bandwidth cshow grestore currentpoint gsave translate rotate ideal cshow grestore currentpoint gsave translate rotate cshow grestore nodes cshow graduated declustering scaling cshow stroke grestore end showpage enddocument endtexfig figure graduated declustering scaling aphs shows performance scaling perfor mance loss due fact eads actively mirr ors gment seek cost incurr oughly peak performance deliver starttexfig begindocument figs eps gnudict dict gnudict begin color true solid 
true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke end endprolog beginsetup feature copy resolution dpi end texdict gnudict begin begin endsetup gsave page bop translate scale searching setgray helvetica sorting findfont record scalefont setfont experiences newpath uning lta -sort andr arpaci-dusseau remzi ltb rshow rshow rshow arpaci-dusseau vid culler oseph rshow hellerstein vid patterson rshow computer science vision uni ersity california rshow berkele dusseau remzi culler jmh pattrsn cshow berkele abstract cshow present xperienc cshow eloping tun ing cshow rfor mance -sort parallel disk-to-disk sorting cshow algorithm -sort cshow cshow cshow currentpoint gsave translate rotate percent holds peak cshow grestore zzz begin currentpoint gsave translate rotate cshow grestore static cshow zzz end disk nodes perturbed cshow graduated declustering perturbation cshow stroke grestore end showpage enddocument endtexfig figure read erturbation aphs shows performance ead perturbation erformance ades slowly case wher eas typical nony adaptive mirr system suf fers slowdown eac perturber competing ead-str disk results -machine xperiment sho figy ure scenario half machines serv disk nodes half serv ata ons umers xplained abo performance mirroring compared mirroring slightly worse unperturbed case single perturbation slo application non-gd system bandwidth slo disk case deli ers data roughly half peak rate due single competing stream ith performance grades slo wly spreading ailable bandwidth enly consumers disks equally perturbed performance dips belo non-gd system due erhead seeking multiple streams finally perturbing write stream collection mir ror xpected fect slo wing write speed slo wer disk sense represents fundamental cost mirroring applications write scratch data data lesser alue mirroring potential performance cost eop page bop applications describe initial application xperience bey gin xample unmodi sequential program infrastructure proceed parallel applications written parallel sort parallel hash-join section focuses application writers add rob ustness applications distrib uted queues sho performance mirror ing enabled mirroring transparent user race-driven simulation rst application xamine trace-dri simulator generation ersion system simulator comple sequential program simulates multiple system layout policies fer management includes complete disk simulator application fast data source simulator modi order access data system simulator loads data system simple copy-in script accesses copy-out script constructs record collection standard output piped standard input simulator case main bene fast switch-based network application disk simulator accessed data nfs serv ethernet shared network parallelism application distrib uted queues pro vide rob ust performance rallel external set xperiments olv complicated apy plication xternal sorting case program written virony ment sort good benchmark clustered systems performance lar gely determined disk memory interconnect bandwidth compare xternal sort uilt frame work ideal statically partitioned sort ideal parallel sort reads data disk full disk bandwidth takes time perform in-memory sort writes back disk full bandwidth erhead parallelism sake simplicity single-pass sort records read memory sorted written disk single pass entuy ally plan world xtend records work include two-pass sorting places databasey industry standard benchmarks critical tuning process setting xpectations programmer wher ere memory tune management demands stop system figure presents data found simple cate gories ersion xternal sort tools tools set xpectations similar con gure application sort dif ferent data hardware gins parameters visualization unsorted parallel collection number disks data read disk node disk read module passed partitioning module tools animate performance counters partitioning modules search perform tools y-range track partitioning performance data anomalies partitioning tools module reads iny teract top bits layers record underlying determine software sorter operating module 
system qyg dep dqz axx kau irgj bder epl vxv applications erage modern features threads memory-mapped intro duction march debate benchmark prototype cluster system decided implement ternal disk-to-disk parallel sort external sorting qualities desired benchmark xternal sorting memory intensi sorting stresses man aspects local distrib uted operating system performance well-understood fks sorting algorithms ist sequential parallel vironments finally vnc presence industry-standard benchmarks allo comy pare erd performance lar ge-scale systems time -processor sgi challenge held worldy records xisting benchmarks whgows datamation benchmark sgi sorted million -byte records -byte disk disk kur seconds minutesort -byte records sorted minute goal surpass hbq records cluster ultrasp arc workstations connected high-speed network year april april ool day man people berkele project laid claim benchmark records machines reduced time sort million records seconds importantly seconds sorted machines -sort datamation minutesort records stand qzl today -sort algorithms perfor mance measurements pre vious idgll paper relate dif culties scaling memoryf o-intensi apy plication machines hlv learned scalable systems disk owa performance ggh cache-sensiti aly gorithms operating system interfaces memory managey ment paper focus methodology tuning -sort tools found methodology achie ving scalable performance rey lied setting meeting optimistic performance xpectay tions gan forming set performance goals phase sort repeatedly characterized implemented progressi ely lar ger components sort measured implementation met cgd xpecy tations found ojvl discrepancies focused optiy mization forts prh slo phases sort xing performance ugs application pbtv underlying system fjxn ning pcw xpectations realistic ith xpectay tions phase algorithm kne wher start tuning process stop found performance tools distinct purposes setting xpectations visualizing measured perfor mance searching anomalies con gur ation tools helped xpectations resource measuring best-case performance achie output tools parameterize sort hardware hand allo wing sort achie peak wnty utilization ariety machine con gurations brp found simple visualization tools allo wed quickly identify performance problems animating machine perfor yti mance iwr counters notice nature problems arose emphasize imy portance record performance counters sorter module els recei system cpu input sorts data network gins switches streaming links disk write module easily implement simple tools proceeds rst write areas data disk implement stream hierarchical sear preserving order tool remo application proceeds run-time anomalies phases read tool partition sort helpful nal stages write forts achie starttexfig begindocument figs fig-sort peaky eps performance magnification undisturbed run psdict dict psdict -sort begin psdict ithout mtrx matrix put colsetgray tool bind forced col srgb track bind anomalies col srgb hand bind rst col isoy lating srgb bind problem workstation col srgb bind identifying col aspect srgb bind machine dif fered col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind paper col srgb bind ganized roughly col follo srgb bind chronology col srgb bind xperience col srgb bind gin section col srgb describing eop bind page bop col srgb bind col starttexfig srgb bind begindocument figs eps col srgb magnification bind psdict dict col psdict srgb begin bind psdict mtrx matrix col put srgb bind colsetgray bind col srgb bind col srgb col bind srgb bind col col srgb srgb bind bind col col srgb srgb bind bind end save col srgb bind translate scale col closepath srgb bind bind col eofill srgb bind bind grestore bind col srgb bind gsave bind save col bind srgb bind restore bind col lineto srgb bind bind moveto bind col srgb bind rmoveto bind newpath col bind srgb bind stroke bind show col bind srgb bind slc setlinecap bind col slj srgb setlinejoin bind bind slw setlinewidth col bind srgb bind srgb setrgbcolor bind col rot srgb rotate bind bind scale bind col srgb bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth col bind translate bind tnt dup dup currentrgbcolor roll dup srgb exch bind roll mul add roll col dup exch srgb bind roll mul add roll dup exch roll mul col add srgb srgb bind shd dup dup currentrgbcolor bind roll mul roll col mul srgb bind roll mul srgb bind col srgb bind drawellipse endangle exch col startangle srgb exch bind yrad exch col xrad srgb exch bind exch exch col srgb bind savematrix mtrx currentmatrix xrad col yrad srgb bind startangle endangle arc col closepath srgb savematrix bind setmatrix col psbegin srgb psdict bind begin psenteredstate col save srgb psend bind psenteredstate restore end col srgb psbegin bind setmiterlimit col srgb bind col srgb clip bind slw ellipse col srgb bind drawellipse end save cols ellipse translate scale closepath drawellipse bind cols eofill bind polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse grestore cols bind ellipse gsave bind drawellipse save bind cols polyline restore bind lineto bind cols moveto polyline bind rmoveto bind cols newpath ellipse bind stroke bind drawellipse show cols bind ellipse slc setlinecap bind slj drawellipse setlinejoin cols bind slw polyline setlinewidth bind srgb setrgbcolor cols bind polyline rot rotate bind cols ellipse scale bind setdash drawellipse bind cols findfont ellipse bind setfont bind drawellipse scf cols scalefont bind polyline stringwidth bind translate cols bind polyline tnt dup dup currentrgbcolor roll dup exch cols roll ellipse mul add roll dup drawellipse exch cols roll ellipse mul add roll dup drawellipse exch cols roll mul polyline add srgb bind shd cols dup dup polyline currentrgbcolor roll cols mul roll ellipse mul roll mul drawellipse srgb bind cols drawellipse ellipse endangle exch startangle drawellipse exch cols yrad exch polyline xrad exch exch cols exch polyline savematrix mtrx currentmatrix cols xrad ellipse yrad startangle endangle arc closepath drawellipse savematrix cols setmatrix ellipse psbegin psdict begin drawellipse psenteredstate cols save polyline psend cols psenteredstate polyline restore end psbegin cols setmiterlimit ellipse drawellipse cols times-roman clip scf slw polyline colsh ellipse col shd cols drawellipse cols polyline times-roman scf col shd colsh polyline cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline clippath col clip shd cols polyline cols arrowhead col shd cols setgray polyline cols polyline clippath col shd clip cols polyline cols arrowhead col shd cols slw polyline setgray cols polyline col shd clippath polyline clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols 
polyline clippath clip cols arrowhead setgray cols polyline clippath clip col shd cols ellipse arrowhead drawellipse col shd ellipse setgray drawellipse cols polyline col shd polyline arcto pop repeat arcto col pop shd ellipse repeat arcto pop drawellipse col repeat shd arcto pop ellipse repeat cols drawellipse polyline col shd ellipse clippath drawellipse col shd ellipse clip drawellipse cols col shd arrowhead polyline setgray col shd cols ellipse polyline clippath drawellipse col shd ellipse clip drawellipse col cols shd arrowhead slw polyline col setgray shd cols cols polyline polyline arcto pop col repeat shd arcto pop cols slw repeat polyline arcto pop repeat arcto pop repeat col shd cols polyline slw polyline arcto pop col repeat shd arcto pop cols slw repeat polyline arcto pop repeat arcto pop col repeat shd polyline cols polyline clippath col shd polyline clip cols arrowhead col shd slw polyline setgray cols col shd polyline cols clippath polyline clip col shd cols cols arrowhead slw polyline col setgray shd cols slw polyline ellipse clippath drawellipse col shd cols clip ellipse cols drawellipse arrowhead col shd cols ellipse drawellipse setgray col cols shd polyline cols clippath slw polyline clip col shd cols cols slw arrowhead ellipse drawellipse col shd setgray cols ellipse cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead drawellipse col shd setgray cols cols polyline ellipse clippath drawellipse col shd cols clip ellipse cols drawellipse arrowhead col shd cols slw polyline setgray clippath cols polyline clippath clip clip clip cols arrowhead cols arrowhead setgray cols polyline setgray clippath cols arrowhead clip setgray cols cols arrowhead polyline clippath setgray clip cols polyline cols clippath arrowhead clip cols setgray arrowhead cols polyline clippath setgray cols polyline clippath clip clip clip cols arrowhead cols arrowhead setgray cols polyline setgray clippath cols arrowhead clip setgray cols arrowhead cols slw polyline clippath clip clip cols arrowhead slw setgray cols setgray polyline cols arrowhead clippath clip setgray cols cols slw arrowhead polyline clippath setgray clip cols polyline clippath clip clip cols arrowhead cols slw arrowhead setgray setgray cols arrowhead cols polyline clippath setgray clip cols slw polyline clippath cols arrowhead clip setgray clip cols polyline cols arcto pop arrowhead slw repeat arcto pop repeat arcto pop setgray cols repeat arrowhead arcto pop repeat cols polyline setgray arcto pop cols polyline repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline clippath clip cols arrowhead setgray cols polyline clippath clippath clip clip cols arrowhead clip col shd setgray cols cols polyline arrowhead clippath setgray clip cols arrowhead cols arrowhead setgray cols polyline setgray cols polyline clippath col shd cols slw clip polyline cols arrowhead col shd cols ellipse setgray drawellipse cols col shd polyline cols slw clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray polyline cols polyline col arcto shd pop cols repeat arcto slw pop polyline repeat arcto pop col repeat shd arcto pop repeat cols cols polyline slw polyline arcto pop col shd repeat arcto pop cols slw repeat polyline arcto pop repeat arcto pop repeat col shd cols cols polyline polyline clippath col clip shd cols polyline cols arrowhead clippath clip setgray cols polyline col shd clippath cols arrowhead clip cols setgray arrowhead cols polyline clippath setgray cols clip polyline col shd arcto pop cols repeat arrowhead arcto pop repeat arcto pop setgray repeat arcto cols pop polyline repeat clippath cols polyline arcto pop clip repeat arcto pop repeat clip arcto pop repeat col shd arcto pop repeat cols cols arrowhead polyline arcto pop repeat setgray arcto pop cols arrowhead repeat arcto pop repeat arcto pop setgray repeat cols cols polyline polyline arcto pop col shd repeat cols arcto polyline col shd cols slw polyline clippath pop clip repeat arcto pop repeat arcto clip pop repeat cols col polyline shd cols arcto arrowhead pop repeat arcto pop repeat setgray arcto pop cols arrowhead repeat arcto pop repeat cols polyline setgray cols polyline arcto pop clippath repeat arcto pop clip repeat arcto pop repeat arcto clip pop repeat cols col shd polyline cols arrowhead arcto pop repeat arcto pop repeat arcto pop setgray repeat arcto cols pop arrowhead repeat cols polyline setgray arcto pop cols repeat arcto pop repeat arcto pop repeat arcto pop repeat cols times-roman scf colsh times-roman scf colsh times-roman slw scf polyline colsh times-roman cols scf slw polyline colsh times-roman scf col colsh times-roman shd scf cols colsh times-roman times-roman scf colsh times-roman scf scf colsh times-roman scf simple single-pass external sort colsh times-roman scf upa data bus colsh times-roman scf colsh times-roman scf colsh times-roman dup scf colsh times-roman pop div scf colsh times-roman neg scf colsh times-roman scf colsh times-roman sysio scf dup pop div colsh times-roman neg scf colsh times-roman scf colsh times-roman asic dup scf pop div neg colsh colsh times-roman times-roman scf scf dup colsh pop div times-roman neg scf colsh times-roman scf colsh times-roman asic scf dup pop div neg colsh colsh times-roman times-roman scf scf rot colsh address bus times-roman dup pop scf div neg colsh colsh times-roman times-roman scf scf upa processor data colsh times-roman bus scf dup pop div neg colsh colsh times-roman psend scf enddocument endtexfig bmx figure dup pop div 
parallel neg colsh times-roman scf chips dup pop div neg colsh times-roman scf cache dup pop div neg colsh times-roman scf processor dup pop div neg colsh times-roman yqcr fsm xnq kazva wyy yby vnv jsn fjotnpe lpo zvw vzc nyp cmr exter nal sort river xlc gur kwz depicts logical data single-pass xternal sort data oceeds lhc disk g-m set static partitioners lkv whic split data based ange eac ecor acr oss set sort modules data ead sort modules sort odv entir ely par allel hand data write modules whic send disk der str eam markers nsj cir cled points wher jhe alter add ustness discussed discuss scaling ais beha vior sort figure jzi sho gti result scaling sfg sort machines rom graph compares sort idealized staticallyy partitioned parallel sort performance sort dktb frame work gins peak cienc drops slightly nodes majority itri inefy cienc attrib uted poorly ion tuned in-memory sort contrib utes total elapsed time un-tuned in-memory sort tgi learn lgg qqy graph relati ely easy uild high-performance non-tri vial appliy cation mel lose cienc inside frame otv work jfs application rkc write single line sksy gcv code manage qualitati ely application writer write zuq partitioning module sort jxd module scaling parallel sort matter constructing proper stands simple parallel sort rob ust performance perturbations ith graduated declusy tering sort jgi tolerate read perturbation focus luwt read partition -jr write phase sort potential performance rob ustness xamine perturb partition modules lef achie reasonable performance jko add pwl rob ustness partition phase insert distrib uted queue disk read modules partitioners zlj lay beled circled figure sort par rvt titioning data order imposed stage sort inserting distrib uted queue performance characteristics sort correctness figure sho result perturbing partitioner modules qvq fgg xperiment disk modules sort mody ules set machines partitioners wrt set machines total perturbations applied partitioners partition modules slack system erloaded grading slo wly partition nodes turbed location modi sbc oid eop page bop starttexfig begindocument figs sort-scale eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor xak bpiz klu stroke setdash currentlinewidth div bgk currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt hmbu currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt pfdbkh exch vpt add vpt neg hpt vpt hpt tym neg closepath stroke stroke setdash exch hpt exch vpt add vni hpt vpt neg currentpoint stroke hpt neg hpt vpt vdl stroke stroke setdash copy vpt mul add vdn hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow aep cshow ady cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent peak cshow grestore add nodes cshow add ideal static sort cshow river sort cshow add sort scalability cshow stroke grestore end showpage enddocument endtexfig figure parallel exter nal sort scaling gur shows scaling behavior sort uilt river ame work compar idealized statically-partitioned sort river sort scales ciency -tuned in-memory sort run-time perturbations sort modules disk write modules labeled figure desire tolerate disks 
slo wing write phase simply records arbitrarily dif ferent disks preserv set sorted partitions generated sort module balancing load disks record-le balance load higher vel anularity dynamically deciding place sorted partition order balance load consumers data producers data items produced original form sort allocates single sort module producer consumer remedy allo wbp load balancing disks zofn allocate utf sort modules dqyj small nib constant note produces slightly jcwc modi output sorted bpq artitions performance load balancing sorted-runs disk perturbation sho figure xpected writy ing runs mfg performance grades gracefully static allocation full perturbation performance wer xkl xpected case yzt erhead current implementation results rew peak performance roughly wer xpected rallel hash jng join hash-join important database operation xtensi ely ctx decision-support benchmarks tpc-d hash-join takes collections gsph records input outputs pairs equal alues jaj join one-pass two-pass ariants xist pass algorithm suitable smaller collection aggre gate cluster memory simplicity discuss one-pa join figure sho gfu data kggsj rst phase smaller collection jca ogh swt lhoz uilding collection hash table uilt read disk partitioned hash function nodes internally hashed inside join module labeled diagram prepare join phase gdk phase probing collection read disk ugr partitioned nodes function records pass join module matching records tawn uilding nxv collection found output proceeds immediately starttexfig begindocument figs sort-perturb eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind hwa rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show olmx color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb -sq lta setdash setrgbcolor r-z lln fab stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt anu vpt currentpoint stroke hpt hyh neg vpt neg hpt stroke stroke setdash copy exch obi hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt yana neg hpt arg vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy kki qmo orj sjj afa lsnue tom mgw vuk zdr baq yuk -rmq jsg jvw pcv dkx eui pcz sqo ker gldw cej hfz cha wbqg pqc vde-hz pgr end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta jdy ltb rshow til rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent peak cshow grestore add ideal static sort cshow river sort cshow add nodes perturbed cshow sort partition perturbation cshow stroke grestore end showpage enddocument endtexfig figure erturbing sort partitioner gur shows sort partition modules perturbed disk sort modules run set mac hines partition modules run set river sort compar perfect sort statically partitioned eac perturbation steals cent cpu starttexfig begindocument figs sort-write-perturb eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor jbl stroke setdash zuln currentlinewidth div pkg currentlinewidth stroke stroke setdash copy vpt add egx hpt min neg vpt neg jky hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt fou neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg -cqas closepath stroke stroke setdash exch hpt gkr exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb zde rshow ajvg rshow rshow rshow dgv rshow pvd rshow cshow cshow cshow cshow cshow tby cshow cshow cshow zzz begin currentpoint gsave translate rotate cshow grestore static xrd cshow zzz ftk end currentpoint gsave translate rotate percent peak cshow grestore disks perturbed cshow sort write perturbation cshow rcq lmmi stroke grestore end showpage enddocument endtexfig figure erturbing sort writer gur shows performance iters rtur bed ring write sort runs set mac hines writing disks separ ate set mac hines case eac perturbation competing write-str eam disk disk phase reading collection writing output operate concurrently addition distrib uted queues nad hash join similar qtv sort queue data sources partitioners allo wing njg faster partitioners partition data join hov performed output relation rug hash form inserted easily balancing load disks application wishes output records hashed partitions situation similar balancing sorted runs xternal sort employed interestingly hash-join kdo oid performance yav perturbations pud join modules replication uilding collection replicated eqz nodes yvt record partitioned probing phase dynamy ically choose vtnu sites functionality limitations current infrastructure performance numbers hash-join scale initial results ehg machines promising eop page bop starttexfig ngw begindocument figs fig-hash eps magnification psdict dict psdict begin -lr psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind wmb col srgb bind col srgb bind ofdv col srgb bind col srgb bind kvt col srgb bind col srgb bind col srgb bind col srgb bind hun col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb vegd bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb yac bind fwo col srgb bind yqy col srgb bind col srgb bind fbs col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap mgo bind slj setlinejoin vsd bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll 
mul srgb bind drawellipse endangle exch startangle noo exch yrad exch lwh xrad exch exch exch cam savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit clip slw ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline ihr cols ellipse drawellipse cols ellipse drawellipse cols polyline cols ami polyline cols ellipse drawellipse daln cols ellipse drawellipse cols polyline cols polyline cols ellipse mkr drawellipse gtn cols ellipse rgo drawellipse cols polyline cols polyline pzd cols ellipse met drawellipse zgu cols ellipse drawellipse cols polyline cols polyline ddf cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols times-roman scf colsh ellipse drawellipse cols times-roman scf colsh polyline dcz arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols ycd polyline clippath wralr clip cols jrg arrowhead setgray cols polyline jwr clippath kopsg clip cols arrowhead setgray cols polyline clippath wfgs vvtf clip yss cols arrowhead setgray cols polyline clippath clip cols arrowhead jpu lgf setgray cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat cst arcto pop repeat arcto pop repeat arcto pop repeat a-yjb cols polyline arcto pop repeat arcto pop repeat arcto omal pop repeat arcto pop repeat cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip plq hwf cols arrowhead setgray cols polyline clippath clip cols wbv arrowhead setgray cols polyline clippath xdg clip cols arrowhead fgo setgray cols polyline clippath clip cols arrowhead ypx setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols lmyu polyline clippath vre clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath mgg clip cols arrowhead setgray cols polyline clippath naum clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols eqsk polyline clippath clip cols arrowhead setgray cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat pla cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols dtnvvju arrowhead lvf setgray cols polyline clippath clip cols arrowhead uzy nza setgray cols polyline clippath clip cols arrowhead egj setgray jmo cols polyline clippath clip cols arrowhead setgray afh cols polyline arcto pop repeat arcto pop repeat arcto pop yui repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat zgwl hta arcto pop repeat arcto pop repeat cols polyline clippath kkc clip cmz cols arrowhead setgray avc cols polyline clippath clip cols arrowhead setgray cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat ala cols polyline wjq arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline ziw arcto pop repeat gdj arcto pop repeat arcto pop repeat bdgz arcto pop repeat jod cols polyline arcto pop qxk repeat arcto pop repeat arcto pop repeat arcto pop repeat dry cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto nbz pop repeat arcto pop repeat cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat cols polyline clippath clip cols arrowhead dpxl uwu setgray cols polyline clippath qge clip cols arrowhead ixw setgray cols fvo polyline clippath clip cols arrowhead setgray cols polyline clippath clip aij cols arrowhead rdf setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath gis clip cols arrowhead setgray cols polyline clippath clip cols arrowhead otn sgpz setgray cols zvzp polyline clippath clip cols ctu arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip ngd cols arrowhead ajy setgray jqarw cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath xof clip cols arrowhead qgo hli setgray cols polyline kgh clippath fyz zyh ziv clip cols dja arrowhead setgray cols polyline clippath clip xud chc cols arrowhead wkd setgray cols polyline clippath kxf clip cols arrowhead sgs cll eeq dow setgray cols fmon polyline kff clippath clip cols mpr arrowhead jnus rtn xccpn ojg oqm setgray jgsi cols polyline clippath clip cols arrowhead setgray cols mqzy polyline clippath clip cols arrowhead hdj setgray cols polyline hqm clippath clip cols arrowhead rxy setgray fls cols polyline clippath clip cols uxs arrowhead setgray cols polyline clippath clip u-f cols n-n arrowhead gtf setgray cols polyline clippath clip yyd cols arrowhead setgray cols polyline clippath clip tfh cols arrowhead setgray kwa cols polyline clippath jcly vxb clip msh cols ity iew arrowhead setgray cols polyline clippath clip mmy cols arrowhead setgray cols jde polyline clippath clip cols arrowhead edmo qbw setgray cols polyline clippath clip sds cols arrowhead setgray cols times-roman scf omd colsh times-roman scf rmk colsh times-roman scf colsh times-roman scf rpd colsh ozy times-roman scf colsh times-roman scf colsh times-roman scf kbyw colsh times-roman qvr scf colsh times-roman ktg scf colsh times-roman scf pnr colsh times-roman siy scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf colsh times-roman scf lze colsh times-roman scf colsh times-roman scf colsh times-roman scf gsgm colsh times-roman scf simple one-pass hash colsh times-roman kml scf xhoc colsh times-roman scf colsh xam times-roman scf colsh times-roman scf colsh psend enddocument endtexfig figure parallel exter nal hash znm river gur depicts logical data single-pass hash-join kzw solid lines haj path rst elation disks hash-partition ejczq modules lsv jpe zic hashy join modules dashed lines path elation similar path rst elation elation passes thr ough hash-join modules join performed output elation gener ated related jbx relates work number distinct areas systems adr 
programming vironments database rpx research section discuss work areas jxs rallel file systems high-performance parallel systems undant literature ppfs spj galle esta swift cfs sfs sio speci cation assume koe performance-homogeneous vices perfor mance dictated slo west component system oid speci programming model applicay tions constructed bjo single-program noza usz multiple-data spmd -like fashion parallel system uld deli consistent high-performance jvr wasted inside rigidly-designed program adv anced parallel systems dtd speci higher interfaces data collecti similar concept nwk xpressed two-phase original pay otz found man scienti codes sho tremendous impro ement aggre gating requests shipping underlying ofc qrjy system ytb w-h nodes schedule requests noticeably increase deli ered bandwidth requests made rey turned speci consumers load balanced consumers dynamically types systems pro vide xibility interface solv problems belie common today clustered systems finally recent le-system work xtolling 
virtue adapti systems hardware systems increase comple xity gued intelligent software systems xtract performance underlying machine architecture systems employ f-line reor ganization impro global formance goal balance load on-line run-time long-term adaptation system programming environments number popular parallel programming viy ronments support spmd programming style includy ing messaging passing vironments mpi pvm xplicit parallel languages splity packages pro vide simple model par allelism user allo wing ready construction parallel applications pro vide facility oid run-time perturbations adapt hardware vices dif fering rates xperience writing parallel ternal sort split-c led realize problems spmd approach run sort -sort broke world record databasey industry standard sorting benchmarks dif cult attain high-le performance consistently man parallel programming vironments aligned design philosophy run-time adapti vity xamples include cilk lazy threads multipol systems balance load consumers order allo highly-irre gular ne-grained parallel applications main dif ference systems abo granularity communica tion limits workloads data pushed interconnect lar ge-sized blocks systems run-times general-purpose parallel programming focus ney grained irre gular applications today clusters latenc remote memory higher laten loca memory orders magnitude microseconds ersus nanosecond forces locality dominant issue man systems remote bandwidth worse local bandwidth dif cult hide remote memory latenc data pushed system cost systems attempt deal problem slo producers important vironment similar vironment linda pro vides shared globally-addressable tuple-space parallel programs applications perform atomic actions tuple-space inserting tuples querying space records attrib utes generality model high performance distrib uted viy ronments dif cult achie distrib uted aspects uilt top linda suf fer performance scaling problems databases rele ant lar body work parallel databases data techniques well-kno database literature stems naturally relational model xample system takes adv antage unordered processing records ibm smps system shared data pools accessed multiple threads faster threads acquiring work referred stra model thread slurps data stra potentially dif ferent rate implementing sysy tem natural smp simple lock-protected queue suf modulo performance concerns ith gue type data distrib ution performed cluster due bandwidth interconnect number parallel databases found liter ature including gamma olcano bubba eop page bop systems similar techniques distrib ute data processes gamma split table olcano hange oper ators generalized split table kno data producers consumers distrib uted memory machine static data partitioning techniques hash partitioning range partitioning round robin functions adapt run-time load ariations consumers current commercial systems ncr eradata machine xclusi ely hashing partition work achie loxm parallelism good hash function fect viding work equally processors pro viding consistent formance bjm achie ving good scaling properties gxdx jim gray recently eradata system perfor nyn mance bad fnq worse consistenc vdv scalability goals xzk system cost akc nvg oks ejy underlying aog hardware uture future man research areas xplore hli rst enhancements system infrastructure serv system realm system xpert programmers easily ocess data placement process wfr placement data placement important gxt decisions uog jap kzo -ij gez ivag yjnq pfg determined user ideal system decisions automated higher -le entity compiler query planner ocess data migration lwl data system fecti ely initial xpey rience sft suggests rny feasibility code migration impro dynamic performance xwf properties system long-term data migration short-term locally optimal placement dey cisions qcm re-e aluated result data ement optimize current usage kzd pplication ault olerance ultimate goal write applications interface kgz aat rob ust performance continue xxe eration machine failure similar work vwo dynamic programming mtq vironments ltmf form autoy matic check-pointing solution suggested belie well-suited lar class ternal distrib fsm uted applications including traditional scienti codes multimedia programs viy dence xists literature olcano scienti data-intensi applications programmed opy timized olcano datao kwr vironment plan xploring add rob hfh ust performance features types applications mjr finally eloping simple models arious performance faults fect system ith welly eloped analytical models easily compare performance system ersus theoretical ideal perturbation scenario conclusions hardware software systems spiral size comple ity systems designed controlled vironments xperience performance defects real-world settings long realized area fso wide-area networky ing end-to-end wrn gument perv ades design methodology protocol stacks tcp sysy tems clear globally-controlled well-beha viy ronment kbfv attainable applications wfe system treat jcx blac box adjusting beha vior dynamically based feedback system achie bar performance current circumstances comple xity slo wly gro yond point bhe ageability smaller distrib uted systems comprised lar gely autonomous complicated indi vidual components clusters hoo xhibit man properties mos ojy neqi gjx obg ccg smxe hct nbw tln swj hlw -tx rjx fcy nkz wjm igtf dklm hdt nvv gfl zim dyt ssw mbg pic aqy kmw pgd fdpp zte fbey vvs lngv limv cfg wwf vhuj oaj lqi rov tiei gclj lrd prw aafs ypb ilgl mjms ymx wyz olt nsc wok byz wik mht -csn cax zbu ein wcq tbm avsh cfm ymr ehg qrf tsg qwv osx szv jnq hwn pyad ylthb ddqk upv uju dax nrn lkhs pjj hry rqs ney btp zht problems lar ger scale wide-area systems proby lem xacerbated clusters wards serving general-purpose knqq computational infrastructure jot lar gay nizations resources pooled shared abl computing machine hundreds thousands jobs yxl users present system -lzh dif cult impossible belie system beha orderly fashion address increase comple xity correspondy ing decrease predictability introduce substrate uilding o-intensi cluster applications cony uence programming vironment system xtending notion ifk adapti vity esgu xibility est els system application programs reliably deli high performance system dbb syj flg mqo mvl ies huvfl mjl bvx uyb rey sources -committed performance applications writy ten style grade gracefully oiding sudden frustrating prolongations xpected run time initial study tgs applications found oidy ing perturbations nsu mers relati ely qbf straight-forward distrib uted queues important issue balancing load anularity ordering required applications rdw ne-grained applications lmx balance load sqt wge indi vidual records simplest construct performance-rob ust manner distrib uted queues pro xcellent load balancers vnqtp require programmer insert oiding perturbations producers proby lem solv graduated declustering dynamiy cally shifting load perturbed producers system deli ers proper proportion ailable bandwidth client application high-performance clusters consistent performance easy bad peak formance matter persistence good run eryy thing goal vus vironment source code ailable request ackno wledgements foremost jim dif gray bmq advice encouragement alan mainwaring work support acti messages qxv sine ipy qua work anonymous vie wers pbqx djn lpk qzuga uyn helpful comments finally gsb lgi andrea arpaci-dusseau amin ahdat ijl i-store group berkeley suggestions improved presentation content paper eop page bop work funded part arp -cy arp evt -co nsf xpb asa fdn california state micr program hmt supercomputers plug play economist ebs bgi november nhb arpaci-dusseau loj arpaci-dusseau culler rkx hellerstein jxl patterson high-performance sorting networks orkstations sigmod arpaci-dusseau arpaci-dusseau culler hellerstein trm patterson 
searching sorting record experiences uning -sort spdt aug bal kaashoek anenbaum orca lany guage parallel programming distrib uted systems ieee ransactions softwar engineering mar barclay barnes gray sundaresan loading databases data parallelism sigmod recor special inter est oup manageme data december bershad black dew itt gibson peterson snir operating system support high-performance parallel systems echnical report ccsfj scalable initiati caltech concurrent supercomputing facilities caly tech blumofe joer kuszmaul leiserson randall zhou cilk cient multithreaded runtime system oceedings symposium priny ciples practice arallel ogramming july blumofe lisiecki adapti reliable par allel 
computing networks orkstations usenix editor annual echnical confer ence anuary anaheim pages berkeley usa jan usenix boden cohen felderman kulawik seitz myrinet gigabit-per -second local area network ieee miy february cabrera long swift distrib uted disk striping provide high data rates computing systems fall carriero implementation tuple space phd thesis dey partment computer science ale uni versity december chakrabarti deprit jones krishnamurthy elick multipol distrib uted data structure library echnical report csd- uni versity california berkeley july choudhary bordawekar harry krishnaiyer pony nusamy singh thakur assion parallel scalable software input-output echnical report sccsj ece dept case center syracuse uni versity september codd relational model data lar shared data banks communications june published readings database systems ediy tion stonebraker hellerstein mor gan-kaufmann copeland alexander boughter eller data placement bubba sigmod recor special inter est oup management data sept corbett feitelson esta parallel sysy tem ransactions computer systems august council tpc-d indi vidual results http tpc results tpc results page html culler dusseau goldstein krishnamurthy lumetta eicken elick parallel programming split-c oceedings super computing pages dew itt gray parallel database systems future high-performance database systems communications june dew itt ghandeharizade schneider formance analysis gamma database machine sigmod recor special inter est oup managemen data sept geist sunderam olution pvm concurrent computing system compcon february gelernter carriero chandran chang parallel programming linda degroot editor international confer ence arallel ocessing pages goldstein schauser culler lazy threads implementing fast parallel call ournal arallel disy trib uted computing aug graefe encapsulation parallelism olcano query processing system sigmod recor special inter est oup managemen data june gray processors nitely fast storage free vited alk iop ads november hsiao dew itt chained declustering ailability strategy multiprocessor database machines oceedings international data engineering confer ence pages huber elford reed chien blumenthal ppfs high performance portable parallel system oceedings international confer ence super computing pages barcelona july press kitsuregawa anaka moto-oka gra relay tional algebra machine based hash sort design cony cepts ournal information ocessing society apan kleiman oll eykholt shi alingiah illiams smith barton skinner symmetric multiprocessing solaris oceedings compcon spring otz disk-directed mimd multiprocessors oceedings symposium operating systems dey sign implementation pages usenix association november updated dartmouth pcs-tr november kubica robey moorman data parallel programy ming khoros data services library lectur notes computer science lindsey smp intra-query parallelism udb database seminar berkeley february lov erso isman nanopoulos nesheim milne wheeler sfs parallel system cmt oceedings summer usenix echnical confer ence pages mainwaring culler acti message applications programming interface communication subsystem ganiy zation echnical report csd- uni versity california berkeley october matthe roselli costello ang anderson improving performance log-structured systems adapti methods oceedings symposium operating systems principles sospp olume operating systems review pages saint-malo france october sigops press eop page bop meter observing fects multi-zone disks oceedings usenix confer ence jan nieuwejaar otz galley parallel system oceedings international confer ence super computing pages philadelphia press nitzber performance ipsc concurrent file sysy tem echnical report rnd- systems vision asa ames december pakin lauria chien high performance messagy ing orkstations illinois fast messages myrinet oceedings ieee super computing confer ence december san die con vention center san die usa press ieee computer society press papadopolous untitled alk inter retreat july ritchie stream input-output system part october saltzer reed clark end-to-end guments system design ransactions computer systems pages november scales lam ransparent fault olerance parallel applications networks orkstaions oceedings usenix confer ence jan seltzer small self-monitoring self-adapting systems oceedings orkshop hot opics operating systems chatham shapiro join processing database systems lar main memories ransactions database systems sept stonebraker chen nathan paxson ioga providing data management support scienti visualy ization applications international confer ence ery lar data bases vldb pages san francisco usa aug mor gan kaufmann publishers mpi forum mpi message passing interface oceedy ings super computing pages november eicken basu buch ogels u-net user -le vel network interface parallel distrib uted comy puting oceedings symposium ope rating systems principles pages december eicken culler goldstein schauser acti messages mechanism integrated communication computation oceedings annual internay tional symposium computer chitectur pages gold coast australia sigarch ieee computer society tcca computer chitectur news inter auerbach big ime inter vldb survey database ogramming design olnie wicz graefe algebraic optimization comy putations scienti databases vldb pages eop trailer end userdict end-hook end-hook eof 
inproceedings arpaci-dusseauetal -spdt title searching sorting record experiences tuning now-sort author andrea arpaci-dusseau remzi arpaci-dusseau david culler joseph hellerstein dave patterson booktitle symposium parallel distributed tools spdt month august year address welches oregon 
abstract architectural costs streaming comparison workstations clusters smps appeared hpca remzi arpaci-dusseau andrea arpaci-dusseau david culler joseph hellerstein david patterson investigate resource usage performing streaming contrasting architectures single workstation cluster smp benchmarks derive analytical empirically-based models resource usage data transfer examining bus memory bus network processor system investigating resource detail assess comprises well-balanced system workloads find architectures study balanced streaming applications platforms main limitation attaining peak performance cpu due lack data locality increasing processor performance improved block operation performance great aid workloads future cluster workstation bus major system bottleneck increased load network communication well-balanced cluster workstation copious bus bandwidth multiple busses smp suffers poor memory-system performance true parallelism benchmark contention shared-memory system leads reduced performance result clustered workstations provide higher absolute performance streaming workloads postscript compressed postscript 
scf ultrasparc dup pop div neg colsh times-roman scf memory simms dup pop div neg colsh times-roman scf interface dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf seagate hawk dup pop div neg colsh times-roman scf rpm dup pop div neg colsh times-roman scf rot scsi bus dup pop div neg colsh times-roman scf rot fast-wide dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf network dup pop div neg colsh times-roman scf myrinet dup pop div neg colsh times-roman scf -bit mhz s-bus dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf rot scsi bus dup pop div neg colsh times-roman scf ultra workstation dup pop div neg colsh times-roman scf rot fast-narrow dup pop div neg colsh times-roman scf seagate barracuda dup pop div neg colsh times-roman scf rpm dup pop div neg colsh psend enddocument endtexfig figure ultra orkstation gur depicts internal hitectur ultr workstation bmx ossbar connection memory sysio main contr oller cluster hardware software section discuss elopment tuning single-node ersion aly gorithm forms core parallel implementation section elops model basic algorithm par allel ersion -sort dif culties scaling full-sized system detailed section section rey late xperience isolating performance problems lar systems call nding needle -stack finally conclude ections xperience cluster rdw berkele cluster consists commodity ultra workstations ultra workstation single ultrasp arc processor on-chip instruction data caches uni second-le cache base memory hierarchy dram diagram internal architecture ultra workstation sho figure system ultra centers s-bus peak theoretical bandwidth workstation houses internal rpm seagate disks single fast-narro scsi peak xperiment disk bandwidth node added additional rpm seagate barracudas disk xtra fast-wide scsi card peak cony gurations cluster generally vie wed homogeneous collection workstations xtra disks run faster rates pro viding challenge conscious programmer addition usual connection world ethernet ery workstation single myrinet network card attached s-bus myrinet switchy based high-speed local-area network links capable bi-directional transfer rates myrinet switch ports -node cluster comprised -node clusters switches connected -ary tree-like structure sho figure -bit s-b higher peak rate vices bits peak starttexfig begindocument figs ultracluster eps magnification psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit clip slw polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols slw interp spline curveto curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols slw polyline col shd cols information-based approach distributed systems design andrea arpaci-dusseau remzi arpaci-dusseau department computer sciences wisconsin madison abstract propose information-based methodology developing distributed systems core approach understand sources gathering information paper develop information taxonomy explore costs benefits source case study river environment clusters investigation performed targeted simulations implementation measurements focuses distributed algorithms foundation dynamic adaptation river information-centric approach design efficient scalable data-transfer mechanisms turn yield robust application performance introduction key making intelligent decisions parallel distributed system timely access accurate information component information state behavior rest system adapt behavior current conditions placing jobs distributed system scheduler load processor pick load tcp client congestion links network calculate sending window-size cache controller marks entry exclusively owned caches entry methods gather information affect performance reliability properties system clear importance system designers employ hoc approach lead pick non-optimal extremes assume information utilize static algorithms employ explicit queries remote nodes information incurring unnecessary overhead complexity understanding full range methods system architects select algorithms system paper develop generalized information-centric methodology designing distributed systems introduce information taxonomy catalog characterize methods information dispersal information taxonomy ways information gathered null implicit parasitic explicit base case null method information exchanged communication components components information state system rely algorithmic knowledge components behave implicit information components observe contents properties existing communication infer traits remote components parasitic information inserts small amount information existing communication structures propagating additional information natural data flows service finally explicit information components introduce additional communication system query remote entities state behavior investigate approach taxonomy perform in-depth exploration trade-offs sources information distributed system river environment clusters main goal river enable data-intensive applications adapt performance faults components cluster perform spite unexpected variations performance disks workstations components system central run-time adaptation river distributed algorithms applications layer reactive middleware algorithms distributed queue applications utilize distributed queue move data processed ameliorate effects consumers performance faults parallel replicated data transfer graduated declustering graduated declustering applications harness replicated data sources intelligently equally sharing producer bandwidth consumers tolerate performance faults data producers tandem constructs utilized fashion robust applications explore methods information dispersal distributed queue graduated declustering algorithms combination simulation implementation modifying algorithms techniques information dispersal judge relative merits identify important decisions made algorithm determine information needed points foster actions case study determine null methods algorithms adapt performance faults information required avoid components performing expected find implicit parasitic information river sources components adapt current conditions scalable efficient manner finally show requests explicit information carefully added increase complexity decrease robustness system generally find information-based approach facilitates deeper understanding design decisions make distributed algorithm employing methods taxonomy construct robust scalable data-transfer mechanisms turn enable assembly robust data-intensive applications rest paper organized introduce information-based methodology taxonomy gathering information section section motivates river interesting case study describes evaluation environment sections study application information distributed queue graduated declustering examine application performance section conclude section information-based methodology section discuss components obtain information remote components distributed system illustrate obtaining information fits behavior distributed-system service begin describing generic framework designing service introduce taxonomy sources remote information illustrate usage real systems literature design distributed services main challenges designing distributed service algorithm architect flows communication information-centric approach suggest breaking process steps key ingredient separation data transfer flow information design data transfer step building service application distributed system architect flow data messages components define data communication absolutely essential implement service protocol underlying layers data communicated specific service communication reading block data remote machine include request block response includes requested block step produces data architecture system identify control points step designer constructs control architecture identifying control points system control point component makes decision potentially affects behavior components component decide machine send piece data design information flow finally information architecture assembled component make decision control point information state rest system inextricable link information algorithm obtained low-cost stale information preferred up-to-date costly information methods obtaining information focus paper information-gathering taxonomy make informed decision control point component information state behavior components classify fundamental methods obtaining information primary categories null implicit parasitic explicit depicted table describe approaches beginning require amount communication null simplest approach guiding decisions null approach leverage communication gather information cases approach approprimethod gathering definition advantages disadvantages information null communication simple build non-adaptive leveraged simple reason lead poor decisions implicit observed free difficult reason existing communication elegant proper info parasitic embedded additional information information flow restricted existing communication low cost data flow explicit adds information cost additional communication communication interface gathered interface table taxonomy information-gathering methods taxonomy information dispersal gathering techniques presented perceived cost gathering information increases method listed table cost measured terms additional communication ate components information control points information obtained algorithmic knowledge discuss cases turn algorithm requires information guide control points information gathered algorithms static adapt current conditions traditional disk striping raid algorithms make static decisions place disk blocks current load system fact information gathered imply component knowledge remote behavior components algorithmic knowledge remote components act component components implemented algorithm follow defined specification theoretical work investigated problem making decisions general knowledge components behave high level game theory predicts actions adversaries absence communication decision theory optimizes utility decisions based uncertain information quantified probability measure specific lard load-balancing web server presented front-end leverages algorithmic knowledge back-end servers cache web pages direct requests page server efficiently aggregate memory primary advantage null method communication overhead gathering information disadvantage components accurate information state rest system make poor decisions implicit lowest-overhead method obtaining accurate information current state changing system observe existing communication implicit methods fall categories monitor contents messages observe information defined interfaces implicit methods powerful combined algorithmic knowledge allowing component infer current state parts system subsequent actions contents messages guide decisions systems including cache coherence algorithms shared-memory multiprocessors contention-avoidance ethernet networks caches shared bus snoop traffic main memory cache controller detects write data block infers controller owns block responds invalidating copy implicit methods additionally observe information interface observing contents data message time messages form implicit information identical covert channel field security distributed systems leveraged type implicit information include tcp congestion-control algorithm observes packet loss infer congestion coordinated scheduling parallel jobs infers remote scheduling state message arrivals round-trip time central advantage implicit methods provide information free communication requisite data messages 
required ability deduce remote behavior local observation disadvantages methods inferences made subtle lead system difficult reason construct information flow restricted exact path data flow system paths ideal information flow system parasitic parasitic category leverages existing data messages disseminate additional information system parasite host means original intention approach referred piggybacking systems parasitic method reduce number messages protocol requires inserting acknowledgement data message reverse direction paper focus application information dispersal sun nfs version reduce frequency getattr requests attribute information returned results file operations getattrrequest generated attribute information seconds number explicit getattrrequests reduced advantage parasitic methods low cost adding bytes existing messages similar implicit methods information flows restricted data communication channels limitation explicit finally direct manner obtain information explicit query remote entities explicit approaches common randomized load-balancing scheme sends explicit probes randomly chosen nodes determine load places job lesser loaded main benefit explicit methods simple understand require inferences knowledge behavior components correct number disadvantages interface obtaining desired information accessing explicit interface costly sending explicit request consumes shared network resources needed data transfers induces additional work remote node finally explicitly contacting remote node prepared deal kinds remote failure occur discussion designing distributed service recommend simple three-step process design data architecture dictates communication generally flows achieve desired service develop control architecture important decisions made finally layer information architecture specifies information gathered inform control decisions advocate step-wise approach design information architecture designers distributed systems obtain information method incurs lowest overhead sufficiently guiding decisions control points information needed knowledge algorithm designer implicit information existing data communication infer remote state implicit information lead decisions acceptable performance designer adding parasitic information finally parasitic information fails provide sufficient guidance explicit information added process naturally iterative design testing occur stage assess efficacy deployed information methods case study river evaluate range methods gathering information distributed system application case study river programming environment section describe river system interesting case study information describe experimental environment motivation river generic data-flow programming environment clusters workstations similar basic design previous parallel database environments volcano river interesting environment studying information primary reasons river solves important problem enables data-intensive applications perform robustly underlying components performing expected river fundamentally requires information state behavior remote components adapt performance problems river environment multiple distributed algorithms information compared discuss reasons detail solves important problem river supports construction parallel data-intensive applications core database query-processing primitives out-of-core scientific programs internet services worthwhile domain river solves additional problem ensuring applications perform robustly underlying hardware software components perform erratically previous work addressed design large-scale systems tolerate correctness faults individual components work focused design systems tolerate performance faults performance fault unexpected low performance component system clusters performance faults commonplace modern disks reasons static dynamic performance faults single disk disks include presence multiple zones scsi bad-block re-mapping thermal recalibration sporadic performance absolute failure contention due workload imbalance heterogeneity due incremental growth goal river enable performance availability application performance tracks aggregate performance components system degrading gracefully increasing number performance faults fundamentally requires information current systems support data-intensive applications interact performance faults static techniques exploit parallelism distribute data standard striping algorithms distributing data requests set disks place amount data disk problem static schemes make rigid assumptions relative performance components perform identically gathering information actual performance result performance service determined slowest component finishes dynamically adjust performance faults distributed system current state remote components implement high performance service scales large numbers components information ideally accurate up-todate gathered overhead sensitivity performance faults consists multiple distributed algorithms river distributed software constructs distributed queue graduated declustering dynamically adjusts data transfered set producers processes parallel application set consumers set disks parallel data-intensive applications consist transfers performance-available environment provided building performance-available data transfer constructs river solve half problem tandem build performance-available applications transferring data set producers set consumers consumers suffer performance fault proper reaction case move data faster consumers amount data proportional relative speed consumer functionality provided distributed queue difficult problem occurs data transfer producers consumers producer incurs performance fault data source replicated multiple producers river applications employ graduated declustering data transfer mechanism carefully divides producer bandwidth equally consumers performance availability producer faults evaluating sources information algorithms side-by-side interesting algorithms characteristics common vary fundamental aspect amount flexibility adjust slow components avoid slow consumer sending data consumer avoid slow producer gathering data producers replicating data restrictive environment forces gather information achieve robust performance experimental environment study costs benefits information sources distributed queue graduated declustering employ simulations implementation event-based simulator explore basic algorithmic behavior wide range system parameters feasible measure implementation measurements implementation gathered confirm simulation results bring systems issues modeled simulations combination techniques improves understanding separating intrinsic properties implementation details river runs cluster ultra workstations running solaris workstation consists mhz ultrasparc processor memory seagate hawk -rpm disks attached fast-narrow scsi bus disk commonly river data disks deliver peak bandwidth workstations connected highspeed myrinet local-area network workstation single myrinet card cards capable moving data workstation approximately entire system connected series -port myrinet switches -ary fat tree communication performed active messages exposes raw performance myrinet integrating features threads blocking communication events multiple independent endpoints distributed queue apply information-based approach distributed algorithms river beginning distributed queue sections present general interface mechanism study identify control points ps-adobecreator dvipsk copyright radical eye software title hpca dvi pages pageorder ascend boundingbox documentfonts times-bold times-roman courier times-italic endcomments dvipscommandline dvips hpca hpca dvipsparameters dpi comments removed dvipssource tex output beginprocset tex pro texdict dict texdict begin bind exch translate isls false vsize mul hsize mul landplus false rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix dup dup round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding end dup foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop dup definefont setfont ch-width ch-data dup length ch-height ch-data dup length ch-xoff ch-data dup length ch-yoff ch-data dup length ch-dx ch-data dup length ch-image ch-data dup type stringtype ctr ctr ctr add charbuilder save roll dup base index bitmaps ch-data pop ctr ch-dx ch-xoff ch-yoff ch-height ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true ch-xoff ch-yoff ch-image imagemask restore dup type stringtype base ctr put bitmaps slw ctr interp spline dup dup length dup index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore showpage userdict eop-hook eop-hook start userdict start-hook start-hook pop vresolution resolution div dvimag array string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval curveto curveto pop cols false ifelse false interp ifelse end gsave spline scale rulex ruley false rmat bdot imagemask grestore gsave rulex curveto ruley scale false rmat bdot imagemask curveto grestore curveto ifelse cols gsave newpath interp transform spline round exch round exch itransform moveto rulex curveto rlineto curveto ruley neg cols rlineto rulex neg interp rlineto spline fill grestore moveto delta tail dup delta rmoveto curveto delta curveto add tail cols tail interp spline curveto curveto cols rmoveto interp spline curveto rmoveto curveto cols roll interp bos spline save eos restore end endprocset beginprocset texps pro texdict begin curveto findfont curveto dup cols interp spline length add dict begin index fid index uniqueid pop curveto pop curveto ifelse forall cols index interp roll spline exec exch roll vresolution resolution div mul neg metrics exch dict curveto begin encoding exch curveto dup type cols integertype pop interp pop spline dup pop ifelse fontmatrix div metrics div ifelse curveto forall curveto metrics metrics cols currentdict end interp index spline currentdict end definefont roll makefont setfont load cvx obliqueslant dup curveto sin curveto cos cols div neg interp slantfont spline index mul add extendfont roll mul exch reencodefont encoding exch end curveto endprocset curveto beginprocset special cols pro texdict interp begin spline sdict dict sdict begin specialdefaults curveto curveto cols interp spline curveto curveto cols interp spline hsc vsc ang clip rwiseen false curveto rhiseen false curveto letter cols note interp spline legal scaleunit hscale scaleunit div hsc vscale scaleunit div curveto vsc curveto hsize cols clip interp spline vsize clip clip clip hoffset curveto voffset curveto cols angle ang interp spline rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true curveto curveto cols interp end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll spline transform roll transform roll transform itransform roll itransform roll itransform roll curveto closepath pathforall newpath counttomark array astore xdf pop put curveto courier fnt invertflag curveto paintblack txpose pxs pys scale curveto 
ppr curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto curveto cols interp spline curveto curveto cols interp spline curveto curveto cols times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh polyline col shd cols polyline col shd cols polyline col shd cols times-roman scf dup pop div neg colsh polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols psend enddocument endtexfig figure berkeley cluster aload pop por noflips pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage copypage macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse clip newpath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath clip showpage erasepage copypage newpath endspecial count ocount pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset texdict begin hpca dvi start times-italic times-roman times-roman times-roman times-italic times-roman courier times-bold times-roman times-roman times-bold times-bold end endprolog beginsetup feature resolution dpi texdict begin endsetup page bop chitectural costs str eaming comparison orkstations clusters smps remzi arpaci-dusseau andr arpaci-dusseau vid culler oseph hellerstein vid patterson computer science vision uni ersity california berkele remzi dusseau culler jmh patterson berkele abstract vestigate resource usage performing streaming cony trasting architectures single workstation cluster smp arious benchmarks deri analytical empiricallyy based models resource usage data transfer examining memory network processor system vestigating resource detail assess comprises welly balanced system workloads architectures study balanced streaming applications platforms main limitation attaining peak performance cpu due lack data locality increasing processor performance improved block 
opy eration performance great aid workloads future cluster workstation major system boty tleneck increased load network comy munication well-balanced cluster workstation copious bandwidth multiple usses smp suf fers poor memory-system performance ven true par allelism benchmark contention shared-memory system leads reduced performance result clustered workstations provide higher absolute performance streaming workloads eywords clusters smps balance intro duction balanced computer system main memory capacity mbit bandwidth mips cpu performan -amdahl rule thumb well-kno tenet computer architecture suggests systems balanced terms memory capacity disk bandwidth processing wer design principle rey minds architects focus engineering fort small subset system performance gains sub-system viated lack similar gains amdahl case rule thumb pro vides guideline uilding balanced systems rule originated performance increased man orders magy nitude fact amdahl made balancedy system estimations xperience ibm timey shared single-processor mainframe rule thumb apply today astly altered vironment term balance dif ferent interpretay tions dif ferent conte xts xample realm scieny computing balance ned number peak oating-point operations ycle vided sustained memory operations ycle o-based workloads clear nition constitutes well-balanced architecture applications lar demands streaming o-intensi workloads well-balanced system resources simultaneously reach peak utilization input output phases assess architecture analyze resource demands set streaming sequential workloads ginning disks ving memory system processor elop models resource usage applications compare models measured usage study questions mind rst data ving peak rate demand arious resources system cient speci architectures ving data apy proach questions technique disk scaling adding disks system monitoring resource usage understand resources tax byte transy ferred disk disco resource bottleneck range hardware platforms pre alent today restrict ourselv class machine xamine costs ement erse architectures rst platform simplest common desktop workstation focus sun ultra workstation forms basis comparison systems platform cluster ultra workstations instance lar ger -scale systems comprised commody ity workstations high-speed networks myrinet pro viding w-latenc highy bandwidth interconnection switches potential fusing workstations cohesi implicitly aluate underlying assumption clustered systems workstation current form good uilding block assumption optimistic machine welly balanced stand-alone case properly archiy tected tightly-inte grated cluster vironment platform small-scale symmetric multiprocesy sor smp speci cally ultra enterprise built man components ultra workstation smp lends direct comparison cluster chitecture main dif ference systems processor -to-processor interconnect cluster archiy tecture local-area network myrinet connects machines smp main memory gigay plane pro vides high-bandwidth cache-coherent channel communication processors eop page bop order dri architectures employ set kernels rst simple scan reads data disk sequentially selects matching records writes records disk benchmark xternal sort sorting longtime database-industry standard benchmark recently garnered interest addition classical database vironment sorting typical workload systems performy ing decision support paper single-node cluster ersions -sort world fastest disk-to-disk sorting program benchmark xternal transpose rst benchmarks database domain transpose found xternal sciy enti codes benchmarks hand optimized platform set benchmarks systems balanced speci cally introduce system gur shows workstations connected eight-port myrinet switc hes thr suc oups comprise entir -node cluster supp soft tuning user -le application perfor mance -sort directly fected number important software sub-systems including multi-layer opy erating system communication layer machine cluster runs copy solaris multi-threaded ersion unix strengths solaris include cient support kernel-le threads well-de eloped unix system sophisticated memory management machines running solaris cluster make present illusion single lar ge-scale system end user cluster employs glunix prototype disy trib uted operating system berkele glunix monitors nodes system load-balancing coschedules parallel programs pro vides job control redirecy tion measurements place dedicated vironment primarily glunix parallel program launcher parallel ersions -sort written support split-c library split-c parallel tension supports cient access global address space distrib uted memory machines split-c library pro vides man group synchronization communicay tion primiti including barriers reductions communication utilized acti messages communication layer designed latenc high bandwidth switch-based tworks acti message esy sentially restricted lightweight remote procedure call process sends acti message speci handler ecuted processor examine approaches information taxonomy applied interface semantics previous section distributed queue presents applications high-speed backplane data sharing tolerate consumer-side performance faults application producers place data distributed queue calling put data size consumers receive data calling data size consumer logically receive data block put system central challenge designing move data producnote ordering data guaranteed pointto-point producer places consumer receives receive strictly speaking bag queue consumer decision producer data processed producer decision consumer data producer consumer communication send data chosen consumer consumer producer communication acknowledge receipt data consumerx producer process block figure data control diagram depicts basic data movement control options distributed queue producer wishes send data block faced decision consumer data decided data block consumer consumer receives blocks producers faced control option order blocks processed consumers block received consumer sends reply producer required active messages request response protocol ers consumers faster consumers receive proportionally higher amount aggregate producer bandwidth implementation accomplish goal distributed scalable manner ways distributed queue 
reminiscent linda tuple space restricted usage entities allocated storage distributed queue simply passed directly producer consumer designed strictly high-performance data transfers tolerate consumer-side performance faults bears similarity distributed load balancing constructs goal performance-available data transfers consumer performance faults one-to-one mapping traditional load-balancing schemes data control figure presents logical structure data flow producer data distribute set consumers consumer queue incoming data blocks process data transferred parallel set producers set consumers part queue flow block behavior system determined decisions control points potentially requires global information candidates exploring information taxonomy producer chooses consumer receive percent peak performance performance faults alternatives performance faults implicit null simulation implicit null implementation null null simulation null null performance drops immediately fault implicit null performance simulations implementation ideal range performance faults ideal figure performance null implicit results simulation null null implicit null implementation implicit null compared ideal performance increasing number performance faults experiments producers generate data nonfaulty consumers consume data performance fault reduces consumer performance factor data block important decision performance-available distributed queue algorithm consumer choose order process blocks received examine levels information taxonomy applied make decisions distributed queue null information begin study information alternatives simplest alternative information distributed queue consists decisions refer distributed queue information decisions null null decision producer consumer receive data block information-free algorithms sending consumers round-robin random pattern round-robin pattern lead excessive endpoint contention focus random choice consumer decision consumer order blocks processed null alternatives study simple first-come first-served policy figure illustrates performance simulated null null experiments producers send data remote consumers total machines producers generate data non-faulty consumers sink data set-up emulates set processes writing in-memory records parallel disk disks consumers bottlenecks transfer x-axis increase number consumers undergoing performance faults performance fault reduces level consumer performance factor left-most point x-axis shows performance system performance faults right-most point shows performance consumers perform perturbed rate y-axis plots performance fraction peak non-perturbed case faults system peak simply aggregate bandwidth bottleneck transfer case consumers bottleneck ideal performance line shown subsequent graphs computed fraction peak performance number performance faults shown figure performance faults null null performs throughput high scales machines single fault performance drops immediately slowest consumer performance faults added system null information schemes fundamentally react changing characteristics consumers system provide performance availability support desired behavior distributed queue form global information dispersed system allowing producers adapt volatile performance delivered consumers implicit information implicit information elegantly solves basic problem distributed queue lack adaptation varying rates consumption implicit information feedback request response paradigm data messages producer sends data consumer form active message request protocol stipulates consumer replies message null null reply empty message implicit null reply signal consumer handled data request producer infers remote consumer making progress producer monitors incoming replies infer current perthis reply message required protocols utilize acknowledgements implement reliable message transfers formance level consumer leverage implicit information implicit null algorithm producer records unacknowledged message outstanding consumer producer send block data finds consumer unacknowledged message consumer producer chooses uniformly random consumers producer relinquishes processor waits consumer reply consumer receives data block processes blocks first-come firstserved order sends empty active message reply producer producer handles reply records longer outstanding message consumer intuition implicit algorithm consumers respond quickly requests receive subsequent requests producer implicit information producer window consumer performance instant producer trusts consumers adequately responded data requests trust responded algorithm property unifying seemingly diverse implementations push-based pull-based approaches found messagepassing layers producers bottleneck data transfer consumers respond quickly data requests choice destinations degenerates random choice entire set consumers push-based approach consumers bottleneck producer messages outstanding consumer reply returns implicitly pulls data request replying consumer depending relative performance rates producers consumers implicit null characteristics push-based pull-based approach shown figure simulated performance implicit distributed queue performance faults excellent delivering ideal performance range induced faults figure shows implementation results system parameters set equal simulation closely match simulation results scheme easily extended outstanding block consumer found sufficient range experiments reported relative bandwidth achieved producer number bandwidth scale implicit null implementation implicit null implementation implicit null implementation implicit parasitic simulation implicit null approach network unfairness producers receive fair-share bandwidth addition parasitic information solves fairness problem unfair unfair figure fairness graph depicts results experiments implementation implicit null simulation implicit parasitic experiments producers sending data fast remote consumers total machines rate consumer controlled varied spot x-axis producer system y-axis plots proportion total bandwidth producer received experiment fair distribution bandwidth leads producers y-value parasitic information implicit information choosing destination data block implicit null non-informed algorithm first-come first-served processing blocks consumer performing detailed measurements implementation found high loads participating nodes myrinet switches fairly schedule transfers producers receive fair share network bandwidth performance determined rate slowest entity unfairness performance system drop figure plots relative bandwidths producers experiments implementation experiments producers sending data consumers performance faults system per-consumer bandwidth set levels ideally producer obtain fair-share aggregate consumer bandwidth occurs per-consumer bandwidths per-consumer bandwidth producers receive substantially lower proportion aggregate consumer bandwidth parasitic information solution fairness problem data producer sends current bandwidth consumers information schedule data blocks process consumer biases service producers lagging encourages global fairness good performance spite networkswitch unfairness note implicit parasitic ideal respect amount communication performs logically adding bytes information large data transfer verify performance implicit parasitic modified simulator model switch unfairness simulation results version figure implicit parasitic performs desired implemented approach real system confident parasitic information equally aid performance note combination simulation measurements implementation pinpoint fix problem readily explicit information successfully utilized implicit information choose destination block data load-balancing literature propose explicit approaches adler suggest simple probe-n model producer sends explicit probes random subset consumers sending data block probes return load consumer producer pick consumer lowest load intuition algorithm time send probe fast roughly equal roundtrip latency network implemented approach realized explicit queries make dangerous performance assumption probe returns promptly type assumptions seeking avoid distributed queue surprisingly implementation explicit null distributed queue proved unsuccessful performance dropped level slow consumers system identical null null algorithm shown figure probe-n algorithm shown balance load cluster performance-available manner performance assumptions made explicit information queries reour implementation incurs overhead active message fixed set arguments unused sult brittle behavior assumptions invalid consumer respond timely 
manner queries explicit approach disadvantage adding probe messages data block finally probebased approach significantly complicates distributed queue adding substantial amounts code discussion studied range information sources performance-available adaptive distributed queue primary importance adaptive algorithm feedback null methods systems tolerate performance faults conclusion implications systems traditional disk striping schemes parallel database techniques rangeand hashpartitioning null methods adapt components varying performance levels important piece information consumption rate remote consumers needed deciding send data block implicit information adequate decision consumer replies signaling rate remote consumer progress yields highperformance algorithm adequate consumer-side scheduling block processing factor switch unfairness mandates parasitic methods disperse extra information system rate progress producer combination parasitic implicit methods leads general robust distributed queue finally explicit methods information remote entities gathered performance assumptions introduced producer queries number remote sites current load wait queries return yield performance-available explicit methods avoided performance dependencies well-understood graduated declustering distributed queue tolerates consumerside performance faults moving data faster consumers suffers producer deliver data expected rate data locale producers bottleneck data transfer bbb fau figure diagram shows alleviates problem producer-side performance faults disks producers data mirrored producer produces data sets consumer consumes data set performs half expected rate producers compensate bandwidth allocations consumers receive fair-share aggregate bandwidth solution problem cases data replicated sake reliability mirrored disk system data block locations river graduated declustering coordinate access replicated data set dividing aggregate producer bandwidth equally consumers avoid producer-side performance faults work shown figure interface semantics internal interface graduated declustering slightly consumer side simple consumers call data size requests eventually returns requested data sources producer interface complex producers call getrequest request request specification put request data size send results request back requesting consumer graduated declustering similar chained declustering technique improves performance absolute failure mirrored disk system carefully spreading replicated blocks disks extends concept tolerate full range performance faults similar adaptive techniques choosing replica read petal petal coordinate activity parallel clients global manner successful avoiding potentially harsh effects consumer decision producer request producer decision consumer request scheduled producer consumer communication reply request data block consumer producer communication request data block producer consumer producerx process requested blocks process request send reply figure data control diagram depicts basic data movement control options graduated declustering consumer requesting block faced decision producer request request selected producer requests consumers consumer faces decision queue serviced serviced data back requesting consumer performance faults parallel clients data control figure presents logical structure data flow graduated declustering consumer sends request block replicated sources block decision represents control point producer choose order handle consumer requests decision represents control point null information null null makes decisions information consumer chooses random producer data request producer services requests first-come first-served manner performance simulated shown figure consumers requests data producers set producers non-faulty producers generate data consumers sink data scenario emulates parallel read disks disks producers application processes consumers x-axis increase number producers performance faults performance fault reduces level producers performance factor surprisingly null null approach works performance faults system performance degrades single performance fault occurs percent ideal performance performance faults alternatives performance faults implicit parasitic simulation layout implicit parasitic implementation layout implicit parasitic simulation worst layout null implicit null simulation layout implicit parasitic performance depends strongly layout performance faults worst null null implicit null performance poor single fault ideal figure performance results simulations null null implicit null implicit parasitic implementation implicit parasitic compared ideal performance increasing number performance faults experiments non-faulty producers generate data consumers consume data aperformance fault reduces producer performance factor limited replication layout performance faults matters implies spread worst occur consecutively producers implicit information implicit null modeled implicit null consumer sends request producer responded recently intuition approach give requests responsive servers avoid slow producers performance implicit null algorithm identical null method consumers adapt responsive producers producer scheduling first-come first-served policy successful due greater flexibility producers producer send data consumer consumer send request subset producers due limited replication producers bias scheduling cooperatively account slow producers implicit method bring behavior parasitic information arrive performance-available algorithm addition parasitic information analogous consumer inserts rate progress request producer localized view progress consumer serves producer biases scheduling service lagging consumer easily shown producer locally balance bandwidths consumers services consumers receive equal share producer bandwidth implicit null consumers implicit method decision sending requests producer recently responded figure shows performance implicit parasitic simulation implementation simulations performance-fault layouts presented worst case faults occur consecutively immediately affect data sources consumer case evenly distributed occurring consumer producers half producers perturbed implementation results shown layout performance layout faults good ideal due limited amount replication producer contained data set flexibility ideal performance generally level replication data item number producers system implicit parasitic algorithm tolerate presence performance faults potentially tolerate faults explicit information finally examine utility explicit information movement graduated declustering distributed queue adding explicit queries system built performance availability dangerous adding explicit information graduated declustering care avoid performance assumptions situation implicit parasitic algorithm performs explicit information case envision alternative parasitic dispersal progress information implicit parasitic piggy-backs consumer progress request producer benefit approach low cost achieves defined goal potential disadvantage occurs consumer request data producer time case producer up-to-date knowledge consumer progress make optimal scheduling decision explicit approach solves problem continually updating producers proparasitic producer consumer parasitic explicit consumer table parasitic explicit tables show percent requests consumer satisfied producer gathered simulation table shows results implicit parasitic algorithm consumer receives roughly half requests producer table shows results implicit parasitic explicit approach consumer receives requests producer experiments performance faults ducer real request dummy request progress information disadvantage implicit parasitic approach faults system case producer divides bandwidth roughly equal parts consumers serves results slight performance cost additional seeks incurred reading streams disk implicit parasitic explicit algorithmically favor consumer deliver bandwidth consumer informed consumer making sufficient progress explicit approach avoids extraneous seeks table presents simulation results approaches disadvantages costs extra explicit information requests generated environments noticeably affect system performance information-bearing requests make performance assumptions implemented reliable protocol request consumes resources buffers retransmission producer slow repeated requests consume resources eventually halting progress information-dispersing requests built unreliable medium raw u-net active messages discussion design successful graduated declustering algorithm requires information baseline 
distributed queue consumer progress passed consumers producers facilitate producerside scheduling producer rates consumers direct requests serviced efficiently realized parasitic information implicit methods kinds information develop robust algorithm information consumer progress widely dispersed explicit techniques explicit informationbearing request producers slight performance improvement represents class information null implicit parasitic techniques implicit parasitic explicit approach demonstrates hybrid techniques leveraged gather information putting demonstrate utility complete distributed queue graduated declustering mechanisms give summary application experience river solid information-centric understanding algorithm final implementation mechanisms straight-forward result performance applications compared previous efforts present performance o-intensive database query-processing primitives transformed static parallel application robust adaptive version programmers insert distributed queues graduated declustering applications form points flexibility places data-flow performance faults tolerated note application writers knowledge information flow focus constructing flexible flows infrastructure handles rest utilizing core river mechanisms application withstands performance faults disks achieves near-ideal performance figure presents summary results figure performance application increasing number disk performance faults shown fault disk utilizes half disk bandwidth applications ideal amount applications paper percent ideal performance performance faults induced application performance scan generate filter top-n selection hash join sort ideal performance applications performance degrades gracefully faults figure application performance performance database primitives disk performance faults presented run implementation machines applications parallel scan data set read parallel generation data set write parallel filter read data disk select records based user-defined function write selected records disk top-n selection find top values data set find efficiently parallel hash-join data sets finally parallel external sort application operates roughly data disk node total machines performance fault reduces performance factor data point represents average runs variance numbers data touched application divided peak rate disks parallel scan reads total disks run ideal time scan seconds cases performance excellent measured execution time river applications ideal summary carefully applying information-based approach build solid implementations distributed algorithms information-ignorant applications advantage informationaware mechanisms reap benefits excellent behavior performance faults instances implicit parasitic techniques proved elegant low-cost methods gathering information constructs needed adaptation conclusions future work paper introduced explored information-based approach systems design understanding information distributed algorithms iteratively evaluating range approaches information taxonomy substantially improved performance system system designers follow steps equally beneficial results case study river found implicit parasitic information distributed queue graduated declustering information derived methods sufficient enable design implementation robust scalable elegant algorithms distributed systems continue increase complexity information-centric techniques critical method classified null implicit parasitic explicit place depending problem domain evaluating costs benefits approach central successful design future increase ease information distributed systems important step goal develop information programming interfaces ipis similar traditional application programming interfaces apis ipis serve isolate information-gathering method rest algorithm allowing implicit parasitic explicit hybrid methods employed depending environment ipis increase portability standard tcp congestion control run wireless environment dropped message longer congestion due simply lossy medium congestion signal encapsulated ipi porting ipi setting forces designers re-think gather information avoiding incorrect inferences implicit observations finally plan formalize gathering information distributed systems interesting environments feedback components involved hope application control theory prove fruitful adding rigor design distributed algorithms adler chakrabarti mitzenmacher rasmussen parallel randomized load balancing proceedings annual acm symposium theory computing stoc pages york acm arpaci-dusseau arpaci-dusseau culler hellerstein patterson searching sorting record experiences tuning now-sort spdt aug arpaci-dusseau culler mainwaring scheduling implicit information distributed systems proceedings acm sigmetrics international conference measurement modeling computer systems arpaci-dusseau performance availability networks workstations phd thesis california berkeley arpaci-dusseau anderson treuhaft culler hellerstein patterson yelick cluster river making fast case common iopads balakrishnan padmanabhan seshan katz comparison mechanisms improving tcp performance wireless links ieee acm transac-tions networking december birman cooper isis project real experience fault-tolerant programming system operating system review pages april birrell nelson implementing remote procedure calls acm transactions computer systems february blackwell girshick theory games statistical decisions john wiley sons york blumofe joerg kuszmaul leiserson randall zhou cilk efficient multithreaded runtime system proceedings symposium principles practice parallel programming july boden cohen felderman kulawik seitz seizovic myrinet gigabet-per-second local-area network ieee micro february bolosky barrera draves fitzgerald gibson jones levi myhrvold rashid tiger video fileserver http research microsoft research bolosky tiger tiger html brewer inktomi web search engine invited talk sigmod brewer kuszmaul good performance cmdata network proceedings international parallel processing symposium cancun mexico april carriero implementation tuple space phd thesis department computer science yale december culler arpaci-dusseau arpaci-dusseau chun lumetta mainwaring martin yoshikawa wong parallel computing berkeley jspp joint symposium parallel processing kobe japan june englert gray kocher shah benchmark nonstop sql release demonstrating near-linear speedup scaleup large databases proceedings acm sigmetrics conference measurement modeling computer systems pages goodman cache memory reduce processormemory traffic proceedings annual international symposium computer architecture pages stockholm sweden june computer architecture news june graefe encapsulation parallelism volcano query processing system sigmod record acm special interest group management data june hsiao dewitt chained declustering availability strategy multiprocessor database machines proceedings international data engineering conference pages jacobson congestion avoidance control proceedings acm sigcomm pages august johnson designing distributed queue proceedings seventh ieee symposium parallel distributed processing pages san antonio texas october karamcheti chien comparison architectural support messaging tmc cmand cray annual international symposium computer architecture pages santa margherita ligure italy june lampson note confinement problem communications acm october lee thekkath petal distributed virtual disks asplos vii pages cambridge october mainwaring culler active message applications programming interface communication subsystem organization technical report csd- california berkeley october metcalf boggs ethernet distributed packet switching local computer networks communications acm july meter observing effects multi-zone disks proceedings usenix conference jan microsysytems whitepaper nfs version http sun software whitepapers wp-nfs march neumann morgenstern theory games economic behavior princeton press princeton jersey edition pai aron banga svendsen druschel zwaenepoel nahum locality-aware request distribution cluster-based network servers asplosviii san jose california patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod international conference management data pages chicago june acm press rubin design automatic control systems artech house norwood schneider implementing fault-tolerant services state machine approach tutorial acm computing surveys december sobalvarro pakin weihl chien dynamic coscheduling workstation clusters proceedings ipps workshop job scheduling strategies parallel processing talagala patterson analysis error behaviour large storage system ipps workshop fault tolerance 
parallel distributed systems tremblay greenley normoyle design microarchitecture ultrasparc-i proceedings ieee december von eicken basu buch vogels u-net user-level network interface parallel distributed computing proceedings fifteenth acm symposium operating systems principles pages copper mountain resort usa wen portable library support irregular applications phd thesis california berkeley january techreport ucb csd- 
bottleneck system resource due lack locality streaming workloads spend time ving data operating increasing ability processor data memory system increased support block operations greatly aid types workloads platforms memory traf high higher inherent applicay tions art discrepanc attrib uted beha vior xtra copies fer cache zeroing heap pages part mismatch grain size benchmarks block size cache cluster scenario part communication layer lar amount memory traf memory interconnect stand-alone clustered workstation capable handling bandwidth demands clustered workstations bandwidth crucial times bandwidth needed comy pared stand-alone workstation due aggre gation network disk traf ideal clustered workstation pro vide bandwidth network disk haps multiple usses ithout suf cient bandy width clusters impro aggre gate disk performance increasing number workstations system smp well-balanced architectures cost wer absolute performance partly attrib uted xtra copy oid lock cony tention false sharing factor memory system lled bank time full memory con guration memory system performance smp study signi cantly decreased rest paper outlined follo gin xplaining methodology section hardware vironment section benchmarks modeled section section presents xperimental results section conclude metho dology metho dological app roach study main objecti rst pro vide general characterization resource usage set benchmarks belie benchmarks representati applications perform lar amounts streaming models sho resources architecture pro vide ciently ecute programs models based understanding program code con rmed empirically range machines objecti aluate architectures hand study stand-alone workstation small cluster workstations small-scale smp dif ferent architectures ecute benchmarks balanced systems types applications approach dual objecti uni method disk scaling system gins single disk procesy sor run benchmark con guration monitor resources arious hardware software counters dey scribed belo add disks system introducing potential run benchmarks measuring resource usage process empirically determine benchmark beha compare xperimental rey sults application models separate inher ent data ement demands actual realization hardware measuring application beha vior systems recognize system bottlenecks criticize architectures data presented forms rst form presents gene ral relationships reso urce age ben chy mark dif ferent platforms xample cluster architecture amount crossing read phase sort roughly times amount data read disk algorithmic property sort deri model section cony rmed empirically section comparing modeled ersus actual usage aids understanding parameters architecture fect resource usage xample cache block size match natural grain size benchmarks leading xtra memory traf form presents actual utilization rey source question xample utilized read phase sort disks added system data gauge fecti eness system test estimate resource question reach maximum utilization exp erimental appa ratus measure resource utilization platforms combination software hardware counters ultrasp arcs on-chip counters track rsth second-le cache access statistics smp study enterprise counters track memory traf obtain information single workstation cluster vironments con gure enter prise emulate single-processor system shutting processors board resulting machine similar single workstation xcept memory system interconnect capable higher data transfer rates cluster measurements attach single network card smp connect ultray arc workstations noted con guration aluate memory workstation employed gather information program beha vior amount traf generated benchmark small modi cations made solaris kernel enable counters non-idle periods crucial tracing kernel acti vity counter -based measurements run benchmarks times graphs present results runs standard viations eop page bop starttexfig begindocument figures ultrasingle eps magnification psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind 
col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit clip slw polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols slw polyline col shd polyline col shd ellipse drawellipse col shd ellipse drawellipse col shd polyline col shd ellipse drawellipse col shd ellipse drawellipse col shd ellipse drawellipse col shd ellipse drawellipse col shd polyline col shd ellipse drawellipse col shd ellipse drawellipse col shd slw polyline col shd cols polyline col shd cols slw polyline col shd slw polyline col shd cols slw polyline col shd polyline col shd polyline col shd slw polyline col shd cols polyline col shd cols slw polyline col shd slw ellipse drawellipse col shd cols ellipse drawellipse col shd cols ellipse drawellipse col shd cols slw polyline col shd cols slw ellipse drawellipse col shd cols ellipse drawellipse col shd cols ellipse drawellipse col shd cols ellipse drawellipse col shd cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead slw setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead slw setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead slw setgray cols arrowhead setgray cols polyline clippath clip clip col shd cols arrowhead setgray cols arrowhead setgray cols polyline col shd cols slw polyline col shd cols ellipse drawellipse col shd cols slw polyline col shd cols slw polyline col shd cols slw polyline col shd cols slw polyline col shd cols polyline col shd cols polyline clippath clip col shd cols arrowhead setgray cols polyline clippath clip col shd cols arrowhead setgray cols polyline clippath clip clip col shd cols arrowhead setgray cols arrowhead setgray cols polyline col shd cols polyline col shd cols slw polyline clippath clip clip col shd cols arrowhead setgray cols arrowhead setgray cols polyline clippath clip clip col shd cols arrowhead setgray cols arrowhead setgray cols slw polyline cols slw polyline col shd cols times-roman scf upa data bus dup pop div neg colsh times-roman scf sysio dup pop div neg colsh times-roman scf asic dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf asic dup pop div neg colsh times-roman scf rot address bus dup pop div neg colsh times-roman scf upa processor data bus dup pop div neg colsh times-roman scf bmx dup pop div neg colsh times-roman scf chips dup pop div neg colsh times-roman scf cache dup pop div neg colsh times-roman scf processor dup pop div neg colsh times-roman scf ultrasparc dup pop div neg colsh times-roman scf memory simms dup pop div neg colsh times-roman scf interface dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf seagate hawk dup pop div neg colsh times-roman scf rpm dup pop div neg colsh times-roman scf seagate hawk dup pop div neg colsh times-roman scf rpm dup pop div neg colsh times-roman scf rot scsi bus dup pop div neg colsh times-roman scf rot fast-wide dup pop div neg colsh times-roman scf rot fast-wide dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf network dup pop div neg colsh times-roman scf myrinet dup pop div neg colsh times-roman scf -bit mhz s-bus dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf rot scsi bus dup pop div neg colsh times-roman scf ultra workstation dup pop div neg colsh psend enddocument endtexfig starttexfig begindocument figures ultraenterprise eps magnification psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt 
dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit clip polyline col shd polyline col shd slw polyline col shd cols polyline col shd cols slw polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols slw polyline col shd polyline col shd polyline col shd polyline col shd slw polyline col shd cols slw polyline col shd polyline col shd polyline col shd polyline col shd slw polyline col shd cols polyline col shd cols slw polyline col shd polyline col shd polyline col shd slw polyline col shd cols slw polyline col shd slw polyline col shd cols slw polyline col shd slw polyline col shd cols slw polyline col shd slw polyline col shd cols polyline col shd cols slw polyline col shd polyline col shd slw polyline col shd cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline col shd cols polyline col shd cols slw polyline clippath clip cols arrowhead setgray cols slw polyline clippath clip clip col shd cols arrowhead setgray cols arrowhead setgray cols polyline clippath clip clip col shd cols arrowhead setgray cols arrowhead setgray cols slw polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols polyline col shd cols times-bold scf dup pop div neg colsh times-roman scf rot sbus dup pop div neg colsh times-roman scf rot sbus dup pop div neg colsh ellipse drawellipse col shd cols times-roman scf controller dup pop div neg colsh ellipse drawellipse col shd cols times-roman scf controller dup pop div neg colsh slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline col shd cols times-roman scf fastwide scsi dup pop div neg colsh times-roman scf fast-wide scsi dup pop div neg colsh times-bold scf sbus board dup pop div neg colsh slw polyline cols slw polyline col shd cols times-roman scf cache dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf processor dup pop div neg colsh times-roman scf ultrasparc dup pop div neg colsh times-roman scf address dup pop div neg colsh slw polyline cols times-roman scf cache dup pop div neg colsh times-roman scf dup pop div neg colsh times-roman scf processor dup pop div neg colsh times-roman scf ultrasparc dup pop div neg colsh slw polyline clippath clip clip col shd cols arrowhead slw setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip cols arrowhead setgray cols polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw ellipse drawellipse col shd cols slw polyline clippath clip clip col shd cols arrowhead slw setgray cols arrowhead setgray cols slw ellipse drawellipse col shd cols slw polyline clippath clip remote node message recei handler ecutes atomically respect message arri als ersion acti messages gam supports single communicating process workstation time gam myrinet round-trip latenc roughly uni-directional bandwidth node sending recei ving eop page bop single-no erfo rmance tuning application programmers set performance xpectations hope achie mflops rating absolute ecution time speed-up ithout xpectations programmer determine point reached suf cient performance man times xpectations aguely ned worse omitted xperience sho xplicitly ning xpectations important components system greatly simplify tuning comple applications section describe xperience eloping meeting xpectations primary uilding-block sort single-node algorithm path follo wed contained simple steps carefully chose initial xpectations based models measurements system operating ideal circumstances implemented straight-forward algorithm poy tential achie ving goals finally measured performance phases implementation focused forts portions meet xpecy tations ning exp ectations sorting benchmark stresses memy ory sub-systems machine xpectations focused memory system performance designing algorithm enumerated goals single-node sort perform minimum amount required oid paging virtual memory ensure dominates total run-time ransfer data disk peak sequential rates rst xpectation basic disks slo west component system miny imized general erall performance achie performing xtra computation additional memory copies accessing disk sorting minimum amount required determined amount memory system records sorted ailable memy ory one-pass sort record read written disk xactly two-pass sort required record read written disk memory xplicitly managed paging virtual memory disk occur aging damaging vironment disks holds records sorting swap space paging hurt memory perfor mance interferes sequential access patterns disk transfers xpectation moti ated pre viou ork disky to-disk sorting pre vious researchers found cle ways hide cost internal sorting erlapping disk goal implementation finally transfers disk proceed maximum rate achie maximum throughput disk seeks optimization performed two-pass model sorted run rst pass temporarily written disk read back minimized achie accessing disk sequentially suf ciently lar transfer sizes sorting accesses data disk gular deterministic fashion goal attainable xpectations predict desired time sort function number records size record expected ime ead ite ead ite amount ailable memory ead ite peak read write disk bandwidths determining amount ailable memory peak disk bandwidth system required implement simple con guration tools memory con guration ool rst xpectations require -sort ware amount ailable memory ideal case amount reported simple system call operating system solaris accurate assessmen free memory eloped user -le tool accessing arious amounts memory monitoring paging acti ity memory con guration tool accurately estimates amount user program safely allocate xample machine physical memory con guration tool determined memory ailable user applications tool number limitations noy tably ailable memory remain constant tool application ecute suf cient forming xpectations determines passes required records disk speci number records sorted pass paging seagate disks scsi bus read ite rpm narro rpm narro rpm barracuda ide rpm barracuda ide wks barracudas disk band width expectations read write columns show peak bandwidth eported disk cony gur ation tool measur emen system wer equir determine scsi-b limits peak performance disk con guration ool concretely set xpecy tations peak disk bandwidth eloped simple disk con guration tool program serv purposes automatically adjust amount data striped disk handle disks dif fering performance characterisy tics reports maximum achie bandwidth processor performing work ithout tool una ware bottlenecks system set unrealistically high xpectations achie bandwidth multiple disks xample read rpm disk disk con guration tool ealed read disks due saturation fast-narro scsi ith nai model xtrapolated xpectation dif ference full set eop page bop xpectations disk performance determined disk con guration tool sho one-p ass algo rithm ith xpectations well-de ned gan eloping -sort code single workstation implementation distinct code paths depending passes required sort records ailable memy 
ory describe xperience tuning rst one-pass sort two-pass sort initial ersion one-pass single-node sort cony tained simple steps read program gins opening input read system call transfers -byte records disk main memory inter nal sort quicksort performed records memory quicksort -byte separated -byte record pointer set full record separation allo sort operate ciently swapping pointers full records quicksort write list sorted pointers tra ersed order gather sorted records output fer output fer lls written disk write system call finally fsync called ensure data safely disk closed measurements ealed initial implementay tion failed meet xpectations ways wer records xpected sorted paging disk time internal sort noticeable percenty age total ecution time brie discuss located performance problems optimizing memo management track une xpected paging acti vity monitored disk traf increasing number records sorted visually observ traf implementing small formance meter diskbar detail belo clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw polyline clippath clip clip cols arrowhead setgray cols arrowhead setgray cols slw ellipse drawellipse col shd cols ellipse drawellipse col shd cols polyline col shd cols polyline col shd cols polyline col shd cols slw polyline cols times-roman scf sysio dup pop div neg colsh slw polyline col shd cols ellipse drawellipse col shd cols times-roman scf sysio dup pop div neg colsh ellipse drawellipse col shd cols times-roman scf data dup pop div neg colsh times-roman scf -bit address bus dup pop div neg colsh times-roman scf data bus dup pop div neg colsh times-bold scf dup pop div neg colsh times-bold scf -bit gigaplane dup pop div neg colsh times-roman scf address dup pop div neg colsh times-roman scf controller dup pop div neg colsh times-bold scf cpu memory board dup pop div neg colsh times-roman scf memory dup pop div neg colsh times-roman scf data dup pop div neg colsh times-roman scf controller dup pop div neg colsh times-roman scf ultraenterprise colsh psend enddocument endtexfig figure hard war diagram gur depicts internals ultr workstation ultr enterprise orkstation inside workstation left bmx ossbar hips asic contr oller ovide switc hed-based access memory smp enterprise eac cpu boar houses cpus whic shar addr ess data eac boar consists s-bus usses boar connected main memory inter connect gigaplane memory physically distrib uted access time uniform systems overview study compare platforms represent imy portant distinct data interconnection architectures hold hardware characteristics common platy forms based ultrasp arc processor cpu caches memory peripheral usses disks platform single processor cluster workstations eight-way smp single rkstation simplest platform single processor ultra model workstation sho figure machine single mhz ultrasp arc processor f-chip secondy cache pro vides crossbar -like connection processor caches main memory ultrasp arc systems sustain bandwidths single processor dri rate main ultra s-bus ethernet single fast-narro scsi connect s-bus motherboard s-bus slots allo additional vices xperimental setup ultra workstation single internal seagate -rpm disk attached narro scsi paging acti vity xtend disk capacity system fasty 
wide scsi controllers connected xternal disks platforms runs solaris modern multi-threaded operating system presenty ing study architectural characteristics operating system beha vior dictates usage patterns underlying hardy ware sho care operating system interfaces data ement ultrasp arc formed special block copy hardware ailable part vis instruction set block loads stores data directly double-precision oaty ing point gisters polluting caches hardware feature accessible library routines memcpy copy rates roughly ving traf memory s-bus -bits wide vices ailable -bit mode including network interface cards reducing potential bandwidth study examine -bit s-bus products cluster rkstations cluster consists ultra workstations identical abo workstations connected myrinet switched-based network machine single myrinet card s-bus attached cable eight-port switch multiple switches linked form lar arbitrary topologies arallel applications cluster communicate acy messages high-performance communication layer designed latenc high bandwidth switch-based networks acti message restricted lightweight rey mote procedure call communication layer studying base architectural costs data ment unnecess ary copying fering data oided paper acti messages gam myrinet round-trip latenc roughly bi-directional sustained bandwidth sending recei ving primary unit data transfer benchmark applications symmetric multip cesso ultra enterprise small-scale symmetric multiy processor uniform memory access main hardware resource distinguishes system gigaplane -bit wide packet-switched memory connects cpu boards sho figure system -cpu processor boards boards total memory distrib uted processor boards board s-busses s-bus uilt-in fast ethernet fast-wide scsi xtra slot vices s-bus slots xperiments add fast-wide scsi controller card fast-wide scsi disks attached communication enterprise performed loads stores shared memory primiti mute condition ariables safely access shared data barriers synchronize threads processors copy rates slightly higher single ultra workstation eop page bop bus memory bus read write read write scan orkstation match total cluster match total smp match total sort orkstation buck buck cluster buck buck smp buck buck ranspose orkstation cluster smp figure benchmark resour models table esents models esour usage thr benc hmarks acr oss workstation cluster smp platforms ead phase esour usage elative ate data ead disk similarly write phase esour usage elative xample ate data xpected oss ead phase single workstation sort equal ate data disk wher eas ead phase cluster sort thr times ate disk oss ows lar benchma descriptions dels section ervie kernels stud elop mode resource usage benchmarks primarily perform sequential future studies plan xamine non-sequential access paty terns rst benchmarks scan sort typical data-processing vironment benchmark transpose commonly found scienti codes models presented section memory usage read write phases benchmarks deri understanding code models resource usage presented ratios rate data read written disk xample data read disk single workstation platform xpect cross benchmarks read data disk memory-mapped les mmap benchmarks alternati read results xtra copy fer cache operating sysy tem problematic applications stream data madvise sequential access pattern pages prefetched pages discarded appropriy ately writing benchmarks repeatedly call write lar fer oid high cost repeated traps kernel mmap natural match writing xtend length les finally benchmarks capability access muly tiple disks concurrently simple user -le striping library similar library spreads disk blocks disk sub-system user -speci block size minimal cpu erhead benchmark hand optimized platform question benchmarks ersions code cluster smp present models perspecti single processor cpu performs identical tasks describe benchmark scan sequential scan modeled scan selection database simplest benchmarks input set scan sort deri datamation minutesort sorting benchmarks byte records -byte terminology size size record scan selects writes disk records match user -speci set criteria match total fraction matching records benchmark data range selected roughly half data written back disk model model usage scan platforms simple traf crossy ing traf disks reading disk cross wise dur ing write phase writing disk cross orkstation memory model read phase scan performs follo wing steps records memory-mapped transferred memory accounting memory portion record xamined determine matches criteria logical crosses memory processor caches matches copied separate fer match total write phase writes fer disk accounting cluster memory model cluster ersion identical single-node scan processes started nodes cluster node ecutes single-workstation scan situation best-case scenario cluster xplicit data xchange occurs embarrassingly parallel complete parallelism models resource usage cluster scan match single node models xactly smp memory model smp ersion forks threads read select records iny dependent portion data write disk logically sharing benchmark resource usage models identical single workstation comple benchmark study xternal sort detail sorting chosen database xperts xcellent test memory communiy cation sub-systems machine scan -byte -byte records eop page bop basic sorting algorithm similar platforms rst step records con erted layout disk format suitable cient sorting records read disk pointer full record uckets based top bits impro cache beha vior sort ways sort operates pairs copying -bytes -byte records compared swapped number ucket matches size second-le cache step sorts ucket algorithm step accounts ery small fraction total ecution time performs discuss finally write phase scans ucket array gathering sorted records writing disk model usage single workstation smp sort identical scan disk traf tra els cluster handle network communication ery record read local disk processor determines destination workstation responsible record nal sorted order assuming initial data randomly data remote processors equi alent amount recei processors reading disk cluster sends recei gro lar cross orkstation memory model memory model captures xtra comple xity sort read phase input mapped read user address space accounting memory ensure pages discarded operating system memory manager records copied input fer set sort phase uckets based top bits xamined top bytes pointer record written ucket array buck buck size pair bytes write phase includes scan ucket array buck copy write fer transfer memory disk cluster memory model dif ference cluster ersion basic algorithm occurs read phase simply placing pointers loy cal ucket entire record workstation hold nal sorted-order procesy sor mapped input records copied send fers fer lls destination processor fering cient communication -byte mesy sages achie peak transfer rates messages recei traf abo cross memory receipt records copied record fer xamined partial pointer written ucket array buck single workstation sort processors synchronize complete phase independently sort write set records identical single workstation sort smp memory model model smp ersion sort account communication proy cessors global 
array uckets record fers allocated processor gins reading separate parallel records accessed procesy sor simply acquire lock copy pair global ucket array copy record global record array release lock leads high lock contention poor performance oid proby lem processor small record ucket fer copies records pairs buck fer lls processor grabs proper lock copies buck records global arrays read phase complete processors synchronize vide global ucket fer array themselv sort parallel finally write phase processor gathers records writes disk single workstation sort ransp ose nal benchmark transpose similar operation found xternal scienti codes out-of-core fft basic operation ith tool found sorting records machine ailable memory small amount paging traf occurred increased input size traf steadily worsened machine thrashing sort write phases readily diagnosed clas sic prob lem read system call system uny necessarily fering input size reached half ailable memory operating system forced discard memory pages replacement polic chose discard running sort program fered useless input switching mmap inter face madvise inform system sequential access pattern found sort records paging desired optimizing internal rting aluate shorten internal sorting time mony itored cpu utilization cpubar home-gro visualization tool ecuting -sort cpu utilization observ read phase implied erlap part internal sort read phase suggested performed ucket sort ready ing records disk follo wed partial-radix sort ith optimization reduced in-memory sort time oney million records disks total ecution time cache con guration ool reduce time spent stalled memory touched partial-radix sort made second-le cache optimal number ucket determined size cache current implementation optiy mized cache ultrasp arc-i running -sort dif ferent cache architecture require size second-le cache determined look-up hardware parameter table cache con guration tool similar microy benchmarks sort tri ially modi accept cache size parameter hard-coded constant o-p ass algo rithm two-pass ersion -sort erages code ptimized -pas ort highesty phases eate runs application repeatedly reads portion input sorts writes sorted run disk kernel-threads erlap reading writing disk fect one-pass sort called multiple times time half ailable memory merge runs sorted runs read disk mer ged single sorted output run created rst phase mapped memory records written disk record west-v alued picked top run copied output fer output fer lls written disk optimizing disk bandwidth measurements initial two-pass implementation ealed creating runs xpected amount time mer ging slo wer desired observing deli ered read disk bandwidth simple diskbar tool quickly illuminated problem reading sorted run sequentially layout multiple runs disk resulted isk etwee ery read signi cantly reducing achie bandwidth achie -peak bandwidth disks -sort amortizes disk seek-time carefully managing mer lar amount data xplicitly prefetched run reading ything empir ically found prefetch-b fers suf ciently lar achie -sequential performance kernel threads required successfully prefetch data writing disk reader thread gins copying run mer fer mer ger thread waits set fers full copies record west-v alued output fer output fer lls writer thread writes fer disk marking fer empty nished eop page bop seek con guration ool general fer size mer phase calculated automatically function disk characteristics disk cony guration tool return disk seek time peak disk bandwidth application non-sequential transfers simple calculation eals required size transfer obtain desired fraction peak disk bandwidth discussion ability focus single-node performance essential tool deb ugging performance analysis parallel machines -sort optimize cache memory processor performance single-node algoy rithm kno beha vior hold parallel algorithm found automatic con guration high-performance applications adapt wide ariety system parameters adapting -sort system parameters simpli concentrating beha vior single node wards end eloped memory capacity disk bandwidth con guration tools cache disk seek time tools dynamic vironment tools serv dual purpose adapting sort arying hardware parameters dif fering speed disks dif fering amounts memory crucial setting xpectations ithout xpectations determine achie ving acceptable transfer rates disks making fecti ailable memory traditional tools report code spending time report stop tuning xample pro ling nal code inform code bound sort implies tuning completed applications imply tuning needed identifying performance problems single node simpli feedback small set visualization tools implemented cpubar tool displays current cpu utilization vided user system wait idle time diskbar displays deli ered bandwidth local disk including swap partition current xt-based tools top iostat report similar information update statistics found update rates order ten times necy essary capture ursts resource usage cpu tool xtual counterpart enabled visualize summation multiple compoy nents simultaneously anomalies simple tools found incredibly ving instantaneous continuous vie system beha vior today rarely run applications concurrent monitoring uning in-memory beha vior sort easier xpected lar gely due elopment cache-sensiti algorithms pre vious researchers early xpey rience ran shade instruction set simulator aluate implementation lar gely easily match reported statistics back speci lines user -le code information tuning shade trace kernel code important interactions -sort algorithm internal sort consumed lar ger fraction total ecution time tools speci cally aimed nding memory bottlenecks cprof memspy ne-tuning codes interact underlying software systems communication layer crucial tools information user -le code modifying tools work tandem complete machine simulator simos rallel erfo rmance focusing single-node performance eloped xcellent uilding block scalable sorting algorithm step wards lar ge-scale parallelism set xpectations parallel performance ning xpectations implemented algorithm small number machines small cluster con gured full set disks found implementation meet initial xpectations single-node ersion -sort found discrepancies xpectations measured formance found remo inef ciencies impley mentation parallel ersion dif ferences found due unrealistic xpectations based erly simplistic model system ning xpectations measuring small cluster determine hardware con guration entire cluster machines ning exp ectations ideal case process ecuting parallel appliy cation sorts number records amount time single-node ersion scalability -sort perfect problem size increased linearly number workstations microbenchmarks acti message communication formance transferred nodes implication bandwidth sending set records node requires noticeably time reading records reads blocks w-major order writes disk column-major order blocks benchmark departure -byte records pre vious benchmarks model model phases single workstation smp write phase cluster match benchmarks model read phase cluster corresponds sort orkstation memory model single node transpose reads input set writes transpose blocks disk reading blocks disk copies column-ordered fers xample program transposes blocks array rst block read fer location location write phase writes blocks sequentially operation complete ving cluster memory model cluster mapping input disk memory node repeatedly sends block local memory-mapped input selected destination node recei ving message processor copies proper fer location based processor block input data read memory proper destinations processor writes data local disk phase communication identical single-node case smp memory model smp ersion gins processor sequentially reading data disk copying fer transpose performed shared memory processor claiming required portion processors data writing disk ving memory write benchma summa models resource usage summarized figure parallelizable workloads scan models identical platforms cluster usage read phases sort transpose roughly times stand-alone workstation due addition network communication finally memory usage cluster smp increases communicating cluster xtra copy performed aggre gate small messages lar ger smp xtra copy oid false sharing lock contention eop page bop starttexfig begindocument graphs unify absolutewsbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate bandwidth delivered disk cshow grestore benchmark phase cshow workstation cshow zzz replace ltb ltb zzzbeg arc arc helvetica findfont scalefont setfont cpu cshow zzzend zzzbeg arc arc helvetica findfont scalefont setfont cpu cshow zzzend stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs unify absoluteclusterbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow cluster cshow zzz replace ltb ltb zzzbeg arc arc helvetica findfont scalefont setfont cpu cshow zzzend zzzbeg arc arc helvetica findfont scalefont setfont bus cshow zzzend stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs unify absolutesmpbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg 
hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow smp cshow zzz replace ltb ltb zzzbeg arc arc helvetica findfont scalefont setfont cpu cshow zzzend stroke grestore end showpage enddocument endtexfig figure absolute erf ormance gur plot incr emental hie ved disk bandwidth benc hmarks eac oup bars scales number disks ocessor measur ate matc xpectations denote disk add parallel xpectation enumerated single-node sort erlap communication phases sort sections present 
algorithm attempts hide cost communication read phase sort discuss xpectation met amount disk bandwidth node increased algo rithm design reduce comple xity tuning parallel sort chose programming model pro vides xplicit control operations performed node single-program-multipley data spmd spmd programming model acti messages one-pass two-pass parallel sorts direct xtensions single-node algorithms ease design due lar gely acti messages paradigm allo communication inte grated on-going computation natural fashion change single-node ersions occurs records initially read disk record eop page bop read disk range-partitioned set worky stations machine recei roughly equi alent fraction data workstation recei ving west-v alued workstation west records temporarily fered transmission multiple records single acti message achie ving communication bandwidth receipt message acti message handler splits uckets copies record record array internal sort write steps entire mer phase two-pass sort identical single-node ersions require communication nodes difying exp ectations aluation onef two-pass parallel sorts bey gan measurements -node cluster ultrasp arc workstations disk initial xperiments rey ealed desired properties algorithm communication costs completely hidden wait time unnecess ary paging data transferred disk peak bandwidth gligible internal sorting time added disks cluster found performance increase xpected found direct method isolating perfor mance problem run application hardware performance counters measure beha vior program dif culty methodology vironment ultra workstation cpu performance counters capture memory traf trafy solution employ sophisticated machine ultraenterprise array performance counters memory chine -processor smp shut processors utilized machine ordinary workstation xtraordinary counters running sorting code counters produced formance pro ealing disks workstation cpu saturated cpu reaches peak utilization due cost initiaty ing reads disk simultaneously sending records remote nodes copying uckets saty urates handling disk network send network recei traf ery byte read disk roughly bytes tra architectural bottlenecks reached bene erlapping reading disk communication communication costs hidden disks workstation performance xpectations mitigated pre vious models based nai understanding machine architecture actual measurements foresee bottlenecks fact originally proy jected disks machine ideal purchase entire cluster running small numy ber well-con gured machines understand architectural limitations hardware vironment correctly shape future hardware purchases entire -node cluster sort cost one-pass sort disk system memy ory half desired sort time minutesort seconds disks cost-performance workstation system read write approxy imately machine memory roughly records accounty ing memory requirements operating system application workstation physy ical memory result calculations hardware entire cluster upgraded disks workstation memory workstation due udget donation limitations ith insuf cient memory one-pass attempt minutesort benchmark measurements continued rely two-pass sort discussion accurate models predictions performance correctly purchase hardware lar systems modeling memoryg o-intensi parallel program non-tri vial task accurately predict resource usage running -sort small well-con gured clusy ter gauge worthwhile hardware purchases entire system models easily constructed comy prehensi set hardware counters els machine modern processors reasonable set formance counters sho detailed performance pro ling components machine xample researchers sho network packet counters xtremely monitoring in-coming out-going packets minimally -bit counters ailable ery interconnection system memory workstation switches nety work counters track number bytes pass monitored part system rey source utilization speci information vice helpful xample disks report seeks transfers include tags dif ferentiate traf pid counters allo tracing short periods acti vity facilitate detailed studies portions code coly lecting data techy niques feeding results back user standard formance monitoring tools cpubar diskbar rst step allo wing user bottlenecks system adv anced systems counters pinpoint troublesome sections program interest scaling system xpectations set ful lled small number machines ready scale -sort full cluster size section discuss dif culties encountered scaling processors general dif culty deb ugging scaling algorithmic aspects sort challenge arose scaly ing characteristics underlying sub-systems distrib uted operating system communication layer ith sub-systems found performance slo wly grade workstations fell clif radical drop performance occurred workstations cluster size system elopers stopped aluations distributed erating system datamation minutesort benchmarks start-up time application included meap eop page bop surements essential task glunix boty tleneck lar cluster sizes encountered start-up times seconds medium-sized clusters nodes starting job nodes required seconds ogether glunix elopers tracked interesting performance set group job glunix daemon performing nis request centralized nis serv lar parallel job meant man clients simultaneously requesting data nis serv shared ethernet responds client sequentially remo ving call nis serv tri vial local system call set group found thought performance problem remo ving group-id slowed start-up time manual instrumentation code ealed bottleneck member paraly lel program set tcp connections start-up process redirect standard input output error glunix client -way parallel job opens socket connecy tions home node lar parallel jobs urst socket-connection requests wed default sockety accept queue entries forced clients timeout retry connection multiple times drasy tically increasing start-up time lar applications time-out retry occur pre viously nis request serialized portion code serializay tion remo bottleneck appeared ortunately size solaris tcp accept-queue readily modi remo ving bottlenecks glunix impro start-up time acceptable ideal range seconds communication running -sort app lication lar gurations stressed communication sub-system distinct ways basic issues arose errors communication hardware insuf cient bisection bandwidth general problems communication layer dif cult isolate indistinguishable performance problems application myrinet local-area network designed pro vide mpp-like backplane local area network setting goal xport w-o erhead high-throughput commuy nication layer design generic acti messages gam myrinet assumed complete hardware messaging reliability medium-sized clusters assumption reasonable bit errors rarely encountered proy cessors lar gest xisting myrinet cluster day bit errors occurred man runs -sort application errors manifested themselv crc errors communication layer recognized reco terminating application current ersion acti messages performs reliable message transfer top reliable medium temporary solution gam reduce number outstanding messages allo wed w-control layer limiting load network soluy tion desired fect reducing chance bit errors disastrous side-ef fect halving achie bandwidth worse change made kno wledge shortly april deadline sorty ing results theoretically sorted seconds sorted seconds stands current minutesort record lar con gurations bisection bandwidth network insuf cient all-to-all communication pattern -sort elopment reay sons earlier phases project distinct clusters roughly machines network topology designed bandwidth clusters suf cient insuf cient links clusters racking bandwidth cienc network dif cult anticipated due deadline pressures suf ciently micro-benchmark 
nety work running -sort assumed lar ger network continued meet xpectations eloped smaller cluster observ utilization links switches inter nal network performance counters readily dif ferentiate poor performance due insuf cient bandwidth poor perfor mance due algorithmic characteristics found adding links bandwidth solv problem discussion dif culties learned numb aluab les son application writers deb programs runy ning lar number nodes interacti vironment realistic assume programmers track ugs smaller number nodes -sort algorithm scalable man cases underlying system lar ge-scale systems system designers access tools restricted application-le programs support system-le performance tuning hoc laborious proy cess arallel pro ling tools quartz modi cluster vironment dey elopers glunix tool aradyn helpful oiding lengthy recompiles allo wing dynamic instrumentation interesting pieces code pro viding visual feedback isolating performance problems frustrating dynamic vironment libraries daemons system services change altering application binary case one-line change acti message library lead astating performance results ools understand complete dependence tree application notify user occur helpful elopmental systems con guration management tools good match problem dif culty approach follo wing chain dependencies xample eny vironment applications link glunix library access glunix glunix library changed glunix user -le daemon contacted library finally lar ge-scale systems commonly tuned tar system size research vironment lar gest common platform testing chines due contention resources elopers result system beha size quickly found system scale desired full clusy ter size implication system elopment groups estigating uild systems consisting worky stations entire system workstations greater eop page bop needle w-stack system scaled nal step chasing sorting record successful unperturbed run sort performance -sort sensiti arious disy turbances requires dedicated system achie peak results section discuss solv set par ticular run-time performance problems foreign agent competing process inadequate memory full disk machines slo wed entire appliy cation general hierarchical process similar search process rst step nding needle -stack slo workstations clusy ter identi step remo ving needle speci problem slo workstations identi solv finding needle process parallel sort performs amount work machine disturbance slo entire application -sort xhibited wer xpected performance isolated nodes distur bances ways ran glunix status tool glustat reports load erage ailable virtual memory workstation cluster nodes anomalous alues ily singled nodes appeared homogeneous glunix ran -sort addiy tional timing statistics displayed rkstation ery phase workstations noticeably slo wer phase pointing machine needle identifying removing needle slo machine isolated dif fer ent machine compared cluster common needles found machines faulty hardware xtra processes competing cpu ailable memory xtra data disks aulty har dwar rst needle encountered consisted machines faulty misbeha ving hardware ginning ware machines -node cluster ilable due faulty wer supp lies motherboards machines een adequate running compute-intensi sequential processes network-interface disk problems cluster machines found usable -sort cpu stealing tri vial common needle foreign job running workstations compety ing process viously slo sorting process workstation slo workstation identi standard process monitoring tools top identi culprit killed memory hog common performance problem caused dif ference free memory machines notable needle scenario glunix master daey mon workstations running sort separate administrati machine cpu requirements master gligible memy ory footprint result sort process running master gan page interfering sequeny tial acti vity racking aberrant glunix process pro dif cult xpected due small dif ferences olv disk layout performance -sort seny siti layout les local disk multiy zone disks signi cantly higher bandwidth data allocated outer tracks full disks lead pected data rates disk con guration tool eri read performance aries signi cantly depending disk layy eral times tracking slo node quick inspection ealed scratch disk full user temy porary les remo les sort performance returned xpected discussion hierarchical methodology rst isolating problematic workstations identifying speci disturbances rey quired performance isolation workstations hard boundary workstations allo wed drill-do focus performance component cpu memory system disk lar ge-scale systems resources aggre gated single interface smps raid-style disk systems lend themselv naturally hierarchical approach strate allo wed successfully solv performance problems required fair amount intelligent user iny terv ention automatic approach desirable users familiar components system xample problematic workstations agged sophisticated tool performance assertion checking ith tool simple assertions performance xpectations code agged succeed standard parallel tools bottlenec cpu exp erimental results section main xperimental results pay gin presenting absolute performance benchmark platforms sho amount deli ered disk bandwidth disks added system establishes facts rst workloads well-tuned fecti ely multiple search process limitations pre ented limitations arise due ced fea tures solaris erage kernel threads disks memory-mapped les point xample benchmarks aradyn reach system work bottleneck threaded proceed apy plications xamining eliminates resource path single-node disk one-pass cpu sort memory codes processor make hea interconnect processor mmap absolute access erfo les rmance man rst sho tools lute track rformance ttained read eac write enc system calls mark reporting platforms beha vior disks added system sysy ablo tem tracks read ideal write system calls achie bandwidth matches breakdo wns peak disk requests rate sizes multiplied times number access disks ith system mmap system disk dif deli cult requiring iny strumentation loads reading stores disk mapped gions identifying speci problems writing simpli disk figure sho viy increase sualization tools bandwidth achie eloped phase section benchmarks problem platforms feedback ample read phase run meters sort single nodes due workstation lar rst bar amount group windo traf data read generate disk adv anced bars sho system adding collect data additional locally disks yields node xpected bene collate disk present adding roughly animation sum wise bars spey problem sho automatically identi total data rate constantly achie monitoring processor memory disks disk utilization fourth disk added machine reporting gain anomalies read user bandy width found xing problems xpected easy indicating reached bottleneck reasonable understanding system comy ponents system users familiar berkele cluster dif cult time isolating anomalies xing problems required interfering rights users killing jobs remo ving les users permission perform case actions cpu bottleneck process graph safely automated summarize eop page bop disks conclusions workstation single paper workstation sort presented reaches cpu xperiences bottleneck writing cluster performance tuning falls -sort read current phases world-record holder sort xternal transy sorty pose ing due crucial cpu attaining peak bottleneck performance respecti ely setting performance occur xpectations disks allo wed workstation finally smp performance performance problems grades sort write phase belie sort tools disks users set processor xpectations due great cpu alue case proceed simpler xploring resource detail main xpectation bus achie peak gin disk bandwidth xploration system resources process made number tools measurements attain peak performance traf con guration tools helped platforms match set predictions xpectations models measurey automate ments utilization parameterization sun eal single workstation sort arious disk systems memory sizes isualizay tion tools instant visual feedback performance sort allo wing quick deductions location performance problems finally hierarchical search tools helpful automating search performance anomalies end mix simple tools hoc practices achie performance desired chaly lenging xternal sorting benchmark minutesort sorted total minute nodes passes deli ered sustained perfor mance sort application roughly peak rate deli ered time nal record achie minute nodes time pass deli ered bandwidth apy plication high case due glunix start-up dif culties one-line change underlying commuy nication layer nal imperfect total serv reminder nature journe ackno wledgments -sort combined fort members berkeley project contrib uted success rich martin doug ghormley extend special jim gray chris 
nyber sparking interest sorting encouragemen sage advice finally shepherd mar garet martonosi anonymous vie wers pieces feedback work funded part arp -cy arp -co nsf asa fdn california state micr program remzi arpaciy dusseau supported intel graduate fello wship acharya uysal bennett mendelson beynon hollingsworth saltz sussman uning perfor mance intensi parallel applications oceedings ourth orkshop input output arallel distrib uted systems pages philadelphia press agarwal super scalar sort algorithm risc procesy sors sigmod confer ence pages june anderson culler patterson eam case networks orkstations ieee micr february anderson lazo wska quartz ool uning parallel program performance oceedings sigmetrics performance confer ence measur ment modeling computer systems pages arpaci-dusseau arpaci-dusseau culler hellerstein patterson high-performance sorting networks orkstations sigmod arpaci-dusseau arpaci-dusseau culler hellerstein patterson architectural costs streaming comparison orkstations clusters smps hpca february boden cohen felderman kulawik seitz myrinet gigabit-per -second local area network ieee miy february chapin herrod rosenblum gupta memory system performance unix cc-numa multiprocessors sigmetrics erformance confer ence pages cmelik eppel shade fast instruction-set simuy lator execution pro ling oceedings sigmetrics confer ence pages culler dusseau goldstein krishnamurthy lumetta eicken elick parallel programy ming split-c super computing culler liu martin oshikawa logp performance assessment fast network interfaces ieee micr dec decchip risc microprocessor preliminary data sheet echnical report digital equipment corporation measure ransaction processing wer datay mation readings database systems stonebraker mor gan kaufmann san mateo ghormley petrou rodrigues ahdat anderson global layer unix network orkstations softwar practice experience hollingsworth inding bottlenec lar ge-scale arallel ograms phd thesis uni versity isconsin aug hollingsworth miller content-deri ved names con guration managem ent symposium softwar reusibility boston kleiman oll eykholt shi alingiah illiams smith barton skinner symmetric multiprocessing solaris oceedings compcon spring lebeck ood cache pro ling spec benchmarks case study ieee computer pages october mainwaring acti message application programming interface communication subsystem ganization master thesis uni versity california berkeley eop page bop martonosi clark mesarina shrimp hardware performance monitor design applications oceedings sigmetrics symposium arallel distrib uted ools spdt february martonosi gupta anderson memspy analyzy ing memory system bottlenecks programs oceedings sigmetrics performance confer ence measur ement modeling computer systems pages mathisen pentium secrets byte pages july meter observing fects multi-zone disks oceedings usenix confer ence jan miller callaghan car gille hollingsworth irvin kara anic kunchithapadam whall paradyn parallel performance measurement ools ieee computer nyber barclay cvetanovic gray lomet alphasort risc machine sort sigmod confer ence perl eihl performance assertion checking oceedings symposium operating systems principles pages december perl sites studies indo performance dynamic execution races osdi pages october reed elford madhyastha scullin ydt smirni performance analysis perfor mance data immersion oceedings masco pages february rosenblum bugnion vine herrod simos machine simulator study complex computer sysy tems ransactions modelling computer simulation oma january saa vedra-barrera cpu erformance evaluation exey cution ime ediction narr spectrum benchmarking phd thesis berkeley computer science vision february stonebraker operating system support database agement communications july sweeney doucette anderson nishimoto peck scalability xfs file system oceedings usenix annual echnical confer ence jan remblay greenley normoyle design microarchitecture ultrasp arc-i oceedings ieee december eicken culler goldstein schauser acti messages mechanism integrated communication computation oceedings annual symposium computer chitectur gold coast australia eop trailer end userdict end-hook end-hook eof 
smp suf cient bandwidth performance cluster limited bus bandwidth orkstation bus leftmost graph figure sho measur ratio data crossing relati data coming disk disks scaled phase workloads predicted applications single workstation usage matches disk traf xample disks ving disk amount crossing viding amount crossing amount read disk ratio bandwidth disk bandwidth gure modeled traf sho horizontal black line models match xperimental results precisely cluster bus cluster communication phases read phases sort transpose interest benchmarks xpected ery read disk -node cluster sho middle graph figure xperimental results con beha vior lar cluster handle roughly times traf stand-alone workstation smp bus single workstation data disk crosses communication traf crosses memory data gure con rms bandwidth ery read written disk bus utilization established demands models empirical measurement apply kno wledge understand architectures study supy port streaming-i applications figure plots utilization applications dif ferent architecy tures number disks increased orkstation s-bus single-processor workstation s-bus suf cient bandwidth support benchy marks high disk transfer rate peak data bandwidth s-bus operating -bit mode theoretically attained ving maximal -word ycle data urst ery ycle arbitration phase due control information form programmed peak utilization occurs figure sho utilization s-bus disks added system disks utilized linear xtrapolation eop page bop starttexfig begindocument graphs unify sbusrelatewsbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate ratio bus disk bandwidth cshow grestore benchmark phase cshow workstation cshow zzz replacing ltb ltb zzz restoring network rshow zzz replacing ltb ltb zzz restoring disk rshow zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replacing ltb ltb zzz add inherent ltb inherent rshow zzz end inherent stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs unify sbusrelateclusterbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke 
setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow cluster cshow zzz replacing ltb ltb zzz restoring network rshow zzz replacing ltb ltb zzz restoring disk rshow zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replacing ltb ltb zzz add inherent ltb inherent rshow zzz end inherent stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs unify sbusrelatesmpbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow smp cshow zzz replacing ltb ltb zzz restoring network rshow zzz replacing ltb ltb zzz restoring disk rshow zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replacing ltb ltb zzz add inherent ltb inherent rshow zzz end inherent stroke grestore end showpage enddocument endtexfig figure bus data movement gur plot atio bandwidth disk bandwidth workloads acr oss platforms models shown horizontal blac lines eac set bars epr esen phase thr benc hmarks eac oup number disks incr eased showing load system incr eased starttexfig begindocument graphs unify sbusutilwsbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate bus utilization cshow grestore benchmark phase cshow workstation cshow zzz replace ltb ltb zzz add peak line ltb helvetica findfont scalefont setfont theoretical peak cshow zzz peak end stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs unify sbusutilclusterbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch 
hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow cluster cshow zzz replace ltb ltb zzz add peak line ltb helvetica findfont scalefont setfont theoretical peak cshow zzz peak end stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs unify sbusutilsmpbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow smp cshow zzz replace ltb ltb zzz add peak line ltb helvetica findfont scalefont setfont theoretical peak cshow zzz peak end stroke grestore end showpage enddocument endtexfig figure bus utilization gur plot utilization workloads acr oss thr hitectur disks added system cluster eac hes peak utilization ead phase anspose bottlenecks system s-bus support approximately disk bandwidth hitting peak utilization s-bus ultra workstation sufy cient bandwidth support disk subsystem internal scsi workstation house internal disks fast-narro scsi peak bandwidth connects disks motherboard con guration limits performance modern disks attached oided cluster s-bus xtra load phases concurrent disk network comy munication s-bus suf fers high contention peaks quickly single workstation scenario figure utilization s-bus read phase sort transpose high disks workstation sho section sort reach peak s-bus utilization ere cpu bottleneck figure s-bus limits performance transpose s-bus tar geted meet bandwidth requirey ments slo wer vices today high-speed disks networks tandem sun microsystems words s-bus optimized technologies xpected dominate late early vident needed support o-intensi apy plications cluster -bit s-bus partially solv widespread ailability -bit cards smp s-bus stated abo smp s-bus utilization identical single-node utilization standards s-bus meet demands enterprise system xamine erall architecture eny terprise filling board slots enterprise symmetrically cpu boards boards machine total s-busses peak achie bandwidth usses single s-bus slot uilt-in fast-wide scsi slot s-bus slots comparison single ultra workstation slots internal scsi attach fast-wide scsi cards ailable slots dri scsi disk bandwidth s-bus transfer roughly half potential data rate lack slots implies modern disk technologies ultrascsi full adv antage ailable bandwidth bus analysis stand-alone workstations problems today technology workstations gro faster future standards pci pro vide bandwidth clusters situation handle times bandwidth standy machines current s-bus technology struggles aggre gate demand disk network traf straighty forward solution pro vide separ ate paths disk network traf multiple usses recent machine sun ultra workstation good xample pci usses make machine ideal cluster computing radical solutions suggest placing network interface memory solv problem remo ving traf placing additional load eop page bop starttexfig begindocument graphs unify mbusrelatewsbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate ratio memory bus disk 
bandwidth cshow grestore benchmark phase cshow workstation cshow zzz replacing ltb ltb zzz restoring processor-memory rshow zzz replacing ltb ltb zzz restoring network rshow zzz replacing ltb ltb zzz restoring disk rshow zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replacing ltb ltb zzz replacing ltb ltb zzz replacing ltb ltb zzz add inherent ltb inherent rshow zzz end inherent stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs unify mbusrelateclusterbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow cluster cshow zzz replacing ltb ltb zzz restoring processor-memory rshow zzz replacing ltb ltb zzz restoring network rshow zzz replacing ltb ltb zzz restoring disk rshow zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replacing ltb ltb zzz replacing ltb ltb zzz replacing ltb ltb zzz add inherent ltb inherent rshow zzz end inherent stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs unify mbusrelatesmpbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz replace ltb ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow smp cshow zzz replacing ltb ltb zzz restoring processor-memory rshow zzz replacing ltb ltb zzz restoring network rshow zzz replacing ltb ltb zzz restoring disk rshow zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb zzz replacing ltb ltb zzz replacing ltb ltb zzz replacing ltb ltb zzz add inherent ltb inherent rshow zzz end inherent stroke grestore end showpage enddocument endtexfig figure memory bus data movement gur plot atio memory bandwidth disk bandwidth modeled amount data movement shown horizontal blac lines -pr edicts actual usage noticeable amount due inter actions cac bloc size oper ating system zer oing copying case cluster copy communication layer memory workloads question bandwidth latenc sensiti solution justify costs finally smp systems standard usses proy vide plenty disk bandwidth foreseeable future architecture pro vide adequate number slots attaching disks memo bus beha vior benchmarks memory memory traf dif cult model models consistently predict memory usage sho underlying cache architecture operating system communication layer responsible dif ferences balance platforms ultra workstation memory bottleneck streaming plenty ailable bandwidth benchmarks workstation cluster xtra copies abound due communication memory interconnect suf ces memo bus bandwidth orkstation memory bus figure sho measured memory traf ratio disk bandwidth inher ent traf designated black horizontal line group bars main reasons models underesy timate memory traf mismatch natural grain size -byte cache blocks operating system beha vior fects account memory traf xplained extra traf occurs read phase scan due distinct interactions cache scan amines -byte ery -byte record -byte block fetched cache transferred memory predicted copying selected records outy put fer -byte record lies cache blocks worst-case ery record matches scan criteria generate generates similar granularity mismatches occur sort dif cult analytically determine memory trafy repeated accesses data cached worst case xamining -byte -byte records full -byte cache block accessed scattering -byte pairs random uckets entire cache line read written generate empirical results sho worst case realized work 
including simy ulations user code operating system required understand beha vior detail part future work operating system beha vior represented models generates signi traf benchmarks read phase hmarks erform work required bring blocks disk pages allocated user process sort transpose entire data set copied user -allocated fer zeroed demand half zeroing takes place scan match total records copied found empirically total traf memory read phase sort transpose scan cluster memory bus figure sho memory trafy -predicted cluster models read phases ort transpo pha tha perform communication dif fer single-workstation imy plementation xtra traf captured mody els rest arises beha vior message layer sort transpose benchmarks send fer communication layer copy fer pre-pinned pre-mapped gion address space dma opy erations performed network vice result signi cantly traf passes memory cluster single-workstation benchmarks sort cross ery read disk smp memory bus memory traf smp benchmarks xcept read phase sort ideny tical single node measurements figure sho xtra generated ery transferred disk belie xtra traf due contention system fers oid lock contention false sharing application oid contention underneath sort transpose benchmarks smp input fers starting measurements results memory traf read phase ithout explicitly performing operation performance suf fered extent fully utilize ven disks cpu eop page bop memo bus utilization present aluation ultra memory systems measure memory utilization workstation estimate utilization based speci cations orkstation inter connect designed support small-scale smp systems -engineered simple case single processor inside workstation -mhz ultrasp arc processor dri memory system memcpy interconnect theoretically capable sustainy ing roughly sort memory-b intensi applications memy ory ery transferred disk peak memory interconnect read disk sub-system cluster inter connect due high capay bility memory interconnect amount memy ory traf generated sort erload memory system sort memory interconnect part system bottley neck reaches yond system components handle ultraenterprise memory system gigaplane main system interconnect enterprise systems bandwidth interconnect high capable deli ering memory banks compare cluster interconnect defer discussion section interestingly memory bandwidth ultraenter prise scales memory capacity system memory banks bank serv increase total memory bandwidth adding dram bank bank lled small capacity systems small performance capabilities iny deed early xperiments serv con gured memory banks limiting sustainable performance processors running copy micro-benchmark similar memo bus analysis subtleties program interaction cache architecture operating system network commuy nication lead xcess memory traf mismatches grain size applications block size cache architecture dif cult oid requiring application wareness underlying machine architecture reducing number copies performed operating system communication layer tractable man modern operating systems oid xtra copies proy viding direct non-b fered allo applications bypass system fer cache ersion soy laris includes functionality zeroing pages protection dif cult oid continue play important role streaming workloads cluster communication results xtra copies current vironment potentially oided xample cluster sort rst copy xplicit program -byte records copied lar ger blocks amortize erhead sending message copy oided tight inte gration nety work interface processor wering erheads allo wing applications send mall mess pea rates copy occurs message layer copy fers portions address space setup dma transfers copy oided xposing communication fers application lar gest reduction memory traf cluster direct disk-to-network transfers completely oiding memory application sort dynamically determine destination -byte record requiring application-speci code disk controller communication interconnect xamine demands communication backplane cluster smp intercony nects signi cantly dif ferent demands bottleneck real systems interconnect bandwidth cluster inter connect analyze communication rates links attaching machines network toy tal amount traf generated nodes established section workstation sends recei roughly read phase sort transy pose link connects machine switch support traf direction ith processors sending aggre gate bandwidth ving network read phase smp inter connect smp interconnect support memory traf surprising resource hea contention xample figure phases scan processor places roughly memory ery read disk scan places roughly shared interconnect sort places transpose roughly scan dif ference aggre gate bandwidth smp intercony nect cluster interconnect roughly factor bandwidth requirements mediums scale linearly processors interconnect utilization myrinet network analyze ability myrinet hardware support traf -node cluster assumy ing single -port switch myrinet links sustain direction suf cient bandy width reaches garding abily ity myrinet switches handle total communication bandwidth switch perfect crossbar support aggre gate bandwidth port cony tention myrinet switch bottleneck total network traf long s-bus handle myrinet links switches pro vide ample bandy width capacity relati today disk speeds current networks proper performance gime ample mbps fast ethernet connection pro vides link bandwidth support disk bandwidth workstation gigaplane enterprise gigaplane support roughly data transfer -processor system established transferred benchmarks place gigaplane achie peak utilization worst case limit amount -processor disk traf eop page bop interconnect analysis processor -to-processor interconnect main concern system designers conclude streamy ing applications small-scale parallel systems uny bottleneck cluster interconnect pro vide bandwidth scales linearly number disks workstation streaming benchmarks switch essentially capability handle sum disk traf lar ger systems consist switches interconnect scale mediumy lar ge-scale clusters smp interconnect handle aggre gate memory data ement small-scale systems modern aggressi usses gigaplane suf cient pro cesso section xamine processing requirements streaming gin analyzing number iny structions ecuted byte read written disk study arc-bas sys tems belie relay tionships coarse estimates risc-based machines understand ultrasp arc procesy sor ecutes workloads measure processor utilization cpi instructions implementation indepeny dent utilization cpi directly determined number architecture-speci factors including branch beha vior memory latenc cpi platforms benchmarks high result processor bottleneck workloads note characterizations section preliminary xact breakdo instructions ecuted time spent part on-going research pro cesso instruction rates orkstation ocessor figure sho number iny structions millions ecuted system user mode deli ered disk bandwidth number instructions ecuted system mode cony stant benchmarks writing write requires system instructions reading mmap due xtra memory copy fer cache main dif ference benchmarks arises work user -le performed ranspose requires amount work read phase user code performs single copy record read phase scan ecutes instructions compared selection criteria copies performed granularity write phases transpose scan perform essentially work user repeatedly calling write data disk sort processor intensi due mismatch disk representation records form internal sorting disk records comprise linear array internal sort 
ecutes -byte separated lar ger records groups second-le cache records read disk scattered uckets pointers set full records write phase erse operation gathering records linear array writing disk cluster ocessor major increases instruction rates relati single workstation occur sending recei ving messages read phases sort orkstation cluster smp sys user sys user sys user scan read write sort read write rans read write figure ocessor instruction rate table shows mips disk bandwidth transpose benchmarks communication performed user increase user instruction counts transpose minimal instruction cost form ulk-message network communication immey diately sends block read disk increase transpose read phase workstation cluster sho slightly mips required send recei data work comy bined system user cost reading writing disk cost communicating greater sort benchmark -byte records copied abstract high-performance sorting networks workstations appeared sigmod andrea arpaci-dusseau remzi arpaci-dusseau david culler joseph hellerstein david patterson report performance now-sort collection sorting implementations network workstations find parallel sorting nows competitive sorting large-scale smps traditionally held performance records -node cluster finish datamation benchmark seconds sort minute smaller equipped -node cluster run datamation seconds sort minute implementations applied variety disk memory processor configurations highlight salient issues tuning component system paper evaluate commodity hardware operating systems parallel sorting note lessons drawn applying technology data-intensive applications abstract compressed postscript postscript now-sort home page 
fers amortize startup cost communication smp ocessor similar cluster sort smp ersions benchmarks perform additional work copy data fering performed oid false-sharing lock contention xample sort copying temporary fer inserting global ucket array increases instruction costs mips higher instruction costs read phase scan write phases programs belie due lock contention kernel pro cesso utilization cpi orkstation ultrasp arc-i figure sho cpu utilization cpi benchmark graphs ascertain sustainable disk bandwidth platform cpu limited single workstation sort places load processor reaching cpu utilization disks roughly xplains drop absolute performance figure earlier section benc hmarks fair wha xtrapolating cpu utilization predicts cpu bottleneck roughly trans ferred disk benchmarks cpu xpected primary bottleneck predicted memory usses handle respecti ely saturating cluster ultrasp arc-i cluster measurements sho fast communication layer places hea demand ultrasp arc processor xample processor utilized read phase sort disks cpu bottleneck adding disks workstation impro performance sorting transpose read fairs reach utilization disks workstation reader tice ber system instru ction rea phase tran spose ecreases clu ster smp imp lemen tation cluster repeatedly small fers lar fer ving operating system cost zeroing pages smp versions pages read phase begins result reducing smp instructions relati platforms eop page bop starttexfig begindocument graphs unify cpuutilbothwsbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz begin rshow rshow rshow rshow rshow rshow zzz end zzz replace ltb ltb rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow nowsort cshow cshow cshow kuuuu cshow cshow cshow cshow cshow cshow cshow cshow vjx wzw h-o cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate mblz rotate cpu utilization cshow grestore benchmark phase cshow workstation cshow zzz replacing ltb ltb zzz restoring system rshow fpx bezo szh vnh woq hnb zzz replacing ltb ltb xcj xsd pac ljh lap xlsd hgc zzz restoring user rshow zzz replace ltb ltb cpi rshow xwr kvu dhz buh ajpp zzz replace ltb ltb tev xzh mak lcw wahve zqk zzz replace ltb ltb twh svb wwbds swr xnl r-i stroke grestore vgpa end showpage ogq enddocument endtexfig clg cgd starttexfig begindocument graphs unify cpuutilbothclusterbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow rfb currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift dgxc show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu jow setlinewidth ltb lta setdash setrgbcolor cps zbp stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke itx stroke setdash vpt vpt currentpoint egyn alwv yrm obr sjcs cfn stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath lrf stroke stroke setdash exch hpt exch oxy vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt bej stroke stroke setdash copy vpt mul add hpt ayd neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz begin yhl rshow ehv rshow rshow rshow rshow rshow zzz end zzz u-s replace ltb ltb rshow jvk rshow rshow rshow rshow rshow helvetica zgtk findfont scalefont setfont scan cshow scan cshow sort azz cshow szk sort cshow trans cshow nsd trans cshow zzz begin helvetica ljm findfont scalefont setfont cshow cshow hhc cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark fucv phase cshow cluster cshow ybc ivs lio dgr vda zzz replace ltb ltb txe zzz replace ltb ltb gsj lan tik zzz gcp replace ltb ltb svo ndc stn wtc stroke grestore end showpage enddocument endtexfig rhw starttexfig begindocument graphs unify cpuutilbothsmpbars eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor 
stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath zzz replace ltb ltb zzz begin rshow rshow rshow rshow rshow rshow currentpoint gsave translate rotate cpi cshow grestore zzz end zzz replace ltb ltb rshow rshow rshow rshow rshow rshow helvetica findfont scalefont setfont scan cshow scan cshow sort cshow sort cshow trans cshow trans cshow zzz begin helvetica findfont scalefont setfont cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow zzz end helvetica findfont scalefont setfont currentpoint gsave translate rotate cshow grestore benchmark phase cshow smp cshow zzz replace ltb ltb zzz replace ltb ltb zzz replace ltb ltb stroke grestore end showpage enddocument endtexfig figure ocessor utilization gur plot ocessor utilization bars corr espond ing left y-axis label cpi line corr espon ding y-axis label workloads acr oss platforms workloads ocessor main bottlenec system ving disk sort transpose cpu s-bus reach peak utilization simultaneously read phase transpose high cpi reasons data locality accessing blocks data leads high cache miss rates fect measured single workstation accessing network interface card s-bus xpensi cpi gro number disks contention increases smp ultrasp arc-i cpu utilization sho sort smp erage disks processor general cpu utilization smp higher single workstation number instructions ecuted similar utilization graphs platforms illustrate importance operating system performance streamingy workloads benchmark platform time spent kernel dominates spent user -le number disks increases interestingly number instructions ecuted biased high cpi poor kernel cache performance pro cesso analysis processor main bottleneck workloads platforms xcept situations cluster vironment ouj limits performance approaches wering processor utilization sfu workloads rst reducing number instructions communication layers acti messages pro vide minimal cost primiti network access time visit instruction costs disk high instruction cost disk acces xace rbated solaris operating system generality modularity support threads increase common code path disk instruction costs reduced additional support lar block operations instruction set approach focuses wering cpi easiest solution hardware tighter inte gration memory system software lesson feasible current systems operations cache conscious crucial group data accesses secondy cache-sized objects oiding high cost repeated access main memory style programming xtensi ely plan estigate support applications achie locality conclusions presented measurements resource costs data ement machine architectures platy forms eloped models benchmark resource usage alidated models empirically measured utilization resource amou disk ban dwidth system scaled order aluate architecture perspecti set kernels summarize results present graphical reprey sentation means balanced system figure plots balance platforms phase workloads question machine resources machine sho x-axis y-axis plots prey dicted -processor disk bandwidth added machine resource reach saturation workloads alue based linear xtrapy olation usage characteristics found earlier sections set bars height balanced system set higher bars system gure machines balanced platforms rst resource bottleneck processor due lack locality streaming benchmarks fact benchmarks cpi wer processor potentially ecute instructions ycle single workstation memory iny terconnect stand-alone workstation -engineered bottleneck types workloads cluster limits performance phases etwork commu nication surprisingly benchy marks communication balance cluster worky station defaults stand-alone case memory pro vides plenty bandwidth memoryy intensi benchmarks fairly utilized network backplane myrinet ample bandwidth easily handling trafy rates proportional disk finally smp absolute performance result appears balanced architecy tures communication backplane gigaplane handles high load streamy ing application set adequate small-scale parallel systems performance cpu weak link chain surprisingly high cpis processor utilization peaks rapidly end result cluster platform performing workloads dominated streaming eop page bop starttexfig begindocument graphs kiviat eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow obus cshow membus cshow cshow currentpoint gsave translate rotate disk bandwidth saturation cshow grestore zzz begin helvetica findfont scalefont setfont currentpoint gsave translate rotate read cshow grestore currentpoint gsave translate rotate write cshow grestore helvetica findfont scalefont setfont zzz end workstation cshow zzz replacing ltb ltb zzz restoring scan rshow zzz replacing ltb ltb zzz restoring sort rshow zzz replacing ltb ltb zzz restoring transpose rshow zzz replacing ltb ltb stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs kiviat cluster eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth 
div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow obus cshow membus cshow backplane cshow cshow currentpoint gsave translate rotate cshow grestore zzz begin helvetica findfont scalefont setfont currentpoint gsave translate rotate read cshow grestore currentpoint gsave translate rotate write cshow grestore helvetica findfont scalefont setfont zzz end cluster workstation cshow zzz replacing ltb ltb zzz restoring scan rshow zzz replacing ltb ltb zzz restoring sort rshow zzz replacing ltb ltb zzz restoring transpose rshow zzz replacing ltb ltb stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs kiviat smp eps gnudict dict gnudict begin color true solid true gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow obus cshow backplane cshow cshow currentpoint gsave translate rotate cshow grestore zzz begin helvetica findfont scalefont setfont currentpoint gsave translate rotate read cshow grestore currentpoint gsave translate rotate write cshow grestore helvetica findfont scalefont setfont zzz end smp cshow zzz replacing ltb ltb zzz restoring scan rshow zzz replacing ltb ltb zzz restoring sort rshow zzz replacing ltb ltb zzz restoring transpose rshow zzz replacing ltb ltb stroke grestore end showpage enddocument endtexfig figure balanced systems gur ect balance eac hitectur x-axis shows dif fer ent esour system y-axis amount -pr ocessor disk bandwidth intr oduce system befor esour eac hes peak utilization set bars balanced system higher set bars system ackno wledgements authors jim gray eric anderson kim eeton rich martin amin ahdat aluable comy ments feedback suggestions ashok singhal sun performance counters katherine hartsell sun information sun enterprise serv ers sharad mehrotra sun gener ous equipment donation special satoshi asami disks finally shephard jean-loup baer direction setting work conte work sponsored arp contract -cb california state micr program remzi arpaci-dusseau funded intel graduy ate fello wship agarwal super scalar sort algorithm risc procesy sors sigmod confer ence pages june amdahl storage parameters system potential ieee computer oup confer ence pages june anderson culler patterson case networks orkstations ieee micr february arpaci-dusseau arpaci-dusseau culler hellerstein patterson high-performance sorting networks orkstations sigmod boden cohen felderman kulawik seitz myrinet gigabit-per -second local area network ieee miy february chen bershad impact operating system structure memory system performance oceedings annual symposium operating systems pages december culler liu martin oshikawa logp performance assessment fast network interfaces ieee micr measure ransaction processing wer datay mation readings database systems stonebraker mor gan kaufmann san mateo gray personal communication june hill larus reinhardt ood cooperati ve-shared memory software hardware scaly multiprocessors ransactions computer systems kleiman oll eykholt shi alingiah illiams smith barton skinner symmetric multiprocessing solaris oceedings compcon spring kuszmaul out-of-core ffts parallel application vironment echnical report echnical report rndy mccalpin sustainable memory bandwidth current high-performance computers white paper mukherjee hill case making network interfaces peripheral hot inter connects aug nyber barclay cvetanovic gray lomet alphasort risc machine sort sigmod confer ence perl sites studies indo performance dynamic execution races osdi pages october stonebraker case shared database engiy neering sunmicrosystems sbus speci cation white paper orrellas gupta hennessy characterizing caching synchronization performance multiprocessor operating system asplos-v pages october eicken basu buch ogels u-net user -le vel network interface parallel distrib uted comy puting oceedings symposium ope ting systems principles pages december eicken culler goldstein schauser acti messages mechanism integrated communication computation oceedings annual symposium computer chitectur gold coast australia eop trailer end userdict end-hook end-hook eof 
wiuu qkij qknv qls muy quc acv sqw axc fjz jtcx qvd lsqc stg vzc yws gki ahi gee jvi wlikx -nz -kz bnc akuiaj ohic fyt skrqxk zow hhw ifh wox mlon sbut ozg ykkhz zhf vtip cav vzk mbd xysj kim ris wjz kza kwf juuz csau rkg cap eci mwj zju azeo essy lsj ari ps-adobecreator dvipsk copyright radical eye software title nowsort dvi pages pageorder ascend boundingbox documentfonts times-bold times-roman times-italic courier endcomments dvipscommandline dvips nowsort nowsort dvipsparameters dpi comments removed dvipssource tex output beginprocset tex pro texdict dict texdict begin bind exch translate isls false vsize mul hsize mul landplus false rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix dup dup round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding end dup foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop dup definefont setfont ch-width ch-data dup length ch-height ch-data dup length ch-xoff ch-data dup length ch-yoff ch-data dup length ch-dx ch-data dup length ch-image ch-data dup type stringtype ctr ctr ctr add charbuilder save roll dup base index bitmaps ch-data pop ctr ch-dx ch-xoff ch-yoff ch-height ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true ch-xoff ch-yoff ch-image imagemask restore dup type stringtype base ctr put bitmaps ctr dup dup length dup index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore showpage userdict eop-hook eop-hook start userdict start-hook start-hook pop vresolution resolution div dvimag array string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div ifelse forall metrics metrics currentdict end index currentdict end definefont roll makefont setfont load cvx obliqueslant dup sin cos div neg slantfont index mul add extendfont roll mul exch reencodefont encoding exch end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter note legal scaleunit hscale scaleunit div hsc vscale scaleunit div vsc hsize clip vsize hcf epj yll gpz clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform roll itransform roll itransform roll curveto closepath pathforall newpath counttomark array astore xdf pop put courier fnt invertflag paintblack txpose pxs pys scale ppr aload pop por noflips pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage copypage macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse clip newpath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath clip showpage erasepage copypage newpath endspecial count ocount pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset texdict begin nowsort dvi start times-italic courier times-bold times-roman times-italic times-roman times-roman times-bold times-bold end endprolog beginsetup feature resolution dpi texdict begin endsetup page bop high-p erf ormance sorting netw orks orkstations andr arpaci-dusseau computer science vision uni versity california berkeley dusseau berk ele remzi arpaci-dusseau computer science vision uni versity california berkeley remzi berkeley vid culler computer science vision uni versity california berkeley culler berkeley oseph hellerstein computer science vision uni versity california berkeley jmh berkeley vid patterson computer science vision uni versity california berkeley patterson berke ley abstract report performance -sort collection sorty ing implementations network orkstations parallel sorting competiti sorty ing lar ge-scale smps traditionally held performance records -node cluster sort minute -node cluster nishes 
datamation benchmark seconds implementations applied ariety disk memory processor con gurations highlight salient issues tuning component system aluy ate commodity operating systems hardware parallel sorting xisting primiti memory management access adequate due aggre gate comy munication disk bandwidth requirements bottleneck system workstation intro duction past years dramatic impro ements speed sorting algorithms lar gely due increased atteny tion issues computer architecture sorting results date produced industrial rey searchers working xpensi well-endo wed ersions shared-memory parallel computers smps produced parent companies paper describe achie records sorting performance relati ely modest shared-nothing network general-purpose unix workstations set minutesort record bytes -node cluster ultrasp arcs datamation benchmark record seconds -node cluster network orkstations sorting number bene pro vide high-de gree performance isolation allo analysis bey vior node-by-node factor -by-factor basis contrast smp resources pooled dif cult achie equi alent ne-grained analysis ample tuning single-processor performance carefully deli roughly disk bandwidth -processor sorting application pro vide incr emental scalability hardware resources addiy tional workstations added well-tuned programs easily scaled lar con gurations cony trast smps hard limit scalability imposed size box xpensi comple scale limit paper note lessons research community made lar gely researchers oper ating systems computer architecture principle similar shared-nothing architectures databases typically analyzed tuned conte computey intensi applications demonstrate state-of-the-art platform data-intensi applications ease assembling dif ferent con gurations moti ated estigate family solutions sorting single algorithm tuned machine estigation xposes range options erlapping steps sorting algorithm implications particuy lar elop tools characterize xisting hardware xplore relationship parallelism bandwidth constraints characterize number tradeof pipelining asy sociated costs memory utilization additional contrib ution work aluate comy modity software hardware sorting xtension database applications threads current interface memory management modern unix operating systems eloping cient imy plementations cheering update welly kno criticisms earlier ersions unix database apy plications hand demonstrate important facilities missing modern workstations handling data striped heterogeneous disks deter mining ailable memory garding machine architecture clustered ultrasp arc workstations limited insuf cient bandwidth left unimpro pre ent data-intensi applications enjoying future gains cpu memory network disk speed ganization paper matches elopment sorting implementations brie vie wing related work section xperimental platform section ersions -sort secy tions figure depicts deri ation sorting algorithms eop page bop starttexfig begindocument figs algs eps magnification psdict dict psdict begin psdict mtrx matrix put colsetgray bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale closepath bind eofill bind grestore bind gsave bind save bind restore bind lineto bind moveto bind rmoveto bind newpath bind stroke bind show bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setdash bind findfont bind setfont bind scf scalefont bind stringwidth bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit clip slw polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols polyline clippath clip cols arrowhead setgray cols times-roman scf one-pass parallel dup pop div neg colsh times-roman scf two-pass parallel dup pop div neg colsh times-roman scf section dup pop div neg colsh times-roman scf section dup pop div neg colsh times-roman scf section dup pop div neg colsh times-roman scf section dup pop div neg colsh times-roman scf one-pass single-node dup pop div neg colsh times-roman scf two-pass single-node dup pop div neg colsh psend enddocument endtexfig figure velopment sorting algorithm sections paper follow velopment ogr ess ion sorting algorithms simplest comple comple ersions uild simpler sho rst understanding tuning applicay tion performance simple con gurations uild highly-scalable parallel ersions fort datamation benchmark time one-pass parallel ersion section minutesort results two-pass parallel sort section present conclusions section related datamation sorting benchmark introduced group database xperts test processor subsystem operating system performance metric benchmark elapsed time sort million records disk disk records gin disk -bytes rst -bytes million -byte records data read written disk elapsed time includes time launch application open create close les ensure output resides disk terminate program pricey performance hardware software computed pro-rating e-year cost time sort pre vious record-holder benchmark processor sgi challenge disks main memory seconds single processor ibm disks memory impressi time seconds price performance disk allo wed benchmark recognizing datamation benchmark outdated test startup shutdo time formance authors alphasort introduced minutesort record speci cations identical datamation performance metric amount data sorted minute elapsed time pricey performance calculated list price hardware operating system depreciated years sgi system pre vious record-holder minutesort benchmark sorting alphasort achie processors disks memory price performance years numerous authors reported perfor mance sorting algorithms implementations erage man implementation algorithmic lessons describe dif ference work pro vide measurements range system con gurations arying number processors number disks chine amount memory dif ference vironment parallel con gurations node complete system virtual memory system qdy disks system exp erimental environment rdw dif ferent cluster zil vironments form xperimental testy bed rst consists commodity ultrasp arc worky stations memory measurey ments xtend nodes due time constraints workstation houses internal rpm seagate disks single fast-narro scsi note disks machine ford dedicate spare ybg disk paging acti vity opl ultra enterprise model hckg rpm disk main memory internal rpm seagate external rpm seagate barracuda enclosure external disks fwa ast-w ide scsi card myrinet card myrinet f-sw switch -node system vjn rpm disks rpm disks scsi car disk enclosur myrinet 
car switc -node system rpm disks myrinet car switc hes hard war list prices october list prices cluster connects fully-equipped uly trasp arc model workstations main memory xtra fast-wide scsi card rpm seagate barracuda xternal disks attached cluster eighth processors con guration quarter number disks amount memory main lesson taught authors alphasort lar sorting problems performed single pass half amount disk performed price memory relati ely pre vious recordy holders datamation minutesort benchmarks sort records single-pass con guration memory-starv perform minutesort benchmark passes addition usual connection world ethernet ery workstation single myrinet network card myrinet switch-based high-speed localy area network links capable bi-directional transfer rates myrinet switch ports -node cluster constructed connecting switches -ary tree eop page bop soft machine cluster runs solaris modern multiy threaded ersion unix disparate resources cluster uni glunix prototype distrib uted operating system glunix monitors nodes system load-balancing co-schedule parallel proy grams pro vides full job control redirection xperiments primarily glunix parallel program launcher parallel ersions -sort written splity split-c parallel xtension supports cient access global address space distrib uted memory machines split-c uilt top acti messages communiy cation layer designed adv antage latenc high bandwidth switch-based networks acti mesy sage essentially restricted lightweight ersion remote procedure call process sends acti message speci handler ecuted remote node message recei handler ecutes atomically respect message arri als acti messages myrinet follo wing performance characteristics round-trip latenc roughly layer susy tain uni-directional bandwidth node sending recei ving input key cha racterization study make number simplifying assumptions distrib ution alues layout records processors disks allo wing focus architectural issues olv sorting impley mentations sorting data sets real world rob ust ollo wing precedent set researchers meay performance -sort alues uniform distrib utions assumption implications method distrib uting local uckets processing nodes ith non-uniform distrib ution modify implementations perform sample sort adding early phase sample data determine range tar geted processor ensure processor recei similar amount records plan estigating future assume initial number records workstation equal performance parallel implementations greatly fected small imy balances records located subset worky stations current read phase utilize processors attached disks ere performance implications restructuring algorithms deal situation yond scope paper one-p ass single-no rting section describe basic one-pass ersion sort single workstation records main memory read disk discuss impact dif ferent interfaces performing disk fer agement in-memory sorting algorithm figure one-pass single-node ersion forms basis sorting algorithms components single-node sort sorts worth understanding tuning detail highest one-pass single-node sort steps detail shortly read read -byte records disk main memory artially sorted imultaneou sly distrib uting uckets sort sort -byte memory uckets ucket sorted indiy vidually quicksort partial-radix sort cleanup write gather write sorted records disk implementation steps erlapped synchronous xample estigate beney erlapping sorting reading copying uckets reading majority ecution time spent phases performing gin describing approach reading disk reading riting disk -sort work ariety cluster con guy rations dif fering numbers disks amounts memory order application con gure performance vironment rst gather rele ant information pro vide user-level striping software xist stripe les multiple local disks dif ferent speeds fully utilize aggre gate bandwidth multiple disks machine implemented user -le library xxo dle xui ylg gya kma nsoh qkb cowf ilj bwb ntq yuiz noh mpd qjj juu ocq efm fzk cio vsz cul ywzvu ytk pxa dth wvi avw uuu sayy knci ofwa eeo hiia ixi euwb 
striping top local solaris system uilding top disk similar approach striped characterized stripe nition speci size base stripe bytes names les dif ferent disks stripe multiplicati factor disk determine proper ratio stripe sizes disks eloped diskconf tool list scsi list disks creates lar data disks reads rst independently reads simultaneously les measuring achie bandwidths determining saturated tool calculates multiplicati factor base stripe disk achie maximum transfer rate tool performs analogous chore writes section disk con gurations disks fast-narro scsi additional disks fast-wide scsi rst eri striping library grade achie bandwidth disk sho performance striped system simple comple disk con gurations rst rpm disks saturate fast-narro scsi fast-narro scsi peak bandwidth measure disks capable total potential performance lost due architectural ersight fast-wide scsi adequately handles faster disks finally sho superiority diskconf con gure striping library compared nai ely striping equal-sized blocks disks dif ferent eop page bop seagate disks scsi bus read write rpm narro rpm narro rpm barracuda ide rpm barracuda ide nai striping disk tool peak aggre gate band widths disk con gurations read write columns show measur bandwidth striping libr ary thr ows give performance naive striping same-sized bloc eac disk disk tool peak aggr calculated sum maximum bandwidths scsi speeds reading writing blocks data slo wer disk fast-narro scsi thr fast-wide scsi achie peak aggre gate bandwidth disks management depending system interface read data disk application fecti ely control memory usage pre ent double-b fering operating system section compare approac hes reading records disk read mmap mmap madvise demonstration purposes ery simple implementation sorting algorithm performs steps sequentially quicksorts memory left-most graph figure sho appliy cation read system call read records memory disk total sort time increases erely records sorted physical memory ailable performance gradation occurs due thrashing virtual memory system ith read system performs fering user program unable control total amount memory oid double-b fering read eraging con enience system estigate mmap interface applications memory mapped les opening desired calling mmap bind memory gment address space accessing memory gion desired sho middle graph performance mmap grades records due page replacement polic virtual memory subsystem replacement thro soon-to-be-needed sort-b fers read phase ensuing thrashing grades performance ortunately mmap auxiliary system call madvise informs operating system intended access pattern gion memory xample call madvise noti kernel gion accessed sequentially allo wing fetch ahead current page thro pages accessed right-most graph figure sho mmap madvise sorting program linear performance roughly ailable memory determining memo amount ailable memory workstation determines number records sorted one-pass sort number records run multi-pass sort pre vious work addressed issue adapting sorting aly gorithms memory constraints run-time rst kno amount free memory ailable sorting application xisting solaris inter face accurate estimate eloped memconf memory tool allocates fer fetches main memory methods writing arbitrary alue rst word page copying words memory-mapped sequentially-advised input prefetching tool touches page fer recording cpu utilization fer main memory cpu utilization high 
current defy inition lar ger fer fer cpu utilization due paging acti vity tool backs smaller fer binary search estimate usable memory running basic ersion memconf sho wed machines real memory respecti ely ailable user appliy cations operating system daemon processes factored applications mmap madvise -sort approximately ailable memory finally eri predictions ailable memy ory matched number records sort memory thrashing sharp increase sort time occurs sort records ailable memy ory conserv ati scale estimate ailable memory predictions comfortable distance memory wall wasting ailable memory in-co rting section qua nti performance arious main-memory sorting techniques performed correctly in-core sort disk-to-disk single-node sort comprises small portion total ecution time xample in-core sort consumes seconds required sort million records ibm disks total time section estigate programy ming comple xity needed achie range performance measuring dif ferent in-core sorting algorithms quicksort rst in-core sort simple quicksort memory pre vious work swapping pointer full record faster swapping entire -byte record xtra memory work required set pointers comparisons gin most-signi word xamine remaining words pre vious identical top line left-side graph figure sho time incore quicksort function number system disks approximately seconds required read write million records quicksort ecution time spent in-core sort bucket quicksort in-core sort performs quicksort distrib uted uckets uckets based highp eop page bop starttexfig begindocument graphs singleinternalread eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore size cshow read cshow total time rshow write time rshow sort time rshow read time rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs singleinternalmmap eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore size cshow mmap cshow total time rshow write time rshow sort time rshow read time rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore size cshow mmap madvise cshow total time rshow write time rshow sort time rshow read time rshow stroke grestore end showpage enddocument endtexfig figure read versus mmap thr aphs show cumulative numbers ultr asp arc memory seagate rpm disk rst aphs show ead mmap total sort time incr eases super -linearly befor nearing memory limits mac hine right-most aph shows memory mapping advising memory mor fectively order bits placing ucket easily erlapped read phase due simple interface pro vided mmap gradation read bandwidth erlapping cpu utilized implementation ucket signi -bits remo ving top -bits pointer full record common case -bits xamined ties occur random accesses memory number uckets determined run-time erage number ucket second-le cache ultrasp arc quicksort performed in-place partial pointer requires 
bytes ucket note approach highly dependent uniform distrib ution ske wed distrib ution uckets cache grading performance sho middle line figure performing quicky sort uckets second-le cache faster quicksort memory approach total time sort million records spent in-core sort bucket partial-radix in-core sort performs partial-radix sort clean-up ucket suggested most-signi -bits remo ving top -bits pointer full record ucket radix sort relies representation -bit numbers perform passes radix size xamining total -bits refer partial-radix sort radix sort bits pass histogram constructed count digits histogram scanned west entry highest calculate rank sorted-order finally permuted destinations rank histogram partial radix sort clean-up phase performed ties top bits ubble-sorted quicksort number uckets selected erage number ucket secondy cache radix sort requires source destination fer half man cache compared quicksort bottom line left-side graph figure sho radix sort ucket greatly superior quicksort starttexfig begindocument graphs singleinternallocalsort eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore keys cshow quicksort rshow quicksort buckets rshow radix buckets rshow stroke grestore end showpage enddocument endtexfig figure comparison in-cor sorting algorithms aph compar rting time quic sor ove memory quic ksort independently eac ket adix sort eac ket aph cumulative total time sort million records spent in-core sort combination distrib uting uckets performing radix sort ucket worth added comple xity note implemented optimizations found including restricting number uckets number tlb entries erlapping sorting writing small optimization clean-up phase signi gain methods discussion summarize figure sho total time returned unix time command one-pass single-node ersion -sort systems disks timing run ush cache unmounting re-mounting striped disks xpected iny core sorting time gligible con gurations compared time reading writing records disk read bandwidth roughly balanced write bandwidth matches transfer times found disk con guration tool finally performance linear number records records main memory eop page bop starttexfig begindocument graphs singleinternal disks eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore keys amout data cshow remzi datamation cshow remzi disks cshow total rshow write rshow sort rshow read rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument graphs singleinternal disks eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore keys amout data cshow remzi datamation cshow remzi disks cshow total rshow write rshow sort rshow read rshow stroke grestore end showpage enddocument endtexfig figure single-node single-pass sort ime aphs cumulative time sort shown function number ecor aph left depicts system disks connected fast-narr scsi aph system additional disks fast-wide scsi systems eal memory optimizing single-node single-pass sort shed light number machine architecture operating system issues disk con guration tool 
sho ultrasp arc internal fast-narro scsi saturates rpm disk fast-wide scsi enabled achie internal disks loss performance found striping disks dif ferent bandwidths requires dif ferent stripe sizes disks aluation system interfaces sho mmap pro vides simple cient ne-grained access les ith mmap madvise interfaces copying uckets completely hidden disk transfer time obtaining performance read system call require programming comple xity cost issuing read high users threads prefetch data lar chunks system fering occurs read wastes inordinate amou memory acceptable data-intensi applications simple memory con guray tion tool application fecti ely determine ailable memory memory tool disco ered fer requirements mmap roughly tax applied free memy ory interface programs accurate run-time estimate free memory preferable one-p ass rallel rting detailed intricacies single-node sorting records memory speci cally disk striping memory management in-core sorting algorithm amine one-pass parallel sort issues arise communication added present bes performance datamation benchmark assuming records gin enly distrib uted workstations numbered steps single-node sort xtend ery naturally -step parallel algorithm read processor reads records local disk main memory communicate alues xamine records local remote uckets sort processor sorts local write processor gathers writes records local disk workstations memory-maps input les calculates processor remote ucket current implementation determines destination processor simple ucket function top bits copies input sendy fer allocated destination processor approach ucketizing assumes alues uniform distrib ution speci records send-b fer ary implementations detail belo message records arri processor acti message handler ecuted handler records sort-b fer copies partial pointers correct local uckets operations directly analogous distrib uting partial uckets single-node sort signi dif ference single-node ersion distrib uting records local uckets processor distrib utes records emote uckets computation naturally decoupled acti messages sending processor determines destination processor wning range uckets recei ving processor determines nal ucket performing calculations identical single-node ersion message handler synchronizing processors ensure records recei node performs iny core sort records writes local portion local disk sort write steps identical single-node ersion end data sorted disks processors west-v alued alued processor highest-v alued processor note number records node approximately equal depends distrib ution alues exploiting overlap simultaneously reading records local disk sending records processors potential erlap disky wait time network latenc erlapping operations shared resources cpu eop page bop starttexfig begindocument graphs eps gnudict dict gnudict begin color true solid true gnu gnu gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnu setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow narrow cshow narrow cshow wide cshow cshow hybrid cshow currentpoint gsave translate rotate time seconds cshow grestore disks cshow remzi currentpoint gsave translate rotate synch lshow grestore currentpoint gsave translate rotate interleaved lshow grestore currentpoint gsave translate rotate threaded lshow grestore remzi ltb write rshow ltb sort rshow ltb distribute rshow ltb read rshow stroke grestore end showpage enddocument endtexfig figure comparison algorithms left-most bar eac oup shows performance eakdown syny onous implementation middle-bar interleaved imy plementation right-most bar thr eaded version interleaved thr eaded versions ead distriy ution time collapsed ead cate gory hybrid implementation eads fast-wide disks writes disks -utilized subsection aluate ersions one-pass parallel sort ary gree erlap disk communication synchr onous synchronous ersion processor reads communicates sorts writes erlap steps fer records xpansion factor related distrib ution alues dra wback straight-forward implementation requires memory records sorted fer needed records read processor fer needed records recei implementation reserv xtra fer communication fers requires xtra synchronization processors iteration processor sends processor mod minimize contention sending complete fer rst processor processors synchronize waiting records recei steps continue records distrib uted interlea ved implementation alternates ready ing communicating thread send-b fer destination relati ely small current implementation waiting records read records sendy fer full alternating reading sending adv antage erlapping memory rob ust distrib ution alues synchronous ersion algorithm synchronizes processors ensuring records recei ginning in-core sort thr eaded nal implementation erlaps ready ing sending threads eader -thr reads records local send-b fers communicator -thr ead sends recei messages sets send-b fers xist destination reader nishes lling fers set signals comy municator sends records current set measurements sho figure found disks node interlea ersions starttexfig begindocument graphs parallelinternalscaling eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt 
mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore processors cshow secs lshow secs lshow disks sort glunix rshow disks sort glunix rshow disks sort glunix rshow disks sort glunix rshow stroke grestore end showpage enddocument endtexfig figure scalability one-pass parallel sort ecor ocessor sorted cluster disks memory mac hine ecor ocessor sorted disks memory mac hine single dual threaded outperform synchronous ersion roughly threads perform slightly stagger read send requests smoothly time ith disks dif ference synchronous erlapped ersions diminishes ith disks system algorithms perform identically interestingly interlea ersions read slo wer rate disks rpm disks reduction occurs ultrasp arc bus bus saturated long theoretical peak read disks simultaneously sending recei ving approximately aggre gate s-bus make good disks capable transferring s-bus sustain roughly aggre gate due limited bandwidth s-bus found hybrid system performance interlea ving reading communication hybrid system reads disks fast-wide writes write phase pro disks concurrent communication oted solely disk acti vity threaded parallel sort equals outperforms implementations focus xclusi ely remainder xperiments discussion one-pass parallel -sort perfectly scalable number processors increased number records processor constant sho figure words sort man amount time simply doubling number processors slight increase time due erhead glunix distrib uted operation system rey mote process start-up increases processors taking approximately seconds nodes seconds performance datamation benchmark sho figure processor sorts equal portion million records processors added eop page bop starttexfig begindocument graphs eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore processors cshow lshow lshow lshow lshow sgi record lshow disks sort glunix rshow disks sort glunix rshow disks sort glunix rshow disks sort glunix rshow stroke grestore end showpage enddocument endtexfig figure erf ormance datamation benchmark aph shows time sort million ecor disks ocessor disks ocessor data points shown million ecor memory node sorts wer records ith resulting small problem sizes remote process start-up signi portion total sorting time fact processors total time equally vided process start-up application function lack maturity cluster fundamental costs distrib uted operating system focus optimization interestingly process start-up time-consuming smps bzero ing address-space signi dominant cost oney pass xternal sorts smp parallelize process aspect process creation problem local address space initialized parallel parallel single-pass sort ealed o-system bottleneck ultrasp arc architecture s-bus bey s-bus achie workstation fecti ely disks simultaney ously communicating network remain viable alternati smps ultrasp arc bandwidth imy pro dramatically radically pro vide communication memory coherence corollary suggests system disks fast-wide scsi sweet-spot cost performance curv conclusion found eloping parallel single-pass sort natural xtension single-node ersion lessons pre vious section garding disk striping memory management in-core sorting directly applicable vironment isolate performance fects -processor basis dif ference single-node ersion additional communication traf s-bus contrast belie smp system pooling resources obscures type analysis finally acti message interface pro vided high bandwidth erhead communication facilitated algorithm dif fered slightly single-node ersion copying local uckets processor copies uckets spread processors o-p ass single-no rting ving one-pass ersions -sort detail xtensions needed single-node insuf cient memory passes made records section memory con guration tool determine amount ailable memy ory choose one-pass two-pass algorithms eate runs one-pass sort read sort write repeated create multiple sorted runs disk merge phase sorted runs mer ged single sorted eate sorted runs rst phase threads created eader -thr ead writer -thr ead ailable memy ory vided fers equals depending reader writer syny chronous erlapped discussed section run records requiring runs number records reader copies records disk pointers uckets signals fer full reader free empty fer run writer waits fer lled sorts ucket writes records disk signals fer empty process repeated runs sorted written disk separate les merge sorted runs pha multiple runs mer ged single output implementation threads eader mer ger writer reader thread memory-maps run les reads rst chunk records run sets mer fers depending reading mer ging synchronous erlapped discussed section prefetching records lar chunks amortizes seek time runs obtains rea widths equ ential sse reading fers reader signals mer ger fers full continues prefetch set empty mer fers mer ger selects west-v alued top run copies record write fer write fer full writer signaled writes records disk note mer phase instance found simple implementation mmap madvise attain sequential disk performance accessing muly tiple read streams disk mmap prefetch data suf ciently lar blocks amortize seek costs mer phase xplicitly manage prefetching multiple threads fers exploiting overlap phases reading disk erlapped writing computation one-pass parallel sort erlapping phases pipelining bene cial resources cpu -utilized erlapping additional implications layout records disks memory usage pipelining phase implies pipelining phases output rst phase input estigate impact run length layout records disks phases eop page bop starttexfig begindocument graphs singleexternalrunsize eps gnudict dict 
gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore number runs run size cshow create runs rshow merge runs rshow total time rshow stroke grestore end showpage enddocument endtexfig figure effect run size non-cumulative time phases two-phase sort shown total time ultr asp arc memory disks eating runs phase eac run memory mer ging runs phase number runs run length synchronous ersion phase memory create run generates half man runs pipelined ersion runs adv ersely fect performance mer phase reading disk streams raise seek time yond hide prefetching lar chunks number runs constrained xists suf cient memory prefetch fers run mer phase disk lay synchronous pipelined ersions manage layout records disks dif ferently maintain sequential access disk dedicated reading writing time pipelined implementations reading writing times half disks reading half writing synchronous implementations utilize disks reading disks writing phases synchronous input temporary sorted runs output striped disks phases pipelined striped half disks phase synchronous synchronous phase suf fers half disks employed pipelined phase measurements two-disk -disk systems rey eal two-pass single-node ersion occurs phases pipelined pipelined mer phase hibits dramatic impro ement synchronous ersion fecti ely prefetches lar chunks mer run hides cost seeking pipelined mer imy pro slightly rst phase synchronous wer runs mer penalty rst phase ecuting synchronously writing half disks outweighs impro ement determining run size ithin pipelined algorithm length run impacts performance rst phase number runs impacts phase section determine compromise number runs lengths results good performance phases tension phases sorting amount data changing number runs sho figure runs created time rst phase lar size run greater amount ailable memory memory manager pages data disk yond point run memory time rst phase continues drop slightly run size decreases due wer cost lling draining read write pipeline data run time writer wait reader read rst run decreases time writer write run decreases con ersely number runs increases time phase increases mer phase reads records disk chunks amortize cost seeking independent runs creating similar starty fect start-up time increases number runs reader prefetches chunk runs net result memory wall runs increasing number runs problem set erall fect performance slightly decreasing time generate runs increasing time mer runs runs performance grades sharply mer time increasing percent beha vior suspect related cache performance performance drop-of mirrored increase user -cpu time disk-wait time discussion conclude summarizing minutesort performance two-pass single-no disk time mer phase slightly lar ger time create runs records vided twelv runs concurs data figure results comparison case two-pass parallel sort section disks disks create mer otal single-node minutesort results amount data sorted minute single node shown ultr asp arc disks memory versus disks memory corr esp ond ecor ecor section -sort accurate estimate ailable memory choose one-pass two-pass algorithm number records determine maximum run size two-pass algoy rithm examining two-pass single-node sort found pipelined ersions phases performed syny chronous implementations gardless number disks found mmap madvise prefetch sufy ciently lar blocks amortize seek costs multiple streams forcing xplicitly prefetching thread eop page bop mer phase prefetching lar blocks sequential perfor mance maintained mer phase read runs greater number disks system finally observ importance carefully aging layout records disks dedicating half disks reading half writing disrupt sequential access pattern generated stream o-p ass rallel rting section describe two-pass parallel algorithm results minutesort benchmark nal sorting algorithm xtends naturally one-pass parallel twoy pass single-node algorithms eate runs processors create sorted runs nodes cluster runs created repeating read send sort write steps one-pass parallel sort merge processor mer ges local sorted runs single local phase identical mer single-node pre vious section discussed exploiting overlap creating multiple sorted runs processors rst phase eral opportunities erlap oney pass parallel algorithm reading sending lapped two-pass single-node sort reading writing erlapped two-pass parallel sort erlap pairs operations understand tradeof describe actions threads detail eader communicator writer read thread responsible mapping input copying records -destination send-b fers send-b fers reader signals comy municator one-pass parallel sort reader comy municator erlapped sets send fers synchronous set signaled communicator -thread picks eny tire set send-b fers sends destiy nation processor message arri acti message handler oked copies records sort-b fer partial ucket comy municator records current run processors synchronize wait recei records run recei writer -thread signaled writer sorts ucket gathers writes records disk similar two-pass single-node sort reading run erlapped writing pre vious run erlapping implies sets sort-b fers uckets xist set consuming approximately half memory measurements number disks system determine operations erlapped ith disks implementation erlaps oper ations ith disks erlaps reading sending performs reading writing synchronously operations erlapped cpu saturated utilization performing read write operations syny chronously minimizes cpu contention creating run time stripes input disks creates runs mer phase discussion starttexfig begindocument graphs eps gnudict dict gnudict begin color false solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow 
currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate amount sorted cshow grestore cshow processors cshow sgi record lshow currentpoint gsave translate rotate perfect scaling lshow grestore currentpoint gsave translate rotate perfect scaling lshow grestore disks rshow disks rshow stroke grestore end showpage enddocument endtexfig figure parallel minutesort results aph shows minutesort esults dif fer ent cluster con gur ations -node cluster disks ocessor -node cluster disks ocessor erfect scaling elative single-node performance performance two-pass parallel -sort minutesort benchmark sho figure ith chines disks machine implementation sorts minute xperience lar drop number sorted single-node sort parallel ersion running processor reading writing performed synchronously erlapped compared parallel ersion processor algorithm scales perfectly linearly processors cluster disks machine parallel ersion sort machine sorts man single-node algorithm implementations erlap phases ith processors sort data ties pre vious minutesort record fully-loaded sgi system processors disks memory ith processors sort seconds nodes sort seconds algorithm scale linearly number processors drop lar gely due start-up bottlenecks costing seconds nodes due relati dearth memory workstations minutesort two-pass algorithm cluster pre vious record-holding systems minutesort performed single pass xample sort data performing sgi xfs system amount time conclusions paper presented -sort collection con urable sorting algorithms networks workstations sho well-suited o-intensi apy plications sorting cluster vironment ideal elopment cient parallel applications eop page bop system ear procs disks mem datamation minutesort ime price perf cents data price perf dec alpha axp dec alpha axp dec alpha axp sgi challenge ibm ultrasp arc ultrasp arc ultrasp arc ultrasp arc ideal ultr asp arc summary datamation minutesort results note price sgi challenge estimated ibm disk whic allowed datamation speci cation note bytes pro vides performance isolation monitoring beha vior application node program-de eloper isolate performance bottlenecks clusters enable increy mental scalability hardware processors disks memory added system fecti manner work enabled pieces software cluster rst acti messages high-speed communication layer pro viding latenc high throughput parallel programs software component glunix distrib uted operating system studying disk-to-disk orting qualitati ely quan titati ely assessed workstation operating system chine architecture underlying goals project utilize xisting commodity software hardware assumption general-purpose workstations form solid uilding blocks clusters connected high-speed nety work paper demonstrated strengths weaknesses assumption -sort important function opy erating system support cient access mmap madvise solaris pro vides fast ney grained access les system pro viding adequate prefetching fer management cony sumes ailable memory older read interface incurs double-b fering problem programs lar memory requirements mmap madvise suf cient ready ing multiple independent streams mer phase two-pass sort needed multiple threads manage prefetching ourselv found xisting solaris support memoryy intensi applications lacking areas ciently employing multiple disks dif fering speeds single workstation straight-forward reasonable determine ailable memory application xtend resou rces thrash solv problems eloped small con guration tools rst aluates speed disks system feeds information striping library allo wing maximal performance disks tool measures ailable memory node cluster tools combine enable sorting application tune ailable cluster attain peak cienc found structure ultrasp arc workstation pro vides inadequate support disk communication sorting xample found disks implementation synchronous reading writing superior pipelined ersion surprised machine disks connection high-speed network fecti uilding block adding disks leads bene solutions pending problem impro infrastructure bandwidth support disks network communication facilities function memory coherence lea ving disks consume precious bandwidth found internal fast-narro scsi pre ents full utilization bandwidth internal disks performance loss performance system relati pre vious recordy holders datamation minutesort benchmarks sho best-performing con guration processors sorts million records one-pass seconds relati ely high cost processor system disks node slightly slo wer seconds signi cantly cost performance ibm achie cost performance kno results disk allo wed benchmark speci cation minutesort results obtained machine con guy rations memory required two-pass xternal algorithms pre vious record-holders contained main memory hold data performing amount sort bytes minute processors con guration disks deli roughly sorting application pre vious minutessort recordy holder needed -disks deli price performance project processors disks memory records memory sorting one-pass hardware obtain slightly performance isit home page -sort project http ber ackno wledgments -sort combined fort members berkey ley project rst richard martin implementing supporting split-c acti messages eop page bop myrinet work nished doug ghormley vid petrou forts making glunix fast reliable system members ertiary disk group lending barracuda disks lutz eric fraser making clusters working reality extend special jim gray chris nyber comments early drafts helpful con versations sorting finally anonymous vie wers providing feedback work funded part arp -cy arp -co nsf asa fdn california state micr program andrea arpaciy dusseau supported intel graduate fello wship agarwal super scalar sort algorithm risc proy cessors oceedings sigmod confer ence pages june anderson culler patterson case networks orkstations ieee micr feb arpaci dusseau ahdat liu anderson patterson interaction parallel sequential orkloads netwo orkstation oceedy ings sigmetrics erformance pages baru fecteau goyal hsiao jhnigran padmany abhan ilson overvie parallel edition oceedings sigmod international confer ence managemen data san jose basu buch ogels eicken u-net user -le vel network interface parallel distrib uted comy puting oceedings symposium ope rating systems principles 
copper mountain colorado dec baugsto greipsland kamerbeek sorting lar data files poma oceedings comp arh appiv pages sept springer erlag lecture notes beck bitton ilkinson sorting lar files backend multiproces sor echnical report department microbenchmark-based extraction local global disk characteristics nisha talagala remzi arpaci-dusseau david patterson computer science division california berkeley abstract obtaining timely accurate information low-level characteristics disk drives presents problem system design implementation alike paper presents collection disk microbenchmarks combine empirically extract relevant subset disk geometry performance parameters efficient accurate manner requiring priori information drive measured benchmarks utilization linearly-increased stride glean spectrum low-level details including head-switch cylinderswitch times factoring rotational effects bandwidth benchmark extracts zone profile disks revealing previously preferred linear model zone bandwidth accurate quadratic model seek profile generated completing trio benchmarks data collected broad class modern disks including scsi ide simulated drives introduction theories fundamental data remains mary leakey sustained innovation hard-drive industry spurred incredible advances disk technology performance capacity benefited bandwidth increasing sixty percent year capacity growing rate disk drive industry moves quickly drive appears market twelve months due rapid evolution clients modern disks left quandary obtain accurate detailed information inner-workings recently manufactured disks system implementors knowledge low-level performance characteristics lead improved policy decisions system researchers simulations parameterized latest disk attributes facilitating timely relevant research straight-forward methods obtaining performance characteristics prove successful detailed specifications complete accurate solution put literature employ microbenchmarks characterize hardware software systems alike carefully crafted microbenchmarks utilized wide range environments accurately describe performance uniprocessor multiprocessor memory systems discover cost communication mechanisms parallel machines measure performance operating system primitives evaluate file systems extract parameters scsi disk drives calculate megahertz rating processors applying microbenchmarks disk drives vexing problem complex drive mechanism involving cooperating mechanical electronic parts benchmarks adequate domains translate disk drives rotational factor affects measurement results renders current position drive unpredictable seek develop microbenchmarks suitable extracting performance parameters modern disk drives ideally disk microbenchmarks exhibit properties general runs vast array systems specialized specific kind disks ideal benchmark requires priori information drive measured complete extracts relevant parameters including disk geometry performance parameters low-level parameters including head cylinder switch times overlooked accurate extracts parameters excellent precision fast runs quickly giving information seconds minutes hours days paper introduce microbenchmarks designed extract performance parameters hard disk drives sum total microbenchmarks approach ideal microbenchmark axes general running scsi ide drive raw-device interface run quickly extracting parameters seconds completely characterize physical properties disk drive finally produce accurate drive geometry performance parameters percent manufacturer-reported values contributions paper three-fold simple method based linearly increased step-size extracting localized disk parameters including platter count sectors track rotational delay head switch time cylinder switch time minimum time media slowly ramping step-size factor rotational effects unveil host drive performance characteristics empirical characterization large collection modern disk drives including scsi ide drives previous work focused solely scsi-drive extraction update results zoned nature modern disks including correction proposed linear model accurate quadratic model present results executing microbenchmarks diverse collection modern drives including scsi ide simulated drives study uncovered numerous interesting results discovered minimum overhead write disk media widely varies drives generation found family drives manufacturer exhibited similar strengths weaknesses seagate drives tend excellent switching times multi-zoned nature modern disks pronounced outer tracks delivering bandwidth tracks surprisingly scsi disks performance characteristics ide disks measured scsi bandwidth switching characteristics programmed dma renders ide drive overhead lower rest paper organized section give background disk terminology related work section section presents overview collection microbenchmarks results range disks presented section conclusions section background explaining functionality disk characterization tool give overview modern disk drives in-depth excellent summaries modern disk drive behavior basic internal structure disk drive rotating disks coated sides magnetic media rotating disk called platter side disk called recording surface data stored recording surface concentric circles called tracks track divided sectors sector minimum unit data accessed disk media typical modern disks -byte sectors tracks surface equidistant center form cylinder disks zoned bit recording zbr outer tracks disk higher sectors track ratio tracks read write heads surface ganged disk arm time move arm proper cylinder called seek time time required sector rotate head referred rotational latency time transfer data media called transfer time modern disks head active time sector track track cylinder access spans tracks disk complete portion track switch heads continue track sector mappings consecutive tracks skewed head switch time switching heads requires short repositioning time skew prevents request crosses track boundaries missing logical block wait full rotation similarly access spans cylinders disk arm seek forward cylinder consecutive cylinders skewed cylinder switch time related work inspired separate works literature saavedra presents microbenchmarking technique memory systems paper worthington describes extract performance geometry parameters scsi disks seek combine simplicity speed accuracy saavedra introduces simple powerful method extract performance characteristics multi-level memory hierarchy benchmark repeatedly performs basic loop reading memory locations fixed-size array stride surprisingly characteristics memory hierarchy including number caches capacity associativity block size access times extracted simply changing size array length stride technique applied disk yield results desired disk subsystems regular memory hierarchies complex interaction rotation seek time leave direct application saavedra disk infeasible study worthington describes partially automated tools extracting parameters scsi disk drives twofold approach interrogative empirical extraction interrogative extraction library scsi access functions read mode pages disk mode pages describe disk parameters sectors track ratio prefetch buffer size information extracted mode pages construct test vectors empirical extraction process measure minimum time requests mtbrc kinds comparing mtbrcs test vectors calculate switching times parameters main disadvantage approach reliance user send low-level scsi commands disks highly non-portable requires user trust disk manufacturer information parameter extracted requires separate group test vectors algorithms outlined worthington minutes hours extract parameters contrast benchmarks require low-level access disk interface sense closer true black box microbenchmarks drive parameters extracted skippy benchmark single fast experiment benchmarks section present collection disk characterization tools table summarizes constituent benchmarks microbenchmark extracts skippy linearly increases step distance platter count sectors track writes sector-sized block rotational delay head switch time cylinder switch time minimum time media writes zoned streams entire disk bandwidth function location reading large blocks seeker repeatedly writes sector-sized blocks seek cost function distance start disk locations table microbenchmarks table describes collection microbenchmarks paper skippy extract parameters runs small portion disk zoned produces bandwidth versus location characterization extracting zone profile disk finally seeker generates seek profile function 
distance standard techniques innovative component benchmark suite skippy utilizing technique linearly increasing stride writing disk factor rotational effects extract surprising amount information disk including sectors track ratio rotation time minimum time access media disk head positioning time head switch time cylinder switch time number recording surfaces impressive run-time characterization completes roughly skippy completely characterize behavior modern disk nature local benchmark crucial pieces global information missing cost seeks function distance effect zones function location derive final pieces information utilize microbenchmarks seeker zoned constructed benchmarks similar found due global nature benchmarks time consuming skippy taking minutes complete benchmarks rely raw device interface order bypass file system optimization activities caching buffering read ahead access raw interface benchmarks difficult impossible construct skippy skippy microbenchmark implements approach disk measurement linearly increasing strides counteract disk natural rotation figure shows pseudocode algorithm benchmark writes sector disk forwards file pointer writes iteration distance increases single sector resulting latency versus step size curve distinctive sawtooth shape extract parameters sectors track ratio rotation time minimum time access media disk head positioning time head switch time cylinder switch time number recording surfaces gathered results read variant skippy sake space present write version benchmark read results analysis presented full version paper intuition analytical foundation traditionally extracting parameters head switch time disk drive difficult request incurs unpredictable rotational latency intuition linearly increasing stride method write accesses drive rotates distance forward requests incur latencies time successive requests reaching disk roughly computer science cornell uni versity mar step size requests linearly blelloch increasing leiserson eventually match maggs comparison sorting algorithms connection machine cmb symy posium arallel algorithms chitectur july blumrich alpert dubnicki felten sandber irtual memory mapped network interface shrimp multicomputer oceedings inter national symposium computer chitectur pages apr boden cohen felderman kulawik seitz distance myrinet gigabit-per disk -second local area rotates network successive ieee requests point miy observable feb requests prior incur extra boral rotation alexander requests afterward clay basically copeland access pattern designed prototyping advantage bubba rotational highly mechanism parallel database separate system rotational latency ieee request ransactions contributing knowledge latencies data result engineering disk characteristics including head mar cylinder culler switch times observable describe skippy works dusseau simple goldstein analytical model krishnamurthy model terms lumetta eicken elick parallel time programy full ming rotation rotational latency split-c hand super computing time request spends waitingfor required culler sector rotate head liu rotationallatency martin vary oshikawa logp formance assessment fast network interfaces ieee micr feb time transfer data dew media itt byte cost ghandeharizadeh including overheads schneider bricker minimum time media gamma database minimum machine time access project data ieee disk surface ransactions disk request completes knowledge data engineering mar incurs witt rotational seek naughton latency schneider number parallel sectors sorting disk rotates time shared-nothing mtm equation architecture defines probabilistic terms splitting oceedings international confer ence arallel distrib uted information systmes dusseau culler schauser martin fast parallel sorting logp experience note cmb equation assumes ieee linear ransactions relationship latency arallel number distrib sectors uted rotated systems seek time aug increase linearly seek distance stated earlier step measure sizes ransaction generate processing arm movement wer delay purely rotational datay mation disk rotates fixed speed delay increases linearly readings number sectors rotated database figure systems shows expected sequence stonebraker events mor gan kaufmann san mateo single sector writes gerber informix track online figure xps shows stages oceedings write sigy mod international confer ence managemen data san jose disk ghormley open raw disk petrou device ahdat measurements time sequence anderson output glunix time lseek global layer single sector unix seek cur write buffer http single sector close berkeley figure glunix skippy glu algorithm nix basic html algorithm skips disk graefe increasing olcano distance seek extensible parallel sector write outputs distance time write raw device interface order avoid file system optimizations single sector size single sector case bytes seek cur argument lseek moves file pointer amount relative current pointer start atdisk atsurface data underhead rotationaldelay query end processing start atdisk atsurface rotationaldelay underheadw end step size latency distance disk rotates requests figure behavior figure shows expected sequence events system sector writes disk media writes echnical searching labeled sorting record rotates experiences sectors tuning now-sort stage andrea illustration arpaci-dusseau remzi show arpaci-dusseau david culler joseph hellerstein david patterson computer focusing science single division sector accesses california transfer berkeley time dusseau negligible remzi culler starts jmh pattrsn time berkeley time present experiences scsi subsystem developing processed tuning performance now-sort parallel disk-to-disk sorting algorithm now-sort holds request command reached disk time disk positioned head track time world required records sector databaseindustry standard benchmarks disk critical head difference tuning process setting expectations programmer tune stop found categories tools tools set expectations configure application rotational latency hardware parameters visualization tools write system animate call performance returned counters short search time tools track write begins performance anomalies tools interact disk rotated layers distance forward underlying illustration software step size operating greater system distance required applications sector leverage ahead modern features request threads served memory-mapped rotation time time start march loop debate iteration execute benchmark lseek prototype call cluster time system negligible decided compared implement disk external access times disk-to-disk parallel system sort external sorting microseconds average qualities desired entire write benchmark takes external sorting assume memory intensive sorting time stresses aspects local distributed operating negligible system make performance interesting well-understood observations sorting algorithms rotational delay exist approaches sequential parallel environments finally presence industry-standard benchmarks compare performance large-scale systems time -processor sgi challenge held worldrecords existing benchmarks rotational delay datamation eliminated benchmark figure sgi sorted million -byte records -byte keys disk disk seconds minutesort disk rotates -byte records approximately sorted time minute goal sectors surpass requests records words cluster ultrasparc workstations connected high-speed network year extra rotation april april fool day people complete rotation logic model latency write request access track prior access request satisfied current rotation latency latency minimum time media time rotate remaining sectors substituting equation simpler term latency equation shows latency linear function step size request satisfied rotation latency equation equation simplified substituting substitution equation latency linear sectors trackwith offset equal rotational latency step puts request track request incurs extra head switch delay tracks skewed head switch disk wait full rotation case latencies calculated equations equations cylinder switch similar place note equations assume long distance seeks model skippy intended step sizes seeks greater single cylinder point significant arm movement latency scale linearly step size illustrate expected graphical result mock disk mock disk rpm recording surfaces sectors track minimum time access media head cylinder switch times benchmark create long distance seeks seek profile figure shows expected graphical result accompanying illustrations shown figures reveal points graph illustration shows writes write shows request pattern marked point graph track shown concentric circles rotational delay marked outer circle rotational delay marked circle increases linearly latency sawtooth pattern point figure causing large rotational delay making equal increases latency increases linearly equation approaches equation shows latency approaches point figure time disk head lowered track required sector missed full rotation takes place latency overhead steps reach point figure slightly larger case disk head lowered time rotational latency latency time distance sectors mock disk base cylinder switch head switch base heads minimal time media transfer time rotational latency cylinder switch head switch figure mock disk output mock disk shown graph constructed strictly models developed text illustrate output benchmark startw atsurface rotationaldelay underhead underhead endw start end atsurface rotationaldelay figure point startw atsurface rotationaldelay underhead end underhead end atsurface start rotational delay figure point rotationaldelay min timeto media start atsurface underhead end start underhead atsurface end figure point underhead end prior start atsurface rotationaldelay end start atsurface track end start ofnew track track underhead end track cylskew figure point increases latency increases linearly equation graph sawtooth shape transition graph shows series upward spikes correspond head cylinder switches point figure illustrates head switch case rotational latency increased equation extracting parameters figure exposes disk details coordinate point coordinate transfer time small single sector coordinate point good estimate difference coordinates points latency step size height transition point information calculate number sectors track point reached reverse equation calculate note calculate sectors track ratio region written modern disks employ zone bit recording zbr outer cylinders packed sectors track cylinders due circular nature disks sectors track ratio regions disk run benchmark regions increases latencies form distinct lines 
slope offsets figure shows lines labeled conforms equation conforms equation taking difference offsets lines calculate slope line extract slope point represents head switch latencies conform equation vertical offset point corresponds cylinder switch vertical offset line finally step size number sectors track number recording surfaces counting number head switches cylinder switches larger number steps successive head cylinder switches decreases figure shows eventually step results head switch sample result prior section showed mock disk parameters extracted figure apply techniques ibm ultrastar disk drive manufacturer specifications learn disk rpm rotational latency recording surfaces recording zones outermost sectors track head cylinder switch times figure shows result running benchmark disk figure similar model result figure result behavior predicted equations equation completely explain result head cylinder switches figure head switches upward latency spikes consistent figure shows upward spikes small downward spikes approaches variation affect ability extract parameters require refinement analytical model refine model subsection focus extracting parameters figure error rates calculated comparing extracted values manufacturer values parameter extraction techniques earlier measured values coordinate point actual latency error height sawtooth wave estimate case error techniques yield extremely accurate results coordinate point coordinate equation states offset writing bytes transfer time small subtracting coordinate point estimate fact transfer time small effect virtually indistinguishable measurement noise coordinate good estimate hand estimate difference time distance sectors ultrastar skippy base base head switch cylinder switch heads minimal time media transfer time rotational latency cylinder switch head switch figure ibm ultrastar sample write result ibm ultrastar disk drive values points counterpart specification represents important estimate system overhead ratio actual sectors track error measured error compared specification similarly measured error compared specification finally counting number head switches cylinder switches find disk recording surfaces matches disk specification disk drive extracted values close actual values cases error rate refined analytical model writes figure showed simple model inadequate describing parts benchmark behavior graph shows downward spikes region explained equation section present refinement initial model explain effects figure downward spikes point happen head switch occurs close normal circumstances head switch mechanics equation apply time position head service write rotation prior write head switch occurs track skew disk head slightly extra time enabling disk service writes waiting extra rotation writes complete latencies close figure shows downward spikes extend head switch line left point observation confirms hypothesis spikes caused head switches adjusting model account effects create model graph identical sample result extra downward spikes reveal interaction disk head positioning head switch property estimate disk head positioning time full paper details refinement limitations limitation write skippy technique work disks delayed write optimizations limitation applies microbenchmarks attempt measure write latencies disks measurable read skippy variant open raw disk device read buffer large size large size transfer large size transfer report size output location bandwidth achieved region transfer close figure zoned algorithm benchmark simply reads disk sequentially blocks size large size threshold amount read report size benchmark outputs location bandwidth achieved region full paper show read result slightly write result interaction read-ahead mechanism smaller cases cases parameters extractable read benchmark slight variant basic read benchmark backwards read benchmark strides disk reverse direction measures parameters basic read write versions avoiding read-ahead optimizations tend obscure results plan investigate utility future work developed tool automatically extract parameter values graphical result extraction algorithm utilizes work statistics image-processing communities process latency versus berkeley project laid claim benchmark records machines reduced time sort report oregon graudate center june graefe parallel external sorting olcano echnical rey port cu-csi computer science uni versity colorado boulder june hill larus reinhardt ood cooperati ve-shared memory software hardware scaly multiprocessors ransactions computer systems hoare quicksort computer ournal kleiman oll eykholt shi alingiah illiams smith barton skinner symmetric multiprocessing solaris oceedings compcon spring linof smith stan thearling practical external sort shared disk mpps oceedings supercomputing pages nov nyber barclay cvetanovic gray lomet alphasort risc machine sort oceedings sigmod confer ence salzber tsukerman gray ste wart uren aughna fastsort distrib uted single-input single-output external sort sigmod recor june stonebraker operating system support database agement communications july stonebraker case shared database engiy neering sweeney doucette anderson nishimoto peck scalability xfs file system oceedings usenix annual echnical confer ence jan andem performance group benchmark nonstop sql debit-credit ransactions oceedings sigmod internay tional confer ence managament data chicago june eradata corporation dbc data base computer system manual release edition nov document number eicken culler goldstein schauser acti messages mechanism integrated communication computation oceedings annual symposium computer chitectur gold coast australia oung swami parameterized round-robin par titioned algorithm parallel external sort oceedings international arallel ocessing symposium pages santa barbara apr zagha blelloch radix sort ector multiprocessors super computing zhang larson memory-adapti sort masor database systems oceedings cascon oronto nov eop trailer end userdict end-hook end-hook eof 
million records seconds data extract parameters listed table details final version paper extraction tool made online benchmark tool set zoned subsection briefly describes zoned microbenchmark designed extract importantly bandwidth profile seconds sorted recording zones machines disk now-sort basic datamation algorithm minutesort depicted records figure stand today straight-forward figure now-sort shows algorithms algorithm result performance measurements ultrastar previous disk drive paper relate manufacturer specification difficulties learn scaling disk memoryand recording zones sectors track ranging outermost zone innermost zone o-intensive application machines learned scalable systems disk performance cache-sensitive algorithms operating system interfaces memory management paper focus methodology tuning now-sort tools found graph methodology shows achieving recording scalable zones performance earlier relied demonstrated setting skippy meeting optimistic extract sectors track local area run running skippy zone defined figure extract sectors track zone drive technique learn largest zone average sectors track sectors track values subsequent zones values performance match expectations specifications began forming set performance observe goals large difference phase delivered bandwidth sort zones repeatedly characterized drive implemented outermost progressively zone larger bandwidth components roughly sort measured tracks deliver implementation met roughly expectations increase found outer discrepancies tracks focused seeker optimization global efforts disk slow characteristic phases missing seek sort profile fixing fortunately performance seek bugs delays based application solely underlying system mechanical movements refining disk expectations arm realistic explored expectations prior phase studies limit algorithm discussion knew seeks start tuning process present variant stop skippy found technique performance tools make seek distinct experiments purposes easier setting factoring expectations visualizing rotational measured latency performance component searching measured time anomalies configuration present tools seek helped curves define function expectations sector distance resource cylinder distance skippy measuring local best-case benchmark performance directly achieved measure output seek distances tools utilize slight parameterize variant sort hardware figure hand allowing measurements sort achieve algorithm writes peak utilization fixed location variety machine beginning configurations disk found variant simple visualization disk tools space allowed reused quickly creates identify performance similar problems identical sawtooth wave animating minimum machine performance estimate counters seek time notice rotational latency nature problems arose emphasize bandwidth location importance ibm performance ultrastar counters levels zones system largest cpu bus size inner-most zone network covers switches links delivers roughly easily implement bandwidth simple tools figure ibm ultrastar zoned areas benchmark run implement ibm hierarchical ultrastar search tool figure shows remove seek run-time latency anomalies versus distance tool sector helpful seagate final barracuda stages shape efforts curve achieve slightly peakperformance seek undisturbed curves run papers now-sort textbooks tool seek forced time versus track sectors anomalies versus hand cylinders isolating note problem workstation minimal time media identifying aspect machine included differed values reported true paper seek values organized roughly obtained follow subtracting chronology experience begin derived section skippy describing benchmark upa basic data algorithm bus sysio asic suffers asic limitations address bus upa similar processor data skippy bus bmx chips work cache drive processorultrasparc memory simms interface seagate hawk rpm scsi bus fast-wide network myrinet -bit mhz s-bus scsi bus ultra workstation fast-narrow seagate barracuda rpm figure ultra workstation figuredepicts internal architecture ultra workstation bmx crossbar immediately write data disk disk area reused read version work connection memory sysio main nearby disk controller sectors cluster hardware found software buffer section cache results discuss section development presents tuning results single-node range version modern scsi algorithm ide drives forms core parallel simulated drives implementation table section lists develops drives model basic measured algorithm real drive parallel version measured now-sort pentium difficulties scaling memory running full-sized freebsd system version detailed scsi drives section connected section fast-wide relate experience scsibus figures isolating performance show problems results large skippy systems seeker call zoned finding needle drive table summarizes now-stack finally extracted conclude numbers benchmarks reflections experience disk skippy scsi disk drives scsi disk cases clear berkeley height cluster consists sawtooth wave commodity ultra rpm workstations hawk wave ultra workstation high single error ultrasparc rate processor on-chip rpm instruction barracuda disk data caches unified error rate second-level cache estimated base memory hierarchy dram diagram micropolis disk internal architecture error rate ultra workstation finally shown rotation figure time system rpm ultra centers giving error s-bus bus measurements show peak theoretical bandwidth bus inproceedings workstation arpaci-dusseauetal houses -nowsort title high-performance sorting networks workstations author andrea arpaci-dusseau remzi arpaci-dusseau david culler joseph hellerstein dave patterson booktitle proceedings acm sigmod conference management data sigmod month year address tucson internal arizona 
rpm seagate hawk disks single fast-narrow scsi bus peak experiment disk bandwidth node added additional rpm seagate barracudas disk extra fast-wide scsi card peak vary disks rpm generation hawk average rpm disks ranged lowest seagate barracuda highest micropolis drive finally latest disk rpm lowest disks measured testbed open raw disk device base base disk size base large configurations size cluster measurements generally lseek viewed seek homogeneous set write collection single workstations sector extra time disks run sequence faster rates output providing location time challenge lseek base conscious single sector programmer seek addition set write usual buffer connection single world sector close ethernet figure seeker workstation algorithm pseudocode single seek myrinet algorithm network presented card benchmark attached jumps betweeen s-bus myrinet beginning disk switchbased high-speed target local-area locale network writing single links sector capable time bi-directional time transfer rates write timed myrinet switch performed repeatedly ports parts -node cluster disk comprised shown loop -node clusters base seek set argument switches moves connected file pointer -ary tree-like absolute structure relative shown location figure -bit s-bus higher peak call rate seek time devices distance seagate bits barracuda seeker bus figure seagate barracuda peak seek curve seek wsws profile figure berkeley seagate barracuda cluster note figure seek 
time non-linear small seeks linear model long-distance seeks note seek time reported includes time distance sectors skippy base cylinder switch head switchbase heads minimal time media transfer time rotational latency shows workstations connected eight-port myrinet switches groups comprise entire -node cluster tuning user-level application performance now-sort directly affected number important software sub-systems including multi-layer operating system communication layer machine cluster runs copy solaris multi-threaded version unix strengths solaris include efficient support kernel-level threads well-developed unix file system sophisticated memory management machines running solaris cluster make present illusion single large-scale system end user cluster employs glunix prototype distributed operating system berkeley glunix monitors nodes system load-balancing coschedules parallel programs job control redirection measurements place dedicated environment primarily glunix parallel program launcher parallel versions now-sort written support split-c library split-c parallel extension supports efficient access global address space distributed memory machines split-c library group synchronization communication primitives including barriers reductions communication utilized active messages communication layer designed low latency high bandwidth switch-based networks active message essentially restricted lightweight remote procedure call process sends active message specifies handler executed remote node message received handler executes atomically respect message arrivals version active messages gam supports single communicating process workstation time gam myrinet round-trip latency roughly uni-directional bandwidth node sending receiving tuning application programmers set performance expectations hope achieve mflops rating absolute execution time level speed-up expectations programmer determine point reached sufficient performance times expectations vaguely defined worse omitted experience shown explicitly defining expectations important components system greatly simplify tuning complex applications section describe experience developing meeting expectations primary building-block nowsort single-node algorithm path contained simple steps carefully chose initial expectations based models measurements system operating ideal circumstances implemented straight-forward algorithm potential achieving goals finally measured performance phases implementation focused efforts portions meet expectations sorting benchmark stresses memory sub-systems machine expectations focused memory system performance designing algorithm enumerated goals single-node sort perform minimum amount required avoid paging virtual memory ensure dominates total run-time transfer data disk peak sequential rates expectation basic disks slowest component system minimized general performance achieved performing extra computation additional memory copies accessing disk sorting minimum amount required determined amount memory system records sorted fit memory one-pass sort record read written disk two-pass sort required record read written disk memory explicitly managed paging virtual memory disk occur paging damaging environment disks holds records sorting swap space paging hurt memory performance interferes sequential access patterns disk transfers expectation motivated previous work diskto-disk sorting previous researchers found clever ways hide cost internal sorting overlapping disk goal implementation finally transfers disk proceed 
maximum rate achieve maximum throughput disk seeks optimization performed two-pass model sorted run pass temporarily written disk read back minimized achieved accessing disk sequentially sufficiently large transfer sizes sorting accesses data disk regular deterministic fashion goal attainable expectations predict desired time sort function number records size record expected time amount memory peak read write disk bandwidths determining amount memory peak disk bandwidth system required implement simple configuration tools memory configuration tool expectations require now-sort aware amount memory ideal case amount reported simple system call operating system solaris give accurate assessment free memory developed user-level tool accessing amounts memory monitoring paging activity memory configuration tool accurately estimates amount user program safely allocate machine physical memory configuration tool determined memory user applications tool number limitations notably memory remain constant tool application execute sufficient forming expectations determines passes required records disk specifies number records sorted pass paging seagate disks scsi bus rpm hawk narrow rpm hawk narrow rpm barracuda wide rpm barracuda wide hawks barracudas table disk bandwidth expectations read write columns show peak bandwidth reported disk configuration tool measurements system required determine scsi-bus limits peak performance disk configuration tool concretely set expectations peak disk bandwidth developed simple disk configuration tool program serves purposes automatically adjust amount data striped disk handle disks differing performance characteristics reports maximum achievable bandwidth processor performing work tool unaware bottlenecks system set unrealistically high expectations achievable bandwidth multiple disks read rpm disk disk configuration tool revealed read disks due saturation fast-narrow scsi bus naive model extrapolated expectation difference full set expectations disk performance determined disk configuration tool shown table expectations well-defined began developing now-sort code single workstation implementation distinct code paths depending passes required sort records memory describe experience tuning one-pass sort two-pass sort initial version one-pass single-node sort contained simple steps read program begins opening input file read system call transfers -byte records disk main memory internal sort quicksort performed keys records memory quicksort -byte key separated -byte record pointer set full record separation sort operate efficiently swapping keys pointers full records quicksort write list sorted keys pointers traversed order gather sorted records output buffer output buffer fills written disk write system call finally fsync called ensure data safely disk file closed measurements revealed initial implementation failed meet expectations ways fewer records expected sorted paging disk time internal sort noticeable percentage total execution time briefly discuss located fixed performance problems track unexpected paging activity monitored disk traffic increasing number records sorted visually observed traffic implementing small performance meter diskbar detail tool found sorting records machine memory small amount paging traffic occurred increased input size traffic steadily worsened machine thrashing sort write phases readily diagnosed classic problem read system call file system unnecessarily buffering input file size file reached half memory operating system forced discard memory pages replacement policy chose discard running sort program buffered useless input file switching mmap interface madvise inform file system sequential access pattern found sort records paging desired evaluate shorten internal sorting time monitored cpu utilization cpubar home-grown visualization tool executing now-sort low cpu utilization observed read phase implied overlap part internal sort read phase suggested performed bucket sort reading records disk partial-radix sort optimization reduced in-memory sort time onemillion records disks total execution time cache configuration tool reduce time spent stalled memory keys touched partial-radix sort made fit second-level cache optimal number keys bucket determined size cache current implementation optimized cache ultrasparc-i running now-sort cache architecture require size second-level cache determined look-up hardware parameter table cache configuration tool similar microbenchmarks sort trivially modified accept cache size parameter hard-coded constant two-pass version cylinder switch head switch bandwidth location zoned seek time distance seeker figure seagate hawk results presented seagate referred hawk note disk older generation head cylinder switch times good disk large number zones typical seagate disks finally seek curve standard time distance sectors skippy base cylinder switch head switchbase heads minimal time media transfer time rotational latency cylinder switch head switch bandwidth location zoned seek time distance seeker figure seagate barracuda results presented seagate referred barracuda note excellent head cylinder switch times skippy curve large number platters seagate devices odd number platters hypothesis extra platter position-sensing information zoned curve shows large number zones small indistinguishable finally seeker curve ranges time distance sectors skippy base cylinder switch head switch base heads minimal time media transfer time rotational latency cylinder switch head switch bandwidth location zoned seek time distance seeker figure micropolis micropolis disk worst performers scsi class poor switch times exceptionally high zone profile odd zone delivers notably higher performance explanation behavior point time distance sectors skippy base basehead switchcylinder switch heads minimal time media transfer time rotational now-sort latency leverages cylinder switch code head switch optimized one-pass sort bandwidth highestlevel location phases create runs application zoned repeatedly seek reads time portion distance input file seeker sorts figure ibm writes ultrastar sorted run disk presents disk kernel-threads typical output curve overlap reading reasonable switch writing times disk effect one-pass sort zones called multiple disk times time outermost half zones occupy memory half merge runs disk sorted seek runs numbers read noisy disk merged repetition single sorted output explanation file run created phase effect mapped time memory distance sectors records skippy base base written head switch disk cylinder record switch lowest-valued heads key minimal time picked media transfer top time run rotational copied latency cylinder output switch buffer head output switch buffer fills written disk bandwidth location zoned seek time distance seeker figure ibm measurements modern initial disks two-pass implementation study revealed creating fastest rotating runs disk expected amount revolution time rpm low merging rotational slower latencies desired low observing small-seek delivered costs read head disk bandwidth cylinder switch times simple diskbar tool prominent quickly zoning illuminated problem ibm disks reading distinct sorted zoning run found sequentially seagate layout multiple runs disk resulted disk seek disks time read distance sectors significantly reducing achieved skippy bandwidth base cylinder achieve near-peak switchhead bandwidth disks now-sort amortizes disk seek-time carefully managing merge large amount data explicitly prefetched run reading switch empirically found prefetch-buffers sufficiently large achieve near-sequential performance kernel threads required successfully prefetch data writing disk reader thread begins copying run merge buffer merger thread waits set buffers full copies record lowest-valued key output buffer output buffer fills writer thread writes buffer disk marking buffer empty finished seek configuration tool general buffer size merge phase calculated automatically function disk characteristics disk configuration tool return disk seek time peak disk bandwidth application non-sequential transfers simple calculation reveals required size transfer obtain desired fraction peak disk bandwidth ability focus single-node performance essential tool debugging performance analysis parallel machines now-sort optimize cache memory processor performance single-node algorithm behavior hold parallel algorithm found automatic configuration high-performance applications adapt wide variety system parameters adapting now-sort system parameters simplified concentrating behavior single node end developed memory capacity disk bandwidth configuration tools cache disk seek time tools dynamic environment tools served dual purpose adapting sort varying hardware parameters differing speed disks differing amounts memory crucial setting expectations expectations determine achieving acceptable transfer rates disks making effective memory traditional tools report code spending time report stop tuning profiling final code inform code bound nowsort implies tuning completed applications imply tuning needed identifying performance problems single node simplified feedback small set visualization tools implemented cpubar tool displays current cpu utilization divided user system wait idle time diskbar displays delivered bandwidth local disk including swap partition current text-based tools top iostat report similar information update statistics found update rates order ten times capture bursts resource usage cpu tool textual counterpart enabled visualize summation multiple components simultaneously anomalies simple tools found incredibly giving instantaneous continuous view system behavior today rarely run applications concurrent monitoring tuning in-memory behavior sort easier expected largely due development cache-sensitive algorithms previous 
researchers early experience ran shade instruction set simulator evaluate implementation largely becausewe easily match reported statistics back specific lines user-level code information tuning shade trace kernel code important interactions now-sort algorithm internal sort consumed larger fraction total execution time tools specifically aimed finding memory bottlenecks cprof memspy fine-tuning codes interact underlying software systems communication layer crucial tools give information user-level code modifying tools work tandem complete machine simulator simos focusing single-node performance developed excellent building block scalable sorting algorithm step large-scale parallelism define set expectations parallel performance defining expectations implemented algorithm small number machines small cluster configured full set disks found implementation meet initial expectations single-node version now-sort found discrepancies expectations measured performance found removed inefficiencies implementation parallel version differences found due unrealistic expectations based overly simplistic model system refining expectations measuring small cluster determine hardware configuration entire cluster machines ideal case process executing parallel application sorts number records amount time single-node version scalability now-sort perfect problem size increased linearly number workstations microbenchmarks active message communication performance transferred nodes implication level bandwidth sending set records node requires noticeably time reading records disk add parallel expectation enumerated single-node sort overlap communication phases sort sections present algorithm attempts hide cost communication read phase sort discuss expectation met amount disk bandwidth base heads minimal time media transfer time rotational latency cylinder switch head switch bandwidth location zoned axis axis data figure quantum fireball ide ide disks study low profile disk recording surfaces recent drives high sectors track ratio single zone definition suggests drive manufacturers chose simplicity performance unable generate seek profile figure full paper time distance sectors skippy base cylinder switch head switch base heads minimal time media transfer time rotational latency cylinder switch head switch bandwidth location zoned seek time distance seeker figure ibm ide ide drive study recent scsi drives considerably lower bandwidth higher switching times time distance sectors skippy base cylinder switch head switchbase heads minimal time media transfer time rotational latency cylinder switch head switch bandwidth location zoned seek time distance seeker figure simulated dartmouth simulator accurately simulates disk generation high rotational latency switch times minimal time media true disks era zone entire disk finally seek profile regular matches formula utilized authors note data simulator cleaner real-world disks time distance sectors skippy base cylinder switch head switchbase heads minimal time media transfer time rotational latency cylinder switch head switch bandwidth location zoned seek time distance seeker figure dec simulated data disksim michigan disk simulator presented disk modern dartmouth simulator show realistic behavior text zone profile uninteresting seek curve expected model year interface capacity dimensions rpm rotational recording latency surfaces seagate scsi hawk seagate scsi barracuda micropolis scsi ibm ultrastar scsi ibm scsi quantum fireball ide ibm-dttaide simulated dec simulated table disks disks years range rpm rpm detailed specifications ibm ultrastar disk drive table relevant information gather disk drives on-line specification sheets drives excepting simulated disks inch half height low profile table describes simulated disk drives drive represents trial benchmarks dartmouth disk drive simulator dec represents trial disksim simulator developed michigan assume operating system scsi overheads similar results show ibm drive lowest overhead access media seagate hawk barracuda drives interestingly seagate hawk considerably older rpm drives ps-adobeboundingbox atend pages atend pageorder atend ibm documentfonts ultrastar atend creator micropolis drive frame documentdata clean bit measured drives endcomments employ beginprolog zbr frame extract prolog sectors track ratio frame outermost products zone prolog file drive copyright hawk roughly frame sectors technology track corporation barracuda rights reserved ultrastar prolog file micropolis freely copied distributed finally conjunction compare documents head created cylinder framemaker switch times framebuilder graphs frameviewer show long seagate copyright barracuda notice drive preserved lowest frame head products cylinder print switch colors times hawk true color cylinder switch color time printer comparable shades gray ultrastar based luminance black-and hawk white older printer drive counting flag set number true head forces switches non-white cylinder colors learn print pure hawk black recording surfaces effect bitmap barracuda images micropolis fmprintallcolorsasblack false frame products match specification set data line table screens seagate drives printer odd default number settings recording flags surfaces control suggesting separately dedicate surface separations spot track separations mentioned process separations ide flag disk drives true figures default show printer settings write behavior changed quantum ibm false ide frame disks products graphs show caching settings activity table based lower step sizes printer fact resolution appears drives true write buffer true cache requests false empties cache postscript printer additional resolution request frame reached products behavior sets screen angles entire frequencies result graph printing shift process separations recomended graphs adobe slightly shifted variable measure chooses higher rotational latency frequencies set height true transition lower frequencies set point false measured effective fmusedefault separationscreen flag false true quantum fireball postscript level printers error accurate specification screens feature improve drive process separation rendering recording surfaces expense consistent compute time disk specifications flag table postscript quantum drive level printers head fmuseacccuratescreens switch true time postscript cylinder procedure switch defines time spot function measured frame rotation products time ibm ide process disk separations un-comment-out error compared alternative specification functions sectors track ratio dot function disk fmspotfunction abs recording surfaces head switch time cylinder switch time disk low values bit scsi disks reflects programmed disk rotation mtm sectors heads head cylinder bandwidth seek time exch abs copy add dup mul exch dup mul add dup mul exch dup mul add exch ifelse line function fmspotfunction pop elipse function fmspotfunction dup mul div mul exch dup mul exch add sqrt switch exch switch outer max fmversion min track fmlevel time languagelevel time pop languagelevel ifelse seagate fmpcolor fmlevel false colorimage pop pop true hawk seagate true ifelse framedict dict barracuda systemdict errordict errordict dict micropolis errordict ibm rangecheck stop put readline ultrastar doesn ibm recognize appletalk framedict quantum tmprangecheck errordict rangecheck put errordict fireball rangecheck framedict bug true put put framedict ibm-dtta bug false put mark machines read sim past dec lines currentfile sim string table extracted readline values cleartomark table errordict lists rangecheck extracted framedict parameters tmprangecheck disk put drive framedict including bug ranges readline bandwidth gstring exch seek curves gfile note exch values gindex seek gfile curve read pop adjusted dup minimum exit time dup media exit reflect gstring actual exch seek gindex characteristics exch put gindex dma gindex add common loop ide pop drives gstring gindex improves getinterval overhead true bind cost fmshowpage showpage load discussing fmquit achieved quit bandwidth load ide fmfailure simulated dup drives flush figures fmshowpage helvetica show findfont results scalefont setfont moveto show fmshowpage fmquit fmversion fmversion frame product version match prolog fmfailure fmbadepsf postscript lang ref man eps call dup dup search pop exch pop exch pop length roll putinterval fmfailure fmlocal framedict begin end concatprocs proc exch cvlit proc exch cvlit newproc proc length proc length add array newproc proc putinterval newproc proc length proc putinterval newproc cvx framedict begin fmnone fmcyan fmmagenta fmyellow fmblack fmcustom framenegative false framesepis fmnone framesepblack framesepyellow framesepmagenta framesepcyan framesepred framesepgreen framesepblue framecurgray framecurpat null framecurcolors framecolorepsilon eqepsilon dup neg framecolorepsilon bind framecmpcolorscmyk copy exch eqepsilon copy exch eqepsilon copy exch eqepsilon exch eqepsilon pop pop false ifelse pop pop false ifelse pop pop false ifelse bind framecmpcolorsrgb copy exch eqepsilon copy exch eqepsilon exch eqepsilon pop pop false ifelse pop pop false ifelse bind rgbtocmyk exch roll exch roll exch roll copy copy pop exch pop ifelse copy pop exch pop ifelse dup dup dup roll roll roll roll dartmouth disk simulator node disksim increased experiments verify skippy technique matches reduce complexity tuning parallel sort chose programming model explicit control operations performed node single-program-multipledata spmd spmd programming model active messages one-pass two-pass parallel sorts direct extensions single-node algorithms ease design due largely active messagesparadigm communication integrated on-going computation natural fashion change single-node versions occurs records initially read disk record read disk range-partitioned set workstations machine receives roughly equivalent fraction data workstation receiving lowest-valued keys workstation lowest records temporarily buffered transmission multiple records single active message achieving communication bandwidth receipt message active message handler splits keys buckets copies record record array internal sort write steps entire merge phase two-pass sort identical single-node versions require communication nodes disks expected work roll disk simulators roll bind cmyktorgb dup dup roll add roll roll add roll add exch dup pop roll exch dup pop exch exch dup pop exch bind framesepinit realsetgray bind framesetsepcolor framesepblue exch framesepgreen exch framesepred exch framesepblack exch framesepyellow exch framesepmagenta exch framesepcyan exch framesepis fmcustom setcurrentscreen bind framesetcyan framesepblue framesepgreen framesepred framesepblack framesepyellow framesepmagenta framesepcyan framesepis fmcyan values setcurrentscreen bind extracted framesetmagenta measurements match framesepblue simulator disk framesepgreen specifications framesepred simulated results framesepblack noticeably framesepyellow cleaner cluster measurement framesepmagenta results river making comparing framesepcyan fast case framesepis simulation common fmmagenta remzi results setcurrentscreen bind disksim arpaci-dusseau framesetyellow result eric shows framesepblue anderson downward noah spikes treuhaft framesepgreen david sawtooth culler framesepred transition joseph framesepblack hellerstein real david disks patterson framesepyellow dartmouth kathy result yelick framesepmagenta computer science suggesting framesepcyan division newer framesepis disksim california fmyellow simulates berkeley drive setcurrentscreen bind closely older framesetblack dartmouth framesepblue introduce simulator zoned framesepgreen drive framesepred river skippy result data-flow framesepblack accompanied programming environment zoned framesepyellow result substrate framesepmagenta make clusters general framesepcyan computers observations river framesepis designed zoned fmblack provide results maximum setcurrentscreen older performance bind simulated drives common framenosep case newer framesepis ide fmnone drives face show setcurrentscreen nonuniformities bind recording hardware zone software framesetsepcolors framedict workload ide river begin drives based exch implies add simple roll drive design manufacturers framesepcolors features exch sacrifice queue end bind performance storage simplicity redundancy framecolorinseplistcmyk mechanism called achieved framesepcolors graduated bandwidth exch declustering dup ide implemented drives roll low reflect programmed number framecmpcolorscmyk dma data-intensive pop true applications exit river scsi drives forall validate seagate dup design drives true near-ideal noticeably pop performance false finely zoned bind variety non-uniform ibm performance framecolorinseplistrgb micropolis scenarios drives framesepcolors finally exch dup disks roll multiple zones framecmpcolorsrgb difference pop true scalable outer-track exit systems inner-track form bandwidth forall ranges dup basis true pop false highperformance recent bind computing comprehensive market discussion realsetgray recent disk setgray years drive load zoning manufacturers realsetrgbcolor found setrgbcolor load growth customer realsethsbcolor appetite sethsbcolor load capacity end outstripping setgray moore framedict law begin cluster framesepis systems fmnone key component realsetgray framesepis design fmblack today scalable realsetgray data-intensive framesepis fmcustom behavior architectures framesepred frustrating framesepgreen observed framesepblue relationship transfer rate realsetgray disk realsetgray pop ifelse ifelse ifelse end bind position setrgbcolor framedict begin framesepis fmnone linear function realsetrgbcolor single copy roll examining framecolorinseplistrgb zone framesepblue results exch framesepgreen curve exch framesepred closer parabolic linear ifelse quadratic fmpcolor function realsetrgbcolor form currentcmykcolor rgbtocmyk ifelse framesepis fmblack exch fit roll zone pop 
graph linear function fact fitting linear quadratic functions data standard linear regression techniques learned quadratic function factor factor error simple linear fit linear fit explored extra advantage required highest lowest bandwidth values drive found quadratic fit values factor linear fit values fact cases quadratic fit aspect values pop cluster pop linear systems fit framesepis fmyellow values common-case pop factor performance exch roll great pop deal model worse pop framesepis employed reported fmmagenta recommend peak usage pop performance pop quadratic exch discrepancy fit arises exch simple pop forms construct framesepis performance fmcyan linear heterogeneity model pop pop requiring clustered pop components exch data points simplest pop heterogeneity matches pop pop profiles hardware pop ifelse cluster linear ifelse composed ifelse fit ifelse ifelse machines realsetgray disks differing ifelse speeds end bind capacities zones principle sethsbcolor exact step framedict problem function begin solved framesepis utilized fmnone fiat disksim simulator packaged realsethsbcolor makes clusters realsethsbcolor ibm exact spmore characterization nefarious seeker currentrgbcolor heterogeneities figures setrgbcolor software table ifelse performance end show bind seek arise latency framedict dynamically begin start setcmykcolor multitude drive sources pop unexpected areas realsetcmykcolor operating setcmykcolor function system load seek activity distance uneven load sectors realsetcmykcolor placement seeks roll heterogeneous index tenth mixture add max operations disk min exch machines seek software latency roll appears heterogeneity repeat increase setrgbcolor linearly hard pop sector bind control distance ifelse quickly userdict seek latency time setcmykcolor increases framedict surprisingly larger hardware begin heterogeneity framesepis fmnone non-trivial numbers control realsetcmykcolor cylinders close copy examination roll cylinders data reveals disk framecolorinseplistcmyk framesepblack seeks bandwidth exch reaching framesepyellow innermost outer zones exch latency framesepmagenta apparently increase identical higher disks exch framesepcyan bandwidths depending locations ifelse framesepis unused fmblack bad disk blocks exch presented roll pop pop pop iopads framesepis input fmyellow output pop parallel exch distributed roll pop systems pop atlanta framesepis georgia fmmagenta pop attempting pop prevent exch performance exch heterogeneity pop framesepis fmcyan designed pop pop system pop takes exch account pop pop inherent pop design pop consideration ifelse ifelse paper ifelse describe ifelse river ifelse data-flow realsetgray programming ifelse environment end bind substrate put fmlevel clusters goal patprocdict river dict dup provide begin common-case maximal setlinewidth performance moveto o-intensive lineto applications stroke achieved moveto lineto basic system stroke mechanisms moveto distributed queue balances lineto work stroke bind consumers system setlinewidth data moveto layout lineto access stroke moveto mechanism lineto called graduated stroke declustering moveto dynamically lineto adjusts stroke bind load generated setlinewidth producers moveto center linear river design lineto observable high-performance stroke ibm implementation seek moveto river result lineto dqs seek stroke time bind data increases flow setlinewidth rapidly operators autonomously moveto sectors adaptive lineto track rates ratio stroke time moveto lineto decreases producer places rapidly stroke data area moveto requiring fast lineto arm stroke movement bind consumer takes sector setlinewidth data distance moveto conclusions lineto fast paper presents stroke disk moveto benchmarks lineto interposing skippy dqs zoned stroke seeker operators moveto extract data lineto range flow stroke load bind parameters end naturally modern balanced disk patdict drives consumers dict skippy dup running begin illustrates rates patterntype advantage approach simplicity measuring disks lack linearly global increasing coordination required consumers stride change patterns rate autonomously technique time extensions communicating clients result full-bandwidth balanced consumption bandwidth naturally utilized times consumers set painttype tilingtype bbox xstep ystep paintproc begin patprocdict bstring patprocdict bstring exec true bstring imagemask ifelse end bind end combinecolor filter data framesepis complete fmnone rotational near-simultaneously effect graymode fmlevel kinds important disk aspect measurements river pattern devicecmyk flexible knowledge setcolorspace redundant present disk framecurcolors layout benchmark getinterval access aload utilizes mechanism pop called disk framecurpat graduated rotational setcolor declustering mechanism framecurcolors generalization characterizing disk mechanism proposed defeat framecurgray realsetgray fmpcolor graymode framecurcolors exch framecurgray mul realsetcmykcolor framecurcolors exch graymode exch framecurgray mul exch framecurgray ifelse ifelse realsetrgbcolor ifelse ifelse ifelse framecurcolors getinterval aload framecolorinseplistcmyk framesepblack exch framesepyellow exch framesepmagenta exch framesepcyan framesepis fmcustom framecurgray ifelse framesepis fmblack framecurgray exch mul exch roll pop pop pop framesepis fmyellow pop framecurgray exch mul exch roll pop pop framesepis fmmagenta pop pop framecurgray exch mul exch exch pop framesepis fmcyan pop pop pop framecurgray exch mul exch pop pop pop pop ifelse ifelse ifelse ifelse ifelse graymode fmlevel pattern devicegray setcolorspace framecurpat setcolor graymode fmlevel dup pop framecurgray realsetgray ifelse ifelse bind savematrix orgmatrix currentmatrix pop bind restorematrix orgmatrix setmatrix bind dmatrix matrix dpi dmatrix 
defaultmatrix dtransform dup mul exch dup mul add sqrt freq dpi dup div round dup pop mul div sangle dmatrix defaultmatrix dtransform exch atan dpiranges cmlowfreqs ylowfreqs klowfreqs clowangles mlowangles ylowtdot true benchmarks run scsi drives ide drives disk simulators revealing numerous results modern disk drives find minimum time access drive media vary widely drives generation seagate drives show excellent switching time characteristics ibm drives bandwidth results show similarities drives made manufacturer odd number recording surfaces present seagate drives scsi drives older show performance ide drives switching times bandwidth overhead ide reads writes lower improvements linear areal density reflected sectors track number recording surfaces measured drives modern drives higher sectors track ratio older drives number recording surfaces concurrently decreasing rotational latency seek times decrease head-switch cylinder-switch times important hawk switch times roughly rotation time percentages ibm simple models disk behavior characterize disks seek rotation time longer full paper provide details skippy read write benchmarks future work includes exploration backwards read variant retains benefits read benchmark avoiding interaction read-ahead mechanism benchmarks extraction tool measured data made public website hope run benchmark contribute data active archive disk characteristics remzi arpaci david culler arvind krishnamurthy steve steinberg kathy yelick empirical evaluation cray-t compiler perspective annual international symposium computer architecture iscapages june peter chen david patterson approach performance evaluation self-scaling benchmarks predicted performance proceedings acm sigmetrics conference pages david culler lok tin liu richard martin chad owen yoshikawa logp performance assessment fast network interfaces ieee micro gregory ganger bruce worthington yale patt disksim simulation environment version manual technical report cse-tr- department electrical engineering computer science michigan february cristina hristea daniel lenoski john keen measuring memory hierarchy performance cache-coherent multiprocessors micro benchmarks supercomputing san jose november ibm ultrastar hardware functional specification models rpm version document number ibm storage products division june ibm ibm disk drive specifications http storage ibm david kotz song bac toh sriram radhakrishnan detailed simulation model disk drive technical report pcs-tr department computer science dartmouth college july larry mcvoy carl staelin lmbench portable tools performance analysis proceedings winter usenix january rodney van meter observing effects multi-zone disks proceedings usenix conference january micropolis micropolis disk drive specifications http procom homepage tech quantum quantum disk drive specifications http quantum chris ruemmler john wilkes introduction disk drive modeling ieee computer march rafael saavedra stockton gaines michael carlton characterizing performance space shared-memory machines micro-benchmarks hot interconnects san jose august rafael saavedra-barrera cpu performance evaluation execution time prediction narrow spectrum benchmarking phd thesis berkeley computer science division february david schwarderer andrew wilson understanding subsystems adaptec press edition january seagate seagate disk drive specifications http seagate carl staelin larry mcvoy mhz anatomy micro-benchmark proceedings usenix annual technical conference pages berkeley usa june usenix association bruce worthington greg ganger yale patt john wilkes on-line extraction scsi disk drive parameters proceedings acm sigmetrics conference pages 
true false true true false false false cmhighfreqs yhighfreqs khighfreqs chighangles mhighangles yhightdot false false true false false true true false patfreq screenindex dpiranges length dup dpiranges exch dpi exit pop ifelse bind getcyanscreen chighangles cmhighfreqs clowangles cmlowfreqs ifelse screenindex dup roll roll fmspotfunction load bind getmagentascreen mhighangles cmhighfreqs mlowangles cmlowfreqs ifelse screenindex dup roll roll fmspotfunction load bind getyellowscreen yhightdot yhighfreqs ylowtdot ylowfreqs ifelse screenindex dup roll roll div add div mul dup floor mul exch repeat fmspotfunction fmspotfunction load ifelse exch bind getblackscreen khighfreqs klowfreqs ifelse screenindex fmspotfunction load bind getspotscreen getblackscreen bind getcompositescreen getblackscreen bind fmsetscreen fmlevel setscreen load dict begin halftonetype spotfunction exch angle exch frequency exch accuratescreens fmuseacccuratescreens currentdict end sethalftone bind ifelse setdefaultscreen fmpcolor orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer orgxfer cvx settransfer ifelse orgfreq organgle orgproc cvx setscreen bind setcurrentscreen framesepis fmnone setdefaultscreen getcompositescreen fmsetscreen ifelse framesepis fmcustom setdefaultscreen getspotscreen fmsetscreen ifelse setdefaultscreen framesepis fmcyan getcyanscreen fmsetscreen framesepis fmmagenta getmagentascreen fmsetscreen framesepis fmyellow getyellowscreen fmsetscreen getblackscreen fmsetscreen ifelse ifelse ifelse ifelse ifelse ifelse bind end gstring fmlocal gfile fmlocal gindex fmlocal orgrxfer fmlocal orggxfer fmlocal orgbxfer fmlocal orgxfer fmlocal orgproc fmlocal orgrproc fmlocal orggproc fmlocal orgbproc fmlocal organgle fmlocal orgrangle fmlocal orggangle fmlocal orgbangle fmlocal orgfreq fmlocal orgrfreq fmlocal orggfreq fmlocal orgbfreq fmlocal yscale fmlocal xscale fmlocal edown fmlocal manualfeed fmlocal paperheight fmlocal paperwidth fmlocal fmdocument array fmfonts exch copies exch framedict begin manualfeed exch paperheight exch paperwidth exch framenegative exch edown exch yscale exch xscale exch fmlevel manualfeed setmanualfeed fmdicttop countdictstack add fmoptop count setpapername manualfeed true papersize ifelse manualpapersize false ifelse desperatepapersize false ifelse select requested paper size frame print job fmfailure count fmoptop pop pop countdictstack fmdicttop pop end dict dup pagesize paperwidth paperheight put setpagedevice stopped select requested paper size frame print job fmfailure dict dup manualfeed manualfeed put setpagedevice stopped pop ifelse fmpcolor currentcolorscreen cvlit orgproc exch organgle exch orgfreq exch cvlit orgbproc exch orgbangle exch orgbfreq exch cvlit orggproc exch orggangle exch orggfreq exch cvlit orgrproc exch orgrangle exch orgrfreq exch currentcolortransfer framenegative pop exch concatprocs roll copy setcolortransfer cvlit orgxfer exch cvlit orgbxfer exch cvlit orggxfer exch cvlit orgrxfer exch currentscreen cvlit orgproc exch organgle exch orgfreq exch currenttransfer framenegative exch concatprocs dup settransfer cvlit orgxfer exch ifelse end pagesave fmlocal orgmatrix fmlocal landscape fmlocal pwid fmlocal fmbeginpage framedict begin pagesave save setmiterlimit landscape exch landscape rotate exch dup pwid exch neg translate pop pop pwid exch ifelse edown pwid concat moveto paperwidth lineto paperwidth paperheight lineto paperheight lineto lineto setgray fill xscale yscale scale orgmatrix matrix gsave fmendpage grestore pagesave restore end showpage fmfontdefine framedict begin findfont reencode index exch definefont fmfonts roll put end fmfills framedict begin dup array fillvals exch dict patcache exch end fmfill framedict begin fillvals roll put end fmnormalizegraphics newpath moveto setlinewidth setlinecap sethsbcolor setgray bind fmlocal fmlocal fmlocal fmlocal llx fmlocal lly fmlocal urx fmlocal ury fmlocal fmbeginepsf end fmepsf save showpage adobe postscript language manual edition page operators eps file emphasis banddevice banddevice fmbadepsf clear clear fmbadepsf cleardictstack cleardictstack fmbadepsf copypage copypage fmbadepsf erasepage erasepage fmbadepsf exitserver exitserver fmbadepsf framedevice framedevice fmbadepsf grestoreall grestoreall fmbadepsf initclip initclip fmbadepsf initgraphics initgraphics fmbadepsf initmatrix initmatrix fmbadepsf quit quit fmbadepsf renderbands renderbands fmbadepsf setglobal setglobal fmbadepsf setpagedevice setpagedevice fmbadepsf setshared setshared fmbadepsf startjob startjob fmbadepsf lettertray lettertray fmbadepsf letter letter fmbadepsf lettersmall lettersmall fmbadepsf tray tray fmbadepsf fmbadepsf ledgertray ledgertray fmbadepsf ledger ledger fmbadepsf legaltray legaltray fmbadepsf legal legal fmbadepsf statementtray statementtray fmbadepsf statement statement fmbadepsf executivetray executivetray fmbadepsf executive executive fmbadepsf tray tray fmbadepsf fmbadepsf tray tray fmbadepsf fmbadepsf small small fmbadepsf tray tray fmbadepsf fmbadepsf tray tray fmbadepsf fmbadepsf fmnormalizegraphics ury urx lly llx exch forall div add div add translate rotate early div parallel neg database div neg systems translate task urx llx div data production shared multiple producers flexible ury lly fashion div mirrors large scale llx sequential neg collections lly neg disks translate fmdicttop countdictstack add producers data fmoptop flow count producer bind multiplexes fmendepsf count bandwidth fmoptop pop pop data sets countdictstack fmdicttop handling pop ensure end fmepsf produces restore share framedict begin global bind bandwidth framedict begin collection setmanualfeed beginfeature result manualfeed full-bandwidth true balanced statusdict production manualfeed true put bandwidth endfeature utilized bind times max copy producers exch pop bind data set min complete copy exch pop near-simultaneously bind introducing inch river mul describe pagedimen paperheight programming model abs exch graphical paperwidth interface abs composing river papername programs exch pop based ifelse traditional bind data-flow diagrams papersizedict composed fmlocal operators setpapername similar database query plans scientific data-flow systems intuitive interface papersizedict dict programmers focus papersizedict begin applicationspecific papername logic unknown river letter transparently handles inch inch issues pagedimen high-performance lettersmall inch parallelism inch pagedimen application tabloid demonstrate inch inch river pagedimen interface ledger number inch inch dataintensive pagedimen applications legal inch inch validate pagedimen statement inch inch perforslowdown pagedimen now-sort single executive anomaly inch inch case pagedimen single disk inch poor inch layout single pagedimen disk hot inch spot inch single pagedimen machine light small cpu single inch machine inch heavy pagedimen cpu inch inch pagedimen inch inch pagedimen end bind papersize papersizedict begin letter lettertray letter lettersmall lettertray lettersmall tabloid tray ledger ledgertray ledger legal legaltray legal statement statementtray statement executive executivetray executive tray tray small tray small tray tray unknown unknown papersizedict dup papername papername unknown ifelse end statusdict begin stopped end bind manualpapersize papersizedict begin letter letter lettersmall lettersmall single machine memory tabloid load figure ledger now-sort ledger perturbance legal legal graph depicts statement best-case statement performance executive now-sort executive versus performance slight disk cpu memory perturbations performance results small small relative -node nowsort delivers unknown data unknown near-peak papersizedict disk dup rate papername papername unknown run ifelse mance end system stopped bind cases river desperatepapersize near-ideal statusdict performance setpageparams face paperwidth severe performance paperheight perturbations statusdict begin setpageparams stopped end true ifelse bind diacriticencoding notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef motivate notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore grave braceleft bar braceright asciitilde notdef adieresis aring ccedilla eacute ntilde odieresis udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave evaluation ucircumflex udieresis oneand two-pass parallel sorts began measurements four-node cluster ultrasparc workstations disk initial experiments revealed desired properties algorithm communication costs completely hidden wait time unnecessary paging data transferred disk peak bandwidth negligible internal sorting time added disks cluster found performance increase expected found direct method isolating performance problem run application hardware performance counters measure behavior program difficulty dagger notdef cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notdef oslash notdef notdef notdef notdef yen notdef notdef notdef notdef notdef notdef ordfeminine ordmasculine notdef oslash questiondown exclamdown logicalnot notdef florin notdef notdef guillemotleft guillemotright ellipsis notdef agrave atilde 
otilde endash emdash quotedblleft quotedblright quoteleft quoteright notdef notdef ydieresis ydieresis fraction currency guilsinglleft guilsinglright daggerdbl periodcentered quotesinglbase quotedblbase perthousand acircumflex ecircumflex aacute edieresis egrave iacute icircumflex idieresis igrave oacute ocircumflex notdef ograve uacute ucircumflex ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron reencode dup length dict begin index fid pop pop ifelse forall encoding diacriticencoding currentdict end bind fmpcolor beginbitmapcolor bitmapcolor beginbitmapcolorc bitmapcolorc beginbitmaptruecolor bitmaptruecolor beginbitmaptruecolorc bitmaptruecolorc beginbitmapcolor bitmapgray beginbitmapcolorc bitmapgrayc beginbitmaptruecolor bitmaptruegray beginbitmaptruecolorc bitmaptruegrayc ifelse fmprintallcolorsasblack dup index index pop repeat framecurcolors astore pop combinecolor bind graymode true bwidth fmlocal bpside fmlocal bstring fmlocal onbits fmlocal offbits fmlocal xindex fmlocal yindex fmlocal fmlocal fmlocal setpatternmode fmlevel bwidth exch bpside exch bstring exch onbits offbits freq sangle landscape add exch exch xindex add div bpside mul cvi yindex add div bpside mul cvi bstring yindex bwidth mul xindex idiv add xindex mod bitshift framenegative onbits onbits add offbits offbits add ifelse setscreen offbits offbits onbits add div framenegative exch framecurgray exch pop pop dup patcache exch patcache exch dup patdict bstring roll put patdict patfreq screenindex div dup matrix scale makepattern dup patcache roll roll put ifelse framecurgray framecurpat exch ifelse graymode false combinecolor bind setgrayscalemode graymode graymode true fmlevel setcurrentscreen framecurgray exch combinecolor bind normalize transform round exch round exch itransform bind dnormalize dtransform round exch round exch idtransform bind lnormalize dtransform exch cvi idiv mul add exch idtransform pop bind lnormalize setlinewidth bind setlinecap bind pfill graymode fmlevel gsave setgray eofill grestore bind pstroke graymode fmlevel gsave setgray stroke grestore stroke bind fillvals fmlocal fillvals exch dup type stringtype setpatternmode setgrayscalemode ifelse bind pfill gsave eofill grestore bind vclip clip bind vstrk currentlinewidth exch setlinewidth pstroke setlinewidth bind pstroke bind nclip strokepath clip newpath bind nstrk currentlinewidth exch setlinewidth pstroke setlinewidth bind newpath moveto bind lineto bind curveto bind closepath bind fmlocal exch newpath normalize moveto pop normalize lineto bind closepath bind fmlocal fmlocal fmlocal fmlocal exch exch exch exch bind rad fmlocal rarc rad arcto bind rad exch normalize exch exch normalize exch exch mark newpath rad add moveto rarc rarc rarc rarc closepath stopped cleartomark bind rrr rad exch normalize exch exch normalize exch exch normalize exch exch normalize exch exch newpath normalize moveto mark rarc rarc rarc rarc closepath stopped newpath moveto lineto lineto lineto closepath cleartomark bind grestore gsave clip setcurrentscreen bind grestore gsave clip setcurrentscreen bind fmpointsize fmlocal fmfonts exch problem performance heterogeneity perform simple experiment now-sort high-performance parallel external sort clusters experiment sort runs machines run perform slight perturbation sort machines results perturbation experiments shown figure graph perturbations single machine global performance effect single file single machine poor layout tracks versus outer performance drops percent single disk hot spot competing data stream performance drops factor cpu loads machines decrease performance proportional amount cpu steal finally memory load pushes machine page factor performance lost build system avoids situations balancing load system perfectly times meticulously managing resources system difficult system size complexity increase carefully managing system near-impossible approaching problem manner assuming presence performance faults providing substrate operate spite rest paper structured section describe design system current implementation euphrates section validate performance properties dynamic infrastructure measurements distributed queues graduated declustering present initial application experience section related work found section section present plans future work section conclude section describes design river environment current implementation euphrates briefly describe hardware software environment present river data model data stored accessed disk continue explaining components river programming model including details typical river program constructed conclude discussion river prototype euphrates runs cluster ultra workstations connected myrinet fmpointsize localarea scalefont network setfont workstation bind mhz fmpointsize exch ultrasparc processor bind seagate moveto hawk rpm show disks bind rotate swap space scale bind common case memory gsave moveto show grestore bind moveto roll widthshow bind gsave moveto roll widthshow grestore bind moveto exch ashow bind gsave moveto exch ashow grestore bind moveto roll exch awidthshow solaris bind operating gsave system moveto machine roll modern exch multi-threaded awidthshow grestore unix communication performed active bind messages gsave newpath generation normalize communication layer designed distributed computing exposes raw performance myrinet providing support threads blocking communication events multiple independent endpoints fast message layers support blocking communication events translate require moveto polling dnormalize network interface scale roll receive arc messages closepath boundless pfill polling fill consumes cpu grestore cycles bind gstrk savematrix building newpath index infrastructure div add exch river index div exch normalize index div exch index div add exch translate scale roll arc restorematrix currentlinewidth exch setlinewidth pstroke setlinewidth bind gclip newpath savematrix normalize translate moveto dnormalize scale roll arc closepath clip newpath restorematrix bind single disk data gsave newpath represented normalize group translate on-disk moveto records rotate dnormalize collection record scale roll set arc named closepath fields pfill fill grestore bind types ggclip catalog savematrix newpath information normalize translate meta-data moveto system rotate data dnormalize accessed disk scale roll unordered arc collection closepath unordered clip collections newpath provide restorematrix ordering bind constraints ggstrk records savematrix newpath collection normalize application translate reading collection receive records arbitrary order subject optimizations system ordering desired application data accessed stream stream moveto ordered set rotate dnormalize records scale application roll writes arc collection closepath disk restorematrix stream currentlinewidth write exch order setlinewidth pstroke preserved applications setlinewidth bind accessing collection gsave directly savematrix receive newpath index records div add order exch index euphrates div implementation exch normalize underlying index solaris div unix file exch system index div ufs add implement exch record translate collections read scale roll disk arc restorematrix pstroke read grestore directio bind enabled aclip unbuffered newpath read savematrix disk normalize translate mmap moveto interface dnormalize scale roll arc closepath strokepath clip newpath restorematrix bind astrk gstrk bind gsave savematrix newpath index div add exch index div exch normalize index div exch index div add exch translate rotate scale roll arc restorematrix pstroke grestore bind aaclip savematrix newpath normalize translate moveto rotate dnormalize scale roll arc closepath strokepath clip newpath restorematrix bind aastrk ggstrk bind fmlocal fmlocal fmlocal fmlocal fmlocal fmlocal fmlocal fmlocal fmsaveobject fmlocal fmoptop fmlocal fmdicttop fmlocal beginprintcode fmdicttop countdictstack add fmoptop count fmsaveobject save userdict begin showpage fmnormalizegraphics index neg index deliver neg data translate bind raw disk rate endprintcode count sequential read fmoptop pop access pop simple read interface directio leads double-buffering inside file system undesirable applications writes disk write system call directio enabled implemented top ufs layout information optimizations unordered collections implemented disk manager implementation river include disk manager top raw disk order exploit range scheduling optimizations enabled disk disk perturbation perturbation clients perceive imbalance bandwidth balanced clients client client figure graduated declustering diagrams depict scenarios graduated declustering perturbation unperturbeddisks deliver bandwidth perturbed disk delivers half left disk serving partitions clients perturbed half bandwidth application left unchecked result clients receive bandwidth clients bandwidths disk adjusted compensate perturbation case graduated desclustering adjustments client receives equal share bandwidth applications system access data spread multiple disks facilitate provide abstraction parallel collection grouping set single-disk collections single logical entity parallel collection facility tracks parallel meta-data names physical locations single-disk collection form parallel collection desired ordering single-disk collections euphrates parallel collection meta-data stored nfs nfs consistency guarantees concurrent access parallel meta-data operations serialized single process application operations rare occur file opened created performance bottleneck large scale clusters presence data availability strategy important data frequently unavailable due disk machine failures river applications increased data reliability availability choose mirror single-disk collection disks housed machines cluster interested exploiting 
redundant data contained mirrors improve consistency application performance building earlier work authors introduced chained declustering key insight chained declustering failure disk mirrored system read-only load balanced evenly remaining working disks balance achieved carefully-calculated distribution read requests mirror segments remaining disks generalize technique call graduated declustering order solve performance consistency problem common case disks storing mirrored collection functional offer bandwidth time reasons enumerated earlier individual reader traditional approaches mirroring variations unavoidable reader choose mirrored segment copy read entire segment variations lead global slowdown parallel programs slow clients complete fast remedy approach problem differently picking single disk read partition client fetch data data mirrors illustrated figure case data replicated disks disk disk client alternatively send request block disk block disk disk responds request desired block solve problem graduated declustering provide client reading set collections equal portion bandwidth application clients receive expected bandwidth disk mirrors receive bandwidth mirror compensation implementation graduated declustering observe bandwidth differences clients adjust bandwidth allocation appropriately euphrates implementation simple algorithm balance load data sources disk manages segments parallel collection continually receives feedback consumers total bandwidth consumers receiving performance inequity clients detected disk manager biases requests lagging client attempts balance rates readers progress result balancing shown right-side figure disks compensate perturbation disk allocating bandwidth clients resulting bandwidths client properly balanced module loop records process msg null operate message operate msg conditionally pass message downstream put msg completion return null figure module api simple river module module messages upstream performs operation calling user-defined operate conditionally put messages downstream methodology iram ruw jvg -ho jsi rts uhty swk ynv ogk twm mesk mfk fsf foem hzk djq zag gur pcx vex -euv tbv wow zkr nqp cmw ate nns qtb pob iuj rwm mfh pkb tij veh ljr m-b gloq klj prw pqu yex countdictstack river ulg fmdicttop generic pop data end flow environment fmsaveobject restore applications bind similar parallel database mul environments read pop volcano dup applications exit constructed add component-like fashion set modules module logical thread control input output channel loop add simple bind str filter fmlocal module cfs str record string single input channel str exch applies val put function str record bind function returns true puts ihom data single output channel modules connected machine machine boundaries queues queue connects producers consumers ratematching modules dynamically sending tjb data faster consumers queues essential adjusting work ahpz distribution system begin execution application master program constructs flow flow connects desired set modules source sink time single module connected queuemust betweenthem flow instantiated fmlocal val master fmlocal program fmlocal computation begins fmlocal nxx continues fmlocal kjme fmlocal data len fmlocal processed pos fmlocal termination control exch returned master val program cfs cfs lrcb val cfs cfs bind xwa module readline basic pop unit exch programming exec river add modules forall operate pop records bind calling obtain rip records bis ris copy input pop channels calling readline put -hj place pop exch output channels exec convenience refer add set forall records pop moving pop ris gis copy pop dup system exch message logically readline module provided pop thread exch control exec one-input add forall pop pop gis bis copy pop dup add one-output exch module readline performs simple pop loop exch obtain exec records upstream add channel forall operate pop records bind put len pass exch records downstream pos exch illustrated figure len getinterval complex modules pos len getinterval copy input pop pos output len case input output number bind argument len put exch non-blocking pos wuk versions exch interfaces len ability yld perform select operation waits set channels ready returns control user euphrates modules written classes current implementation module vjko thread control benefits drawbacks main advantage approach applications naturally overlap computation data movement ryi user freed burden carefully managing thread switches dry costly amortize waffs cost uww modules pass data set records large chunks experience getinterval complicated pos modules len getinterval copy pop noticeable pos len bind string fashion felt len exch inclusion pos exch complex buffer val managementwas worth readhexstring pop implementation effort pos pos len add exch val put queues pos connect len multiple bind producers multiple copy consumers getinterval exch local readhexstring pop machine pop distributed bind machines fmlocal cases avf fmlocal flow construction fmlocal queues fmlocal bitmapsave modules fmlocal q-e messages fmlocal -ytk transmitted fmlocal wbytes producers dup consumers dup modules pop pop side mul local pop distributed queues add idiv oblivious add idiv type ifelse queue -of ifelse ifelse bind interact messages river beginbitmapbwc move commonbitmapc arbitrarily bind system beginbitmapgrayc depending commonbitmapc run-time bind performance characteristics beginbitmap lvl bitc constraints commonbitmapc flow bind dynamic load commonbitmapc balancing exch achieved routing exch messages faster gsave consumers index div queues add u-c exch index imi div add consumer exch improve translate performance rotate ordering index div relaxed neg index queues div neg multi-producer translate queue scale consumer grsqcc exch tull receive exch arbitrary interleaving wbytes messages ddh producers bitmapsave save ordering guarantee provided queue getinterval point-to-point getinterval producer copy places pop message currentfile queue message neg image bitmapsave consumer restore pzfd receives grestore bind messages receives beginbitmapbw commonbitmap receives bind ordering beginbitmapgray commonbitmap bind beginbitmap bit hse commonbitmap bum bind commonbitmap exch exch gsave index div add exch index div add exch translate rotate index div mzx neg index div neg translate scale retain exch ordering exch disk-resident bitmapsave stream save attaching single consumer wbytes single string producer currentfile stream ordered property neg stream readhexstring pop properly image maintained bitmapsave restore implementation grestore local bind queues data ngrayt structures array shared nredt threads array nbluet array locking ngreent j-xq signalling array protocol gryt euphrates fmlocal blut implementation fmlocal grnt fmlocal redt interesting fmlocal indx takes fmlocal cynu fmlocal flavors magu -zi fmlocal general yelu case fmlocal fmlocal lightweight fmlocal randomized fmlevel credit-based colorsetup scheme currentcolortransfer balance gryt exch blut exch grnt exch load redt exch consumers indx exch push-based algorithm cynu red indx producer tracks div number magu 
cwca nde outstanding lct rtl ven uem vaf lpb lju vxc qnk ttl kiq green indx div yelu blue indx div cynu magu min yelu min currentundercolorremoval exec nredt indx cynu max redt exec put ngreent ure indx rnf magu max grnt exec put nbluet indx yelu max blut exec put ngrayt indx currentblackgeneration weji exec gryt exec put mul cvi nredt messages exch mul cvi ngreent exch mul cvi consumer nbluet exch mul cvi ngrayt sends exch setcolortransfer pop hkp setundercolorremoval messages setblackgeneration cjo randomly oro voek consumers messages outstanding fiv threshold desired behavior automatically bind sending records nodes colorsetup indexed consuming devicergb higher dup rates red exch implemented div efficiently exch randomized dup algorithm green adds exch near-zero cpu div overhead exch top blue exch normal message div transfer costs setcolorspace bind cases ifelse found tran load fmlocal balancing fakecolorsetup provided tran larger-than-record string size units indx exch sort module tran indx sorted red input data indx mul green indx pass mul blue entire indx sorted run mul add disk add write eticn idiv module put order currenttransfer preserved mul cvi tran exch exact -az div exch section concatprocs provide settransfer bind functionality bitmapcolor implementation gsave handed index arbitrarily div large add set exch records index div add pullbased exch algorithm translate consumers rotate querying index producers div data neg balance index load div neg randomized translate push-based algorithm scale exch work ngj exch case bitmapsave save single bad decision fmlevel colorsetup costly wbytes guarantee string provided version currentfile single neg consumer receive readhexstring entire pop set records true order colorimage colorsetup load wbytes balancing string occurs granularity currentfile large dict potentially dup begin unit imagetype handed width simple copy height program flow imagematrix module neg instantiate module datasource instances readhexstring place pop ufsread bind file bitspercomponent place ufswrite file decode end attach image read haz ifelse module bitmapsave write restore attach grestore fomj bind zcl execute flow bitmapcolorc figure gsave flow api index div simple add reader exch writer index flow div add shown exch ufsread translate module reads rotate oye index collection div neg output index div input neg translate ufswrite module scale writes exch disk exch znl wbytes bitmapsave save fmlevel colorsetup cik getinterval getinterval ezg copy pop currentfile neg true colorimage colorsetup getinterval amb getinterval copy pop currentfile hoo dict dup begin imagetype mtb width vmx execute height program kvio river environment imagematrix neg modules zcg datasource connected bind form flow bitspercomponent flow graph decode data cmab source end image sink ifelse bitmapsave restore intermediate stages grestore bind dictated bitmaptruecolorc program phases gsave involved epd index instantiating div flow add construction exch index operation div h-a tear-down add exch construction translate master rotate program index specifies div neg global index graph div describing neg translate scale data exch flow exch including modules wbytes specific interconnection bitmapsave save construction phase complete getinterval master ris program instantiates getinterval flow gis operation getinterval phase threads bis created mul machines getinterval control passed getinterval modules copy flow data pop begins data currentfile sources flows system neg graph rip pop completion ris flow gis construction bis true performed programmatically colorimage flow bitmapsave api restore provided grestore graphically bind flow construction api bitmaptruecolor simple add gsave node index graph div add place exch routine index called div add exch translate module rotate arguments index div neg index div read neg on-disk translate collection scale exch programmer exch ufsread bitmapsave module save string argument gis string filename bis shown string currentfile figure neg place returns readhexstring pop gis readhexstring pop bis module readhexstring pop true colorimage bitmapsave restore grestore attach bind modules bitmaptruegrayc gsave index div add exch index simpleattach div add exch translate interface rotate index div neg index interface div neg translate scale exch exch graph wbytes edges bitmapsave figure save simple getinterval copy ris flow getinterval gis formed getinterval bis mul read getinterval write getinterval copy module pop currentfile neg flow rip pop ris gis bis attached gray image attaching bitmapsave restore grestore bind modules fmlocal fmlocal places fmlocal fmlocal queue fmlocal modules input output case gray user exch exch extra exch arguments exch attach exch routine mul input connect mul output finally mul instantiate add add flow ago roll interface floor provided cvi put starts threads performs bind attachments bitmaptruegray waits gsave completion index asynchronous div version add exch index div add flow description exch translate point rotate index div restricted neg index single-machine div flow neg specification translate sake scale exch exch bitmapsave save string gis string bis string currentfile neg readhexstring pop gis readhexstring pop simplicity bis construct readhexstring parallel pop flows gray multiple machines image bitmapsave programmer restore grestore nodes bind place bitmapgray modules fakecolorsetup local commonbitmap bind distributed queues bitmapgrayc inserted fakecolorsetup commonbitmapc program run bind spawned nodes endbitmap bind system end simple aldsave remote execution fmlocal aldmatrix module matrix internal aldmatrix system currentmatrix user pop add extra startald arguments aldsave save attach routine savematrix details aldmatrix remote setmatrix bind connections producers inald consumers restorematrix bind single doneald -to-a aldsave distributed restore queue bind -todistinct setdash queues bind fully-connected setdash graph bind euphrates endprolog implementation beginsetup numerous languages fmversion program flows fmdocument times-roman interface fmfontdefine times-bold found fmfontdefine overly times-italic cumbersome fmfontdefine re-compile courier codes fmfontdefine fmfills simple tot change fmfill flow fmfill fmfill provide fmfill tcl fane fmfill perl fmfill interfaces fmfill allowing kpx fmfill brw rapid fmfill assembly flows dui scripting fmfill fmfill fmfill language fmfill finally fmfill built fmfill graphical fmfill user interface fmfill gui fmfill data fmfill flow graphs fmfill similar fmfill spirit fmfill tioga fmfill gui fmfill programmers fmfill select modules fmfill fmfill module fmfill library fmfill draw fmfill data flow endsetup graph page desired beginpapersize user letter endpapersize execute program generate flow construction code environment re-use ultra gui workstation fmbeginpage variables framesetsepcolors cpu performance added framenosep counters program capture enabling memory user traffic easily bus construct generic traffic iram programs solution smartsimm overcoming employ simple bus copy sophisticated machine user bottleneck choose ultraenterprise input array output performance collection counters names quantity variables memory bus retail generate bus general-purpose price copy machine program 
-processor general smp shut found simpler processors programmatic utilized interface machine ordinary bug-prone workstation extraordinary counters running sorting code counters produced conclude performance section profile revealing discussion system disks workstation expect cpu typical programmer bus writing saturated program cpu reaches spend peak utilization time due programming cost individual modules initiating reads disk bulk simultaneously application sending code records remote live nodes copying keys modules buckets bus saturates modules handling disk network send network receive traffic byte read disk roughly bytes travel bus architectural bottlenecks reached benefit system overlapping reading order disk construct flow communication imagine communication costs user community hidden interested similar problem areas disks workstation performance libraries expectations standard modules mitigated previous models share based naive tuned understanding high machine performance architecture achieving actual parallelism measurements foresee straight-forward bottlenecks user fact construct originally flow projected script disks machine gui ideal tool purchase nodes entire cluster run running system small spawn number modules well-configured machines multiple nodes easily understand generate architectural limitations desired connections hardware queues environment local correctly shape distributed future hardware modules purchases focus entire -node river cluster sort simply enabling keys construction cost one-pass high-performance sort parallel o-intensive disk system applications seek fill provide memory half framework desired sort time building performance-robust minutesort programs system seconds disks part give solution cost-performance transparently workstation application system writers read write graduated approximately declustering algorithm enabling mirroring machine applications automatically memory gain roughly robustness records read accounting perturbations memory requirements component operating system river application workstation performance robustness distributed physical queues memory result inserted calculations hardware application writer entire cluster upgraded cases place dqs depends disks program workstation semantics memory difficult workstation automate due budget decision donation general dqs limitations insufficient easily memory inserted one-pass attempt embarassing minutesort benchmark parallelism cases measurements producers continued place rely work two-pass sort queue consumers work queue individual rates accurate models addition predictions dqs performance situations correctly bit purchase difficult hardware requires large solid systems understanding modeling application memoryand o-intensive parallel program construction non-trivial task performance-robust applications accurately requires predict resource application usage writer running construct now-sort optimize small sequential well-configured modules cluster describe flow gauge connect worthwhile hardware purchases inserting distributed entire queues system models spending easily programmer constructed effort placement comprehensive set user hardware gain counters return levels scalable machine application runs modern processors face reasonable set variablerate performance producers counters consumers shown well-designed river application detailed run performance high profiling performance components set machine machines highly researchers varying shown performance network packet counters extremely characteristics bandwidth nodes monitoring distributed in-coming queue scaling out-going ideal packets figure distributed minimally queue -bit scaling counters experiment scalability interconnection system scrutiny memory run bus producersread data workstation blocks disk switches put network distributed counters queue track number sources bytes pull pass data monitored part ideal line system shows aggregate resource bandwidth utilization specific information disk device helpful disks report seeks transfers include tags differentiate traffic section perform pid experiments validate counters expected performance tracing properties short periods system activity facilitate explore detailed studies absolute portions performance adaptability code collecting data distributed queue techniques performance feeding queue results crucial back system user standard primary performance mechanism monitoring tools providing load cpubar balancing diskbar flow step allowing distributed user queue effective bottlenecks balancing system load advanced consumers systems moving data counters faster pinpoint consumers troublesome sections perform experiments program graduated interest declustering performance enhancement mirrored collections balancing work consumers distributed queues expectations solve set problem achieving fulfilled consistent small performance number single machines producer slows ready performance scale now-sort system drops full proportionally cluster size case important section system discuss avoid difficulties producer encountered hot-spot scaling precisely processors general transparently difficulty simple distributed algorithm adapt run-time debugging perturbations scaling data algorithmic sources aspects sort challenge arose scaling characteristics underlying sub-systems distributed operating system communication layer sub-systems found performance slowly degrade explore scaling workstations behavior fell distributed queue cliff radical drop experiment performance occurred set-up data workstations read cluster size disks put system developers distributed queue stopped consumed evaluations cpu sinks scale results scaling experiment shown figure graph reveals scaling properties datamation minutesort benchmarks start-up time application included measurements essential task glunix bottleneck large cluster sizes encountered start-up times seconds medium-sized clusters nodes starting job nodes required seconds glunix developers tracked interesting performance bug set group job glunix daemon performing nis request centralized nis server large parallel job meant ideal clients disk capable simultaneously requesting delivering data disks expect nis peak server read bandwidth shared ethernet responds data moving client sequentially removing achieve call percent nis server peak trivial distributed local system call set group found thought performance problem removing group-id bug slowed start-up time manual instrumentation code revealed bottleneck member parallel program set tcp queue connections found start-up scaling process problems redirect standard cluster input size output error design glunix aggressive client algorithm -way producer parallel sends job data opens subset socket consumers connections home node large parallel jobs performance burst writing disks overflowed shown scales default equally socketaccept queue entries percent peak static overflow forced performance cliff reached clients single timeout perturbation retry cpu nodes connection perturbed multiple cpu times drastically increasing consumer start-up time perturbation figure large applications read time-out retry perturbation figure occur shows previously percent nis peak request serialized performance portion achieved code consumer perturbations serialization removed added bottleneck appeared system fortunately size balance solaris load tcp accept-queue unperturbed consumers readily performance modified drops removing bottlenecks single glunix consumer improved start-up slowed time acceptable performance unaffected ideal range large number seconds nodes perturbed cpu perturbationsteals processor test consists producers separate consumers running now-sort application large configurations stressed communication sub-system distinct ways basic issues arose errors examine communication hardware results insufficient bisection consumers bandwidth arbitrarily general slower problems rest communication type layer perturbation difficult arise isolate dynamic load imbalance indistinguishable hot spots performance problems system due presence application cpus disks myrinet local-area performance network designed provide mpp-like backplane local area network setting goal export low-overhead high-throughput communication layer design generic active messages gam myrinet assumed complete hardware messaging reliability medium-sized clusters assumption reasonable bit errors rarely encountered processors largest existing myrinet cluster iram-i day bit errors occurred smartsimm-i runs mbit now-sort application dram errors manifested iram-ii crc errors smartsimm-ii gbit communication layer dram recognized memory cost recover terminating application simm 
current version active messages dram performs chip reliable message transfer cost top reliable medium estimated temporary minimum solution iram gam cost reduce dram number outstanding messages allowed flow-control layer limiting estimated load maximum iram network cost solution dram desired effect reducing chanceof bit errors disastrous side-effect smartsimm halving crossbar achievable bandwidth worse change made disk knowledge cost shortly april deadline sorting results theoretically sorted otal disk seconds sorted cost seconds stands current minutesort record large -disk configurations enclosure bisection bandwidth network insufficient all-to-all communication pattern now-sort development reasons estimated earlier costs phases smartsimm project system components distinct clusters roughly machines network topology designed bandwidth clusters sufficient insufficient links clusters tracking bandwidth deficiency network difficult anticipated due deadline pressures sufficiently micro-benchmark network running now-sort assumed larger network continued meet expectations fmendpage developed endpage smaller cluster page observe utilization links switches internal fmbeginpage network framesetsepcolors performance framenosep counters readily differentiate poor iram performance due smartsimm overcoming insufficient bandwidth bus poor performance bottleneck due algorithmic characteristics found adding links nyber bandwidth solved problem barclay cvetanovic gray lomet alphasort difficulties risc machine learned number sort valuable lessons application oceedings writers acm debug programs sigmod running large confer number nodes ence interactive environment realistic assume programmers patterson track anderson bugs cardwell smaller fromm number nodes keeton kozyrakis thomas now-sort algorithm scalable elick cases case underlying system intelligent large-scale ram systems system ieee designers micr access march april perissakis kozyrakis anderson tools asanovic cardwell restricted fromm application-level keeton programs patterson support thomas system-level performance tuning elick hoc laborious process scalt parallel ing profiling processors tools billion quartz modified ransistors cluster environment iram submitted developers march glunix tool seagate paradyn barracuda data helpful sheet avoiding lengthy seagate recompiles corporation allowing dynamic http instrumentation seagate interesting pieces code providing visual feedback shanley isolating performance problems anderson pci frustrating system dynamic environment chitectur libraries daemons edition mindshare system services change addison-w altering application esley binary case one-line change active stephens message library raphael lead informix devastating software performance personal results tools understand complete dependence tree application notify user occur helpful developmental systems configuration management tools good match problem difficulty approach chain dependencies environment applications link glunix library access glunix glunix library changed glunix user-level daemon contacted library finally large-scale systems commonly tuned target system size research environment largest common platform testing machines due contention resources developers result system behaved size quickly found system scale desired full cluster size implication system development groups investigating build systems consisting workstations entire system workstations greater system scaled final step chasing sorting record successful unperturbed run sort performance now-sort sensitive disturbances requires dedicated system achieve peak results section discuss solved set run-time performance problems foreign agent competing process inadequate memory full disk machines slowed entire application general hierarchical process similar search process step finding needle now-stack slow workstations cluster identified step removing needle specific problem slow workstations identified solved process parallel sort performs amount work machine disturbance slows entire application now-sort exhibited lower expected performance isolated nodes disturbances ways ran glunix status tool glustat reports load average virtual memory workstation cluster nodes anomalous values easily singled nodes appeared homogeneous glunix ran now-sort additional timing statistics displayed workstation phase workstations noticeably slower phase pointing machine needle slow machine isolated key find machine compared cluster common needles found machines faulty hardware extra processes competing cpu memory extra data disks faulty hardware needle encountered consisted machines faulty misbehaving hardware beginning aware machines -node cluster unavailable due faulty power supplies motherboards machines adequate running compute-intensive sequential processes network-interface disk problems cluster machines found usable now-sort cpu stealing trivial common needle foreign job running workstations competing process slows sorting process workstation slow workstation identified standard process monitoring tools top identified culprit killed memory hog common performance problem caused difference free memory machines notable needle scenario glunix master daemon workstations running sort separate administrative machine cpu requirements master negligible memory footprint result sort process running master began page interfering sequential activity tracking aberrant glunix process proved difficult expected due small differences involved disk layout performance now-sort sensitive layout files local disk multizone disks give significantly higher bandwidth data allocated outer tracks full disks lead expected data rates disk configuration tool verified capabilities read zff performance figure varies shows significantly effect dependingon slowing disk enw layout cpu times consumers tracking slow node quick reading inspection revealed scratch disks disk full work user pre-allocated temporary consumers files removed fhf single consumer files slows sort shf performance returned performance expected bad level consumers slowed labeled static static allocation hierarchical wwa figure methodology isolating inserted problematic workstations producers disks identifying specific consumers disturbances zcl data required flows performance unperturbed isolation consumers workstations flowing hard hot rxuw boundarybetween spots workstations allowed system qxp drill-down cpus focus fully performance utilized unperturbed component case cpu noticeable memory performance system drop-off disk perturbation large-scale systems consumers resources perturbed aggregated previous experiment single interface form parallel smps read raid-style disk experiment systems parallel write lend experiment naturally place hierarchical cpu approach sources strategy generate allowed records successfully solve disks performance problems system required results fair amount write experiment intelligent user shown akj intervention figure automatic approach static allocation desirable behaves poorly users familiar slight perturbation components case system performance problematic writing workstations disks flagged degrades immediately sophisticated tool eyx perturbation gradually performance falling assertion checking fact performance tool slightly simple worse assertions static performance application expectations code disks txo flagged perturbation succeed standard degradation parallel tools disk bandwidth fully search utilized process begin limitations prevented unlike cpus read limitations arise experiment due advanced features solaris leverage kernel threads single memory-mapped disk files system paradyn perturbed work total threaded bandwidth applications eliminates reduced difference single-node one-pass sort data codes make unperturbed heavy disks mmap static access application files tools adapt track read demonstrated write system calls distributed queue reporting behavior desired properties system pablo balancing tracks load read write data calls consumers give mirroring breakdowns producerof requests data sizes times access mmap unique percent difficult peak requiring static instrumentation performance cliff reached single perturbation graceful degradation disk nodes perturbed disk consumer perturation figure write perturbation figure shows effect disk perturbation writes dynamically adapts system test consists disks falling performance cliff routes data bandwidth gracefully degrades case perturber continually performs sequential large-block writes local disk stealing roughly half bandwidth collection records complete flow deliver data consumers producers bottleneck system case streaming large data sets slowing single producer lead large global slowdown program complete slow producer finished producer problem exact problem graduated declustering attempts solve describe experimental validation graduated declustering implementation find absolute performance behavior perturbations expected initial implementation performance graduated declustering reads disk perturbation slightly worse non-mirrored case direct result design fetches data mirrors selecting single order ready adapt performance characteristics change multiplexing streams single disk slight cost seek occur streams increasing disk request size amortizes cost seek achieve percent peak nonmirrored bandwidth figure writes disks incur problem real strengths read-intensive workloads decision support data mining cases applications reading non-adaptive mirroring system slow rate slow disk system system shifts bandwidth allocation disk consumer data receives data rate aggregate bandwidth ideal nodes graduated declustering scaling figure graduated declustering scaling graphs shows performance scaling performance loss due fact reads actively mirrors segment seek cost incurred roughly peak performance delivered percent peak static disk nodes perturbed graduated declustering perturbation figure read perturbation graphs shows performance read perturbation performance degrades slowly case typical nonadaptive mirrored system suffers slowdown perturber competing read-stream disk results -machine experiment shown figure scenario half machines serve disk nodes half serve data consumers explained performance mirroring compared mirroring slightly worse unperturbed case single perturbation slows application non-gd system bandwidth slow disk case delivers data roughly half peak rate due single competing stream performance degrades slowly spreading bandwidth evenly consumers disks equally perturbed performance dips non-gd system due overhead seeking multiple streams finally perturbing write stream collection mirror expected effect slowing write speed slower disk sense represents fundamental cost mirroring applications write scratch data data lesser mirroring potential performance cost describe initial application experience begin unmodified sequential program river infrastructure proceed parallel applications written parallel sort parallel hash-join section focuses application writers add robustness applications distributed queues show performance mirroring enabled mirroring transparent user application examine trace-driven simulator generation version file system simulator complex sequential program simulates multiple file system layout policies buffer management includes complete disk simulator application river fast data source simulator modified order access data river system simulator loads data river system simple copy-in script accesses copy-out script constructs flow record collection standard output piped standard input simulator case main benefit river fast switch-based network application disk river simulator accesseddata nfs file server ethernet shared network parallelism application distributed queues provide robust performance set experiments involve 
complicated application external sorting case program written river environment sort good benchmark clustered systems performance largely determined disk memory interconnect bandwidth compare external sort built river framework ideal statically partitioned sort ideal parallel sort reads data disk full disk bandwidth takes time perform in-memory sort writes back disk full bandwidth overhead parallelism sake simplicity single-pass sort records read memory sorted written disk single pass eventually plan extend work include two-pass sorting places severe memory management demands system figure presents flow data simple version external sort river flow similar nowsort data begins unsorted parallel collection number disks data read disk node disk read module passed partitioning module partitioning modules perform key-range partitioning data partitioning module reads top bits record determine sorter module record sorter module received input sorts data begins streaming disk write module proceeds write data disk stream preserving order application proceeds phases read partition sort write simple single-pass external sort figure parallel external sort river figure depicts logical data flow single-pass external sort data proceeds disk set static partitioners split data based key range record set sort modules data read sort modules sort parallel hand data write modules send disk ordered stream markers circled points flow altered add robustness discussed discuss scaling behavior sort figure shows result scaling river sort machines graph compares river sort idealized staticallypartitioned parallel sort performance sort river framework begins peak efficiency drops slightly nodes majority inefficiency attributed poorly tuned in-memory sort contributes total elapsed time un-tuned in-memory sort learn graph easy build high-performance non-trivial application lose efficiency inside framework application write single line code manage qualitatively application writer write partitioning module sort module scaling parallel sort matter constructing proper flow stands simple river parallel sort robust performance perturbations graduated declustering sort tolerate read perturbation focus read partition write phase sort potential performance robustness examine perturb partition modules achieve reasonable performance add level robustnessto partition phase insert distributed queue disk read modules partitioners labeled circled figure sort partitioning data order imposed stage sort inserting distributed queue performance characteristics sort correctness figure shows result perturbing partitioner modules experiment disk modules sort modules set machines partitioners set machines total perturbations applied partitioners partition modules slack system overloaded degrading slowly partition nodes perturbed location flow modified avoid percent peak nodes ideal static sort river sort sort scalability figure parallel external sort scaling figure shows scaling behavior sort built river framework compared idealized statically-partitioned sort river sort scales deficiency under-tuned in-memory sort run-time perturbations sort modules disk write modules labeled figure desire tolerate disks slowing write phase simply move records arbitrarily disks preserve set sorted partitions generated sort module balancing load disks record-level balance communication april alagala asami anderson patterson ertiary disk lar scale distributed storage submitted ransaction processing council tpc tpc benchmark speci cation http tpc ransaction processing council tpc tpc benchmark speci cation http tpc suei packer database buf fer size investigation orkloads oceedings sigt mod confer ence zagha blelloch radix sort ector multiprocessors oceedings super computing november appendix supporting calculations smartsimm minutesort disk capacity media ransfer rate rack buffer ransfer rate access ime min seek lat serial line speed gbps annual relationship ojected echnology parameters characteristic smartsimm-i smartsimm-ii otal sorted -node memory size -node number disks -node number serial lines -node disk bandwidth -node network bandwidth -node bandwidth -node memory bandwidth otal system cost iram dram otal system cost iram dram summary smartsimm minutesort performance price results fmendpage endpage page fmbeginpage framesetsepcolors framenosep iram smartsimm overcoming bus bottleneck applications ith high vector performance high memory bandwidth capacity iram potential approach existing applications instance tcp checksumming raid parity calculations vectorized fectively data copying data movement memory zeroing memcpy memset performed higher bandt width vector unit traditional scalar processing iram serial smartsimm put spin lar class existing applications conclusions performance current workstations severely limited poor bus bandwidth intelligent ram iram gbps serial lines signi cantly higher -performance alternative conventional systems high memory bandt width provided iram single integrated processor memory system coupled iram vector unit high-speed interfaces fresh existing applications provide high-performance solution problems paper introduced smartsimm collection irams simm module lar ger system prot grammed dif ferent models con gurations provide higher memory system perfort mance presented case study minutesort database industry standard sorting benchmark illustrate utility iram smartsimm smartsimm-i composed rst-generation irams gbps serial interfaces on-chip memory capable sorting data minute second-generation smartsimm-ii memory gbps serial interfaces sort minute system o-challenged smartsimm-ii bene additional serial interfaces systems provide order magnitude higher performance contemporary systems small fraction cost provided qualitative discussion applications iram smartsimm provide interesting architectural building block performance cost estimates approximate clear iram presents opportunity achieve order magnitude greater performance lower cost alternatives additional perfort mance system continues scale processor memory system refer ences arpaci-dusseau 
arpaci-dusseau culler hellerstein patterson high-performance sorting networks orkstations oceedings sigmod confer ence http berkeley arpaci-dusseau empirical evaluation networks orkstations dissertation qualifying exam proposal april asanovic ector microprocessors phd dissertation california berkeley compusa online http compusa prd pgen compusa compusa menu htm dally poulton equalized signalling hot inter connects symposium recor september fox gribble brewer amir adapting network client ariability on-demand dynamic distillation ceedings asplos vii october fromm perissakis cardwell kozyrakis mcgaughy patterson anderson elick ener ciency iram architectures oceedings isca june gray graefe storage metrics submitted april growchowski ibm leadership disk storage echnology http storage ibm storage technolo grochows grocho htm hennessy patterson computer chitectur quantitative appr oach edition mor gan kaufmann san mateo calt ifornia ang horowitz cmos oversampled receiver serial links ieee isscc digest echnit cal papers february martin ectorized hash join unpublished report california berkeley http http berkeley rmartin fmendpage endpage page fmbeginpage framesetsepcolors framenosep iram smartsimm overcoming bus bottleneck general smartsimm signi cantly cost-performance contemporary cases smartsimm obtains times performance optimistic generation smartsimm achieves performance improvements order magnitude relative pessimistic greater smartsimm load wzisax loads stores mapped file regions qofp identifying specific problems simplified oty poy visualization tools developed section problem feedback run meters nodes due large amount window traffic generate advanced system collect data locally node collate present animation likewise specific problem automatically identified constantly monitoring processor memory disk utilization machine reporting anomalies user found fixing problems easy reasonable understanding components system users familiar berkeley cluster xar difficult time isolating anomalies fixing problems required interfering rights cpo users killing jobs removing files users permission perform actions zpz process safely automated jec fyax euc acg szl aece -xu higher level granularity vqh dynamically deciding place -wvu sorted partition order balanceload amonga consumers data ebm producers data items produced original form sort allocates single sort module producer hrzl consumer remedy load balancing disks pyo allocate sort modules wherea small constant note produces slightly modified output sorted partitions performance load balancing sorted-runs disk perturbation shown figure expected writing runs performance degrades gracefully static allocation full perturbation performance lower expected case overhead current implementation results peak yxzw performance roughly lower expected gkrgw buk cum hash-join important database operation extensively decision-support benchmarks tpc-d hash-join takes collections records input outputs pairs equal values join key one-pass two-pass variants exist pass algorithm suitable smaller collection fits aggregate cluster memory simplicity discuss one-pass hash join figure shows flow data phase smaller collection building collection hash table built read disk partitioned hash function nodes internally hashed inside join module labeled diagram prepare join phase phase probing collection read disk partitioned nodes sle hash function nhm records pass join module matching records building collection found output proceeds immediately dnw jww mix wso kos ufl tr- qko rqek jnq voix vte slf lxv xqn kzbc fku wjh psg qqu mbok act zads -ngs 
abstract now-sort scalable commodity-workstation sort class project remzi arpaci andrea dusseau implemented measured performance sorting implementations network workstations preliminary study find nows competitive large-scale smps dominant sorting arena fast communication based active messages key making parallel versions sorting scale distribution disks cluster evaluated operating system support managing memory interacting file system finding support place full paper postscript compressed postscript 
percent peak ideal static sort river sort nodes perturbed sort partition perturbation figure perturbing sort partitioner figure shows sort partition modules perturbed disk sort modules run set machines partition modules run set river sort compared perfect sort statically partitioned perturbation steals percent cpu static percent peak disks perturbed sort write perturbation figure perturbing sort writer figure shows performance writers perturbed write phase sort runs set machines writing disks separate set machines case perturbation competing write-stream disk disk phase reading collection writing output operate concurrently addition distributed queues hash join similar sort queue data sources partitioners allowing faster partitioners partition data join performed output relation hash form inserted easily balancing load disks application wishes output records hashed partitions situation similar balancing sorted runs external sort employed interestingly hash-join avoid performance perturbations join modules replication building collection replicated nodes record partitioned probing phase dynamically choose sites functionality limitations current infrastructure performance numbers hash-join scale initial results machines promising simple one-pass hash figure parallel external hash river figure depicts logical data flow single-pass hash-join solid lines path relation disks hash-partition modules hashjoin modules dashed lines path relation similar path relation relation passes hash-join modules join performed output relation generated river relates work number distinct areas file systems programming environments database research section discuss work areas high-performance parallel file systems abundant literature ppfs galley vesta swift cfs sfs sio specification assume performance dictated slowest component system devoid specific programming model applications constructed single-program multiple-data spmd -like fashion parallel file system deliver consistent high-performance wasted inside rigidly-designed program advanced parallel file systems higherlevel interfaces data collective similar concept expressed two-phase original paper kotz found scientific codes show tremendous improvement aggregating requests shipping underlying system nodes schedule requests noticeably increase delivered bandwidth requests made returned specific consumers load balanced consumers dynamically types systems provide flexibility interface solve problems common today clustered systems finally recent file-system work extolling virtue adaptive systems hardware systems increase complexity argued intelligent software systems extract performance underlying machine architecture systems employ off-line reorganization improve global performance goal river balance load on-line run-time long-term adaptation system number popular parallel programming environments support spmd programming style including messaging passing environments mpi pvm explicit parallel languages splitc packages provide simple model parallelism user allowing ready construction parallel applications provide facility avoid run-time perturbations adapt hardware devices differing rates experience writing parallel external sort split-c led realize problems spmd approach run sort now-sort broke world record databaseindustry standard sorting benchmarks 
difficult attain high-level performance consistently parallel programming environments aligned river design philosophy run-time adaptivity examples include cilk lazy threads multipol systems balance load consumers order highly-irregular fine-grained parallel applications main difference river systems granularity communication river limits workloads data pushed interconnect large-sized blocks systems run-times general-purpose parallel programming focus finegrained irregular applications today clusters latency remote memory higher latency local memory orders magnitude microseconds versus nanoseconds forces locality dominant issue systems remote bandwidth worse local bandwidth difficult hide remote memory latency data pushed system cost systems attempt deal problem slow producers important environment similar river environment linda shared globally-addressable tuple-space parallel programs applications perform atomic actions tuple-space inserting tuples querying space find records attributes generality model high performance distributed environments difficult achieve distributed aspects river built top linda suffer performance scaling problems relevant river large body work parallel databases data flow techniques well-known database literature stems naturally relational model system takes advantageof unordered processing records ibm smps system shared data pools accessed multiple threads faster threads acquiring work referred straw model thread slurps data straw potentially rate implementing system natural smp simple lock-protected queue suffice modulo performance concerns river argue type data distribution performed cluster due bandwidth interconnect number parallel databases found literature including gamma volcano bubba systems similar techniques distribute data processes gamma split table volcano exchange operators generalized split table river move data producers consumers distributed memory machine static data partitioning techniques hash partitioning range partitioning round robin functions adapt run-time load variations consumers current commercial systems ncr teradata machine exclusively hashing partition work achieve parallelism good hash function effect dividing work equally processors providing consistent performance achieving good scaling properties jim gray recently teradata system performance bad worse consistency scalability goals system cost underlying hardware future research areas explore enhancements system infrastructure serve paper presented experiences writing tuning now-sort current world-record holder external sorting crucial attaining peak performance setting performance expectations allowed find fix performance problems sort tools users set expectations great case simpler move system main realm expectation system achieve expert peak disk programmers bandwidth easily process made process data number placement tools process placement attain data peak placement performance configuration important tools decisions helped set expectations determined automate user parameterization river sort ideal system disk decisions automated systems memory higher-level sizes entity visualization tools compiler gave query instant visual planner feedback process data performance migration river sort allowing moves quick data deductions system location effectively initial performance experience problems suggests finally feasibility hierarchical search code tools migration helpful improve automating dynamic search performance properties performance anomalies system long-term end data migration mix simple tools hoc short-term practices locally achieved optimal placement performance decisions desired re-evaluated challenging external result sorting data benchmark movement minutesort optimize sorted current total usage minute nodes application fault passes tolerance ultimate delivered goal write sustained applications performance river interface sort application roughly robust performance peak rate continue operation machine delivered failure similar time work final record dynamic achieved programming environments form minute automatic nodes check-pointing time pass solution delivered suggested bandwidth river application well-suited high large class case due external glunix distributed start-up applications difficulties including traditional one-line change scientific codes underlying multimedia communication programs layer final evidence imperfect total serves exists literature reminder volcano nature scientific journey data-intensive applications programmed optimized volcano data-flow environment plan exploring add robust performance features types applications finally developing simple models performance faults affect system welldeveloped analytical models now-sort easily compare performance combined effort system versus members theoretical ideal berkeley project perturbation scenario contributed success rich martin hardware doug ghormley software systems extendspecial spiral jim size gray complexity chris nyberg systems sparking designed interest controlled sorting environments experience performance encouragement defects sage real-world advice settings finally long realized shepherd area margaret martonosi wide-area networking anonymous reviewers end-to-end pieces argument pervades feedback design methodology work funded part darpa -cdarpa -cnsf cda nasa fdnagwand california state micro 
program remzi arpacidusseau supported intel graduate fellowship acharya uysal bennett mendelson beynon hollingsworth saltz sussman tuning performance intensive parallel applications proceedings fourth workshopon input output parallel distributed systems protocol pages stacks philadelphia tcp acm press systems clear agarwal super scalar globally-controlled sort well-behaved algorithm risc environment processors attainable acm applications sigmod conference system treat pages black june box anderson culler adjusting patterson behavior dynamically based team case networks feedback workstations system ieee achieve micro february performance current circumstances complexity slowly grown anderson point lazowska manageability quartz smaller tool distributed systems tuning parallel program comprised performance largely autonomous proceedings complicated individual acm components sigmetrics clusters performance exhibit conference measurement properties modeling computer systems problems larger pages scale wide-area systems arpaci-dusseau problem arpaci-dusseau exacerbated culler clusters move hellerstein serving general-purpose patterson computational high-performance infrastructure sorting large networks workstations organizations resources sigmod pooled shared arpaci-dusseau computing machine arpaci-dusseau hundreds culler thousands jobs hellerstein users present patterson system architectural difficult costs streaming comparison workstations clusters smps hpca february boden cohen felderman kulawik seitz myrinet gigabit-per-second local area network ieee micro february perfort mance chapin achieved herrod fraction rosenblum cost roughly gupta memory system performance smartsimm-i unix cc-numa smartsimm-ii multiprocessors acm futur sigmetrics performance conference pages cmelik keppel ork shade fast instruction-set irams simulator fast serial execution profiling lines proceedings smartsimms composed acm irams sigmetrics provide conference balance processing pages power culler dusseau memory system goldstein performance krishnamurthy lumetta system von performance eicken wide class applications yelick section parallel brie programming discuss split-c supercomputing ongoing culler examinations liu applications martin context iram yoshikawa logp smartsimm performanceassessment fast decision network support interfaces ieee databases micro dec decision decchip support risc dss microprocessor database preliminary workloads data sheet technical tpc-d report perform digital read-only equipment read-mostly queries corporation measure lar transaction datasets processing power answer datamation what-if readings questions database systems stonebraker morgan typically kaufmann perform san lar mateo sequential ghormley scans petrou rodrigues datasets vahdat signi anderson computation global layer unix network majority workstations data read apply lters comprising query contrary intuition decision support workloads compute-bound o-bound types operations performed bene greatly software practice iram experience vector hollingsworth finding unit bottlenecks decision large-scale support parallel workloads programs join phd thesis tables wisconsin hash-join algorithms aug results hollingsworth sorted miller in-order content-derived names grouped configuration presentation management acm user symposium software reusibility earlier boston hash joins sorting kleiman bene voll vector eykholt assist shivalingiah williams computational smith bene barton concert andg high skinner symmetric memory multiprocessing bandwidth iram solaris make proceedings iram compcon smartsimm spring architectures attractive lebeck database application database wood ransaction cache ocessing profiling spec ransaction processing workloads tpc-c dif benchmarks ferent execution characteristics case dss cousins study perform smaller ieee page-sized random computer data pages small pages portion page utilized october computation hand sorts performed mainwaring frequently active workload hash joins message commonly application programming great deal interface pointer -chasing operations communicationsubsystem manipulating index organization structures master b-trees general latency thesis latency california critical workloads berkeley user transaction martonosi satis clark response time constraint mesarina databases employ intelligent buf fering shrimp prefetching hardware schemes performance aggressively monitor overlap design computation latency applications rescheduling database threads proceedings sigmetrics symposium parallel distributed tools spdt appropriately february fortunately martonosi temporal locality gupta buf anderson fer accesses memspy result databases analyzing typically memory lar system bottlenecks amounts programs memory avoid proceedings acm rule sigmetrics thumb performance recently conference suggested measurementand modelingof optimal computer memory systems buf fer size shared memory database running workloads tpc-c pages case mathisen pentium database secrets size byte pages percentage sounds july small meter optimal observing memory size effects greater multi-zone disks proceedings lar usenix ger conference databases jan challenge miller iram system callaghan determine cargille provide hollingsworth suf cient irvin amount memory karavanic buf kunchithapadam fer caching newhall paradyn parallel providing performance measurement suf tools cient ieee bandwidth processing computer nyberg power barclay natural choice cvetanovic collection gray smartsimms lomet alphasort simm risc smaller number machine sort processors acm sigmod conference high-bandwidth dram lling perl remainder weihl slots performance assertion checking simm proceedings high-bandwidth drams acm treated symposium shared operating memory systems principles shared pages memory database december perl local sites iram studies memory windows performance enormous hardware dynamic execution cache traces trade-of osdi pages irams october drams topic reed elford madhyastha ongoing scullin research aydt dynamic smirni content performance distillation analysis performance data emer immersion proceedingsof ging trend mascots web pages internet service february provision rosenblum bugnion proxy servers devine perform on-demand herrod translation simos machine difp simulator ferent study data complex formats computer dif ferent systems image acm formats transactionson gif modelling jpeg andcomputer simulation service tomacs entails high impossible january computational saavedra-barrera requirements cpu system perform performance behave evaluation on-demand dynamic orderly execution fashion distillation time high address network prediction increase accept narrow complexity spectrum transmit benchmarking document phd thesis decrease repret predictability berkeley sentations computer introduce possibly science moderate river division disk substrate february proxy building service stonebraker o-intensive serving operating cluster system web applications support cache river iram database confluence excellent management programming communications combip environment nation resources system acm task high extending july memory notion sweeney bandwidth adaptivity doucette easily push flexibility pull anderson dynamic content nishimoto lowest vector levels unit peck system scalability xfs perform file application river system relevant programs translation proceedings algorithms reliably deliver usenix high annual chance performance technical operate system conference nodes resources server jan over-committed tremblay performance simm greenley applications deal written normoyle fectively style varying load degrade design requirements gracefully avoiding fault sudden microarchitecture ultrasparc-i tolerance frustrating proceedings prolongations expected run ieee time december initial study von eicken applications found culler avoiding goldstein perturbations instance schauser consumers business active environment messages dss straight-forward query mechanism distributed integrated queues pro communication important change issue computation raised balancing price proceedingsof load product granularity annual symposium ordering required applications fine-grained applications balance load level individual records simplest construct performance-robust manner distributed queues proven excellent load balancers require programmer insert flow avoiding perturbations producers problem solved river graduated declustering dynamically shifting load perturbed producers system delivers proper proportion bandwidth client application high-performance clusters consistent performance easy bad peak performance matter persistence good run goal river environment source code request foremost jim gray advice encouragement alan mainwaring work support active messages sine qua work anonymous reviewers helpful comments finally andrea arpaci-dusseau amin vahdat i-store group berkeley suggestions improved presentation content paper work funded part darpa -cdarpa -cnsf cda nasa fdnagwand california state micro program supercomputers plug play economist november arpaci-dusseau arpaci-dusseau culler hellerstein patterson high-performance sorting networks workstations sigmod arpaci-dusseau arpaci-dusseau culler hellerstein patterson searching sorting record experiences tuning now-sort spdt aug bal kaashoek tanenbaum orca language parallel programming distributed systems ieee ps-adobecreator dvipsk copyright radical eye software title nowsort dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic courier transactions endcomments software dvipscommandline dvips engineering nowsort nowsort mar dvipsparameters barclay dpi barnes comments removed gray dvipssource tex sundaresan loading databases output dataflow beginprocset tex parallelism pro sigmod texdict record dict acm texdict special begin interest group management bind exch data december translate bershad isls false black dewitt vsize mul gibson hsize peterson mul snir landplus operating false system rigin support isls high-performance parallel landplus systems ifelse technical concat report resolution ccsfscalable div vresolution initiative div caltech neg scale concurrent isls supercomputing landplus facilities vresolution div vsize caltech mul exch blumofe resolution joerg kuszmaul leiserson randall zhou cilk efficient multithreaded runtime system proceedings symposium principles practice parallel programming july blumofe lisiecki adaptive div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix dup dup round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat reliable fbb fmendpage endpage ctr page df-tail fmbeginpage dict framesetsepcolors begin fonttype computer architecture gold coast australia 
fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding end dup foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop dup definefont setfont ch-width ch-data dup length ch-height ch-data dup length ch-xoff ch-data dup length ch-yoff ch-data dup length ch-dx ch-data dup length ch-image ch-data dup type stringtype ctr ctr ctr add charbuilder save roll dup base index bitmaps ch-data pop ctr ch-dx ch-xoff ch-yoff ch-height ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true ch-xoff ch-yoff ch-image imagemask restore dup type stringtype base ctr put bitmaps ctr dup dup length dup index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore showpage userdict eop-hook eop-hook start userdict start-hook start-hook pop vresolution resolution div dvimag array string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div ifelse forall metrics metrics currentdict end index currentdict end definefont roll makefont setfont load cvx obliqueslant dup sin cos div neg slantfont index mul add extendfont roll mul exch reencodefont encoding exch end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter note legal scaleunit hscale scaleunit div hsc vscale scaleunit div vsc hsize clip vsize clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform roll itransform roll itransform roll curveto closepath pathforall newpath counttomark array astore xdf pop put courier fnt invertflag paintblack txpose pxs pys scale ppr aload pop por noflips pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage copypage macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse clip newpath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath clip showpage erasepage copypage newpath endspecial count ocount pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset texdict begin nowsort dvi start times-roman courier times-italic times-bold times-bold slantfont times-roman times-roman times-bold times-roman times-bold times-roman times-roman end endprolog beginsetup feature resolution dpi texdict begin endsetup page bop -sort scalable commodity-w orkstation sort remzi arpaci andrea dusseau final project report csb implementation database systems computer science vision uni ersity california berkele abstract implemented measured performance arious sorting implementations network orkstations preliminary study competiti lar ge-scale smps dominant sorting arena ast communication based acti messages making parallel ersions sorting scale distrib ution disks cluster aluated operating system support managing memory interacting system nding support place intr oduction networks workstations emer ging cost-ef fecti alternati vironment massi ely parallel processors mpps shared memory serv ers ecuting ariety workloads throughput-dri 
sequential jobs communication-intensi parallel applications intention sho vironment natural cost-ef fecti memory intensi parallel applications problem focus paper sorting xtensi research history theoretical community parallel programmers database world parallel framenosep computing networks workstations usenix iram editor smartsimm annual overcoming technical bus conference bottleneck january anaheim pages berkeley usa iram-i jan lar usenix boden cohen felderman kulawik seitz myrinet gigabit-per-second local area network ieee micro february cabrera long swift distributed disk striping provide high data rates computing systems fall carriero implementation tuple space phd thesis department computer science yale december chakrabarti deprit jones krishnamurthy wen yelick multipol distributed data structure library technical report csd- california berkeley july choudhary bordawekar harry krishnaiyer ponnusamy singh thakur passion parallel scalable software input-output technical report sccsece dept npac case center syracuse september codd relational model data large shared data banks communicationsof acm june published readings gest database amount systems sort edition minute stonebraker requires hellerstein disks morgan-kaufmann gbps serial lines copeland alexander case boughter keller transfer data size placement bubba mer sigmod record acm partitions special phase interest group iram-ii management sort data minute sept corbett performance feitelson vesta transfer parallel size file system acm mer transactions computer partitions phase systems requires disks august gbps council serial tpc-d lines individual results http higher tpc results tpc single-node results page performance html attainable due culler fact dusseau sorting goldstein vectorizable note number required disks iram-i iram-ii disks needed store input data krishnamurthy inconsistency due lumetta von limited eicken transfer rate yelick parallel disk programming practice split-c utilize proceedings fraction supercomputing pages disk dewitt gray parallel capacity database systems future fraction high-performance database capacity systems transferred communications required time acm constraint june usable dewitt capacity ghandeharizadeh small schneider fraction performance disk analysis gamma capacity database machine sigmod iram-i record acm special interest group iram-ii management parallel sort data smartsimm sept geist andv sunderam evolution pvm 
concurrent computing system compcon february gelernter carriero chandran chang parallel programmingin linda degroot editor international conference parallel processing pages goldstein schauser culler lazy threads implementing fast parallel call journal parallel distributed computing aug graefe encapsulation parallelism volcano query processing system sigmod record acm special interest group management data june gray processors infinitely fast storage free invited talk iopads november hsiao dewitt chained declustering availability strategy multiprocessor database machines turn proceedings international data parallel engineering two-pass sort conference recall pages parallel version huber processor elford performs network reed addition chien blumenthal local ppfs disk high performance portable parallel file performed system single-node proceedingsof case acm international conference supercomputing pages barcelona data july read acm press disk kitsuregawa tanaka moto-oka grace relational algebra machine based network hash sort performed design send concepts receive journal network information processing society data addition japan kleiman voll eykholt memory shivalingiah bandwidth williams required smith barton equations andg relationships skinner technology symmetric parameters multiprocessing solaris calculated proceedings minutesort amounts compcon smartt spring simm-i kotz smartsimm-ii disk-directed results shown mimd detail multiprocessors proceedings symposium operating systems appendix design smartsimm-i implementation simm pages module usenix association holdt november ing updated iram-i dartmouth chips pcs-tr sort november minute kubica disks robey gbps moorman serial data lines parallel iram programming khoros smartsimm-ii data services iram-ii library system lecture notes sort minute computer utilizing disks science gbps lindsey serial smp lines intra-query iram parallelism systems udb database seminar berkeley february transfer sizes loverso isman note number serial lines limiting factor cases smartsimm-ii system higher sorting performance number serial lines greater bandwidth serial line higher smartsimm cost-performance section examine cost-performance smartsimm systems compare utility nanopoulos comparable nesheim milne wheeler sfs note parallel file system calculations cmin approximate proceedingsof viewed summer usenix technical smartsimm conference cost assumptions pages mainwaring based culler retail active message prices applications programming well-understood interface technology communication trends subsystem organization shown technical report csd- california berkeley appendix october matthews roselli costello wang estimate cost anderson improving iram performance double log-structured file triple systems cost adaptive methods dram proceedings generation symposiumon existing operatingsystems prices principles cost sospvolume decrease operating trends systems review pages saint-malo iram-i france cost october acm sigops acm iram-ii press meter observing effects multi-zone disks proceedings cost usenix conference jan smartsimm nieuwejaar prices kotz computed galley summing parallel cost file system irams proceedings simm modules acm international simm conference crossbar supercomputing intercont pages nect philadelphia disks acm disk press enclosures nitzberg prices performance ipsc concurrent file smartsimm-i system technical report rnd- nas systems division nasa smartsimm-ii ames december pakin lauria chien note high performance prices messaging dominated workstations disk illinois subsystems fast disks messages comprise smartsimm-i total cost smartsimm-ii total cost actual cost iram higher calculated drastic change system price predicted performance held price constant extrapolated performance -processor nows based technology trends optimistic estimate performance scale processor performance rate year pessimistic estimate performance scale disk transfer rates year comparisons system cost performance smartsimms nows shown figure fmbeginepsf begindocument home tomorrow grad kkeeton research isimm graphs mycompareepsi ps-adobeepsf- boundingbox save countdictstack mark newpath showpage ps-adobecreator gnuplot documentfonts times-roman boundingbox pages atend endcomments gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke 
stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end endprolog page gnudict begin gsave translate scale rotate translate setgray times-roman findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate cost cshow grestore total sort size cshow smartsimm-i circa cshow pessimistic rshow optimistic rshow myrinet proceedings acm ieee supercomputing conference december san diego convention center san diego usa acm press ieee computer society press papadopolous untitled talk winter retreat july ritchie stream input-output system bltj part october saltzer reed clark end-to-end arguments system design acm transactions computer systems pages november scales lam transparent fault tolerance parallel applications networks workstaions proceedings usenix conference jan seltzer small self-monitoring self-adapting systems proceedingsof workshop hot topics operating systems chatham shapiro join processing database systems large main memories acm transactions database systems sept stonebraker chen nathan paxson tioga providing data management support scientific visualization applications international conference large data bases vldb pages san francisco usa aug morgan kaufmann publishers mpi forum mpi messagepassing interface proceedings supercomputing pages november von eicken basu buch vogels u-net user-level network interface parallel distributed computing proceedings acm symposium operating systems principles pages december von eicken culler goldstein schauser active messages mechanism integrated communication computation proceedings annual international symposium computer architecture pages gold coast australia acm sigarch ieee computer society tcca computer architecture news winter auerbach big time winter vldb survey database programming design wolniewicz graefe algebraic optimization computations scientific databases vldb pages 
smartsimm-i rshow 
smartsimm-i rshow stroke grestore end showpage trailer pages cleartomark countdictstack exch end repeat restore enddocument fmendepsf fmbeginepsf begindocument home tomorrow grad kkeeton research isimm graphs mycompareepsi ps-adobeepsf- boundingbox save countdictstack mark newpath showpage ps-adobecreator gnuplot documentfonts times-roman boundingbox pages atend endcomments gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end endprolog page gnudict begin gsave translate scale rotate translate setgray times-roman findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate cost cshow grestore total sort size cshow smartsimm-i circa cshow pessimistic rshow optimistic rshow smartsimm-ii rshow smartsimm-ii rshow stroke grestore end showpage trailer pages cleartomark countdictstack exch end repeat restore enddocument fmendepsf figur cost performance smartsimms nows fmendpage endpage page fmbeginpage framesetsepcolors framenosep iram smartsimm overcoming bus bottleneck iram single node minutesort nowsort illustrates common technique trading memory disk accesses lar amount memory perform in-memory one-pass sort records read memory sorted written disk requires memory lar hold records sorted insuf cient memory perform one-pass sort execute two-pass sort algorithm single-node two-pass sort shown figure rst phase eate partitions one-pass in-memory sort multiple times create sorted partitions runs commonly referred database literature disk subsequent mer partitions phase portion data ioxfersize partition read memory mer ged partitions written disk step repeated data sorted written disk performance optimizations phase allocate fraction memory prefetching writing sorted data optimization illustrated gure parallel version algorithm phases eate partitions phase processor reads entire part tition local disk separates data local remote buf fers remote buf fers network remote processor remainder local data received network processor sorts local keys writes sorted records local disk parallel mer partitions phase local identical single-node case interested reader referred information algorithms one-pass counterp parts create partition phase size partition constrained size memory memorysize number partitions calculated sortsize memorysize phase number partitions cont strained portion partition simultaneously memory ioxfersize memorysize substitutp ing equation memorysize memory sort sortsize data two-pass sort sortsize memorysize ioxfersize determine single-node iram con guration serial lines disks iram derive simple relationships amount sorted required memory bandwidths sort sortsize two-pass sort read write entire set records times minutesort requires sortsize average disk bandwidth addition disk read bandwidth require memory bandwidth equations constraints iram system bandwidth iram-i iram-ii determine amount single iram sort minute calculations assume disk charp acteristics transfer rates seek times rotational latency density continue increase decrease current rates rates projected disk characteristics serial line assumptions shown appendix sortsize proc memory unsorted input data sorted partitions memory sorted output data sortsize partition phase eate partitions phase merge partitions partition partition partition partition proc partitions sortsize memorysize size memorysize ioxfersize part tition memory ioxfersize transfer figur single-node wo-pass sorting partition ime fmendpage endpage page fmbeginpage framesetsepcolors framenosep iram smartsimm overcoming bus bottleneck irams connected crossbar switch gbps serial lines practice smartsimms con gured smaller number irams high-bandwidth drams completing system dif ferent architectural alternatives resources building block adv managed antages numa network coma workstations con choices guration reasonable disks architectures processors choice management uences xible applicat tion programming endor model -constructed smartsimm system experience network goals workstations environments quantify focus impact arious ganization processor application study presented disk con paper gurations sorting case study time disk-to-disk external function sorting number sections demonstrate processor iram smartsimm provide interesting building internal block sorting input nont technical applications records present gin in-depth end discussion disk disk-to-disk sorting minutesort database main industry memory sortt ing benchmark xternal section sorting presents higher size -level discussion data lar iram ger bene memory additional commercial goal beat nett work service current applications records disk-to-disk popular external sorting sorting benchmarks recognizing previous sorting benchmarks outdated authors held alphasort cpu mhz disk sgi challenge multiprocessor memory rst benchmark introduced minutesort datamation test prot input cessor subsystems disk-resident operating systems million benchmark -byte records performance metric amount records data incompressible records -byte keys eld sorted disk disk output minute elapsed time price-performance permutation computed input list sorted price hardware operating ascending system order depreciated performance years metric recently elapsed researchers time berkeley set launch land-speed record program minutesort open network ultrasp arc workstations minutesort results shown unlike previous sorting champions results obtained shared-memory machines lar amounts input output les read input sort records write output close les terminate program datamation benchmark completed memory results obtained cluster workstations memory node experiments authors found bus structure ultrasparc workstation inadequate support disk network communication high-performance sorting achieve reasonable performance writing software disk striping seconds library consistent benchmark previous sorting work program startup shutdo literature discussion benchmark minutesort rst present algorithm ned single node two-pass measures sort extend number algorithm parallel case details sorted single-node parallel minute two-pass sorts one-pass counterparts refer number intert ested reader current record-holder system minutesort ocessors sgi system otal sorts disks otal minute memory auxiliary goal study minutesort amount aluate current operating minutesort system price support perf class applications ultrasp focusing virtual arc memory system test interfaces access patterns ultrasp kernel arc suf cient oiding paging acti ultrasp vity arc application determine amount usable memory tar system measure cpu utilization arious interfaces reading writing disk ultrasp performance relati arc disk finally aluate fecti eness threads nowsort minutesort erlapping disk results acti vity communication computation eop page bop draft rest paper ganized follo section describe testbed measurements section presents single-node internal sorting algorithm measurements aluation current operating system support continue section describing parallel implementations performance node disk cluster section predict performance datamation benchmark lar ger cluster sizes processors disks sections discuss single-node parallel algorithms xternal sorting preliminary measurements rough calculations performance minutesort benchmark section finally conclude section vir onment networks workstations fast communication potential achei performance competiti special-purpose massi ely parallel processors olume production price performance main dif ference vironments pro vide support parallel program remote job ecution fortunately eral research projects addressing issue cluster prototype study part berkele project cluster consists ultrasparc workstations sun running solaris connected single high-speed myrinet switch node memory approximately usable applications single internal disk capable reading writing peak set local non-parallel measurements identical ultrasparc connected myrinet switch additional xternal disks parallel applications written split-c parallel xtension programming language supports cient access global address space current distrib uted memory machines promotes careful engineering optimization programs pro viding simple predictable cost model split-c programs programmer speci ability xploit parallelism locality limited compiler recognition capability guess compiler transformations optimizing program split-c uilt top acti messages pro vides erhead high bandwidth communication speci cation acti messages written implemented cluster allo multiple programs ecute simultaneously acti messages implies parallel programs run time sorting programs unkno xtra functionality impact performance starting parallel applications cluster part glunix fort glunix uilt layer top solaris portable tracks endor software upgrades suf fers additional erhead limitation process acti messages time glunix tcp communication finally glunix supports functionality gang-scheduling identifying idle resources unnecessary urdensome dedicated cluster vironment adv antages glunix allo time start subsequently kill split-c program node cluster automatically redirects standard output produced nodes startup node local inter nal sorting section discuss issues related internal sorting internal implies data read disk memory present quantitati ely compare alternati phases implementation local sort reading sorting nally writing comment features underlying system cumbersome ery baseline algorithm baseline algorithm internal local sort follo read read records disk note -byte on-disk xpanded -byte memory sort sort data memory eop page bop draft starttexfig begindocument figs incore eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore size cshow in-core quicksort memcpy cshow total time rshow write time rshow sort time rshow read time rshow stroke grestore end showpage enddocument endtexfig figure erformance simple internal sort write write data disk -byte in-core con erted back bytes write phase simple implementation read write system calls read write phases reading writing chunks sort employ quicksort quicksort domain in-place sort memory wasted results sho figure number items interest gure vide amount read written time phase takes deri achie bandwidth read phase consistently read write phase peak measurements disk read write times ealed read write bandwidths roughly ufs system deli ers -peak performance sequential reads writes gure sho sort time substantial contrib utor erall benchmark time quicksort algorithm entire -byte record pairs ery time performs swap time spent ving blocks memory aster sorting sort time baseline algorithm dominant worthy consideration ulk sort time due xcessi number memory copies ery time xchange takes place -byte records swapped remedy add xtra eld in-core ersion points record reading data disk pointers fer records sort pointers place nally gather write records disk figure sho results algorithm gure performance read write phases unaf fected sort time dropped belo lar amounts data transformed internal sorting benchmark read write benchmark dif ference read write phases algorithm ersus baseline algorithm necessity scattering records preparation sort gathering write gligable buffer management read phase benchmark attains peak disk bandwidth minimizes sorting time benchmark moti ated alternati data disk memory figure moti ation left-most gure sho 
performance lar ger range pre viously sho records read sorted time benchmark linearly increases read point performance monitoring machine additional thrashing occurs leading steadily worse ecution times eop page bop draft starttexfig begindocument figs key ptr eps gnudict dict gnudict begin color true solid true gnulinewidth figur smartsimm chitectur devices devices devices devices fmendpage endpage page fmbeginpage framesetsepcolors framenosep iram smartsimm overcoming bus bottleneck architecture decide internal structure notify processor events caches coherent update memory single iram high-bandwidth serial provide higher performance cost-ef fective building block applications applications require resources iram chips clustered single simm module form lar ger system call smartsimm irams cluster communicate hight speed 
serial links connected high-speed crossbar switch smartsimms con gured smaller number irams high-bandwidth drams rambus synchronous dram lling system paper demonstrate iram serial interesting design point applications focus non-scienti commercial workloads remainder paper ganized section describe iram smartsimm architectures greater detail examine disk-to-disk sorting depth section section hight level discussion on-line transaction processing decision support workloads dynamic web content distillation high-perp formance service finally present conclusions section oposed chitectur iram smartsimm intelligent ram iram intelligent ram iram addresses growing processor -memory performance gap integrating processing memory single dram chip dram chosen sram greater memory density lower cost iram number potential advantages iram fers increased memory bandwidth reduced memory latency due single-chip integration iram fers reduced ener consumption memory hierarchy due reduction f-chip memory accesses high-capacitance busses ith addition gbps serial interconnect iram signi cantly higher system bandwidth traditional bus-based systems iram designers adjust size width on-chip dram propose prototype irams iram-i iram-ii based future dram generations shown lar pert centage chip devoted memory addition risc scalar microprocessor iram includes vector unit ector architectures natural match high bandwidth memory system iram addition shown usep ful broader class applications scienti calculations multimedia video voice processing encryption database primitives sorts hash joins shown vectorizable ectors present numerous advantages iram architectures smartsimm addition single-chip iram systems expect multiple irams grouped simm-like modules lar ger systems basic architecture building block call smartsimm shown figure smartsimm characteristic iram-i iram-ii dram generation mbit gbit on-chip memory processor speed mhz on-chip memory latency on-chip memory bandwidth bandwidth serial lines ector performance gflops power consumption die size iram arget performance characteristics fmendpage endpage page fmbeginpage framesetsepcolors framenosep iram smartsimm overcoming bus bottleneck iram smartsimm overcoming bus bottleneck kimberly keeton remzi arpaci-dusseau david patterson kkeeton remzi patterson berkeley http iram berkeley computer science division california berkeley soda hall berkeley intr oduction internally single iram intelligent ram chip presents enormous computing potential due high bandwidth low latency access memory forded tighter integration single iram provide complete solution application domains fundamental issue addressed designing conventional systems iram core building block iram interact f-chip devices shown figure conventional computer architectures connect devices parallel busses communicate memory bridge parallel memory bus parallel busp ses natural match irams reasons performance busses lags performance components computing system researchers found modern ultrasp arc workstation handcuf fed modest performance s-bus conventional parallel busses typically high pin requirements bandwidth needed busses simply double number lines attain performance increase instance -bit pci requires pins -bit pci pins iram bandwidth increase unfortunate side-ef fect doubling number pins chip fortunately great advances recently made serial communications technology researchers demonstrated syst tems deliver gbit commercial standards including fibre-channel arbitrated loop fc-al disks upcoming gigabit ethernet standard local-area networks place current workstations unable advantage devices due system design conventional parallel bus design mandates fast serial lines converted serial parallel match bus throttled bus low performance contrast irams perfect match technology figure shows high-performance serial line connected directly iram chip iram tremendous internal memory bandwidth match virtually amount serial bandwidth interfering on-chip computation single-chip integration additional bene connecting serial line directly iram chip research funded defense advanced research projects agency darp -cdarp dabt -ca calp ifornia state micro grant nsf grant cda- kimberly keeton funded lucent echnologies bell laboratories doctoral fellowship net ector proc iram architecture net proc mem controller bridge memory bus net abstract communication behavior distributed operating system master remzi arpaci present measurements communication behavior prototype distributed operating system solaris employ server workloads drive study build solaris source tree synthetic web server parallel database measurements reveal number facts implications design solaris prototype implementation proc solaris design message layer find message traffic centered nodes house mem disks potential cont bottleneck file system troller striped data cluster avoid problem messages medium sized range bytes indicating message-layer support bridge messages crucial messages structured chain buffers suggesting gather interface avoid additional buffer allocation memory copies finally request-response time conventional high due architecture overhead current message layer fact bus indicative prototype status system case low-overhead message layer substantially improve performance full paper postscript compressed figur comparison system-level chitectur postscript fmendpage 
endpage trailer boundingbox pageorder descend pages documentfonts times-roman times-bold times-italic courier eof 
vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore size cshow in-core disk-to-disk quicksort key ptr cshow total time rshow write time rshow sort time rshow read time rshow stroke grestore end showpage enddocument endtexfig figure erformance ointer sort gure sho sort time dropped -zero transforming sorting benchmark read write benchmark solv problem thrashing double-b fering read phase altered mmap read data disk steps process open call mmap establish mapping address space sorting process finally copy records mapped sorting fers needed directly sort mapped gion reasons preserv input scatter records dif ferent fers middle gure sho performance nai ersion mmap performance grades starting records problem replacement polic copying record pair referenced pages thro page replacement act manner thro wing older pages including fer pages sorted data written disk result write phase sort takes longer complete ving page records write disk ortunately mmap auxiliary system call madvise call lets user inform operating system intended access pattern gion memory xample call madvise inform kernel gion accessed sequentially allo wing fetch ahead thro pages accessed right-most gure figure sho performance implementation sorting program linear performance gion roughly gins feel limits total memory machine piece missing memory management point vie answer masters question lbq fqpl memory program experimentally easily determined found system starttexfig begindocument figs big read eps gnudict dict gnudict begin nzt color true solid true omse gnulinewidth vshift zqwz mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse lbyz stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor tbv ecz --r stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt cwh currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg cmo hpt wxt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg vzx hpt vpt xonii stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta rov ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow epx cshow cshow cshow bna obc currentpoint gsave translate rotate time seconds cshow grestore size cshow read cshow total time rshow szr -bth oha write time rshow wxoi sort time rshow read time rshow enc pqo qyi stroke grestore end showpage enddocument endtexfig starttexfig begindocument figs big mmap eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt utx vpt moveto bind lineto bind rmoveto bind znt rlineto bind vpt vpt mul jism hpt hpt mul dyq lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div fdp vshift show color setrgbcolor solid pop pwt setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul cqi setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta ryp setdash setrgbcolor hlj xtq wzd x-q jwu stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg kvh currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add wmd hpt neg vpt xmd mul hpt skx mul hpt neg vpt mul closepath stroke copy kmw end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow vwqih nio vds naa nbe hvk -tt ibf ycl oqa puu eiu luoh xdz edf lmh wtr zri lom tsq iep rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore size cshow naive mmap cshow total time rshow write time rshow sort time rshow read time rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figs big mmap madvise eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg 
hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore size cshow madvise sequential dontneed cshow total time rshow write time rshow sort time rshow read time rshow stroke grestore end showpage enddocument endtexfig figure buf fer management alternatives left-most gure sho performance read ersion sort thrashing gins sorting nai mmap middle gure slightly worse replacement polic chooses incorrect fer viction combination mmap madvise leads sorter memory doubling size amount sort starting thrash eop page bop draft starttexfig begindocument figs disk eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke ocygv v-b pah pfk mhn zan oti mztm rsv lvr bfo cxc hxz csb tpx ezx myy rpy xtxi mka irb fbwm xnr frlevku tfq vnj ckka pixu hzcn lcu uxnr -sz uud uzi csh qun umkw yjs mri hmiuml kvw ltor lkkbob dzf nwp amdd qyqah ahxe eqm vxy odc sjz bznr izr irw urft wpv pbf boo myz eej xye cbo pcld nfd wyx nvp dzm zewl fib rrtl ive wkt ynrlm uik aam sjk gjm smh kgh mmk jxe uaa- gmbh mba hdu ptv xht xhj bwq rsdr elk -jk fct sbt yxy njl occj qox pgu afx ugu mmy map wbgx ofw smq kouhr cjtlft qis mbe imvi ipkg ndpi mhl nfp wpn qwb lmv jgno xhj bls aox blk alkx gfv jlu kle jle nfpwbo leg awbo blk lsl sleg bmc sli nam bkx klu slo nvw vfc iza scvf jucf wmn ocw gdzm eym zas cyg lvz cwq gfof xpnf tcki poz eyo qzl jfd gct xmen xba yfh setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore size cshow in-core quicksort disks key ptr cshow total time rshow write time rshow sort time rshow read time rshow stroke grestore end showpage enddocument endtexfig figure erformance disks surprisingly disks sort roughly data trouble due unkno fering performed operating system presence system daemons program conserv ati memory usage face possibility paging user programs competing memory current solution problem vie potential area research optimizing cpu utilization wall-clock time ultimate measure performance important gures merit cpu utilization sho cpu utilizations phase sort slightly dif fering ersions write phase ersion user system otal write gather write cpu utilization write phase user cpu utilization gather write ersion noticeably higher write ersion write ersion spends time system code rst ersion write writev system call gather separate pointers con enient programming standpoint small catch write set elements time elements -byte -byte records write records time bytes write data trap kernel times gather write performs xtra copy user -le xtra user cpu time amortizes cost trapping kernel writing data time cpu utilization matter simple case disk dif cult fully utilize machine disks due cpu erhead mor disk band width benchmark read write benchmark estigate add disks system figure eals performance benchmark data striped disks gure time spent reading writing signi cantly ultrasp arc fast scsi limiting performance theoretical peak read phase achie roughly write phase runs roughly performance single disk eop page bop draft inter nal arallel sorting section describe parallel sorting algorithms performance -node -disk cluster rst algorithm synchronous suf fers lack erlap remedies problem oblem speci cation records input internal parallel sort initially striped multiple disks cluster workstations assume input disk number workstation number disks end sort sorted records distrib uted multiple disks disk disjoint range west alued contained output disk west group disk guarantee output disk xactly number sorted load balancing sorting algorithm applications sorted put approximately number disk taxonomy speci multiple-input multiple-output algorithm baseline algorithm gin describing simple parallel sorting algorithm optimize section parallel algorithms kno wledge precise layout disks processors minimize communication base-line algorithm follo wing phases read processor reads records reside local disk local memory distrib ute processor sends processor housing disk alue belongs nal sorted order scatter sort recei processor rearranges records pointer pairs sorts local gather write sorted records gathered written local disks read sort gather write phases identical phases internal local sorting algorithm distrib uting phase olv calculating destination node copying local fer sending fer lar amortize start-up cost sending ucket sort partitioning nodes nal range node determined number nodes node inde distrib utio alues upper log bits destination node number obtain destination node number requires shifting most-signi word log note partitioning scheme works uniformly distrib uted data alues dif ferent distrib ution approach sample sort determine splitter values partition groups equal sizes benchmark datamation distrib ution sample sort introduces unnecessary erhead rst calculating splitters nodes comparing splitters destination node determined immediately sending record copied local fer amortize start-up cost sending messages fer full bytes split-c bulk store operation increments local send counter copies speci number bytes local source remote destination increments recei counter destination node local quicksort requires contiguous memory locations processor store fer empty fer destination processor oid copying compressing data multiple processors sending simultaneously kno priori man processor send sender fetch update current fer location destination node storing fetch update requires round-trip message moti ating decision fer multiple note acti message layer handles messages destination node touches network sending message xplicitly polling time sender recei response arbitrarily high eop page bop draft starttexfig begindocument figs sync parallel eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow 
currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth nmq setlinewidth gbv ltb lta grs setdash setrgbcolor hir nne aah stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt izu exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray heo helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow iofw cshow vfc cshow yqil fok cshow currentpoint gsave translate rotate time secs cshow grestore keys processor cshow synchronous parallel in-core sort processors cshow start-up rshow write disk rshow local sort rshow mrbiv move records rshow rym zyf distribute rshow read disk rshow stroke grestore end showpage enddocument endtexfig figure erformance base-line internal allel sorting algorithm run time sort processor ultrasparcs sho stored destination processors processor wait recei ginning sort waiting performed split-c store sync command performs barrier i-l processors repeatedly polls jon network sum send counters equal sum recei counters nodes jcti scatter phase written reduce nvre amount memory copying xpense slightly memory usage drz records original record fer create fer pointers back original fer compressing records contiguous area waste bytes ery bytes roughly figure sho ecution time phases abo baseline parallel algorithm erhead spa wning starting processes nodes graph time perform local sort gligible compared time read distrib ute write disk erhead starting parallel job returning control job completion disappointedly high seconds erhead includes time glunix send vironment redirect standard spa jobs remote machines acti message layer perform initialization algorithm distrib utin requires signi ecution time sort time increases linearly number due paging acti vity memory required sending processor recei ving processor ery processor datamation benchmark section memory usable sorting summary perform datamation benchmark algorithm processor disk con guration requires seconds pipelined algorithm nai parallel algorithm reads records local memory distrib uting suf fers respects performs erlap read distrib ution phases requires memory number local observ ation processor wait read memory sending implement pipelined ersion internal parallel sort threads processor reader sender thread producer consumer relationship allocate fers sharing threads reader thread gins reading records disk rst fer completion signals fer full fer sender thread waiting rst -al qcw gjqp gxq nnht rvg jnj xmc rqd sdn yum smn fer lled sender woken read fer glp send fer stores fer full sender processed read fer signals ddm reader eaoe thread rst fer wit empty iwzo kka fers ving cay reader thread prefetch data disk network utilized figure demonstrates greatly impro performance pipelined parallel sort sending messages scsz completely erlapped reading disk remaining distrib ution time sending read fer waiting messages arri qpd sorting times closer linear eop page bop wrl draft starttexfig begindocument xwx figs pipeline nls parallel eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind ssl isi wybx rxg fgo gir rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul azs setlinewidth stroke gnulinewidth div hhs setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor isax stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt ikc hpt neg vpt closepath stroke stroke setdash vpt lnz vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash ank copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke prk copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont eul newpath lta ltb rshow npi rshow rshow rshow rshow rshow rshow iaw wmv lkin cshow bjng cshow qkb suf cshow cshow cshow cshow currentpoint gsave translate rotate time secs cshow grestore keys processor cshow pipelined parallel in-core sort processors cshow start-up rshow architectural costs streaming comparison workstations clusters smps remzi arpaci-dusseau andrea arpaci-dusseau david culler joseph hellerstein david patterson computer science write disk rshow division california berkeley remzi dusseau culler jmh patterson berkeley local sort investigate rshow resource usage wod performing streaming contrasting architectures single workstation cluster fxm smp benchmarks derive analytical empiricallybased models resource usage data transfer examining bus memory move bus records network rshow processor system investigating jbp resource detail assess comprises wellbalanced system workloads find architectures study balanced streaming xyam applications platforms main distribute limitation rshow attaining peak performance cpu due lack data locality increasing processorperformance improvedblock operation performance great aid workloads future cluster workstation bus major system read zah bottleneck disk rshow increased load network ovxv communication well-balanced cluster workstation copious xsp bus bandwidth multiple busses smp suffers poor memory-system performance true parallelism stroke benchmark grestore contention end showpage shared-memory enddocument system leads endtexfig lvi reduced figure performance result clustered erformance workstations provide higher pipelined absolute performance internal par streaming allel workloads sort keywords clusters smps measured balance run time sort processor balanced computer ultrasparcs system sho main memory number capacity mbit processor bandwidth mips cpu operating performance system -amdahl case rule longer thumb forced well-known page tenet computer memory architecture suggests systems processor balanced terms memory capacity requires disk bandwidth xtra processing space power design principle reminds read architects focus fers engineering effort small subset system send performance gains fer sub-system processor obviated lack similar gains xtra amdahl space case rule thumb bag guideline building datamation balanced benchmark systems edictions rule originated performance increased model orders time magnitude fact pipelined amdahl internal made parallel balancedsystem sort estimations experience datamation benchmark ibm timeshared function single-processor mainframe number rule processors thumb apply today number vastly disks altered environment processor term balance number interpretations disk controllers contexts amount realm memory scientific computing balance hardware defined time number constraints peak floating-point limit operations cycle discuss divided impact sustained memory adding operations cycle processors o-based disks workloads ocessor scaling figure clear sho definition constitutes time well-balanced xcluding architecture program applications startup large demands pipelined streaming parallel algorithm o-intensive sort workloads arious define numbers well-balanced system processor resources simultaneously reach nearpeak utilization processors input output processor phases line assess identical architecture analyze write resource demands line set figure streaming sequential workloads beginning disks moving memory system processor develop models smq resource usage -hr applications compare models measured usage study questions mind data moving peak rate demand resources system cqk efficient specific architectures moving data approach questions technique disk scaling adding disks system monitoring resource usage understand resources taxed byte transferred disk discover resource bottleneck range cew hardware platforms yzy prevalent today restrict class machine examine costs data movement diverse architectures platform simplest common desktop workstation focus sun ultra workstation forms basis comparison systems agc platform jzm cluster ycs ultra workstations instance larger-scale systems comprised commodity workstations high-speed networks atm a-j myrinet providing xii low-latency highbandwidth interconnection xmg switches potential fusing workstations cohesive implicitly evaluate urd underlying blk assumption clustered systems vvwz workstation current form good building block assumption optimistic machine euctl nyh wellbalanced faz stand-alone case properly architected tightly-integrated cluster primary interest fact processors added time sort number processor remains constant sort man total amount time simply doubling number processors graph time sorting increase slightly processor pipelinined algorithm due fact updating destination fset sending fer oneself faster sending network comparing sort time processors absolutely increase leading optimistically conclude increase processors multiple myrinet switches required nodes otal disks otal ime sec ime sec node memory startup startup datamation edictions disk ocessor beat current time datamation benchmark assuming start-up time -sort requires processors disk piece current process spa costs acti message initialization processors required eop page bop draft starttexfig begindocument figs proc efficiency eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke 
setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time seconds cshow grestore keys processor cshow efficiency parallel in-core sort cshow procs rshow procs rshow procs rshow stroke grestore end showpage enddocument endtexfig figure pipelined internal sort scales ocessor measured run time sort processor processors sho xcluding job startup time communication portion completely erlapped algorithm appears scale perfectly processors number processor predict processors sort processor total million time processors xcluding startup costs seconds predictions follo wing reasoning processors sho ignore startup costs completely appears beat current datamation time seconds processors disks seconds lea breathing room program startup assuming optimize glunix realistically disk processor require processors lea ving seconds program startup acti message initialization disk scaling aluate time parallel sort disks node disks xperiment xtrapolate local sorting times section sho wed disks local sort algorithm achei reading writing justify assumption parallel sort read write rates erlapping communication sho cpu erloaded communication phase limiting factor communication user system otal primiti ulk store request user system cpu utilizatio read distrib ution phase measured percentange cpu utilized read distrib utio phase pipelined parallel sort sho dif ferent communication primiti ulk store operation ersion measurements request similar performance disk due wer cpu utilization achie performance disks presents cpu utilization erlapped read distrib ution phases ith current bulk store implementation cpu utilized imply additional disk bring xpected bene cpu remaining processing wer implementation uilt acti message primiti request wer cpu utilization slightly performance run disk xhibit signi speedup disks request primiti allo round-trip message required bulk store ersion fetch update current fset cost xtra copy eop page bop draft destination node copying local fer user -speci remote address request copies system fer destination calls user -le handler handler responsibility copying data system fer desired memory location request ersion appears occasionally lose message high loads comparing ulk store request implementations shed light high cpu load ulk store ersion node preparing store fer initiates round-trip message obtain correct destination fset sending thread spin-waits response message return polling network meantime measurements sender thread spending seconds send phase waiting responses lar wait time due fact mentioned pre viously environment request message platform handled small-scale symmetric destination multiprocessor processor smp specifically ultra sender thread enterprise built xplicitly touches components network ultra workstation spin-waiting smp arti lends cially direct ates comparison cpu cluster utilization architecture numbers signi factor performance disk bottleneck system eri condition time communication phase critical path main difference disks systems measuring processor-to-processor time interconnect communication cluster phase architecture local-area network myrinet connects wait machines reader thread smp main memory input bus gigaplane fer high-bandwidth cache-coherent channel vironment communication sender thread processors distrib order utes drive architectures employ set erage kernels signi simple cantly scan faster reads data disk transfer sequentially bandwith selects matching records disks writes records disk safely benchmark assume external sort sorting disks longtime read database-industry standard benchmark distrib recently ution garnered phase interest addition ecute classical database environment small sorting additional typical time workload distrib ute systems performing decision support read paper fer single-node cluster versions write now-sort phase world fastest disk-to-disk sorting program nodes benchmark external transpose benchmarks fit otal disks database domain transpose otal found external ime scientific codes sec ime benchmarks sec hand optimized platform node memory set benchmarks startup find systems startup balanced specifically introduce system processor bottleneck system resource due lack locality streaming workloads spend time moving data operating increasing ability processor move data memory system increased support block operations greatly aid types workloads platforms find memory traffic high higher inherent applications part discrepancy attributed behavior extra copies buffer cache zeroing heap pages part mismatch grain size benchmarks block size cache cluster scenario part communication layer large amount memory traffic memory interconnect datamation stand-alone edictions clustered workstation disks capable handling ocessor bandwidth demands clustered workstations bus sho bandwidth crucial predictions times bus wsort bandwidth needed disks compared processor stand-alone workstation due nodes aggregation network ith disk traffic con ideal guration clustered workstation appears provide bandwidth network disk multiple busses beat sufficient bus datamation bandwidth clusters record improve aggregate disk nodes performance increasing number total workstations system disks smp work well-balanced optimizing architectures startup cost code lower absolute performance current time partly xcluding start-up attributed extra seconds copy avoid lock seconds contention cost false sharing system factor memory system filled sgi system bank time nodes disks full memory configuration memory memory system performance local smp exter nal study significantly sorting decreased external rest sorting paper poses outlined lar begin ger explaining challenge internal methodology sorting section nition hardware environment data section benchmarks memory modeled implies section section presents sort experimental results section phases conclude rst describe algorithm sort lar gely based work discuss performance issues study main objectives change provide dif general ferent characterization system con resource usage gurations set benchmarks baseline algorithm benchmarks representative algorithm applications perform main large amounts phases streaming rst reads models portions show resources data architecture sorts provide efficiently execute writes programs models disk based understanding reads program code runs confirmed empirically mer ges range machines form objective nal evaluate sorted architectures hand output study rst stand-alone phase workstation repeats small cluster workstations data small-scale smp sorted run architectures execute phase benchmarks read balanced run systems read types applications data approach amount dual objectives depends unified method disk threaded scaling ersion system begins running single disk processor synchronous run benchmark ersion configuration sort monitor resources run sort hardware software data counters write add disks run run system spot introducing run potential write run run benchmarks temporary measuring resource usage eop process page bop empirically determine benchmark behaves compare experimental results draft application models separate inherent data movement phase demands runs actual mer realization ging hardware runs measuring application behavior nal form systems phase recognize system read bottlenecks criticize runs start architectures reading data presented runs forms form merge presents general runs relationships mer resource usage selecting benchmark platforms alue cluster architecture runs find write amount merged crossing run write selected records numerous options approach dif ferent phases sort rst phase internal ersion sort repeatedly make sense read phase write phase lea plenty cpu idle wait iteration gin based observ ation implementation phase bus threads read phase sort reader roughly times sorter amount data read writer disk allo algorithmic property parallelism sort derived partition model memory section confirmed empirically fers section comparing phase modeled versus gins actual usage aids reader understanding lling parameters fer architecture affect resource data usage read cache disk block size match reader natural grain size start benchmarks reading leading extra memory traffic form fer presents actual sorter utilization enabled resource question sorts rst utilized fer bus read writer phase nally sort enabled disks added system point data gauge run effectiveness system work test estimate ailable pipeline resource question reading reach writing maximum utilization sorting continues writer thread writes data phase measure lacks resource utilization comple xity platforms phase combination software phase sorted runs disk phase gins opening les runs mapping address space continues logically picking top sorted runs writing apply simple optimization fering writes lar chunks hardware apply counters adv ultrasparcs anced on-chip selection counters track firstand second-level cache access statistics tournament smp tree study enterprise counters disk track limited memory yho bus traffic obtain performance information single algorithm workstation disk cluster environments woeful configure reading enterprise writing emulate single-processor time system shutting perform worse processors board resulting synchronous rst machine phase read similar sort single write workstation repeatedly memory reading system writing interconnect capable time higher data transfer perfectly rates good sequential cluster measurements make attach single random network card nite smp pitfall connect ultrasparc single disk workstations simpler noted algorithm configuration phase evaluate memory bus workstation timings ect employed gather latenc information program sorting behavior amount data traffic generated results benchmark sho small modifications made solaris kernel enable counters non-idle periods crucial tracing kernel activity counter-based measurements run benchmarks times graphs present results runs standard deviations upa data bus sysio asic asic address bus upa processor data bus bmx chips cache processorultrasparc memory simms interface seagate hawk rpm seagate hawk rpm scsi bus fast-wide fast-wide network myrinet -bit mhz s-bus scsi bus ultra workstation sbus sbus controllercontroller fastwide 
scsifast-wide scsi sbus board cache processorultrasparc address cache processorultrasparc sysio sysio data -bit address bus data bus -bit gigaplane address controller cpu memory board memory data controller ultraenterprise figure hardware diagram figure depicts internals ultra workstation ultra enterprise workstation inside workstation phase left bmx crossbar chips ime seconds asic controller provide switched-based access memory smp threads enterprise cpu board houses cpus share address data bus synchronous board consists s-bus busses boards connected erformance disk sorting data threads don main disk memory interconnect bandwidth gigaplane back memory physically distributed access time uniform disks add study disk compare platforms represent important distinct data interconnection architectures hold hardware characteristics common platforms based ultrasparc processor cpu caches memory bus peripheral busses disks platform single processor cluster workstations eight-way smp simplest platform single processor ultra model workstation shown figure machine single mhz ultrasparc processor off-chip secondlevel cache upa crossbar-like connection processor system situation gins data gins disks sorted written runs caches mer main ged memory ultrasparc disk systems back sustain bandwidths original single processor sho drive performance rate main sorting bus ultra data s-bus impro ethernet single fast-narrow scsi bus connect s-bus phase motherboard s-bus ime slots seconds additional devices experimental setup ultra workstation single threads internal seagate hawk -rpm disk attached narrow scsi bus synchronous paging activity extend disk capacity system fastwide scsi controllers connected external disks platforms runs solaris erformance modern multi-threaded operating disks system presenting disks study allo architectural sequential characteristics operating system remain behavior sequential dictates usage reading patterns underlying disk hardware shown writing care eop page bop operating system interfaces data movement ultrasparc performed special draft block copy hardware part external vis instruction sorting set block demanding loads stores system move data resources directly requiring disk double-precision bandwidth floating point internal registers sort polluting implementation caches hardware smart feature accessible case library routines plenty memcpy disk copy rates bandwidth roughly threads moving attempts traffic memory bus erlap reading s-bus sorting -bits wide writing devices optimal -bit mode disk-limited including network scenarios interface cards reducing arallel potential exter bandwidth nal study sorting examine -bit s-bus products cluster consists ultra section workstations identical describe parallel workstations ersion connected xternal myrinet sorting switched-based unlike network pre machine vious single algorithms myrinet card s-bus attached cable eight-port switch multiple switches implemented linked sort form speculate large arbitrary performance topologies parallel applications local cluster communicate ersion active messages high-performance basis communication layer baseline designed low algorithm latency high algorithm bandwidth bears switch-based great networks active similarity message restricted local ersion lightweight remote procedure call dif ference communication layer reading studying sorting base architectural costs mer data ging movement phase unnecessary copying reader buffering thread data follo avoided wed paper distrib ute thread scatters data remote processors parallel internal sort data recei processor constitute run sorter thread sorts fer active writer messages thread gam acti myrinet ated round-trip latency commits roughly write bi-directional sustained bandwidth disk goal sending receiving algorithm primary unit scalability data transfer hope benchmark hide applications communication time disk access time achie good 
performance reasonable number workstations minutesort benchmark edictions section crude estimates parallel xternal sort perform minutesort benchmark benchmark goal sort seconds assume disks machine case disks assumes additional controller ables sho predicted performance disk con gurations nodes otal disks otal amount sorted node memory minute million million million million minutesort edictions disks strict ideal xtrapolation local xternal sort start-up times nodes otal disks otal amount sorted node memory minute million million million million minutesort edictions disks dream true realize reading disks writing start-up costs numbers based direct linear xtrapolation local sorting numbers assume base case sort seconds disks seconds disks tables assume communication cost completely hidden case eop page bop draft current record minutesort benchmark performed -processor sgi challenge memory disks predictions ywhere close reality -sort beat ultrasp arcs disks ultrasp arcs conclusions paper implementation eral sorting algorithms network workstations measured predicted performance ariety processor disk con gurations test vironment consisted ultrasparcs running acti messages connected myrinet due current lack hardware measurements single disk node xamined disks node limited cluster workstations xtrapolated lar ger con gurations focused single-node parallel internal sort suf cient memory system records brie single-node xternal sort plans parallel ersion aluated support modern operating system solaris memory o-intensi applications sorting found mmap allo wed oid double fering memory conjunction madvise inform kernel access patterns input output les data structures ciently memory oid paging acti vity disco method determining amount memory ailable sorting kno amount free memory starting application single-user vironment determine amount fering operating system allocate result acti vity application belie interesting area future research found sequential access patterns system essentially fast reading disk found ultra threads scheduled independently made easy prefetch data disk performing operation pipeline distrib uting internal parallel sort quicksorting xternal single-node sort perform additional works xtra cost multiple threads multiple disks important ware current cpu utilization disk bandwidth limitations belie network workstations natural cient vironment sorting ith sorting xplicit control placement disks memory processors distrib uted disk memory vironment hide communication sharing programmer desired control acti messages myrinet pro vided suf ciently high bandwidth erhead communication enable completely erlap time distrib ute destination processors time read disk algorithm appears perfectly scalable processors added number processor constant current limitations cluster high cost starting parallel program initializing message layer beat time datamation benchmark seconds reduce current startup time seconds nodes weak aspect current con guration disk-starv disk node beat datamation record assuming optimized realistic program startup cost require processors hand disks processor processors suf cient drastically feasible perform minutesort xternal sort disk node processor simultaneously reading writing data parts algorithm predict limitations corrected set record datamation benchmark minutesort node cluster disks memory con guration compares ery orably current record-holder sgi nodes disks memory ackno wledgments richard enterprise martin small-scale pre symmetric vious multiprocessor work uniform implementing memory split-c access main acti hardware resource message distinguishes system myrinet gigaplane -bit assistance wide packet-switched setting memory testbed ultrasparcs myrinet eop page bop draft bus connects cpu refer boards ences shown figure system anderson -cpu processor culler boards boards total atterson memory case distributed networks processor boards orkstations board ieee micr s-busses s-bus feb built-in fast ethernet fast-wide scsi batcher bus sorting extra networks slot devices applications s-bus oceedings slots experiments afips add spring fast-wide scsi oint controller computing confer card ence fast-wide scsi disks attached communication enterprise performed loads stores shared memory primitives mutexes condition variables safely access shared data barriers synchronize threads processors copy rates slightly blelloch higher leiserson single ultra workstation maggs comparison bus sorting memory bus algorithms read write read connection write scan machine workstation cmh symposium allel algorithms hitectur july culler dusseau goldstein krishnamurthy lumetta cluster eicken elick arallel programming split-c super computing culler smp dusseau martin schauser ortability erformance allel ocessing chapter ast sort workstation arallel sorting logp theory practice pages john ile sons witt naughton schneider arallell sorting shared-nothing architecture cluster probabilistic splitting oceedings international confer ence allel distrib uted information systmes measure ransaction processing wer datamation smp readings database systems stonebraker mor gan kaufmann san mateo graefe arallel external sorting olcano computer science cu-csf uni ersity colorado transpose workstation boulder june highto wer cluster prins reif implementations randominzed sorting lar smp arallel machines symposium figure benchmark resource allel models algorithms table presents models resource hitectur usage june benchmarks workstation cluster smp hill platforms read larus phase resource usage reinhardt relative rate data ood read cooperati disk e-shared similarly memory software write hardware phase scalable resource usage relative multiprocessors ansactions computer systems knuth editor sorting sear hing addison-w esle leighton ight bounds comple xity arallel rate sorting data ieee expected cross ansactions bus computers read apr phase single linof workstation sort equal smith rate stan data disk thearling read practical phase external sort cluster sort shared disk times mpps rate disk oceedings cross supercomputing bus grows pages large mainwaring acti message application programming interface communication subsystem section gay give nization overview master thesis kernels uni ersity study california develop berkele models resource usage benchmarks nyber primarily perform sequential barclay future etano studies vic plan examine gray non-sequential access lomet patterns alphasort risc benchmarks machine scan sort sort typical oceedings benchmark sigmod transpose confer ence commonly found scientific codes models presented reif section memory bus aliant usage logarithmic read time write sort phases linear benchmarks size derived networks ournal understanding code models jan resource sweene usage presented doucette ratios rate anderson data nishimoto read written peck disk scalability data read xfs disk file system single workstation oceedings platform expect usenix cross annual bus hnical benchmarks read confer data ence disk jan memory-mapped files usemmap benchmarks thearling alternative read smith results impro extra copy buffer supercomputer cache sorting operating benchmark system echnical problematic report applications thinking stream machines data corporation usingmadvise sequential accesspattern pages prefetched eicken culler pages discarded appropriately goldstein writing benchmarks schauser repeatedly call write acti large messages buffer avoid mechanism high cost inte repeated traps grated communication kernel computation mmap oceedings annual symposium computer hitectur gold coast australia natural zagha match writing blelloch extend radix length sort files finally ector benchmarks multiprocessors capability access super computing multiple disks concurrently eop trailer simple end user-level userdict striping end-hook library similar end-hook eof 
library spreads disk blocks disk sub-system user-specified block size minimal cpu overhead benchmark hand optimized platform question benchmarks versions code cluster smp present models perspective single processor cpu performs identical tasks describe benchmark sequential scan modeled scan selection database simplest benchmarks input set scan sort derived datamation minutesort sorting benchmarks byte records -byte keys terminology size key size record scan selects writes disk records outi match user-specified set criteria fraction matching records benchmark keys data range selected roughly half c-j data written mjxb back disk model mlf gxo szm xzh ign vyzkh tht model gry bus usage scan platforms simple traffic crossing bus traffic rlo disks reading 
disk cross bus likewise write phase writing disk cross bus workstation memory model read phase scan performs ps-adobecreator steps dvipsk records copyright radical memory-mapped eye file software title transferred masters dvi memory pages accountingfor pageorder ascend memory boundingbox bus documentfonts times-roman key times-bold portion courier times-italic record endcomments examined dvipscommandline determine dvips masters key masters matches dvipsparameters dpi criteria comments removed logical dvipssource tex output beginprocset tex pro crosses texdict bus dict memory texdict processor begin caches key matches copied bind separate buffer exch translate isls false vsize mul hsize mul bus landplus false write phase writes rigin buffer isls disk landplus accounting ifelse concat cluster resolution memory div model vresolution cluster div neg version scale isls identical landplus single-node vresolution scan div vsize mul processes exch resolution started div hsize nodes mul ifelse cluster resolution node vresolution executes vsize single-workstation div scan add mul situation matrix currentmatrix best-case dup dup scenario round cluster abs round explicit data forall round exchangeoccurs exch round exch embarrassingly setmatrix parallel landscape isls true complete parallelism manualfeed statusdict models manualfeed resource true usage put copies cluster copies scan match fmat single node models fbb smp memory model ctr smp df-tail version forks dict begin threads fonttype fontmatrix read fntrx select fontbbox records fbb string base independent portion array bitmaps data buildchar file charbuilder write encoding end disk dup foo setfont logically array sharing copy cvx benchmark load put ctr resource usage models fntrx identical fmat single df-tail workstation dfs div fntrx neg df-tail complex pop benchmark dup definefont study setfont ch-width external ch-data sort dup length detail sorting ch-height ch-data chosen dup database length experts excellent ch-xoff test ch-data dup memory length communication ch-yoff sub-systems ch-data dup length ch-dx ch-data dup length ch-image ch-data dup type stringtype ctr ctr ctr add machine charbuilder save scan roll dup -byte base keys index -byte records bitmaps basic sorting ch-data algorithm pop ctr similar ch-dx ch-xoff ch-yoff platforms ch-height ch-xoff step ch-width add records ch-yoff setcachedevice ch-width converted ch-height true layout disk ch-xoff format ch-yoff suitable ch-image efficient imagemask sorting restore records read dup type disk stringtype key base pointer ctr full put record bitmaps ctr buckets based dup dup top length bits dup index key div improves put put cache ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore showpage userdict eop-hook eop-hook start userdict start-hook start-hook pop vresolution resolution div dvimag array string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div ifelse forall metrics metrics currentdict end index currentdict end definefont roll makefont setfont load cvx obliqueslant dup sin cos div neg slantfont index mul add extendfont roll mul exch reencodefont encoding exch end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter note legal scaleunit hscale scaleunit div hsc vscale scaleunit div vsc hsize clip vsize clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform roll itransform roll itransform roll curveto closepath pathforall newpath counttomark array astore xdf pop put courier fnt invertflag paintblack txpose pxs pys scale ppr aload pop por noflips pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage copypage macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse clip newpath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath clip showpage erasepage copypage newpath endspecial count ocount pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset texdict begin masters dvi start times-roman behavior sort ways sort operates times-roman partial key pointer pairs copying -bytes -byte records keys times-roman compared swapped number keys bucket matches size second-level cache times-bold step sorts keys bucket algorithm step accounts times-italic small fraction total execution time performs discuss finally write phase scans bucket courier array gathering sorted records writing disk model times-bold bus usage single workstation smp sort identical scan disk traffic travels bus cluster bus handle network times-bold communication record read local disk processor determines destination workstation responsible record final sorted order assuming initial data randomly times-bold data remote processors equivalent amount received times-bold processors reading disk cluster sends receives grows large times-roman cross bus workstation memory times-bold model memory bus model captures extra complexity sort read phase input file mapped read user address space accounting memory bus 
ensure pages discarded operating system memory manager records copied input buffer set sort phase keys buckets based top bits key examined top bytes key pointer record written bucket array size partial key pointer pair bytes write phase includes scan bucket array copy write buffer transfer memory disk cluster memory model difference cluster version basic algorithm occurs read phase simply placing keys pointers local bucket entire record workstation hold final sorted-order processor mapped input file records copied send buffers buffer fills destination processor buffering efficient communication -byte messages achieve peak transfer rates messages received traffic cross memory bus receipt records copied record buffer key examined partial key pointer written bucket array single workstation sort processors synchronize complete phase independently sort write set records identical single workstation sort smp memory model model smp version sort account communication processors global array buckets record buffers allocated processor begins reading separate file parallel records accessed processor simply acquire lock copy key pointer pair global bucket array copy record global record array release lock leads high lock contention poor performance avoid problem processor small record bucket buffer copies records key pointer pairs buffer fills processor grabs proper lock copies keys records global arrays read phase complete processors synchronize divide global bucket buffer array sort keys parallel finally write phase processor gathers records writes disk single workstation sort final benchmark transpose similar operation found external scientific codes out-of-core fft basic operation reads blocks row-major order writes disk column-major order blocks benchmark departure -byte records previous benchmarks model bus model phases single workstation smp write phase cluster match benchmarks model read phase cluster corresponds sort workstation memory model single node transpose reads input set writes transpose blocks disk reading blocks disk copies column-ordered buffers program transposes blocks array block read buffer location location write phase writes blocks sequentially operation complete moving bus cluster memory model cluster mapping input disk memory node repeatedly sends block local memory-mapped input file selected destination node receiving message processor copies proper buffer location based processor block input data read memory proper destinations processor writes data local disk phase communication identical single-node case smp memory model smp version begins processor sequentially reading data disk copying buffer transpose performed shared memory processor claiming required portion processors data writing disk moving memory bus write models resource usage summarized figure parallelizable workloads scan models identical platforms cluster bus usage read phases sort transpose roughly times stand-alone workstation due addition network communication finally memory bus usage cluster smp increases communicating cluster extra copy performed aggregate small messages larger smp extra copy avoid false sharing lock contention scan scan sort sort trans trans bandwidth delivered disk benchmark phase workstation cpu cpu scan scan sort sort trans trans benchmark phase cluster cpu bus scan scan sort sort trans trans benchmark phase smp cpu figure absolute performance figures plot incremental achieved disk bandwidth benchmarks group bars scales number disks processor measured rate match expectations denote bottleneck cpu bus section main experimental results paper begin presenting absolute performance benchmark platforms shown amount delivered disk bandwidth disks added system establishes facts workloads well-tuned effectively multiple disks point benchmarks reach system bottleneck proceed examining resource path disk cpu bus memory bus processor interconnect processor show absolute performance attained benchmark platforms disks added system ideal system achieved bandwidth matches peak disk rate multiplied number disks system system disk deliver reading disk writing disk figure shows increase bandwidth achieved phase benchmarks platforms read phase sort single workstation bar group data read disk bars show adding additional disks yields expected benefit disk adding roughly sum bars shown total data rate achieved disks fourth disk added gain read bandwidth expected indicating reached bottleneck system case cpu bottleneck graph summarize disks workstation single workstation sort reaches cpu bottleneck cluster performance falls read phases sort transpose due cpu bottleneck occur disks workstation finally smp performance degrades write phase sort disks processor due cpu proceed exploring resource detail begin exploration system resources bus find measurements bus traffic platforms match predictions models measurements utilization times-roman times-roman times-roman end endprolog beginsetup feature resolution dpi texdict begin endsetup page bop communication beha vior distrib uted operating system remzi arpaci department electrical engineering computer science computer science vision uni ersity california berkele eop page bop abstract present measurements communication beha vior prototype distrib uted operating system solaris employ serv workloads dri study uild solaris source tree synthetic web serv parallel database measurements eal number facts implications design solaris prototype implementation solaris design message layer message traf centered nodes house disks potential bottleneck system striped data cluster oid problem messages medium sized range bytes indicating message-layer support messages crucial 
messages structured chain fers suggesting gather interface oid additional fer allocation memory copies finally request-response time high due erhead current message layer fact indicati prototype status system case w-o erhead message layer substantially impro erall performance eop page bop contents intr oduction backgr ound experimental setup solaris experimental method hardware racing orkloads orkload characterization erall performance cpu utilization system calls conte switches summary message raf message destinations message sizes message rates implications message dependencies request-response orkload implications eop page bop anatomy message buf fer chains protocol erheads implications conclusions futur ork eop page bop ackno wledgements viously man people making report advisor atterson insight guidance friendship ithout insistence completed report reader vid culler advice sort facets arbitrary design decisions fundamental remember long time man xtended members group learned rst years berkele dif cult single yone unch amin ahdat rich martin alan mainwaring making soda hall slightly tolerable place xtend xtra note alan wning xcellent recording beetho work time fort entire solaris group sun labs ousef khalidi ving great opportunity willingness lend ear moti thadani xcellent xplanations agaries streams man enjoyable discussions ithout assistance jose bernebeu patience vlada matena xpert kno wledge arious parts solaris finally shirrif time friendship single member group time xtend special double co-worker eith etter helped gather measurements presented eith introducing magic bob greenber music lectures parents support encouragement rst years graduate studies direction advice aluable achie finally ance andrea dusseau erything person indebted man els academically xcellence profoundly uenced co-worker learned uncountable lessons rigorous careful pursuit truth sounding board xpert reader xample follo personally support terri friendship ali happy past years eop page bop ery luck found wonderful person forward man years eop page bop chapter intr oduction finite unknown infinite intellec tua stand islet midst illimitab ocean inexplicab ili business generatio reclaim land -thomas huxley distrib uted systems long acti area research distrib uted system comprised man components including process management networking systems requirements arious services eclectic common communicate lines early work achie ving high network performance paramount attaining good erall distrib uted system performance surprisingly man researchers focused forts design implementation fast communication protocols recent arri high-speed switch-based local-area networks impro communication formance order magnitude bandwidth man networks range making lightweight communication protocols one-way end-to-end times range microseconds pro vides quantum leap shared-medium ethernet man pre vious systems designed ith radical change underway important understand characterize modern distrib uted systems make communication technologies performance characteristics underlying network functionality message layer pro vide measurements eop page bop act implication message traf centered disks striping system aluable medium-sized messages account traf message-layer support medium-sized messages request-response time high w-o erhead message layer messages chain fers message-layer support gathering interface rst column present main ndings measurements communication beha vior solaris column sho potential implications design implementation system message layer structure distrib uted system gin answer questions instrumented communication layer distrib uted operating system system scrutin solaris prototype cluster operating system number ways xtends real commercial kernel solaris distrib uted system uilding top distrib uted object system based corb xtends system process management networking subsystems unix pro vide users single-system image pro vides interesting measurement testbed early stages dey elopment man aspects system optimized directly fects measurements timing-sensiti xample load message subsytem ery high measurements including sizes destinations messages fected bearing mind attempt separate results poor implementation design decisions fundamental dri traces communication beha vior employ serv workloads uild solaris source tree web serv responding synthetic stream http requests database performing series debit credits analysis consists progressi steps trace resource usage statistics characterize workloads trace aggre gate communication nodes cluster data deri message distrib utions rates communication solaris based requests subsequent responses instrument higher system eil communication dependencies conclude xamining structure indi vidual message eop page bop understand type interface message layer pro vide measurements eal number facts highlighted discuss results implications design solaris prototype implementation design message layer message traf cluster centered disks striped system oid potential disk bottlenecks global services network port name-space manager distrib uted suf fer similar bottlenecks messages roughly workloads range bytes support message sizes critical design message layer surprisingly data lar ger messages frequently oiding memory copies actions function message size bene cial instrumenting object subsystem prototype implementation solaris suf fers unusually high request-response times simple request-response attrib uted high-o erhead streams-based transport implication case vious system desperate w-o erhead transport layer current cost object infrastructure high accounting roughly ideal case transport layer fast erhead object system signi finally messages formed chain fers gathering interface bene ving cost memory-to-memory copy fer allocation messages chains by-product design object subsystem attaches header separate fer message implementation fort potentially remedy situation follo outline rest paper section ervie solaris operating system describes hardware con guration methodology study section describe workloads dri study section gin rst sun bus measurements reveal aggre single gate workstation summaries smp communication sufficient patterns bandwidth performance section cluster understand limited higher vie wing communication request-response workstation pairs bus finally leftmost graph figure section shows detail structure message measured implications ratio data layers crossing bus relative belo conclude data coming future directions section disk disks eop page bop chapter backgr ound experimental setup section describe solaris system scaled high-le phase ervie workloads predicted concepts applications single philosophy workstation bus usage system matches disk traffic outline particulars disks xperimental vironment solaris moving solaris prototype multi-computer disk operating system amount crossing multi-computer cluster bus dividing homogeneous amount crossing computers bus amount connected read disk ratio high-speed bus bandwidth interconnect disk bandwidth solaris figure modeled pro vides single-system image constructing illusion single machine users applications xternal network xisting solaris api abi preserv traffic xisting shown solaris horizontal applications black line vice dri models ers match run experimental results precisely modi cluster cation finally bus pro cluster vides communication support phases high read ailability phases sort solaris transpose comprised interest major subsystems benchmarks system expected process move management networking extensions made bus components read normal disk solaris -node kernel cluster order attain shown middle aforementioned graph goals figure experimental results confirm brie behavior xplain large cluster component bus handle roughly times underlying traffic object stand-alone workstation substrate smp bus solaris single system workstation pxfs data disk proxy crosses system bus xtends communication traffic local crosses unix memory bus system data figure confirms distrib uted bandwidth move vironment bus pxfs read written disk access location transparent process ywhere system open located established demands disk bus system models pxfs empirical accomplishes measurement apply interposing knowledge understand vnode layer architectures study pxfs support streaming-i intercept applications operations figure plots forward bus utilization correct applications physical node architectures number nodes disks increased single workstation path s-bus hierarchy single-processor workstation accessible s-bus les sufficient ensure bandwidth unix support system benchmarks semantics coherenc high disk protocols transfer rate employed peak data performance bandwidth pxfs s-bus makes operating -bit xtensi mode caching theoretically based attained moving eop maximal page -word bop -cycle data techniques burst found bus spring -cycle arbitration phase entually due pro control vide information zero-copy ulk form programmed lar peak data utilization occurs objects major figure subsystem shows process utilization management s-bus disks solaris added process system management globalized disks bus location utilized process linear transparent extrapolation user scan scan sort threads sort trans trans process restricted ratio bus disk physical bandwidth node benchmark phase process workstation network disk ywhere inherent system scan scan system sort makes sort trans trans remote ecution facilities benchmark phase run 
cluster jobs nodes network system disk process management implemented inherent scan scan sort sort virtual trans layer trans vproc benchmark top phase smp network xisting solaris disk process inherent management figure code bus data tracking movement state figures plot parent ratio bus children bandwidth processes disk process bandwidth groups workloads sessions platforms models supports posix shown process horizontal black semantics lines set bars access represents information phase processes solaris benchmarks xtends group number proc disks increased system showing load system deb increased uggers scan scan sort sort trans global trans proc ers bus processes utilization benchmark system phase workstation solaris theoretical peak pro scan vide scan migration sort facilities sort trans remote trans fork capability benchmark global phase networking cluster theoretical subsystem peak solaris scan scan sort network sort applications trans trans creates single benchmark system phase smp image theoretical peak respect figure bus network utilization vices figures plot system bus utilization process workloads architectures node disks added system system cluster network reaches connecti peak vity utilization read phase process transpose gardless bottlenecks location system s-bus components support approximately olv disk achie bandwidth ving hitting peak end utilization global management s-bus ultra 
network workstation sufficient bandwidth support disk subsystem internal scsi bus workstation house internal disks fast-narrow scsi bus peak bandwidth connects disks motherboard configuration limits performance modern disks attached avoided cluster s-bus extra load bus phases concurrent disk network communication s-bus suffers high contention peaks quickly single workstation scenario figure utilization s-bus read phase sort transpose high disks workstation show section sort reach peak s-bus utilization severe cpu bottleneck figure s-bus limits performance transpose s-bus targeted meet bandwidth requirements slower devices today high-speed disks networks tandem sun microsystems words s-bus optimized technologies expected dominate late early evident bus needed support o-intensive applications cluster -bit s-bus partially solves widespread availability -bit cards smp s-bus stated smp s-bus utilization identical single-node utilization standards s-bus meet demands enterprise system examine architecture enterprise filling board slots enterprise symmetrically cpu boards boards machine total s-busses peak achievable bandwidth busses single s-bus slot built-in fast-wide scsi slot s-bus slots comparison single ultra workstation slots internal scsi attach fast-wide scsi cards slots drive scsi disk bandwidth s-bus transfer roughly half potential data rate lack bus slots implies modern disk technologies ultrascsi full advantage bandwidth stand-alone workstations problems today bus technology workstations grow faster future standards pci provide bandwidth clusters situation bus handle times bandwidth standalone machines current s-bus technology struggles aggregate demand disk network traffic straightforward solution provide separate paths disk network traffic multiple busses recent machine sun ultra workstation good pci busses make machine ideal cluster computing radical solutions suggest placing network interface memory bus solves problem removing traffic bus placing additional load scan scan sort sort trans trans ratio memory bus disk bandwidth benchmark phase workstation processor-memory network disk inherent scan scan sort sort trans trans benchmark phase cluster processor-memory network disk inherent scan scan sort sort trans trans benchmark phase smp processor-memory network disk inherent figure memory bus data movement figures plot ratio memory bus bandwidth disk bandwidth modeled amount data movement shown horizontal black lines under-predicts actual usage noticeable amount due interactions cache block size operating system zeroing copying case cluster copy communication layer memory bus workloads question bandwidth latency sensitive solution justify costs finally smp systems standard busses provide plenty disk bandwidth foreseeable future architecture provide adequate number slots attaching disks bus behavior benchmarks move memory bus memory traffic difficult model find models consistently underpredict memory bus usage show underlying cache architecture operating system communication layer responsible differences balance platforms ultra workstation memory bus bottleneck streaming plenty bandwidth benchmarks workstation cluster extra copies abound due communication memory interconnect suffices workstation memory bus figure space shows measured memory bus distrib traffic uted ratio multiple disk bandwidth xing inherent distrib traffic uted designated de-multiple black horizontal xing line distrib group uted bars program kno main reasons models sap-serv underestimate memory manages traffic mismatch global natural network grain size space -byte cache blocks sapy operating serv system behavior pre effects ents simultaneous account allocation memory traffic tcp explained ports extra traffic dif occurs ferent read processes phase spread scan due nodes distinct interactions cluster cache outgoing packets scan examines processed -byte key node -byte record -byte application block fetched forwarded cache network interface transferred similarly memory packet bus lter intercepts predicted incoming packets directs correct node copying selected nal records subsystem output solaris buffer global -byte record subsystem lies xtends solaris cache allo blocks worst-case cross-node vice record access matches scan criteria accomodate generate cross-node functionality generates made follo similar granularity mismatches wing occur vice sort con guration difficult loading analytically unloading determine kernel memory modules traffic vice naming repeated accesses pro viding data process conte cached worst dri case ers examining -byte keys subsystems -byte uilt records top full -byte cache runtime block vironment accessed distrib uted scattering objects -byte kno partial key pointer object pairs request random broker buckets orb entire orb cache line vie wed read written object communication generate backplane performs work support remote object ocations solaris empirical results show orb pro worst case vides realized features work including simulations counting objects support one-way communication full description orb eop page bop experimental method section describes xperimental method describe hardware software user code platform operating system required understand behavior xperiments detail part xplain future work operating instrumented system behavior solaris represented models generates performance fects arose instrumentation finally details workloads dri simulations hard war cluster machines consists arcs arcs arcs running copy modi ersion solaris includes support solaris xperiments performed -cpu -node cluster arcs memory machine ethernet connection world connection fast intra-cluster network myrinet local-area network possibly xtra disk acts part global system section cluster con guration slightly dif ferent xplained racing trace communication beha vior solaris make xtensi tnf tracing facility solaris utility allo ents kernel time-stamped logged kernel fer easily xtracted analyzed call log ent takes roughly microseconds insertion man calls critical path alter results performing timing measurements judiciously inserted logging statements measuring ents long timing erhead insigni cases care subtract timing erhead orkloads paper utilize workloads dri system illustrated figure workloads slightly dif ferent hardware con gurations rst workload make performs lar parallel make solaris source tree shell starts make rexec system call distrib ute jobs arious nodes significant traffic benchmarks system read phase disk benchmarks holding source perform tree work required attached bring blocks disk pages allocated user process workload sort stresses transpose remote entire data set ecution copied facilities user-allocated buffer pxfs zeroed demand eop half page zeroing takes bop place scan workload web based spec benchmark records copied found benchmark empirically total xternal traffic stream memory bus http requests read phase generated sort transpose cluster node scan cluster running memory bus figure copy shows memory ncsa architectural httpd traffic serv requirements under-predicted scalability cluster requests models nas parallel benchmarks read frederick phases wong sort richard transpose martin remzi phases arpaci-dusseau anddavide perform culler communication computer science differ division department single-workstation electrical implementation engineering computer extra science traffic captured california berkeley models fredwong rmartin remzi rest arises culler berkeley behavior abstract message present study layer architectural sort requirements transpose scalability benchmarks send nas parallel buffer benchmarks communication layer direct measurements copy buffer simulations identify pre-pinned pre-mapped factors region affect address scalability space benchmark dma codes operations relevant connected performed distinct platforms network ethernet cluster device workstations network result interface significantly ccnuma sgi traffic passes origin request find memory recei bus benefit cluster increased global networking cache subsystem single-workstation size redirects benchmarks traf pronounced sort applications cross connection offsets bus communication cost constructing working set profile benchmarks visualize improvement computational efficiency constant-problem-size scaling find origin mpi point-to-point performance cluster mpi layer scalable communication load communication performance applications lower achieved microbenchmarks show nodes read disk smp system memory bus similar memory traffic smp mach benchmarks packet read phase lter sort identical responses single node forwarded measurements figure show responding extra cluster node generated communication protocols transferred mpi disk runtime library extra back influential traffic due communication contention performance original applications file source system buffers benchmark disk codes avoid wide lock spectrum http contention communication false les sharing requirements introduction connected application nas parallel benchmarks avoid npb contention widely underneath evaluate sort parallel workload transpose machines hea benchmarks date vily smp vendor utilizes large input parallel buffers machines networking starting presented sub-system npb measurements results potentially results original memory paper caching traffic features read phase pencil explicitly performing system version lastly operation reports provide performance comparison suffered database extent execution workload time performs fully function utilize series number disks processors transactions cpu execution rate oracle speedup efficiency arallel easily computed database extremely valuable results provide understanding delivered performance fixed algorithm simple standard debit message credit passing interface transactions mpi programming performed model nas parallel parallel benchmarks version nodes make disk benchmarks basis database indepth comparative analysis present attached parallel evaluation architectures ultra memory current systems reports provide measure crude memory workload performance bus comparison stresses utilization aspects workstation reported result estimate global utilization total based execution specifications time system workstation upa eop interconnect performance metrics upa page bop designed support small-scale smp systems starttexfig over-engineered begindocument simple figures derived workload case make execution eps time single processor psdict measured inside dict nas workstation benchmarks psdict begin -mhz berkeley psdict ultrasparc network mtrx processor matrix workstations put drive coldef memory pleasantly system surprised col find srgb bind speedup memcpy interconnect good col theoretically srgb capable bind cray sustaining roughly per-node col srgb performance bind sort memory-bus col intensive ibm srgb applications bind spalthough lesser performance moves col srgb processor bind memory bus raw speed col mpi srgb transferred bind active disk messages move col ratio srgb peak processor bind performance memory message interconnect col performance srgb provided bind read adequate accounting disk col sub-system srgb differences bind cluster lack upa interconnect clear col explanation due srgb motivated bind high develop capability set col upa tools srgb memory analyze bind interconnect architectural amount requirements col npb srgb bind detail memory single traffic col pass generated srgb bind sort class benchmarks overload roughly col memory srgb trillion system bind instructions traditional sort simulation moves col techniques srgb bind intractable memory ruled interconnect col part srgb employed bind system hybrid method combining bottleneck col direct srgb bind measurements reaches real machine col parallel srgb system trace-driven bind components simulations handle ultraenterprise col memory srgb system bind understand gigaplane performance main characteristics col system srgb interconnect actual bind platform enterprise systems shows col bandwidth srgb bind architectural interconnect parameters affect high col scaling srgb capable paper bind delivering detailed analysis col memory srgb banks architectural bind factors determine compare col scalability srgb cluster bind nas interconnect parallel defer col discussion srgb bind section interestingly col memory srgb bandwidth ultraenterprise scales memory capacity system memory benchmarks banks parallel bank machines serves increase berkeley total cluster memory bandwidth bind sgi adding origin dram col relevant srgb bind distinct bank platforms col basis bank srgb bind study filled starting small col base capacity srgb systems performance bind speedup small curves performance col break srgb capabilities bind benchmarks terms early col experiments srgb computation bind server communication configured costs col isolate srgb bind factors end determine save speedup translate memory analysis banks shows limiting scale clp machines sustainable closepath performance scalable bind communication processors eofill performance running bind improvements copy memory micro-benchmark grestore system similar bind performance due gsave bind increasing cache lineto effectiveness bind compensate time spent communication moveto extra bind computational work newpath bind subtleties stroke program bind interaction slc cache setlinecap architecture bind operating slj system setlinejoin bind network slw communication setlinewidth lead bind excess memory srgb traffic setrgbcolor mismatches bind rot grain size rotate bind applications scale block bind size cache translate architecture bind difficult tnt avoid dup dup applications requiring currentrgbcolor exhibit application perfect roll awareness dup exch super-linear underlying speedup machine roll mul architecture add machine reducing sizes roll dup number typically exch copies roll performed mul class add data operating roll system set dup exch processors communication roll layer mul class add srgb bind behavior tractable shd dup modern dup operating currentrgbcolor systems roll avoid mul extra roll copies mul inherent providing roll mul direct constant srgb problem non-buffered bind size cps drawellipse scaling endangle applications exch bypass benchmarks startangle file exch system buffer characterized yrad cache exch precisely xrad constructing version exch working exch solaris exch includes savematrix functionality mtrx zeroing currentmatrix pages set graphs protection xrad yrad difficult startangle endangle avoid arc input closepath size continue savematrix main play setmatrix contributions important role work drawsplinesection streaming exch workloads characterization cluster exch communication complex exch interactions results software exch extra hardware copies effects exch current speedup exch environment methodology potentially understanding speedup avoided mul add cps domain cluster sort quantitative mul analysis copy add explicit architectural requirements program mul nas -byte add parallel records benchmarks copied suite larger version mul including blocks add amortize detailed lineto study overhead nas sending benchmarks message curveto working set copy psbegin behavior avoided psdict tight scaling begin integration psenteredstate evaluation save network communication interface efficiency psend applicationswith processor psenteredstate lowering restore mpi overheads end communication allowing protocols applications psbegin experimental send environment small messages setmiterlimit methodology peak rates understanding slw polyline performance copy occurs scaling message large layer parallel codes clp copy col buffers difficult times-roman problem portions ideally findfont address scalefont space setup setfont run dma benchmarks transfers colshow real copy machines times-roman findfont avoided option scalefont exposing precludes setfont communication detailed 
study buffers application largest reduction memory traffic cluster direct disk-to-network transfers completely avoiding memory bus application sort dynamically determine destination -byte record requiring application-specific code disk controller examine demands communication backplane cluster smp find interconnects significantly demands bottleneck real systems cluster interconnect analyze communication rates links attaching machines network total amount traffic generated nodes established section workstation sends receives roughly read phase sort transpose link connects machine switch support traffic direction processors sending aggregate bandwidth moving network read hardware phase characteristics cache size parameters simulations problematic limit size problem potentially miss longterm smp effects interconnect remedy smp situation interconnect apply support hybrid memory approach traffic instrumented surprising communication resource library tandem heavy contention hardware counters measure figure execution characteristics phases benchmarks scan real processor machine places roughly trace simulate memory bus benchmarks vary read disk architectural parameters details scan places roughly methods shared direct interconnect measurement sort study places executions nas benchmarks bus performed transpose cluster roughly ultrasparc model workstations sgi origin system runtime measurements present paper average runs excluding outliers cluster node single myricom network interface card attached s-bus bus machines interconnected ten -port scan myrinet switches difference aggregate fattree bandwidth topology smp node interconnect cluster cluster running interconnect solaris roughly factor cache bandwidth main requirements memory mediums ultrasparc scale linearly main processors memory obtain single processor runtime origin machine consists processors running mhz processor myrinet cache network nodes analyze ability machine node myrinet hardware processors support traffic main memory -node running cluster irix assuming single mpi -port switch initial study myrinet links origin system sustain based direction mhz system sufficient numerical bandwidth aerospace simulation reaches facility nasa ames research center ability myrinet switches investigation handle hardware total communication configuration bandwidth origin switch system perfect upgraded crossbar mhz support mhz aggregate bandwidth origin system measurements port based contention mhz myrinet system switch bottleneck section total network performance traffic nas long benchmarks processor speeds discussed s-bus handle nas benchmarks myrinet communicate links mpi switches provide ample bandwidth mpich capacity relative today implementation disk speeds adi calls current networks mapped active proper messages performance regime operations layer mbps highly tuned fast ethernet performance connection break link performance bandwidth support benchmarks add disk instrumentation bandwidth code workstation mpi gigaplane layer mpi enterprise call gigaplane record support desired set roughly statistics data transfer end -processor execution system write established results disk cases transferred instrumentation adds bus benchmarks place execution time cases gigaplane achieve peak manner utilization gather bus information worst case message limit sizes amount destinations per-processor time disk stamps traffic communication events occur measure instruction count cpi performance counters ultrasparc processors main beginning concern run system designers configure conclude counter count streaming cycles applications small-scale count parallel instructions systems start end bottleneck mpi event cluster record interconnect provide values bandwidth end scales run linearly de-construct number disks amount time workstation spent streaming number instructions benchmarks executed switch inside essentially mpi capability routines handle measurements sum run disk traffic larger systems consist switches interconnect scale mediumand large-scale clusters smp interconnect handle aggregate memory data movement full number iterations nas benchmarks small-scale systems class problem modern aggressive sizes simulation instrumented busses mpi layer give gigaplane usage sufficient characteristics breakdowns time spent code give section working examine sets processing requirements benchmarks counters streaming provide miss begin rates analyzing number cache design instructions executed machine byte read cluster written disk origin study sparc-based systems miss rate relationships cache size coarse tosolvethisproblem estimates weemploytheshadesimulation risc-based machines understand ultrasparc environment processor executes cluster workloads shade measure processor sparc-based utilization virtual cpi machine instructions application implementation program independent utilization shade cpi directly manner determined running number independent architecture-specific instances factors including simulator branch behavior memory workstations latency cluster inside cpi virtual platforms cluster benchmarks communication high processes result parallel program processor takes place bottleneck real myrinet network workloads note written shade characterizations analyzer outputs section data preliminary cache address trace exact breakdown process instructions simulated executed machine benchmarks time traced spent part single time-step on-going research experiments revealed behavior time steps identical benchmarks trace produced dinero cache simulator simulate desired cache configurations workstation speedup processor figure figure shows table show number speedup instructions single millions processor executed execution system time user mode cluster delivered origin disk bandwidth class problem size number nas instructions executed figure speedup system mode nas parallel benchmarks constant figures benchmarks present writing speedup curves write requires berkeley system cluster instructions sgi reading origin mmap class due problem extra size memory copy nas parallel buffer benchmarks cache version main cluster difference achieves perfect benchmarks arises slightly perfect work speedup user-level programs performed transpose origin requires attains amount superlinear work speedup read phase benchmarks user code wide performs spread single speedup copy behavior record origin read phase scan executes instructions key compared speedup machine selection size criteria processors copies spe performed dup fine granularity write ideal cluster phases transpose scan perform essentially work speedup userlevel machine repeatedly size calling write processors spe move data dup disk sort ideal processor table intensive single due processor execution mismatch time table disk presents representation single records processor runtimes form berkeley cluster internal sorting sgi disk origin records comprise class linear problem array size nas internal sort benchmarks executes version benchmark -byte cluster keys seconds separated origin seconds larger records groups keys fit second-level cache figure records time read breakdown disk nas keys benchmarks scattered figures buckets break pointers total set execution time full summed records write processors phase nas reverse benchmarks operation cluster gathering keys origin records communication linear computation array time writing shown disk separate cluster non-cumulative processor lines total major time increases sum instruction rates communication relative single computation workstation time occur presented sending receiving messages read phases sort workstation cluster smp sys user sys cluster machine size processors eco total comp user comm sys ideal user scan read write sort origin machine read size processors write trans eco read total comp comm write ideal figure processor instruction rate table shows origin mips machine size disk processors bandwidth transpose benchmarks eco communication total performed comp user comm level ideal increase user instruction counts transpose cluster machine minimal size instruction cost processors perform bulk-message network communication immediately sends block read disk increase eco total comp transpose comm read ideal phase workstation cluster shows slightly origin machine size mips processors required send eco receive data total comp work comm ideal combined system user cost reading writing cluster disk machine cost size communicating processors greater sort eco benchmark total -byte comp records comm copied ideal buffers amortize startup cost cluster communication machine smp size processor processors similar cluster sort eco smp versions total comp comm ideal cluster machine size processors eco total comp comm ideal benchmarks origin machine size processors eco total comp comm ideal origin machine size processors eco total comp comm ideal cluster perform machine additional size work processors copy data buffering eco performed avoid false-sharing total comp lock comm contention ideal figure time sort breakdown copying keys nas temporary buffer benchmarks continued inserting figures global break bucket array increases total instruction costs execution time mips summed higher processors instruction costs nas benchmarks read phase cluster scan origin write communication phases computation programs time shown due separate lock non-cumulative contention lines total time kernel sum communication computation time presented origin machine size processors 
eco total comp comm ideal benchmarks run class class problem size basis study class run single processor parallel machines observe cluster obtains perfect speedup slope benchmarks obtains efficiency benchmarks speedup slightly super-linear machine sizes behavior complex origin performance benchmarks substantially super-linear range performance falls efficiency reason cache effects communication effects behavior systems generation ago occurs large second-level caches present today machines time step understanding nas benchmarks behavior isolate components application execution time parallel programs work time spent processors curves labeled total figure show sum execution time processors nas benchmarks machines function number processors metric perfect speedup corresponds horizontal line labeled ideal intercept single processor execution time cluster follow ideal closely drop super-linear speedup moderate machine sizes rise sub-linear speedup origin curves show greater variation understand behavior isolate components execution time instrumenting portions program obtained detailed breakdowns time spent inside mpi library hard practice distinguish inherent load imbalance parallel program synchronization cost communication event actual communication cost curves labeled communication figure show sum time spent mpi communication synchronization including send colshow receive wait time curves labeled computation showthe sum times-roman time spent findfont mpi library scalefont processor count setfont increases general communication time grows processor count compensated improvements computational efficiency super-linear speedup observed decrease total colshow computation times-roman time findfont scalefont increase setfont communication cost colshow computation bound times-roman communication findfont scalefont setfont total execution time colshow times-roman processors findfont configuration scalefont setfont benchmark experiences modest colshow linear ellipse improvement computational efficiency drawellipse larger cols machine size ellipse hand drawellipse roughly constant cols efficiency polyline processors change cols relative polyline processor opposite machines cols times-roman findfont communication scalefont computation setfont cost roughly balance colshow communication ellipse time occupies drawellipse execution cols time times-roman benchmarks findfont offset scalefont decrease setfont computation time colshow ellipse communication bound shows drawellipse gain cols computational efficiency times-roman run findfont scalefont processors setfont fact computation time colshow increases ellipse slightly increase drawellipse cols times-roman findfont scalefont setfont colshow ellipse drawellipse cols times-roman findfont scalefont communication setfont time significant colshow times-roman dominant factor findfont scalefont speedup setfont benchmark colshow computation efficiency times-roman benchmark findfont scalefont improves setfont increases communication time make dominate colshow ellipse performance benchmark drawellipse cps cols scaling rule times-roman total findfont amount scalefont work setfont total number computational colshow operations ellipse solve fixed problem remains drawellipse cols number times-roman processors findfont scalefont setfont computation time processors colshow remain ellipse constant computational efficiency unchanged hand moreprocessors added solve problem communication time increases number computational operations due redundant work nonetheless benchmarks show perfect super-linear speedup extra time spent communicating synchronizing compensated improvement computational efficiency hardware counters concluded reduction computation time corresponds reduction miss rateandincpi sections investigate factors drawellipse govern cols speedup times-roman nas findfont benchmarks scalefont setfont section examines change colshow computational ellipse efficiency caused effective drawellipse memory system cols total polyline amount cache increases arcto section pop examine communication repeat behavior arcto nas pop benchmarks working repeat sets arcto gain pop insight repeat memory access arcto pop characteristics repeat clp benchmarks cols scaling polyline obtained per-processor memory address arcto trace pop application figure repeat working arcto set pop profiles nas repeat benchmarks arcto pop working sets class repeat problem arcto size pop repeat top clp middle cols andlu bottom polyline presented curve corresponds arcto pop machine size repeat curve arcto pop labeled corresponds repeat -processor arcto pop machine cases repeat large arcto cache pop sizes repeat increasing clp number cols processors polyline working problem decreases arcto per-processor pop miss rate noticeable repeat amount arcto pop smaller cache size repeat scaling arcto pop makes difference repeat cache arcto performance pop repeat increases clp miss cols rate times-roman findfont scalefont setfont colshow open processor spline cache size drawsplinesection cols processor cache size rate clp setgray workstation ultrasparc-i figure shows cpu utilization cpi processor benchmark cache size graphs ascertain sustainable disk bandwidth rate platform cpu limited single workstation sort processor places cache size load processor reaching cpu utilization disks roughly explains drop absolute processor performance cache size figure earlier section rate benchmarks fair extrapolating cpu utilization predicts cpu bottleneck roughly processor cache transferred size disk benchmarks cpu rate expected figure working primary set bottleneck profiles predicted nas benchmarks memory busses continued handle working sets class problem saturating size cluster ultrasparc-i top cluster middle measurements show bottom fast communication presented layer places heavy demand ultrasparc per-processor processor miss rate processor change significantly utilized read size phase cache sort scales disks slight improvement cpu bottleneck cache adding miss rate large disks cache workstation sizes improve miss rate performance sorting per-processor transpose cache read size fairs increases scaled reach utilization machine size interest disks ran workstation trace reader processor notice cache simulator number system range level cache instructions size read phase simulations transpose caches decreases fully associative cluster lru smp replacement implementations -byte cluster blocks repeatedly write back small buffers write allocate large buffer saving operating system cost zeroing pages smp versions pages read phase begins result reducing smp instructions relative platforms scan scan sort sort curves trans labeled trans offigure showthedata cache miss rate cpu utilization -processor benchmark machine phase workstation function system user cache size size cpi scan scan sort demonstrate sort effect trans scaling trans miss rates concentrate benchmark phase effect cluster pronounced cpi scan scan smooth decrease sort miss sort rate trans trans benchmark general phase rule smp figure doubling processor cache utilization eliminates figures constant plot fraction processor utilization misses bars left y-axis roughly label miss cpi rate line flat y-axis drops label workloads platforms levels workloads processor knees main working bottleneck set correspond system moving disk shared sort address space transpose programs cpu measured s-bus reach peak splashthe utilization key observation simultaneously read cps phase scaling transpose high cpi reasons low data locality accessing blocks data leads high cache miss rates effect measured single workstation accessing network interface card s-bus expensive cpi grows number disks contention bus increases smp ultrasparc-i cpu utilization shows sort smp leverage disks processor general cpu utilization smp higher single workstation number instructions executed similar utilization graphs platforms illustrate importance operating system performance streamingi workloads benchmark platform time spent kernel dominates spent user-level number disks increases interestingly number instructions executed biased high cpi poor kernel cache performance processor main bottleneck workloads platforms situations cluster environment bus limits performance approaches lowering processor utilization workloads reducing number instructions communication layers active messages provide minimal cost primitives network access time revisit instruction costs disk high instruction cost disk access exacerbated solaris operating system generality modularity support threads increase common code path disk instruction costs reduced additional support large block operations instruction set approach focuses lowering cpi easiest solution hardware tighter integration memory system software lesson feasible current systems operations cache conscious crucial group data accesses secondlevel cache-sized objects avoiding high cost repeated access main memory style programming extensively plan investigate support applications achieve locality presented measurements 
resource costs data movement machine architectures platforms developed models benchmark resource usage validated models empirically measured utilization resource amount disk bandwidth system scaled order evaluate architecture perspective set kernels summarize results present graphical representation means balanced system figure plots balance platforms phase workloads question machine resources machine shown x-axis y-axis plots predicted per-processor disk bandwidth added machine resource reach saturation workloads based linear extrapolation usage characteristics found earlier sections set bars height balanced system set higher bars system figure machines balanced platforms resource bottleneck processor due lack locality streaming benchmarks fact benchmarks cpi lower processor potentially execute instructions cycle single workstation memory interconnect stand-alone workstation over-engineered bottleneck types workloads cluster bus limits performance phases network communication surprisingly benchmarks communication balance cluster workstation defaults stand-alone case memory bus plenty bandwidth memoryintensive benchmarks fairly utilized network backplane myrinet ample bandwidth easily handling traffic rates proportional disk finally smp absolute performance result appears balanced architectures communication backplane gigaplane handles high load streaming application set adequate small-scale parallel systems performance cpu weak link chain surprisingly high cpis processor utilization peaks rapidly end result cluster platform performing workloads dominated streaming obus membus disk bandwidth saturation read write workstation scan sort transpose obus membus backplane read write cluster workstation scan sort transpose obus backplane read write smp scan sort transpose figure balanced systems figures reflect balance architecture x-axis shows resources system y-axis amount per-processor disk bandwidth introduce system resource reaches peak utilization flat set bars balanced system higher set bars system authors jim gray eric anderson kim keeton rich martin amin vahdat valuable comments feedback suggestions ashok singhal sun performance counters katherine hartsell sun information sun enterprise servers sharad mehrotra sun generous equipment donation special satoshi asami disks finally shephard jean-loup baer direction setting work context work sponsored darpa contract -cand california state micro program remzi arpaci-dusseau funded intel graduate fellowship agarwal super scalar sort algorithm risc processors acm sigmod conference pages june amdahl storage parameters system potential ieee computer groupconference pages june anderson culler patterson case networks workstations ieee micro february arpaci-dusseau arpaci-dusseau culler hellerstein patterson high-performance sorting networks workstations sigmod boden cohen felderman kulawik seitz myrinet gigabit-per-second local area network ieee micro february chen bershad impact operating system structure memory system performance proceedings annual symposium operating systems pages december culler liu martin yoshikawa logp performance assessmentof fast networkinterfaces ieee micro measure transaction processing power datamation readings database systems stonebraker morgan kaufmann san mateo gray personal communication june hill larus reinhardt wood cooperative-shared memory software hardware scalable multiprocessors acm transactions computer systems kleiman voll eykholt shivalingiah williams smith barton andg skinner symmetric multiprocessing solaris proceedings compcon spring kuszmaul out-of-core ffts parallel application environment technical report nas technical report rnd- mccalpin sustainable memory bandwidth current high-performance computers white paper mukherjee hill case making network interfaces peripheral hot interconnects aug nyberg barclay cvetanovic gray lomet alphasort risc machine sort acm sigmod conference perl sites studies windows performance dynamic execution traces osdi pages october stonebraker case shared database engineering sunmicrosystems sbus specification rev white paper torrellas gupta hennessy characterizing caching synchronization performance multiprocessor operating system asplos-v pages october von eicken basu buch vogels u-net user-level network interface parallel distributed computing proceedings acm symposium operating systems principles pages december von eicken culler goldstein schauser active messages mechanism integrated communication computation proceedingsof annual symposium computer architecture gold coast australia 
working set curve machine size processors knee starts processors processors cases sharp drop occurs amount global cache sum local caches reaches mbforthebenchmarklu memory access requirements cluster drawing vertical line per-processor cache size miss rate drops significantly -processor system cluster flattens larger configurations change reflected change total computation time figure ontheoriginsystemwith mbofl cache working set knee captured cache single processor increase computation processors due factors decrease large configurations working set fits global cache algorithms tuned cache friendly phenomenon pronounced benchmarks experience levels boost global cache size increases benchmark moderate improvements efficiency significant change interestingly small local cache size typical early parallel machines miss rate benchmarks increases number processors improvement computational efficiency benchmarks machines small caches increase miss rate scaling benchmarks amount work increases processors added figure shows percentage increase computational instructionson cluster relative single processor case benchmarks experience moderate growth instructions scales significant increase extra work load memory system expected increase instruction load important point examining cache effects significant influence scalability benchmarks cps scaling result increase memory system efficiency due figure extra work figure shows percentage increase computational instructions relative single processor nas benchmarks cluster scales extra work machine size processors crea cache effects overlooked case nas benchmarks dismissed assumed cols working open sets spline exceed cache size work demonstrates combination large caches drawsplinesection processor cols cache-friendly codes cache effects play significant role scalability machine clp cps setgray scaling rules cols open case spline nas benchmarks cache boost mask poor performance areas drawsplinesection communication communication cols performance breakdowns execution times figure benchmarks spend clp significant amount setgray time communication cols benchmarks times-roman findfont scalefont increase setfont communication time primarily determines rexec scalability colshow times-roman benchmarks findfont section scalefont investigate setfont communication load rexec benchmarks place colshow times-roman architecture findfont scalefont sensitivity setfont benchmarks underlying rexec communication colshow protocol psend mpi restore communication scaling enddocument table shows endtexfig baseline communication characteristics nas benchmarks processors communication scaling relative base case table shows total number messages processors collective operation performs processors counted message total volume total number bytes processors processors benchmarks send messages size messages large benchmarks send messages megabytes size non-blocking mpi isend primitive traditional blocking mpi send number collective communication operations low surprisingly benchmark barriers benchmarked portion code benchmarks reduce operations reduce operations contribute performance significantly communicate primarily collective communication series all-to-all exchanges figure shows communication characteristics nas benchmarks change machine sizes figure top plots change total message count processor function machine sizes normalized message count -processor figure middle shows byte count processor finally figure bottom shows resulting average message size processor realm interest order magnitude difference average size message benchmark interestingly smallest messages benchmarks order bytes substantially larger grain found parallel benchmarks all-to-all pattern normalized per-processor message count growth linear machine size total number pointto-point messages increases square number processors total byte volume remains constant bytes processor decreases 
message size decreases range processors studied absotable nas benchmarks baseline communication characteristics table shows baseline communication characteristics nas benchmarks codes class problem sizes -processor table shows number messages breakdown type total number bytes results -processor case reduce allreduce benchmark isend send alltoall allreduce barrier total volume figure message scaling figure shows number messages normalized processor case top number bytes middle average size message bottom scale function processors machine size processors ssa sso bytesperprocessor machine size processors lum averagemessagesize machine size processors age age lute number messages remains small squaring message count resulting decrease message size important implications machine designers machines processors efficient transfer mechanisms exist messages ranging hundred bytes megabytes size total amount communication surface volume ratio scale number processors unlike benchmarks finer-grained communication message sizes benchmarks span order-ofmagnitude range paticular sends messages ranging bytes range processors interest scaling communication lines unduly limit speedup spatial decomposition communication nearest-neighbor regime benchmarks summary nas benchmarks place wide variety communication loads system ranging nearest-neighbor point-to-point exchange coarse-grained all-to-all communication general communication load increases scale cluster sensitivity communication protocol message characteristics imply total communication costs increase cps scale machine size figure shows starttexfig total communication costs begindocument rise figures workload sizable differences platform handles increased communication load figure plots mpi one-way latency bandwidth platforms dongarra echo test one-way latency half message round-trip time one-way bandwidth reciprocal latency startup cost maximum bandwidth sec sec cluster origin micro-benchmarks results message characteristics nas benchmarks construct expected communication cost message accumulate micro-benchmark latency message size predicted communication time nas benchmarks communication efficiency ratio predicted measured communication figure mpi eps performance figures psdict show dict performance psdict mpi begin platforms psdict mtrx dongarra matrix echo put test top coldef figures show one-way col latency srgb small bind messages bottom figures show col srgb one-way bind bandwidth message size col srgb bind mpi one-way bandwidth col srgb bind col srgb bind cluster message col size srgb bytes bind col srgb bind mpione-way latency col srgb bind onorigin col message srgb size bind bytes col srgb bind mpi one-way latency col srgb bind cluster message col size srgb bytes bind col mpione-way srgb bind col srgb bind bandwidthonorigin col message srgb size bind bytes col srgb bind sec col sec srgb cluster bind col srgb bind rendevous machinesize col processors srgb bind cien col 
srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale clp closepath bind eofill bind grestore bind gsave bind lineto bind moveto bind newpath bind stroke bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix drawsplinesection exch exch exch exch exch exch mul add mul add mul add mul add lineto curveto psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit slw polyline clp col times-roman findfont scalefont setfont colshow times-roman findfont scalefont cluster eager machinesize processors cien origin machinesize processors setfont cien colshow times-roman figure findfont communication scalefont efficiency setfont figures show percentage colshow predicted bandwidth times-roman delivered findfont mpi scalefont layer setfont total time spent sends colshow waiting times-roman application findfont scalefont function number setfont processors top figure shows colshow communication times-roman efficiency findfont rendevous scalefont protocol setfont mpi layer colshow cluster polyline middle figure shows communication efficiency eager clp protocol cols bottom figure times-roman shows findfont communication scalefont efficiency setfont origin machine time figure colshow graphs ellipse communication drawellipse cols ellipse efficiency platforms notice cluster rendevous benchmarks efficiency half drop slightly scale hand starts high efficiency falls sharply scale communication efficiency benchmarks origin figures show cluster platform handles load origin show delivered performance micro-benchmark performance anomaly implementation mpi layer interacts underlying architecture evaluation nas benchmarks drove development mpi layer cluster total time predicted combining micro-benchmark performance message profile data significantly time spent communication investigation cluster revealed source problem internal protocol mpi layer initial implementation mpi conservative rendevous protocol low-latency active messages building block rendevous protocol simplified receive code message format short round trip time rtt easily amortized large impending bulk transfer micro-benchmarking conditions design deliver optimal performance practice queueing delays source mpi-to-network interface exacerbate rtt real applications resulting efficiency shown figure rendevous figure plots histogram measured round-trip times protocol message run benchmark -processor micro-benchmark tests rtt actual cost variance high indicating prediction round-trip times difficult large average message size nas benchmarks protocol messages experience long queueing delay surface application level form low communication efficiency revised mpi implementation aggressive eager protocol significantly increased complexity re-sequence out-of-order messages slightly worse micro-benchmark performance communication performance context real applications improved benchmarks shown figure eager eager protocol increases utilization outgoing channel reducing queueing delays figure plots histogram measured communication time message running -processor eager protocol figure shows cost message reduced significantly smaller variance benchmarks achieve higher communication efficiency eager protocol benchmarks -processor achieve full efficiency communication efficiency falls larger configurations network saturated benchmarks communication efficiency limited point-to-point communication primarily mpi send mpi isend improvement communication efficiency eager protocol effective benchmarks communication efficiency benchmark increases efficiency improves unchanged efficiency benchmark caused inherent load imbalance program investigation shows benchmark experiences approximately load imbalance processors suggests improvement point-to-point communication hidden large amount synchronization time origin sensitivity processor speed initial study origin system based mhz processor origin system nasa ames upgraded mhz investigation change behavior illuminating section study differences performance nas benchmarks systems difference systems increase processor speed on-chip cache latency memory bus speed closely tied processor speed performance memory system mpi change micro-benchmarks capture differences systems experience user applications figure shows performance memory systems memory stride benchmark benchmark shows approximately decrease latency cache approximately improvement latency main memory figure shows one-way point-to-point bandwidth mpi mhz system dongarra echo test improvement processor speed memory system micro-benchmark obtains roughly maximum bandwidth decrease latency small messages sec predicted std node isend cost sec coun figure message cost mpi internal protocols figures show change message costs mpi layers figure plots histogram observed round-trip times initial mpi layer set-up message node benchmark -processor figure plots time mpi isend eager protocol message standard deviation shown graphs tails distributions omitted clarity sec sec std sec ount node set-up message cost figure memory system characteristics figures show memory system characteristics origin machines mhz mhz processors origin mhz stride origin mhz stride mhz system one-way latency achieves maximum bandwidth sec message size mhz system figure one-way latency obtains maximum bandwidth sec message size nas benchmarks performance figure shows speedup nas benchmarks older origin single processor performance benchmarks newer origin increased improvement observed benchmarks improvement larger configurations runtimes processor higher mhz system benchmarks roughly speedup speedup benchmarks drops efficiency super-linear efficiency sensitivity workload measurements present paper dedicated environment program run time origin machine meant running odd hours load low found time-sharing workloads sec sec figure mpi performance figures show mpi point-to-point performance mhz origin system dongarra echo test mpione-waylatency mhz system message size bytes mpione-waybandwidth mhz system message size bytes origin speedup mhz system machinesize processors spe dup ideal figure nas benchmarks performance mhz origin machine figure shows speedup nas benchmarks origin mhz machine execution time benchmarks significantly higher multi-workload environment dedicated environment average runtime benchmark -processor seconds average runtime benchmark -processor seconds dedicated mode benchmarks run processors execution time benchmarks increases seconds seconds execution time profile shows communication time increase 
average seconds processor communication time increases factor unexpected results suggest communication benchmarks interfere leads higher synchronization cost conclusion detailed analysis architectural requirements nas benchmarks shows benchmarks perform non-trivial amount communication scalable communication system principle handle communication load dominant factor base performance scalability sequential node architecture including cpu caches local memory system important node architecture interacts application requirements cps scaling communication found applications carefully designed perform coarsegrained communication efficiency communication lower expected interestingly origin spite availability fine-grained shared memory data transport achieves fairly low communication efficiency cases spending time communication cluster result work word caution common assumptions machine architecture scalability tempted judge communication ability machine based speedup nas benchmarks good speedup implies good communication conversely poor speedup implies poor communication nas benchmarks necessarily defined scalability communication system origin superlinear speedups poor communication scalability examine computation communication scaling parallel machine order judge machine effectiveness areas understanding scaling performance characteristics large parallel machines difficult problem nas parallel benchmarks critical step goal providing set common benchmarks comparison platforms current output benchmarks execution time scaling plotted time speedup efficiency reveal complexities benchmarks processor counts lightweight instrumentation added standard mpi libraries minimally report time spent computation versus communication simple breakdown give users insight nature processorversus networkperformancefora machine acknowledgments william saphir ernest orlando lawrence berkeley national laboratory mary hultquist nasa ames research center obtaining account origin numerical aerospace simulation facility nasa ames research center dan lenoski sgi mark straka ncsa helping understanding issues performance counters finally shirley chiu alan mainwaring david helpful comments discussions work research supported part darpa nsf cda doe asci djb california micro program agarwal horowitz hennessy analytical cache model acm trans comp sys vol anderson culler patterson team case networks workstations ieee micro february david bailey harris rob van der wigngaart william saphir alex woo maurice yarrow nas parallel benchmarks technical report nas- nasa ames research center nanette boden danny cohen robert felderman alan kulawik charles seitz jakov seizovic wen-king myrinet gigabet-per-second local-area network ieee micro volume number feb bob cmelik doug keppel shade fast instruction-set simulator execution profiling proceedings signetrics leonardo dagum david bailey eric barszcz horst simon nas parallel benchmarks results technical report rnr- nasa ames research center dongarra dunnigan message passing performance computers tennessee technical report cs- von eicken culler goldstein schauser active messages mechanism integrated communication computation proceedings international symposium computer architecture gold coast qld australia gropp lusk doss skjellum high-performance portable implementation mpi message passing drawellipse interface cols standard polyline parallel computing cols polyline september mark hill dinero cols cache ellipse simulator aug http drawellipse wisc cols larus warts times-roman html findfont mainwaring scalefont active message setfont application programming interface colshow communication ellipse subsystem organization drawellipse california cols berkeley computer times-roman science department findfont scalefont technical report setfont ucb csd- colshow october richard ellipse martin amin vahdat drawellipse david cols culler thomas anderson effects latency overhead bandwidth cluster times-roman architecture proceedings findfont scalefont setfont international symposium computer colshow architecture ellipse june message passing interface drawellipse forum cols mpi times-roman message passing findfont interface scalefont standard setfont technical report colshow tennessee ellipse knoxville april nasa drawellipse ames research cols center times-roman npb detailed findfont scalefont results http setfont science nas nasa gov software colshow npb npb times-roman results findfont steven scalefont reinhardt setfont mark hill colshow ellipse james larus alvin drawellipse lebeck cols james lewis times-roman david findfont wood scalefont wisconsin setfont wind tunnel virtual web prototyping colshow parallel times-roman computers findfont scalefont sigmetrics setfont edward rothberg jaswinder colshow pal singh ellipse anoop gupta working drawellipse sets cache cols sizes node times-roman granularity findfont issues scalefont large scale setfont multiprocessors proceedings colshow ellipse international symposium computer drawellipse architecture cols pages times-roman findfont saavedra-barrera scalefont cpu setfont performance evaluation execution time colshow prediction polyline narrow spectrum benchmarking thesis arcto pop berkeley technical report repeat ucb arcto csd pop february william repeat saphir arcto alex pop woo maurice repeat yarrow nas arcto parallel pop repeat benchmark clp results technical cols report polyline nas- nasa ames research arcto pop center elisabeth wechsler nas repeat parallel arcto pop benchmarks set industry repeat standard arcto mpp pop performance nas news repeat jan arcto feb pop volume repeat clp number http cols science nas polyline nasa gov pubs nanews benchmark arcto pop html steven cameron woo repeat moriwoshi arcto ohara pop evan torrie jaswinder repeat pal arcto singh pop anoop gupta repeat arcto splashprograms pop characterization repeat clp methodological cols considerations polyline proceedings international arcto pop symposium computer repeat architecture pages arcto pop june maurice repeat yarrow arcto pop rob repeat arcto pop repeat clp cols times-roman findfont van scalefont der setfont wijngaart communication improvement colshow open nas spline parallel benchmark model efficient parallel relaxation schemes technical report nas- drawsplinesection nasa ames research cols center november 
clp setgray cols open spline drawsplinesection cols clp setgray cols open spline drawsplinesection cols clp setgray cols open spline drawsplinesection cols clp setgray cols open spline cols clp setgray cols open spline cols clp setgray cols open spline drawsplinesection cols clp setgray cols open spline drawsplinesection cols clp setgray cols times-roman findfont scalefont setfont tcp traffic colshow times-roman findfont scalefont setfont tcp traffic colshow times-roman findfont scalefont setfont tcp traffic colshow times-roman findfont scalefont setfont external http requests colshow psend restore enddocument endtexfig starttexfig begindocument figures workload oracle eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale clp closepath bind eofill bind grestore bind gsave bind lineto bind moveto bind newpath bind stroke bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix drawsplinesection exch exch exch exch exch exch mul add mul add mul add mul add lineto curveto psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit slw polyline clp col times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow ellipse drawellipse cols times-roman findfont scalefont setfont colshow ellipse drawellipse cols times-roman findfont scalefont setfont colshow ellipse drawellipse cols times-roman findfont scalefont setfont colshow ellipse drawellipse cols times-roman findfont scalefont setfont colshow ellipse drawellipse cols ellipse drawellipse cols polyline cols polyline cols ellipse drawellipse cols times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont database colshow ellipse drawellipse cols times-roman findfont scalefont setfont colshow ellipse drawellipse cols times-roman findfont scalefont setfont colshow ellipse drawellipse cols times-roman findfont scalefont setfont colshow polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont colshow open spline drawsplinesection cols clp setgray cols open spline drawsplinesection cols clp setgray cols open spline drawsplinesection cols clp setgray cols open spline drawsplinesection cols clp setgray cols open spline drawsplinesection cols clp setgray cols open spline drawsplinesection cols clp setgray cols times-roman findfont scalefont setfont transactions colshow times-roman findfont scalefont setfont transactions colshow times-roman findfont scalefont setfont transactions colshow psend restore enddocument endtexfig figure orkload setup upper -left diagram sho xperimental setup make workload note workstation processors circled symbol parallel make started remotely ecutes jobs workstations disk solaris source tree attached upper -right diagram depicts web workload setup xternal http requests streaming raf distrib uted machines round-robin fashion responses proceed back source disk requested attached wer diagram sho database workload setup disk attached xperiment machines perform transactions time period eop page bop chapter orkload characterization 
process gathering workloads study distrib uted system important concentrate nding programs stress system services section characterize workloads dri study sho make operating system services present erall performance workloads insight nature workloads breakdo wns cpu usage measures system system calls conte switches erall erf ormance section sho workloads perform tracing acti ated run time rate operation workloads run-time workloads chosen xperimenter run-time make workloads determined amount work rate make eals number compilations case web workload xternal clients perform http operations fetch speci rate measures number http operations database workload clients system perform simple debit credit operations due gal issues rate workload ealed prototype system performance system spectacular tuned performance section main reason workloads run minute period eop page bop orkload ime rate make mins secs compiles sec web mins secs http ops sec database mins secs benc hmark erformance total performance time rate benchmark cpu utilization figure sho cpu utilization workload lifetime xperiment collect data user -le daemon wakens ery collects statistics cpu usage consists distinct parts user percent time spent running program system percent time spent operating system wait percent time spent waiting disk return idle remaining dif ference note graphs cumulati system line sum system user time starttexfig begindocument figures cpu make eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate cpu percentage cshow grestore time seconds cshow cpu profile make cshow ltb wait rshow ltb system rshow ltb user rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures cpu eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate cpu percentage cshow grestore time seconds cshow cpu profile cshow ltb wait rshow ltb system rshow ltb user rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures cpu oracle eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate cpu percentage cshow grestore time seconds cshow cpu profile database cshow ltb wait rshow ltb system rshow ltb user rshow stroke grestore end showpage enddocument endtexfig figure cumulative cpu utilization cumulati cpu utilization split user system wait time displayed time workload rest idle maximum cpu percentage moment cpus peak utilization note graphs cumulati system time sum system user time wait time sum white space top-most line wait time idle time make workload utilization time rst make runs sequential portion utilization rst seconds roughly processors worth cpu parallel portion gins relati ely constant utilization processors spikes peak finally make ends long link phase roughly seconds erage workload spends time user mode time system mode total cpu usage eop page bop starttexfig begindocument figures cpuindiv make eps gnudict dict gnudict begin color false solid true 
gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow abstract effective distributed rshow scheduling parallel workloads appeared rshow sigmetrics andrea dusseau remzi rshow arpaci david culler present rshow distributed algorithm time-sharing parallel workloads rshow competitive coscheduling mbox rshow implicit mbox scheduling local scheduler rshow system make independent decisions cshow dynamically coordinate scheduling cooperating processes cshow processors importance blocking algorithm cshow decides action cshow process waiting communication synchronization event cshow complete simulation bulk-synchronous parallel cshow applications find simple two-phase fixed-spin cshow blocking algorithm performs two-phase adaptive algorithm cshow gathers run-time data barrier wait-times performs slightly results currentpoint hold gsave range translate machine rotate parameters machine parallel cpu program number characteristics cshow findings grestore direct time contrast seconds literature states explicit coscheduling fine-grained programs show choice local scheduler crucial priority-based scheduler performing times round-robin scheduler find cshow performance implicit individual scheduling cpu traces make coscheduling cshow requirement explicit global coordination full paper postscript compressed postscript 
currentpoint stroke eel oju sqyy cya nkq uia rqd wju csmdh tks tod swb imf adi nzc tdf -bh mwu jxdi eul bbb mla koj tdy zve gsf ytt xgzr xlb ujq eby kjc xprd sxc mxy mlpr mmqzi kuqf wueob zbh fezd tgo sor mvt qti fzp jee sebh odx nhm nfs tzes cfk adh pjl dkn dba kbx tdg oorfv uxi pmu rza fxz iax fvx vklp mpyj xds mvq hep wkdt xpd gwjy gge gxe zjczbk iim sok ncli dqy apjd vpdv glj fke cse gji qil lgk nlr avv cbk ugl tdv yrpk wic lml wki currentpoint stroke stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures cpuindiv eps gnudict dict gnudict begin color false solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate machine cpu number cshow grestore time seconds cshow individual cpu traces cshow currentpoint stroke cxj czu jt-pt stroke grestore end showpage enddocument rav endtexfig starttexfig begindocument figures cpuindiv oracle eps gnudict dict gnudict dvi begin color false solid true gnulinewidth vshift pii mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt lgx vpt mul hpt hpt mul mfs lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div jxje setlinewidth stroke gnulinewidth setlinewidth ltb lta van pjx setdash setrgbcolor t-b gnu jlc vtv cyi khq tfw uaj utf aze stroke setdash currentlinewidth yrv div kjn currentlinewidth stroke stroke setdash copy vpt add hpt bpgq neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt qki vpt currentpoint stroke hpt neg vpt neg hpt stroke wpe stroke setdash copy kfm exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke tdk stroke setdash exch hpt exch vpt add hpt vjg vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt gfoypf mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate machine cpu number cshow grestore time seconds cshow individual cpu traces database cshow high-performance sorting networks workstations andrea arpaci-dusseau computer science division california berkeley dusseau berkeley remzi arpaci-dusseau computer science division california berkeley remzi berkeley david culler computer science division california berkeley culler berkeley joseph hellerstein computer science division california berkeley jmh berkeley david patterson computer science division california berkeley patterson berkeley report performance now-sort collection sorting implementations network workstations find parallel sorting competitive sorting large-scale smps traditionally held performance records -node cluster sort minute -node cluster finishes datamation benchmark seconds implementations applied variety disk memory processor configurations highlight salient issues tuning component system evaluate commodity operating systems hardware parallel sorting find existing primitives memory management file access adequate due aggregate communication disk bandwidth requirements bottleneck system workstation bus past years dramatic improvements speed sorting algorithms largely due increased attention issues computer architecture sorting results date produced industrial researchers working expensive well-endowed versions shared-memory parallel computers smps produced parent companies paper describe achieved records sorting performance modest shared-nothing network general-purpose unix workstations set minutesort record bytes -node cluster ultrasparcs datamation benchmark record seconds -node cluster network workstations sorting number benefits nows provide high-degree performance isolation analysis behavior node-by-node factor-by-factor basis contrast smp resources pooled difficult achieve equivalent fine-grained analysis tuning single-processor performance carefully deliver roughly disk bandwidth -processor sorting application nows provide incremental scalability currentpoint hardware stroke resources additional workstations added well-tuned programs easily scaled large configurations contrast smps hard limit scalability imposed size box expensive complex scale stroke grestore end limit showpage enddocument paper note endtexfig lessons figure research community individual cpu made utilization largely researchers cpu operating utilization systems computer sum user architecture system time principle nows similar time shared-nothing displayed architectures cpu databases cluster ohf g-s aar cm-f cvoi avd bjs yfh efer omek vfi qho bko zmr rwg hzkx evs kyaje sax jdn gkg cod typically analyzed tuned context computeintensive applications demonstrate nows state-of-the-art platform data-intensive applications ease assembling configurations motivated investigate family solutions sorting single algorithm tuned machine investigation exposes range options overlapping steps sorting algorithm implications develop tools characterize existing hardware explore relationship parallelism bandwidth constraints characterize number tradeoffs pipelining costs memory utilization additional contribution work evaluate commodity software hardware sorting extension database applications find threads current interface memory management modern unix operating systems developing efficient implementations cheering update wellknown criticisms earlier versions unix database applications hand demonstrate important facilities missing modern workstations -js dlo handling data striped heterogeneous disks determining memory machine architecture find clustered ultrasparc workstations limited insufficient jtk bus bandwidth jgqh left unimproved prevent data-intensive applications enjoying future gains cpu memory network disk speed organization paper matches development sorting implementations briefly reviewing related work cprtw section experimental platform section cover fos versions now-sort sections figure depicts derivation ojv sorting algorithms one-pass rqk parallel two-pass pyo ony cga oea jxrb v-l dse zgt parallel section section section section one-pass single-node two-pass single-node figure development sorting algorithm sections paper follow development progression sorting algorithms rbs simplest complex complex versions build simpler show understanding tuning application performance qbh simple configurations build highly-scalable parallel versions effort datamation benchmark time one-pass kqh parallel version section kms minutesort results two-pass parallel sort pfx section present conclusions section datamation sorting benchmark introduced group database experts test processor subsystem operating system performance metric benchmark elapsed time sort million moj nsk records disk disk records begin disk -bytes lkn -bytes key million -byte records data read written disk elapsed time includes umi awd mye los jwgv fbn jve dnyl swz hws ksw eygo sdt mmq ajv snw gewk frb -tk pww eyfs qhp wkd gaa ijo xyo lxr xxp zyt nio izv wdh jygd lavogs ggg wxm cbgm hkx fsa azp gqp fab eqi htl gcz zvot obrn vrj iqb ahk prpyl time launch application open create close files ensure output resides disk terminate cpgs program priceperformance hardware software computed pro-rating five-year cost time sort previous record-holder benchmark xtr processor sgi challenge disks main memory seconds single processor ibm ach disks memory qmr mur impressive time seconds price performance raw ia-y disk allowed vbi benchmark uzg recognizing datamation benchmark outdated test startup shutdown time performance uas authors alphasort introduced minutesort key record specifications identical datamation performance metric amount data sorted minute elapsed time priceperformance calculated list price hardware operating system depreciated years sgi system previous record-holder minutesort benchmark sorting alphasort achieved processors disks memory price performance years numerous authors reported performance sorting algorithms implementations leverage implementation algorithmic lessons describe difference work provide measurements range system configurations varying number processors number disks machine amount memory difference environment parallel configurations node complete system virtual memory system disks file system cluster environments form experimental testbed consists commodity ultrasparc workstations memory measurements extend nodes due time constraints workstation houses internal rpm seagate hawk disks single fast-narrow scsi bus note disks machine afford dedicate spare disk paging activity ultra enterprise model rpm disk main memory internal rpm seagate hawk external rpm seagate barracuda enclosure external disks fast-wide scsi card myrinet card myrinet f-sw switch -node system rpm disks rpm disks scsi cards disk enclosures myrinet cards switch -node system rpm disks myrinet cards switches table hardware list prices october list prices cluster connects fully-equipped ultrasparc model workstations main memory extra fast-wide scsi card rpm seagate barracuda external disks attached cluster eighth processors configuration quarter number disks amount memory main lesson taught authors alphasort large sorting problems performed single pass half amount disk performed price memory low previous recordholders datamation minutesort benchmarks sort records single-pass configuration memory-starved perform minutesort benchmark passes addition usual connection world ethernet workstation single myrinet network card myrinet switch-based high-speed localarea network links capable bi-directional transfer rates myrinet switch ports -node cluster constructed connecting switches -ary tree machine cluster runs solaris modern multithreaded version unix disparate resources cluster unified glunix prototype distributed operating system glunix monitors nodes system load-balancing co-schedule parallel programs full job control redirection experiments primarily glunix parallel program launcher parallel versions now-sort written splitc split-c parallel extension supports efficient access global address space distributed memory machines split-c built top active messages communication layer designed advantage low latency high bandwidth switch-based networks active message essentially restricted lightweight version remote procedure call process sends active message specifies handler executed remote node message received handler executes atomically respect message arrivals active messages myrinet performance characteristics round-trip latency roughly layer sustain uni-directional bandwidth node sending receiving study make number simplifying assumptions distribution key values layout records processors disks allowing focus architectural issues involved sorting implementations sorting data sets real world robust precedent set researchers measure performance now-sort key values uniform distributions assumption implications method distributing keys local buckets processing nodes non-uniform distribution modify implementations perform sample sort adding early phase sample data determine range keys targeted processor ensure processor receives similar amount records plan investigating future assume initial number records workstation equal performance parallel implementations greatly affected small imbalances records located subset workstations current 
read phase utilize processors attached disks severe performance implications restructuring algorithms deal situation scope paper section describe basic one-pass version nowsort single workstation records fit main memory read disk discuss impact interfaces performing disk buffer management in-memory sorting algorithm figure one-pass single-node version forms basis sorting algorithms components single-node sort sorts worth understanding tuning detail highest level one-pass single-node sort steps detail shortly read read -byte records disk main memory keys partially sorted simultaneously distributing buckets sort sort -byte keys memory keys buckets bucket sorted individually quicksort partial-radix sort cleanup write gather write sorted records disk implementation steps overlapped synchronous investigate benefits overlapping sorting reading copying keys bucketswhile reading majority execution time spent phases performing begin describing approach reading disk now-sort work variety cluster configurations differing numbers disks amounts memory order application configure performance environment gather relevant information provide software exist stripe files multiple local disks speeds fully utilize aggregate bandwidth multiple disks machine implemented user-level library file striping top local solaris file system building top raw disk similar approachdescribedin striped file characterized stripe definition file specifies size base stripe bytes names files disks stripe multiplicative factor associatedwith file disk determine proper ratio stripe sizes disks developeddiskconf tool list scsi buses list disks buses creates large data file disks reads file independently reads simultaneously files bus measuring achieved bandwidths determining bus saturated tool calculates multiplicative factor base stripe disk achieve maximum transfer rate tool performs analogous chore writes section disk configurations disks fast-narrow scsi bus additional disks fast-wide scsi verified striping library degrade achievable bandwidth disk table shows performance striped file system simple complex disk configurations rows rpm disks saturate fast-narrow scsi bus fast-narrow scsi bus peak bandwidth measure disks capable total potential performance lost due architectural oversight rows fast-wide scsi bus adequately handles faster disks finally rows show superiority diskconf configure striping library compared naively striping equal-sized blocks disks seagate disks scsi bus read write rpm hawk narrow rpm hawk narrow rpm barracuda wide rpm barracuda wide naive striping disk tool peak aggregate table bandwidths disk configurations read write columns show measuredbandwidth striping library rows give performance naive striping same-sized blocks disk disk tool peak aggregate calculated sum maximum bandwidths scsi buses speeds reading writing blocks data slower disk fast-narrow scsi fast-wide scsi achieve peak aggregate bandwidth disks depending system interface read data disk application effectively control memory usage prevent double-buffering operating system section compare approaches reading records disk read mmap mmap madvise demonstration purposes simple implementation sorting algorithm performs steps sequentially quicksorts keys memory left-most graph figure shows application read system call read records memory disk total sort time increasesseverely records sorted physical memory performance degradation occurs due thrashing virtual memory system read file system performs buffering user program unable control total amount memory avoid double-buffering read leveraging convenience file system investigate mmap interface applications memory mapped files opening desired file calling mmap bind file memory segment addressspace accessingthe memory region desired shown middle graph performance mmap degrades records due page replacement policy virtual memory subsystem lru replacement throws soon-to-be-needed sort-buffers read phase ensuing thrashing degrades performance fortunately mmap auxiliary system call madvise informs operating system intended access pattern region memory call madvise notifies kernel region accessed sequentially allowing fetch ahead current page throw pages accessed right-most graph figure shows mmap madvise sorting program linear performance roughly memory amount memory workstation determines number records sorted one-pass sort number records run multi-pass sort previous work addressed issue adapting sorting algorithms memory constraints run-time amount free memory sorting application existing solaris interface accurate estimate developed memconf memory tool allocates buffer fetches main memory methods writing arbitrary word page copying words memory-mapped sequentially-advised input file prefetching tool touches page buffer recording cpu utilization buffer fits main memory cpu utilization high current definition larger buffer buffer fit cpu utilization low due paging activity tool backs smaller buffer binary search refine estimate usable memory running basic version memconf showed machines real memory user applications operating system daemon processes factored applications mmap madvise now-sort approximately memory finally verified predictions memory matched number records sort memory thrashing sharp increase sort time occurs sort records fit memory conservative scale estimate memory predictions comfortable distance memory wall wasting memory section quantifies performance main-memory sorting techniques performed correctly in-core sort disk-to-disk single-node sort comprises small portion total execution time in-core sort consumes seconds required sort million records ibm disks total time section investigate programming complexity needed achieve range performance measuring in-core sorting algorithms quicksort in-core sort simple quicksort keys memory previous work swapping key pointer full record faster swapping entire -byte record qjj hod vbw saq tob hjs lwte axx ztvw ztk mmo kio biy jye hpa ulg mvn jdvd aaa xsh wwvo shnq upd qfsy dskq t-a axis sho cpu machines xample implies extra memory work required set pointers comparisons keys begin most-significant word examine remaining words previous identical top line left-side graph figure shows time incore quicksort function number keys system disks approximately seconds required read write million records quicksort execution time spent in-core sort bucket quicksort in-core sort performs quicksort keys distributed buckets keys buckets based hightime seconds size read total time write time sort time read time time seconds size mmap total time write time sort time read time time seconds size mmap madvise total time write time sort time read time figure read versus mmap graphs show cumulative numbers ultrasparc memory seagate rpm disk graphs show read mmap total sort time increases super-linearly nearing memory limits machine right-most graph shows memory mapping advising memory effectively order bits key placing keys bucket easily overlapped read phase due simple interface provided mmap degradation read bandwidth overlapping cpu underutilized implementation bucket significant -bits key removing topa -bits pointer full record common case -bits key examined ties keys occur random accesses memory number buckets determined run-time average number keys bucket fits second-level cache ultrasparc quicksort performed in-place partial key pointer requires bytes keys bucket note approach highly dependenton uniform distribution keys skewed distribution buckets keys fit cache degrading performance shown middle line figure performing quicksort buckets fit second-level cache faster quicksort memory approach total time sort million records spent in-core sort bucket partial-radix in-core sort performs partial-radix sort clean-up keys bucket suggested most-significant -bits key removing top -bits pointer 
full record bucket radix sort relies representation keys -bit numbers perform passes keys radix size examining total -bits refer partial-radix sort radix sort bits pass keys histogram constructed count digits histogram scanned lowest entry highest calculate rank key sorted-order finally keys permuted destinations rank histogram partial radix sort clean-up phase performed keys ties top bits bubble-sorted quicksort number buckets selected average number keys bucket fits secondlevel cache radix sort requires source destination buffer half keys fit cache compared quicksort keys bottom line left-side graph figure shows radix sort bucket greatly superior quicksort time seconds keys quicksort quicksort buckets radix buckets figure comparison in-core sorting algorithms graph compares sorting time quicksort keys memory quicksort independently bucket radix sort bucket graph cumulative total time sort million records spent in-core sort combination distributing keys buckets performing radix sort keys bucket worth added complexity note implemented optimizations found including restricting number buckets number tlb entries overlapping sorting writing small optimization clean-up phase significant gain methods summarize figure shows total time returned unix time command one-pass single-node version now-sort systems disks timing run flush file cache unmounting re-mounting striped disks expected drnu incore sorting time negligible configurations yxr compared time reading sqms writing records disk read bandwidth roughly balanced write bandwidth matches transfer times found disk configuration tool finally 
performance linear number records records fit main memory time seconds keys amout data datamation disks total write sort read time seconds keys amout data datamation disks total write sort read figure single-node single-pass sort time graphs cumulative time sort shown function number records graph left depicts system disks connected fast-narrow scsi bus graph system additional disks fast-wide scsi systems real memory optimizing single-node single-pass sort shed light number machine architecture operating system issues disk configuration tool shown ultrasparc internal fast-narrow scsi bus saturates rpm disk fast-wide scsi bus enabled achieve internal disks loss performance found striping disks bandwidths requires stripe sizes disks evaluation file system interfaces shown mmap simple efficient fine-grained access files mmap madvise interfaces copying keys buckets completely hidden disk transfer time obtaining performance read system call require programming complexity cost issuing read high users threads prefetch data large chunks file system buffering occurs withreadwastes inordinate amount memory acceptable data-intensive applications simple memory configuration tool application effectively determine memory memory tool discovered buffer requirements ofmmap roughly tax applied free memory interface gave programs accurate run-time estimate free memory preferable detailed intricacies single-node sorting records fit memory specifically disk striping memory management in-core sorting algorithm examine one-pass parallel sort issues arise communication added present performance datamation benchmark assuming records begin evenly distributed workstations numbered steps single-node sort extend naturally four-step parallel algorithm read processor reads records local disk main memory communicate key values examined records local remote buckets sort processor sorts local keys write processor gathers writes records local disk workstations memory-maps input files calculates processor remote bucket key current implementation determines destination processor simple bucket function top bits key copies key input file sendbuffer allocated destination processor approach bucketizing assumes key values uniform distribution specifics records send-buffer vary implementations detail message records arrives processor active message handler executed handler moves records sort-buffer copies partial keys pointers correct local buckets operations directly analogous distributing partial keys buckets single-node sort significant difference single-node version distributing records local buckets processor distributes records remote buckets computation naturally decoupled active messages sending processor determines destination processor owning range buckets receiving processor determines final bucket performing calculations identical single-node version message handler synchronizing processors ensure records received node performs incore sort records writes local portion local disk sort write steps identical single-node version end data sorted disks processors lowest-valued valued keys processor highest-valued keys processor note number records node approximately equal depends distribution key values simultaneously reading records local disk sending records processors potential overlap diskwait time network latency overlapping operations shared resources cpu narrow narrow wide hybrid time seconds disks synch interleaved threaded write sort distribute read figure comparison algorithms left-most bar group shows performance breakdown synchronous implementation middle-bar interleaved implementation right-most bar threaded version interleaved threaded versions read distribution time collapsed read category hybrid implementation reads fast-wide disks writes disks bus under-utilized subsection evaluate versions one-pass parallel sort vary degree overlap disk communication synchronous synchronous version processor reads communicates sorts writes overlap steps buffer records wherea expansion factor related distribution key values drawback straight-forward implementation requires memory records sorted buffer needed records read processor buffer needed records received implementation reserves extra buffer communication buffers requires extra synchronization processors iteration processor sends processor mod minimize contention sending complete buffer processor processors synchronize waiting records received steps continue records distributed interleaved process management network workstations process management network workstations remzi arpaci andrea dusseau amin vahdat premise study find schedule sequential jobs cluster workstations achieve end compiled suite types workloads emphasis cpu development interactive implementation performed alternates number reading sensitivity tests communicating workloads thread establish resource requirements send-buffer destination tests include run-times small workstation models effect current sharing implementation processor effect waiting flushing records file cache read runs records parallelism cost sendbuffer remote full execution alternating reading effect network sending over-utilization found advantage overlapping workloads cpu sensitive memory robust processor model distribution run key values compounding synchronousversion problem algorithm total ordering synchronizes set processors machines ensuring surprisingly records cpu-intensive workloads cpu received development beginning suffer in-core sharing sort cpu threaded final process implementation jobs overlaps utilize reading cpu interactive sending easily share resource effect file cache cleaning threads noticeable reader-thread reads workloads records development moves slowdown implication scheduling user job stream attention ran job important analysis workloads reveals local fair amount send-buffers parallelism users communicator-thread submit multiple sends jobs time throughput receives vastly increased running messages jobs workstations sets scheduling send-buffers policy exist unfair destination users reader finishes overcommitting filling buffers user cost set remote signals execution machines communicator today sends measured records seconds current found set measurements shown seconds figure found suffer negligable slowdown lastly disks node interleaved versions time seconds processors secs secs disks sort glunix disks sort glunix disks sort network over-utilized glunix disks workloads sort development glunix figure slowed scalability significantly one-passparallel suggest sort records scheduling policy processor monitor sorted network activity cluster source disks alter memory decisions based machine records current on-goings processor designed sorted disks typical workloads memory machine experiments single cpu dual workload threaded development outperform synchronous workload version interactive roughly workload threads perform workload slightly links give results stagger read experiments send sensitivity requests smoothly processor time model sensitivity disks sharing difference cpu workload synchronous overlapped parallelism versions sensitivity diminishes locality disks sensitivity system network algorithms perform over-utilization back identically interestingly selection guide interleaved 
versions read slower rate disks rpm disks reduction occurs ultrasparc bus bus saturated long theoretical peak find read disks simultaneously sending receiving approximately aggregate s-bus make good disks capable transferring s-bus sustain roughly aggregate due limited bandwidth s-bus found hybrid system performance interleaving reading communication hybrid system reads disks fast-wide bus writes sigmetrics zmo znc kik xeozja tui uou poyc h-g uqs jjz ndn lnb fow uyk rtuw wxi dmh bzt egi krq lmc ddjvo seb -gm cax ele oqk xmcr pce hlk ncyh mya pia xym qyx fof phv ckj gfd pwf anubd abstract interaction parallel sequential workloads network workstations appeared sigmetrics remzi arpaci andrea dusseau amin vahdat lok liu thomas anderson david patterson paper examines plausibility network workstations mixture parallel sequential jobs simulations study examines issues arise jga combining workloads single platform starting dedicated parallel programs incrementally relax uniprogramming restrictions multi-programmed multi-user interactive sequential users parallel programs show number issues distributed environment daemon activity coscheduling skew small noticeable effect parallel program performance find efficient migration idle workstations maintain acceptable parallel application performance present methodology deriving optimal delay time recruiting idle machines parallel programs recruitment threshold minutes research cluster measured finally quantify effects additional parallel load interactive users keeping track potential number user delays simulations limit maximum number delays user maintain acceptable parallel program performance summary find workloads rule applies cluster approximately machines sustain -node parallel workload addition sequential load interactive users full paper postscript compressed postscript 
nfr unf jynz lhbooyt mem zysi lxb khr karwl xld vmie asq dq-o axm hjl nms qrl snsh pcl shj dir zvi xbb lqe buq vzt soj gqf ctwk rmz fph wkq jcs cws eawaq sxq tom bouc wvg ifea ssdh mpv wsx gxf kkc ysf bnv bvs kio fai gxir dmr vsq vba onh jlf apv wva ezx vow uyd weq pkq wfc xpo iyx qhmw gph wmk pfmv cjm iyr rtam wtpz ajp unl jpn bpcg hbc girm hau xut jjp uwqxz kmmry udl uwqxz tvx qii wjz qii cgu cgyx gydmj dan ctr ctr qpb gkei kpv aol asq skg qii cym uus dub nuq qer vum tkj kpd cjm iyr rtam wtpz ajp unl jpn bpcg hbc girm hau xut jrn iih zyd rig enmiqq cyxhr mne yhrj eyy mne ctr jzyg -gk rzia niwd mne mfw ctr aze -tn ctr nhyd mlea rya tew zga qii jnyg rnpv ekmipq ude edz ynz wupa fui qms jrd edn efw txd fau dya xcg cqb uhj setk ybz cel etl frpf rlz sre nhn cqx l-r ipq xan wsu jpr mfd hsa drh dkm drm jsio fjx lwd vdh cbeaw zqph hzz nqj yhgc hvi rrq uph qzz cji vrj aguu jvv ouaqdq qxh olfu qew jydg ndr utd bfu asi hhd jdac fmyr eyy quv yde uvq hxpg nzn vfy kum sx-d gui zia pzd crq wgoxy nvx dea jih cpoz mnv inx atj xoz bri jmr dbhq ps-adobecreator dvips copyright radical eye software title sigmetrics dvi pages pageorder ascend boundingbox endcomments dvipscommandline dvips sigmetricspreprint fhh sigmetrics dvipsparameters dpi comments removed dvipssource tex dhy output beginprocset tex pro texdict dict texdict begin bind exch translate isls false vsize mul hsize mul landplus false rigin isls landplus ifelse concat resolution div zjdf vresolution div neg scale isls landplus jvbz vresolution div vsize mul exch resolution div hsize mul ifelse bus resolution hey vresolution vsize div add mul matrix currentmatrix dup dup round osn abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding end dup foo setfont ahd array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop dup definefont setfont mkd ch-width ch-data dup length ch-height ch-data dup length ch-xoff ch-data dup length ch-yoff ch-data dup length ch-dx ch-data dup length ch-image ch-data dup type stringtype eyu ctr ctr ctr add charbuilder save roll qct dup base index bitmaps ch-data pop ctr ch-dx ch-xoff ch-yoff ch-height ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true ch-xoff ch-yoff ch-image imagemask restore dup type stringtype base hxpg ctr put bitmaps ctr dup dup length dup index div put put ctr ctr add nzn add bop userdict bop-hook bop-hook save vfy rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore showpage userdict eop-hook eop-hook start userdict start-hook start-hook pop vresolution resolution div dvimag array sx-d string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display gui exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail rmoveto gox rmoveto roll bos save eos restore end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ohd ang clip rwiseen false rhiseen false letter note legal scaleunit ohp hscale scaleunit div hsc vscale scaleunit div nybl vsc hsize clip vsize clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly pdz urx urx rrz ury ury magscale true end macsetup userdict userdict type dicttype userdict begin length arhm add qnb maxlength dup length add dict ebi copy end begin letter note legal txpose mtx defaultmatrix dtransform xsg atan newpath clippath mark transform itransform moveto yoy transform itransform lineto hkn roll transform roll transform roll transform itransform gxp roll itransform roll l-rc itransform roll curveto closepath pathforall newpath counttomark array hri astore xdf pop put courier fnt invertflag paintblack txpose pxs pys scale ppr aload pop por noflips pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip l-rc yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate hqb scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage copypage macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse clip newpath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath clip showpage erasepage copypage newpath endspecial count ocount pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset texdict begin home barad-dur grad remzi papers sigmetrics final sigmetrics dvi start end endprolog beginsetup feature resolution dpi texdict begin endsetup page bop teraction arallel sequen tial orkloads net ork orkstations remzi arpaci andrea dusseau amin ahdat lok liu thomas anderson vid atterson computer science division univ ersit california berk eley berk eley abstract pap examines plausibilit net ork orkstations mixture parallel sequen tial jobs sim ulations study examines issues arise bining orkloads single platform start- ing dedicated parallel programs in- cremen tally relax uniprogram ing restrictions til ulti-progra ulti-user oth teractiv sequen- tial users parallel programs sho issues asso ciated distributed vironmen daemon activit cosc heduling small noticeable ef- fect parallel program erforman cien migration idle orkstations main tain accept- parallel application erformance urthermore presen metho dology deriving optimal dela time recruiting idle mac hines parallel programs cruitment thr eshold min utes researc cluster measured finally quan tify ects additional parallel load in- teractiv users eeping trac oten tial user delays sim ulations limit maxim dela user main tain acceptable parallel pro- gram erformanc summary orkloads rule applies cluster appro ximat ely mac hines sustain -no parallel orkload addition sequen tial load teractiv users intro duction exploiting idle resources net ork orkstations een 
opular topic man ears researc orts aimed idle cycles sequen tial load sharing theimer douglis ousterhout pro duction load sharing systems mutk livn zhou widely ailable large sun microsystems dream delisle cluster dedicated orkstations run man inde- enden sim ulations ork supp orted part adv anced researc pro jects agency -co national science oundation california micr oundation digital equip- men corp oration hewlett ard tel siemens corp oration sun microsystems synoptics thinking mac hines xero corp ora- tion anderson supp orted national science ounda- tion presiden tial acult ello wship authors reac hed remzi dusseau ahdat ltli tea patterson berk eley app ear sigmetrics perf ormance long een widespread terest parallel computing gelern ter kronen erg carriero gelern ter sunderam blumric reinhardt ears massiv ely parallel pro cessors mpps ecome alik mpps pro cessors memory erating systems found orkstations started switc hes cal-area net orks lans similar mpp-st yle nety orks anderson den mpps tak adv tage orkstation pricey erformance curv disparit een lan mpp net ork erformance eing addressed recen lan dev elopmen oth sequen tial load sharing parallel proy cessing een attempted ariet systems comy bining single platform largely goal researc build runs parallel programs erformance dedicated mpp runs sequen tial programs erformance equiv alen dedicated unipro cessor pap quan titay tiv ely examine impact mixing parallel sequen tial orkloads emplo oth trace-driv direct sim ulation aluate impact sequen tial pary allel jobs starting dediy cated parallel programs incremen tally rey lax restrictions til ultiprogrammed uly tiuser oth teractiv sequen tial users pary allel programs eac step path cus measuremen answ olicy questions sev eral asp ects system bining sequen tial parallel orkloads tro duces set resource managemen olicy cony cerns pro vide desktop erformance equiv alen dedy icated unipro cessor assume system ust deliv equiv alen dedicated orkstation eac activ user happ ens issue distributed load balancing system man users ould erio dical tap eyb oards prev orkstation eing harv ested sysy tem parallel programmers idle orkstay tions ust receiv guaran tees predictable erformance similar smaller dedicated mpp orkstation cluster sho relativ ely simple tec niques main tain oth teractiv resp onse times parallel program throughput results con tuition literature demonstrates crucial cosc hedule paraly lel programs hiev acceptable erformance ousterhout eop page bop gupta sho requiremen holds true quan tifying impact cosc heduling results run coun ter opular opinion set idle mac hines hanges time to- tal numb idle mac hines sta relativ ely constan traces busiest time ork-da con- sequen tly relativ ely simple heduling olicies mac hine running program idle activ idle mac hine lik ely ailable running dislo cated pro cess measuring mac hine ailabil target cluster quan tify cien pro write phase profits disks concurrent communication bus devoted solely disk activity threaded parallel sort equals outperforms implementations focus exclusively remainder experiments one-pass parallel now-sort perfectly scalable number processors increased number records processor constant shown figure words sort keys amount time simply doubling number processors slight increase time due overhead glunix distributed 
operation system remote process start-up increases processors taking approximately seconds nodes seconds performance datamation benchmark shown figure processor sorts equal portion million records processors added time seconds processors sgi record disks sort glunix disks sort glunix disks sort glunix disks sort glunix figure performance datamation benchmark graph shows time sort million records disks processorand disks processor data points shown million records fit memory node sorts fewer records resulting small problem sizes remote process start-up significant portion total sorting time fact processors total time equally divided process start-up application function lack maturity cluster fundamental costs distributed operating system focus optimization interestingly process start-up time-consuming smps bzero ing address-space significant dominant cost onepass external sorts smp parallelize process nows aspect process creation problem local address space initialized parallel parallel single-pass sort revealed o-system bottleneck ultrasparc architecture s-bus s-bus achieve workstation effectively disks simultaneously communicating network remain viable alternative smps ultrasparc bandwidth improve dramatically radically provide communication memory bus coherence corollary suggests system disks fast-wide scsi bus sweet-spot cost performance curve conclusion found developing parallel single-pass sort natural extension single-node version lessons previous section disk striping memory management in-core sorting directly applicable environment isolate performance effects per-processor basis difference single-node version additional communication traffic s-bus contrast smp system pooling resources obscures type analysis finally active message interface provided high bandwidth low overhead communication facilitated algorithm differed slightly single-nodeversion copyingkeys local buckets processor copies keys buckets spread processors one-pass versions now-sort detail extensions needed single-node insufficient memory passes made records section memory configuration tool determine amount memory choose one-pass two-pass algorithms create runs one-pass sort read sort write repeated create multiple sorted runs disk merge phase sorted runs merged single sorted file create sorted runs phase threads created reader-thread writer-thread memory divided buffers equals depending reader writer synchronous overlapped discussed section run containsa records requiring runs number records reader copies records disk moves keys pointers buckets signals buffer full reader free fill empty buffer run writer waits buffer filled sorts bucket writes records disk signals buffer empty process repeated runs sorted written disk separate files merge sorted runs phase multiple runs merged single output file implementation threads reader merger writer readerthread memory-maps thea run files reads chunk records run sets merge buffers depending reading merging synchronous overlapped discussed section prefetching records large chunks amortizes seek time runs obtains read bandwidths sequential accesses reading thea buffers reader signals merger buffers full continues prefetch set empty merge buffers merger selects lowest-valued key top run copies record write buffer write buffer full writer signaled writes records disk note merge phase instance found simple implementation usingmmap andmadvise attain sequential disk performance accessing multiple read streams disk mmap prefetch data sufficiently large blocks amortize seek costs merge phase explicitly manage prefetching multiple threads buffers phases reading disk overlapped writing computation one-pass parallel sort overlapping phases pipelining beneficial resources cpu bus under-utilized overlapping additional implications layout records disks memory usage pipelining phase implies pipelining phases output phase input investigate impact run length layout records disks phases time seconds number runs run size create runs merge runs total time figure effect run size non-cumulative time phases two-phase sort shown total time keys ultrasparc memory disks creatingruns phaseone run fit memory merging runs phase number runs run length synchronous version phase memory create run generates half runs pipelined version runs adversely affect performance merge phase reading disk streams raise seek time hide prefetching large chunks number runs constrained exists sufficient memory prefetch buffers run merge phase disk layout synchronous pipelined versions manage layout records disks differently maintain sequential access disk dedicated reading writing time pipelined implementations reading writing times half disks reading half writing synchronous implementations utilize disks reading disks writing phases synchronous input file temporary sorted runs output file striped disks phases pipelined file striped half disks phase synchronous synchronous phase suffers half disks employed pipelined phase measurements two-disk four-disk systems reveal two-pass single-node version occurs phases pipelined pipelined merge phase exhibits dramatic improvement synchronous version effectively prefetches large chunks merge run hides cost seeking pipelined merge improves slightly phase synchronous fewer runs merge penalty phase executing synchronously writing half disks outweighs improvement pipelined algorithm length run impacts performance phase number runs impacts phase section determine compromise number runs lengths results good performance phases tension phases sorting fixed amount data changing number runs shown figure runs created time phase large size run greater amount memory memory manager pages data disk point run fits memory time phase continues drop slightly run size decreases due lower cost filling draining read write pipeline data run time writer wait reader read run decreases time writer write run decreases conversely number runs increases time phase increases merge phase reads records disk chunks amortize cost seeking independent runs creating similar startup effect start-up time increases number runs becausethe reader prefetches fixed chunk runs net result memory wall runs increasing number runs problem set effect performance slightly decreasing time generate runs increasing time merge runs runs performance degrades sharply merge time increasing percent behavior suspect related cache performance performance drop-off mirrored increase user-cpu time disk-wait time conclude summarizing minutesort performance two-pass single-node sort disks table time merge phase slightly larger time create runs records divided twelve runs concurs data figure results comparison case two-pass parallel sort section disks disks create merge total table single-node minutesort results amount data sorted minute single node shown ultrasparc disks memory versus disks memory corresponds records records section now-sort accurate estimate memory choose one-pass two-pass algorithm number records determine maximum run size two-pass algorithm examining two-pass single-node sort found pipelined versions phases performed synchronous implementations number disks found mmap madvise prefetch sufficiently large blocks amortize seek costs multiple streams forcing explicitly prefetching thread merge phase prefetching large blocks sequential performance maintained merge phase read runs greater number disks system finally observed importance carefully managing layout records disks dedicating half disks reading half writing disrupt sequential access pattern generated stream section describe two-pass parallel algorithm results minutesort benchmark final sorting algorithm extendsnaturally one-passparallel twopass single-node algorithms create runs processors create sorted runs nodes cluster 
runs created repeating read send sort write steps one-pass parallel sort merge processor merges local sorted runs single local file phase identical merge single-node previous section discussed creating multiple sorted runs processors phase opportunities overlap onepass parallel algorithm reading sending overlapped two-pass single-node sort reading writing overlapped two-pass parallel sort overlap pairs operations understand tradeoffs describe actions threads detail reader communicator writer read thread responsible mapping input file copyingkeys records per-destination send-buffers send-buffers fill reader signals communicator one-pass parallel sort reader communicator overlapped sets send buffers synchronous set signaled communicator-thread picks entire set send-buffers sends destination processor message arrives active message handler invoked copies records sort-buffer partial keys bucket communicator records current run processors synchronize wait receive records run received writer-thread signaled writer sorts keys bucket gathers writes records disk similar two-pass single-node sort reading run overlapped writing previous run overlapping implies sets sort-buffers buckets exist set consuming approximately half memory measurements number disks system determine operations overlapped disks implementation overlaps operations disks overlaps reading sending performs reading writing synchronously operations overlapped cpu saturated utilization performing read write operations synchronously minimizes cpu bus contention creating run time stripes input file disks creates runs merge phase amount sorted processors sgi record perfect scaling perfect scaling disks disks figure parallel minutesort results graph shows minutesort results cluster configurations -node cluster disks processor -node cluster disks processor perfect scaling relative single-node performance performance two-pass parallel now-sort minutesort benchmark shown figure machines disks machine implementation sorts minute experience large drop number keys sorted move single-node sort parallel version running processor reading writing performed synchronously overlapped compared parallel version processor algorithm scales perfectly linearly processors cluster disks machine parallel version sort machine sorts keys single-node algorithm implementations overlap phases processors sort data ties previous minutesort record fully-loaded sgi system processors disks memory processors sort seconds nodes sort seconds algorithm scale linearly number processors drop largely due start-up bottlenecks costing seconds nodes due relative dearth memory workstations minutesort two-pass algorithm cluster previous record-holding systems minutesort performed single pass sort data performing sgi xfs system amount time paper presented now-sort collection configurable sorting algorithms networks cess workstations migration shown nows non-dedicated well-suited vironmen o-intensive applications urther sorting cluster limiting environment ideal development efficient parallel times applications system year procs disks mem datamation minutesort time price perf cents data price perf dec alpha axp dec alpha axp dec alpha axp sgi challenge ibm users ultrasparc disco ultrasparc ultrasparc ultrasparc ideal ultrasparc table summary datamation minutesort results note price sgi challenge estimated ibm raw disk allowed datamation specification note bytes performance isolation monitoring behavior application node program-developer isolate performance bottlenecks clusters enable incremental scalability hardware processors disks memory added system effective parallel manner program work enabled key pieces software mac cluster hine active messages spread high-speed communication layer providing low orkload latency high enly throughput parallel mac hines programs key ell software component reduce glunix distributed operating orst-case system nows studying dela disk-to-disk sorting qualitatively quantitatively giv assessed sequen workstation tial operating system user machine architecture traces underlying goals project utilize existing rule commodity applies software hardware assumption cluster general-purpose workstations appro form solid ximately building blocks mac clusters hines connected easily high-speed sustain network paper -no demonstrated parallel strengths orkload weaknesses addition assumption sequen now-sort tial load important function operating system support efficient teractiv file access users find mmap pap madvise solaris organized fast finegrained follo access files section file describ system providing adequate metho prefetching dology buffer management section consumes memory describ older read interface incurs problems double-buffering asso problem ciated running programs parallel large jobs memory requirements distributed find mmap vi- madvise ronmen sufficient section reading adds consideration non-dedicated vironmen pro cessors running parallel job terrupted multiple independent time streams section merge phase quan two-pass sort needed ects multiple threads parallel manage prefetching orkload found existing solaris support teractiv memoryintensive users applications pap lacking key concludes areas efficiently related employing multiple ork disks differing speeds summary single workstation results straight-forward metho reasonable dology determine memory section application giv over-extend resources thrash erview solve problems developed exp small erimen configuration tal tools metho evaluates speed study disks system feeds complimen information tary yles striping library sim allowing ulation maximal emplo performance disks rst tool measures dir memory simulation node cluster tec hnique tools combine enable measures sorting application ects tune arious cluster attain peak efficiency found hedul- bus ing structure erturbations ultrasparc workstation real parallel inadequate support applications disk communication sorting e-driven found simulation disks terlea implementation synchronous traces reading writing oth superior pipelined paral- version lel surprised mac find hine machine disks net connection ork high-speed network orkstations effective building disco block adding disks leads impact benefit parallel program solutions throughput pending problem ell improved infrastructure oten bandwidth tial support disks ect network communication orkstation facilities users function memory utilizin bus oth coherence leaving sim disks ulation consume precious tec hniques bus bandwidth found hier internal chic fast-narrow scsi bus prevents full deling utilization bandwidth internal disks etter performance understand loss performance teraction system relative previous recordholders orkloads datamation minutesort benchmarks shown table direct best-performing simulation configuration processors sorts measure million records one-pass ects seconds disturbances real high cost parallel processor appli- system cations disks node direct slightly sim slower ulation seconds tec significantly hnique cost measures performance ibm run achieves time cost performance real parallel program results executing raw disk mas- allowed siv ely benchmark parallel specification mac minutesort results hine obtained arying machine parameters configurations suc memory required heduling two-pass external algorithms previous olicies record-holders contained teraction main memory sim hold ulated data performing paral- lel amount jobs teraction sort sim bytes ulated minute sequen processors tial jobs configuration sim disks ulation testb deliver roughly -no sorting thinking application mac previous hines minutessort recordholder cm- needed -disks message-passing mpp deliver leiserson price performance project start processorswith simple disks memory sim ulate fit records memory ter- sorting action one-pass sequen tial hardware applicatio obtain slightly running performance visit pro home page cessor find now-sort parallel project applicatio http berkeley runs pro cessors eri- now-sort dically combined effort terrupt members pro cessor berkeley force project execute richard idle martin implementing supporting split-c disturbance active app messages ears parallel pro- gram sequen tial program time-slice pro cessors measuring execution time par- allel application observ slo wdo induced sim ulated sequen tial applicatio exp erimen generate eac data oin times rep orting erage sim ulations messages whic arriv non- heduled pro cess ered small xed-size til target pro cess heduled curren tly del net ork memory tra congestion cac ects due time-slicing migh ect results found ect amortized longer time-slice comp osed suite parallel applicatio writy ten split-c culler direct sim ulation rst cholesky erforms factorization sparse symmetric matrices column implemen tation column-sort algorithm leigh ton description implemen tation found culler program sim ulates propagation electro-magnetic jects dimensions culler ersion sample sort algorithm blello implemen ted sample finally connect randomized algorithm connected comp nen arbitrary graph krishnam urth enc hmarks represen cross-section parallel application eren message sizes eren comm unication sync hronization frequencies ery age message size column ytes algorithms comm unicate small messages een bytes erage sorting algorithms column sample bulk-sync hronou alternating een computation comm unication phases eac order seconds sync hronizin een phases cholesky comm unicates medium gran ularit computing sev eral undred microseconds een myrinet work finished doug ghormley david petrou efforts making glunix fast reliable system members tertiary disk group lending barracuda disks ken lutz eric fraser making clusters working reality extend special jim gray iwe chris cpu nyberg utd web workload displays comments early signi drafts cantly dif helpful ferent conversationsabout beha sorting vior finally anonymous workload reviewers starts providing feedback work -second mark funded part ends darpa -cdarpa minutes -cnsf cda nasa fdnagwand california state micro program andrea arpacidusseau supported intel graduate fellowship quarters agm cpu utilized agarwal fmwf super scalar times sort algorithm risc run processors proceedings item acm sigmod interest conference pages dips june anderson graph culler patterson case seconds networks times workstations ieee micro transport layer feb lost arpaci message dusseau vahdat liu hiccup anderson sii patterson interaction parallel sequential workloads network workstations proceedings sigmetrics performance pages baru fecteau goyal hsiao huu jhnigran padmanabhan wilson overview message parallel times edition proceedings sigmod retransmitted international conference management mishap data san system jose continues basu slf buch web vogels workload von eicken oqt sensiti u-net user-level network interface type parallel distributed failure computing proceedings acm symposium stops cjl operating forwarding systems http principles copper requests mountain colorado nodes dec baugsto system greipsland kamerbeek nodes sorting large data files poma work proceedingsof comparvappiv time pages sept remain didml springer verlag idle lecture notes main point beck interest bitton lar wilkinson sorting large percentage files time backend spent multiprocessor technical report system department roughly computer science total cornell time mar non-idle time blelloch leiserson maggs comparison sorting algorithms connection machine cmin symposium parallel algorithms architectures july bmdu blumrich alpert dubnicki kbd felten sandberg virtual cfa memory mapped network interface shrimp multicomputer proceedings international symposium computer architecture pages finally apr tid boden gure cohen eals felderman kulawik database seitz myrinet gigabit-per-second workload local makes area network 
ery ldo cpu ieee micro ngw small feb fraction boral alexander prm utilized clay copeland spent prototyping bubba system highly time parallel database system total ieee time transactions knowledge data non-idle engineering time user mar time culler accounts dusseau goldstein krishnamurthy total lumetta time von eicken workload yelick parallel spends programming split-c time waiting supercomputing disk culler requests liu martin sho yoshikawa logp load performance assessment balanced fast network interfaces cluster ieee micro figure feb presents dewitt cpu utilization ghandeharizadeh schneider processor bricker gamma database set machine project graphs ieee transactions vie knowledge sum data zni user engineering system mar dewitt time naughton make schneider parallel ipt workload sorting shared-nothing architecture probabilistic load splitting fairly proceedings balanced international conference parallel nodes distributed information nish systmes dusseau sooner culler schauser note martin fast parallel sorting logp experience cmieee transactionson usiest parallel node distributed houses systems disk aug measure source tree transaction processing power located diagram datamation readings web database workload systems sho stonebraker morgan kaufmann san mateo xpk processors utilized benchmark note dips cpu graphs packet lost usy lastly gerber informix database online xps workload proceedings note sigmod relati international conference ely management data san constant jose cpu usage ghormley petrou machines vahdat uyv case anderson glunix global layer unix http usiest berkeley node glunix glunix due html graefe presence volcano extensible parallel disk dataflow query eop processing system page technical bop report oregon graudate center june starttexfig graefe parallel external begindocument sorting figures syscalls volcano make technical eps report gnudict dict cu-cscomputer gnudict science begin color false colorado solid boulder true june gnulinewidth hill vshift larus reinhardt mul hpt wood cooperative-shared vpt memory software moveto bind hardware lineto scalable bind multiprocessors acm rmoveto bind transactions computer rlineto bind vpt vpt systems mul hpt hpt mul hoare quicksort computer journal kleiman voll eykholt shivalingiah williams l-rc smith barton andg skinner isbj symmetric multiprocessing solaris proceedings rph compcon spring linoff smith stanfill sqh thearling practical lshow external sort currentpoint stroke shared disk vshift mpps show proceedings rshow currentpoint supercomputing stroke pages nov nyberg dup barclay stringwidth pop cvetanovic neg vshift gray show lomet cshow alphasort currentpoint risc stroke machine dup sort yqr stringwidth proceedings pop acm div sigmod vshift conference show color lri salzberg setrgbcolor solid tsukerman pop gray stewart setdash pop uren pop pop u-wx solid vaughna pop fastsort distributed setdash single-input ifelse single-output stroke external l-qc sort gnulinewidth sigmod mul setlinewidth record stroke june gnulinewidth div stonebraker setlinewidth operating system support stroke gnulinewidth database setlinewidth management ltb communications ohp lta acm july setdash stonebraker setrgbcolor case shared database engineering l-qc sweeney doucette anderson nishimoto peck scalability xfs file system proceedings dhy usenix annual technical conference jan tandem performance group ddy benchmark nonstop sql debit-credit transactions proceedings sigmod international conference managament data chicago june teradata corporation dbc data base computer system manual release edition nov document number von eicken culler goldstein stroke schauser setdash active currentlinewidth messages div mechanism integrated currentlinewidth communication stroke computation hqv stroke proceedingsof setdash copy annual vpt add symposium hpt computer neg vpt architecture neg gold hpt coast vpt australia neg hpt vpt young hpt neg vpt swami closepath parameterized stroke round-robin partitioned stroke algorithm setdash vpt parallel external vpt sort currentpoint proceedings stroke international parallel processing hpt neg symposium vpt neg pages hpt santa barbara stroke apr stroke zagha setdash copy blelloch exch hpt radix sort exch vpt vector add multiprocessors vpt ywc neg hpt supercomputing vpt zhang hpt larson neg closepath memory-adaptive sort stroke masort dwc database stroke lfm systems setdash exch proceedings hpt exch cascon vpt add toronto hpt nov 
vpt hmm neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash 
copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt nq-i mul closepath lsmc stroke copy end gnudict begin mwt gsave translate scale setgray helvetica findfont scalefont setfont newpath lta whvc ltb rshow rshow kwz rshow rshow rshow zly rshow rshow cshow cshow hmk cshow cshow huz cshow cshow wkp cshow currentpoint gsave translate rotate system calls cshow grestore time seconds cshow system call profile make cshow fnc rfs ptu rnu utd stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures syscalls eps gnudict dict gnudict begin gju color false solid true gnulinewidth vshift mul hpt vpt moveto bind lineto xkd gqd dzn bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate system calls cshow grestore time seconds cshow system call profile web cshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures syscalls oracle eps gnudict dict gnudict begin color false solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow ps-adobecreator dvipsk cshow copyright radical eye software title sigmetrics cshow dvi pages pageorder ascend boundingbox cshow endcomments dvipscommandline dvips sigmetrics sigmetrics dvipsparameters cshow dpi comments removed dvipssource tex output beginprocset currentpoint tex gsave pro translate texdict dict rotate texdict system begin calls bind cshow exch grestore time translate seconds isls false cshow vsize system mul call hsize mul landplus false rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix dup profile dup round database cshow abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding end dup foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop dup definefont setfont ch-width ch-data dup length ch-height ch-data stroke dup grestore length end showpage enddocument ch-xoff ch-data endtexfig dup length figure ch-yoff ch-data dup system length calls ch-dx ch-data aggre dup gate length system ch-image ch-data calls dup type stringtype ctr ctr workstations ctr add starttexfig begindocument charbuilder figures save context roll make dup eps base gnudict index dict gnudict bitmaps begin color ch-data false pop solid ctr true ch-dx ch-xoff ch-yoff gnulinewidth ch-height vshift ch-xoff ch-width add mul ch-yoff hpt setcachedevice ch-width vpt ch-height true moveto bind ch-xoff ch-yoff lineto ch-image bind imagemask restore rmoveto bind dup rlineto type bind stringtype vpt vpt mul base hpt ctr hpt put mul bitmaps lshow ctr currentpoint stroke dup dup vshift length show dup rshow index currentpoint stroke div put dup put stringwidth ctr pop ctr add neg vshift show add bop cshow userdict currentpoint bop-hook stroke dup bop-hook stringwidth pop save div vshift rigin moveto show matrix currentmatrix color dup dup mul setrgbcolor exch solid dup pop mul add setdash pop pop ifelse pop load solid pop setdash ifelse pop pop stroke eop gnulinewidth restore mul showpage setlinewidth userdict eop-hook stroke eop-hook gnulinewidth div start userdict setlinewidth start-hook stroke start-hook gnulinewidth pop vresolution setlinewidth resolution ltb div dvimag lta array string setdash dup setrgbcolor index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt rmoveto add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke rmoveto stroke roll setdash vpt bos save vpt eos currentpoint restore stroke end hpt neg endprocset vpt neg beginprocset special hpt pro texdict stroke begin sdict stroke dict setdash copy exch hpt sdict exch begin vpt add specialdefaults vpt neg hpt vpt hsc hpt neg vsc closepath ang stroke clip rwiseen false stroke setdash rhiseen exch false hpt letter exch vpt note legal add hpt scaleunit vpt neg hscale currentpoint scaleunit stroke div hsc hpt neg vscale hpt scaleunit vpt div vsc stroke hsize stroke clip setdash copy vsize vpt mul clip add hpt clip neg clip vpt mul hoffset hpt mul voffset hpt neg vpt mul angle closepath ang stroke rwi div copy rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform roll itransform roll itransform roll curveto end closepath gnudict pathforall begin newpath gsave counttomark array translate astore scale xdf pop setgray helvetica put findfont scalefont setfont newpath courier lta fnt invertflag paintblack txpose ltb pxs pys scale ppr aload pop por noflips pop neg rshow pop scale xflip yflip pop neg rshow rotate scale ppr ppr neg neg rshow ppr ppr neg neg xflip yflip rshow pop neg pop rotate ppr rshow ppr neg neg yflip xflip rshow ppr neg ppr neg rshow noflips pop pop rotate cshow scale xflip yflip pop pop rotate cshow scale ppr ppr neg neg ppr cshow ppr neg neg xflip yflip cshow pop pop rotate cshow ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage copypage macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin cshow specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse cshow clip newpath llx lly moveto urx lly lineto currentpoint urx gsave ury lineto translate llx rotate ury lineto context closepath switches clip cshow showpage erasepage grestore copypage time newpath seconds endspecial count ocount cshow context switch profile make cshow pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset texdict begin sigmetrics dvi start end endprolog beginsetup feature resolution dpi texdict begin endsetup page bop ectiv distributed heduling arallel orkloads andrea dusseau remzi arpaci vid culler computer science division univ ersit california berk eley dusseau remzi culler berk eley abstract presen distributed algorithm time-sharing parallel orkloads comp etitiv cosc hedulin implicit sche duling allo eac cal heduler system mak indep enden decisions dynamically ordinate heduling erating pro cesses pro cessors imp ortance blo king algorithm whic de- cides action pro cess aiting comm unication sync hronization complete sim ulation bulk-sync hronou parallel applications sim- ple o-phase xed-spin blo king algorithm erforms ell o-phase adaptiv algorithm gathers run-time data barrier ait-times erforms sligh tly etter results hold range mac hine parameters parallel program haracteristics ndings direct con trast literature states explicit cosc heduling ne-grained programs sho hoice cal heduler crucial priorit y-based heduler erform- ing times etter round-robin heduler erall erformance implicit heduling cosc heduling require- men explicit global ordination intro duction pap tro duce implicit sche duling dis- tributed metho time-sharing parallel orkloads philosoph implicit heduling comm unication sync hronization parallel applications pro- vide cien information ordinating heduling erating pro cesses observing terv pro- cesses ait comm unication mesy sage sends sync hronizin frequen tly een pairs pro cessors ne-grain applications connect comm unicate ery resp ectiv ely erforms barrier sync hronization pro cessors ery compared terv millisecy onds application race-driven simulation direct sim ulation tec hnique studying eha vior single parallel application approac quic kly ecomes tractable examining execution man parallel jobs reason trace-driv sim ulator estigate binay tion parallel sequen tial orkloads single study rst collected traces orkstay tion cluster berk eley cad group cluster consists decstation eac memory graduate studen electrical engineering departmen user-lev daemons logged information ery seconds cpu memory disk eyb oard mouse activit data collected mon ths ebruary marc resulting roughly orkstation-da traces orkstation traces sim ulations randomly selected dify feren eekda traces allo wing sim ulate cluster 
orkstations parallel mac hine trace obtained mon orth data cmg los alamos national laby oratories data consists submission time cpu time des amoun memory utilized eac jobs executed mon octob lanl cmg des statically partitioned sizes size jobs lanl divided sigmetrics classes nbrr dev elopmen pro duction capture ects oth classes jobs traces partitions whic consists mix pro duction dev elopmen runs trace eop page bop starttexfig begindocument figures nlzb submitfinal eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind zqn vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show bxk rshow currentpoint stroke dup stringwidth pop neg vshift show obo cshow currentpoint stroke dup stringwidth pop div vshift show color zgs setrgbcolor solid pop setdash pop pop pop solid tlr pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor unz stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke fzyb stroke obn setdash exch xorm hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt trg mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow cshow ahp stg cshow noon cshow cshow cshow tmx currentpoint gsave translate rotate percent jobs submitted ubh hour cshow grestore gju time day cshow fbblsiy mpp submission times cshow qf-u rdwo twl xqw wrg lnth sxo dbd isk cib stroke grestore end showpage enddocument endtexfig starttexfig begindocument figurescrunch distfinal eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul gbp gdt hpt vpt moveto bind lineto bind rmoveto bind jft lph gxt jkt rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop bjj setdash pop pop pop solid pop setdash ifelse suoj stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth gmy stroke gnulinewidth setlinewidth ltb zvg lta xob setdash setrgbcolor mvw lnfo xmb htb stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg stroke hpt grestore vpt end stroke showpage enddocument stroke endtexfig setdash copy vpt mul add hpt neg vpt starttexfig mul hpt begindocument mul figures context hpt neg eps vpt gnudict mul dict closepath gnudict stroke begin color false copy solid true end gnudict gnulinewidth begin vshift gsave translate mul scale hpt setgray helvetica vpt findfont scalefont moveto setfont bind newpath lineto lta bind rmoveto ltb bind rlineto bind vpt vpt mul rshow hpt hpt mul lshow currentpoint stroke rshow vshift show rshow currentpoint stroke dup rshow stringwidth pop neg vshift show cshow rshow currentpoint stroke dup stringwidth pop div vshift rshow show color setrgbcolor solid pop rshow setdash pop pop pop solid pop setdash cshow ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor cshow cshow cshow currentpoint gsave translate rotate percent jobs finish minutes cshow grestore length job minutes stroke cshow setdash mpp job currentlinewidth length div distribution cshow currentlinewidth stroke frequency stroke rshow setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul weighted frequency closepath stroke rshow copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow stroke grestore end showpage enddocument endtexfig figure rshow lanl job char acteristics rshow leftmost diagram sho ercen jvz rshow jobs submitted hour rshow righ pni tmost diagram sho efb rshow oth jhv frequency eigh rshow ted frequency job lengths cshow jobs cshow min utes length cshow jobs run hzo min utes cshow accoun cshow total execution time cshow races tak partitions currentpoint gsave hea translate rotate context switches submissions examine cshow grestore orst- ubre case time seconds rxh eha cshow vior context switch profile cshow lanl partition utilized wice erage orkload bination kof results xbo presen ted pa- obtained trace-driv pht sim ulator hed- ule rry stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures context oracle eps gnudict dict gnudict begin color false solid true lanl parallel gnulinewidth vshift orkload top mul hpt sequen tial vpt moveto orkload bind presen ted lineto bind rmoveto bind orkstations rlineto bind arallel jobs vpt vpt mul run hpt hpt mul time lshow currentpoint stroke round-robin vshift fashion show rshow currentpoint stroke sec- dup ond stringwidth 
wsu pop neg vshift show cshow currentpoint stroke dup stringwidth pop h-a div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop eidt setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta lph setdash setrgbcolor lbe stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add vbn hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke drm stroke setdash copy exch hpt exch vpt add vpt neg fnj hpt vpt hpt neg phb closepath stroke stroke setdash rth exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt tgd vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow jiej rshow hqo rshow rshow time quan rou matrix algorithm ousterhout hedule parallel jobs sim ulator pro duces metrics aluating rshow erformance normalized rshow parallel program slo cshow times user cshow dela parallel cshow programs non-normalized slo wdo resp cshow onse pft time ned cshow sim ulated clo time cshow job di- vided currentpoint gsave cpu time slo wdo caused ul- tiprogramming translate rotate parallel context jobs switches ell cshow grestore ects time seconds cshow non-dedicated context switch profile vironmen database cshow isolate lat- ter slo wdo normalized dividing slo wdo mze dedicated mpp job exp riences slo wdo due queuing dela mpp xis slo wdo rmhox stroke rep grestore ort end showpage normalized enddocument slo endtexfig wdo figure conte dela switc plld hes eryda orkstation users aggre gate conte main switches ect running parallel workstations programs system calls context switches returning cpu utilizations orkstations users notice workloads sig- making dela operating ecause system mac sho hine uwl virtual fqh memory rfv operating system cac duress sfy ere ushed sho execution number parallel system pro- calls gram conte sim switches ulation trac figure suc oten aggre tial gate user number dela system quan calls titativ ely performed determine yvws ect workloads eren heduling olicies gkb workloads dedicated make decentralized fairly system hea hmcm operating een system suggested services idle resources workloads blrv make performs harv west ested -hours erage pro vide ercomputer gjy nigh calls system traces related web suc workload arrange- intense men performing aggre ould gate erage unacceptable lanl syscalls user comm wkl unit workload makes imp ortance imy system main rdc taining networking teractiv subsystem resp onse time frequently crossing parallel user users -space sho kernel boundary figure finally roughly half database sho par- constant allel jobs system call submitted rates regular orking hours cluster jobs run stressing min system utes ll-us indicating arch running solaris fast resp trapping onse vdg times returning imp ortan parallel kernel users takes roughly ell ilx ugy sequen tial users workload performs system calls zbw rate rst step ving parallel applicati ons ery mpp spent vironmen crossing qdx user -kernel ulti-programmed boundary ulti-user run time applicatio spent kernel dedicated call erhead small clusy ter dev oid eop page teractiv bop users noticeable fraction vironmen ers htu xamine total mpp number eac conte switches orkstation runs full workstations indep enden cluster ylz erating system counts number terconnect times pro w-le vide conte erfory dpi switch mance vmx routine inferior called mpp inside kernel rst section process cjc examine sleep suy erences system call force vironmen conte suc switch np-r gure heduly ing olicy clo correlated cal figure daemon activit data comm gure nication erformance rai vidence ect execution operating time system parallel application strain ecution coscheduling agiul versus workloads cal-scheduling mpps suc general trends cmf tel raw pre vious gure make web database workloads erage conte switches aragon yks interesting eraty point ing systems whic conte switch rate ecialized intensity heduling parallel conte iiv application switch ily takes hand net orks switches orkstations implies indep enden unix ernels zho eac pro cessor time heduly spent ing xmyw switching tec hniques mpps milliseconds ell understo cosc switch qjb time heduly ing ery ousterhout parallel applications generally results wnk parallel program erformance cro ella gupta khm eitelson rudolph cosc heduly ing time pro cesses parallel summary job heduled sim uly taneously section number measures system usage cpu utilization system call ordinated rates time-slicing conte switch een rates eren parallel jobs workloads approac operating-system heduling intensi parallel jobs allo underlying unix ernel eac orkstation non-idle time hedule parallel applications spent indep enden operating system term make web al-sche lin database workloads olicy respecti emplo ely parallel workloads perform viy ronmen hea suc number system pvm calls sunderam spending adv time tage trapping kernel ernel cations system switches conte required xts frequently workloads earlier studies section cro ella gain insight eitelson rudolph frequenc demonstrate switches cal-sc heduli characterization leads unacceptable workloads exy order ecution times frequen purposes tly-comm unicatin study pro cesses mind lea slo wdo ccurs future ecause work pro cess eop stalls page comm bop chapter uniy cates message sync hronizes raf non-sc heduled pro cess section introduced vironmen messages workloads whic dri arriv non-sc study heduled proy cesses section ered trace resp onses messages returned nodes destination cluster pro cess heduled eop workloads page bop trace destinations starttexfig messages begindocument figures cluster local eps gnudict dict gnudict begin color true solid false gnulinewidth vshift mul hpt vpt moveto 
man bind bytes lineto bind rmoveto bind node rlineto node bind vpt vpt mul hpt hpt mul cumulati lshow currentpoint stroke breakdo vshift wns show message rshow currentpoint sizes stroke finally dup stringwidth pop neg rate vshift show cshow node currentpoint stroke sends dup stringwidth messages pop div presented vshift show rha measurements color setrgbcolor solid kernel-kernel pop traf setdash rha pop pop pop messages solid pop setdash ifelse intra-cluster color interconnect setrgbcolor solid pop setdash pop pop kernel-user pop solid traf pop setdash ifelse color xample setrgbcolor solid pop serv setdash pop pop pop implemented solid pop user setdash space ifelse stroke gnulinewidth mul amount setlinewidth stroke traf gnulinewidth div setlinewidth gligible stroke note gnulinewidth setlinewidth ltb nodes lta workers performing setdash setrgbcolor fraction work complete workload hand addition nodes serv special purpose workload message destinations figure sho pictorial representation message destinations width arro proportional total number messages workstation note data found discern number facts diagrams foremost number messages node node equal number messages conserv ation communication holds due request-response nature traf ery request node met response node note one-way communication time measurements case communication traf eop page bop starttexfig begindocument figures destinations make eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind ojp col srgb bind -wk col srgb bind col srgb bind col srgb bind col zgm srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind jfm col srgb bind col srgb bind col srgb bind end save translate scale clp closepath bind eofill bind grestore bind gsave bind lineto bind moveto bind newpath bind cml stroke bind slc setlinecap bind slj setlinejoin bind jwi slw setlinewidth bind srgb prz setrgbcolor bind zhs rot rotate bind ucy scale bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle ajp exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit slw polyline jon clp col times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont xusj scalefont setfont awl colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont gai colshow times-roman findfont scalefont setfont colshow ellipse drawellipse cols ellipse drawellipse cols times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont ofa cqo colshow polyline cols polyline rkng cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont colshow polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman sun findfont scalefont setfont make colshow begin arrows line width slw pwd polyline qlw cols lac clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols mkyy clp setgray cols line width slw polyline cols ubf clp setgray cols e--u -uammy line width slw polyline cols clp hyi setgray cols line width slw polyline cols mkj clp setgray cols kvyl line dst width slw polyline cols qhb clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols end arrows times-roman findfont scalefont setfont colshow psend restore enddocument endtexfig starttexfig begindocument figures destinations eps psdict dict psdict begin psdict mtrx 
matrix put coldef col srgb bind col srgb bind daz col srgb bind col srgb bind ifz stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt xon exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt dxq stroke dxq stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke tubl copy end gnudict begin gsave fvc translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow zqx rshow gbs eai rshow rshow rshow bcw rshow djh rshow rshow rshow rshow eeof rshow cshow cshow cshow currentpoint gsave translate rotate slowdown cshow grestore number competing parallel jobs cshow local scheduling cshow ltb cholesky rshow end damage gnw dux gai nku ijx rne pxn hli eqe q-l rol bgw gjz baqr iwc loj ymd hld currentpoint stroke ksd blu dsv sra w-m znz eod uwh xqk ebx ltb column rshow end damage -ab mha icnujb mea z-ia szu xul ysa aao owr qwr lis opkr xkk qco seg seg seg seg zwo fpk zdn fxf cpo yht yhh ysg kcf lkg efx hgb kgl idu uur azh bej ldjv whuz dtr etth gos ril rxo bqa ssls dku nbp fmo ubp fyw von kjl nsp zzym dli dad dyyb adq yxh pnz fyy xcxh zis ppfi xcv ysmn kfidl rys lns sync hronizatio complete eac cal 
heduler mak indep enden decisions tend hedule pro cesses parallel application ordinated manner pro cessors aluate erformance implicit heduling rela- tiv zero-o erhead implemen tation osche duli ork supp orted part adv anced researc pro ject agency -co national science oundation ccrd california state micr pro- gram dusseau supp orted tel oundation graduate ello wship ermission mak digital hard copies part ork ersonal classro gran ted fee pro vided copies made distributed pro commercial adv tage copies ear notice full citation rst page cop yrigh comp onen currentpoint stroke ork wned ust honored abstracting credit ermitted cop republish ost serv ers redistribute lists requires prior eci ermission fee sigmetrics philadelphia usa cosc heduling pro cesses parallel job run time pro cessors explicit manner extery nally con trolled con text-switc ccurs sim ultaneousl mac hines ene cosc heduling eraty ing pro cesses eha ere running dedicated vironmen spin-w ait comm unication sync hronization cosc heduling ell-suited emerging pro cessing vironmen orkloads fault-toleran scalable cosc heduling non-trivial design implemen cosc heduling traditionally een tigh tly-coupl parallel pro cessing vironmen view siny gle system failure del tire mac hine fails pro cessor dies view practical disy tributed setting suc net ork orkstations similarly cosc heduling designed orkloads parallel jobs result ignores mixed orkloads con tainy ing teractiv o-in tensiv jobs teractiv jobs heduled round-robin manner cosc heduled parallel jobs users exp erience excessiv dela prey serving teractiv resp onse time requires raising priory teractiv jobs erturbs heduly ing parallel jobs drastically reducing erformance frequen tly comm unicating parallel application cosc heduling requires pro cesses busy-w ait asting pro cessor cycles reducing throughput sche duling parallel jobs existing ery ating system ltb eac connect pro rshow cessor hedules pro cesses indep eny den tly oten tial structural erformance adv tages cosc heduling cal heduling exists ery mac hine requiring additional implemen tation eac heduler indep enden system trivially proy vides fault-con tainmen parallel job running subset mac hines ected failure secy ond time-sharing priorit y-based cal hedulers een carefully tuned oth teractiv end o-in tensiv damage proy cesses impro throughput jobs aiting relinquish pro cessor impro resp onse time jobs blo frequen tly giv higher priorit computation reasons motiv ated estigate cal hedulers ectiv ely hedule parallel orkloads sev eral previous researc compared erfory mance cosc heduling approac hes cal hedy ulers unanimously concluded cal heduling insu cien ne-grained parallel applicatio erformance cal heduling ccurs ecause erating pro cesses heduled sim ultaney ously pro cessors result pro cess attempts comm unicate sync hronize pro cess heduled programmer runp eop page bop time system ust ose action initiating comm nication request spin-w ait til resp onse receiv blo switc comp eting job pro cess spin-w aits resp onse pro cessor time asted pro- cess spins idly alternativ ely pro cess blo time asted con text-switc hing thrashing een comp eting pro cesses order cal hedulers parallel jobs comm nicating pro cesses ust dynamicall iden or- dinated comp onen implicit heduling hiev ordination two-phase blo king o-phase xed-spin blo king aiting pro cess spins pre- determined time resp onse receiv efore time expires con tin ues executing resp onse receiv requesting pro cess blo pro cess heduled selecting spin-time suc barriers ultiprogrammed viron- men non-trivial adaptive o-phase algorithm adjusts spin-time currentpoint stroke run-time measuremen aiting terv als ene cial conditions pap sho implicit heduling feasible alternativ cosc heduling giv realistic bulk- sync hronous programming del commercial priorit based cal heduler adaptiv o-phase blo king algorithm bination enables pro cesses uence collection cal hedulers ordinate them- selv comm unication phases remaining inde- enden computation phases results hold neb coarse-grained parallel applications programs arying degrees load-im balance arious comm uni- cation patterns sho conclusion robust hanges net ork erformance con text-switc costs rest pap organized follo egin section reviewing researc parallel hedul- ing section ltb describ rshow parallel orkload sim ulation vironmen results section examine rha erformance cal heduling pro cesses blo immediately comm unication section explore impact o-phase xed-spin blo king presen o-phase adaptiv blo king algorithms section demonstrate barrier erations parallel application collect data heduler run-time section examines sensitivit implicit heduling underlying cal heduler finally presen con- clusions section related heduling parallel jobs long een activ area researc hallengin problem ecause erfor- mance applicabi parallel heduling algorithm highly dep enden host factors man er- lev els orkload parallel programming language blo king algorithm cal erating system mac hine arc hitecture arallel heduling comp osed ter- dep enden steps allo cation pro cesses pro cessors space-sharing heduling pro cesses time time-sharing large studies fo- cused pro cessor allo cation step parallel job hedul- currentpoint ing stroke es- tigated step eliev mixed approac utilizing oth space-sharing time-sharing required main tain teractiv resp onse times high throughput pap problem jobs een al- cated set pro cessors cus time-share een comp eting jobs pro cessor ousterhout tro duced idea osche duly ing whic erating pro cesses single job sim ultaneously heduled pro cessors giving eac job impression running dedicated mac hine cosc heduling destination pro cess message guaran teed heduled sync hronizati time dedicated vironmen pro cesses spin aiting comm unication sync hronizatio resp onses previous ork comparing erformance cosc heduly ing cal heduling unanimously concluded exy plicit cosc hedulin ne-grained parallel apy plications cal heduling ordinate comy unication phases pro cesses man studies estigate gkd impact eren blo tildbb king algorithms vuc cal hedulers programming dels studies considered spin-w aiting blo king phase blo king ioh estigated ect kdkg eren mtj xed-spin eih times urthermore previous ork considered simpli cal hedulers suc roundy robin priorit y-based hedulers comy mercial systems pql pap exploring merits run x-kh time iden cay tion osld erating pro cesses erformance cal heduling o-phase blo king examined impro emen due short spin-time relativ con tuq text-switc gbv cost vironmen eren upv ect eren clk xed-spin times tqk quan shared-memory sync hronizati zal cal heduling lzgxv spinning con texty switc cost giv higher utilization xed-spin times cosc hedulin results est utilization small studies ecy examined tery action txm een ultiprogramming hji adaptiv o-phase sync hronization algorithms karlin ylo sho sev eral adaptiv algorithms erform etter xed-spin algorithms shared-memory sync hronization t-t adaptiv blo king tec hniques barriers drastically eren due global cost 
blo king barriers previous researc apy plying adaptiv algorithms barrier sync hronizatio lycd assumed radically eren programming del sdsa whic sdsb threads parallel job execute pro cessor finally ubg time-sharing approac hsq hbsb curren tly uny der dev ltb elopmen xcsz sample rshow comm uyvg unicating pro cesses dynamicall cosc rsgg heduled h-e message arriv als lyz trigger heduling authors mdeb ltc explore rha algorithms releasing pro cessor sending side eliev ftf ziyup approac complemen j-a tary plan zwi estigating future ork metho dology wdd section giv edq erview exp erimen tal metho study egin presen ting mood rey alistic del parallel programs whic syny thetic application sim ixh ulations describ t-driv sim hbo ulator details cal heduler conclude examining execution haracteristics syn ehf thetic orkload cosc heduled vironmen eop page bop starttexfig begindocument xfig program eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind nid col srgb bind col srgb bind col srgb bind col srgb bind col srgb ioh bind gmf nqt jcs lcx col srgb bind col srgb bind col srgb bind col srgb bind ugr col srgb bind fwa col srgb bind col dxh srgb bind col srgb bind sdx col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind izz jeool col srgb toh bind col srgb bind col srgb bind qma col srgb bind col srgb bind col srgb bind icu naf etl hch kcp moar xmb gwa biz faf kchyg xze currentpoint stroke jcm dvxm ajdvaf vqf vqf ijn xmb xjh fqf ybr xjh obsa ohr enq ruv tdy ukde wjy jood stroke grestore end showpage enddocument endtexfig figure sche duling versus cosche duling hbc real parallel application sim ulated parallel jobs dpt heduled round-robin fashion time quan tum slo wdo ratio measured cally- glz heduled execution uvq time cosc heduled jxe time nwxd repro duce erformance result eliq cal-sc heduli enc hmark application direct sim ulation figure sho slo wdo cally-sc hedu eac ap- plication round-robin fashion fic lke arying sim ulated comp eting parallel jobs een rep orted slo vcdw wdo relativ execution time application cosc heduled results sho erformance cally-sc dul rll parallel application incredibly resources iood shared een jcr parallel application eac application ytd slo dwd factor eigh exp ected applicatio fdgmq sync hronizes frequen tly slo etv signi zuv tly times er- formance vxl column whic comm unicates infrequen tly fyv sev erely degraded result insu cien ering destination pro cessor ery large messages vkyk col ytes srgb bind col erage srgb bind col srgb bind comp eting col parallel srgb bind application col in- srgb bind creased col srgb bind execution col times srgb increase bind end save translate reasons scale clp closepath bind comm unicating eofill bind destination grestore bind pro gsave cess bind lik lineto bind elih moveto bind newpath bind destination pro stroke cess bind slc setlinecap bind heduled slj increases setlinejoin bind slw comp setlinewidth eting bind pro srgb cesses setrgbcolor bind sec- rot ond rotate bind destination pro scale bind cess translate bind heduled tnt dup dup currentrgbcolor time roll dup remaining exch efore roll mul pro add cess roll dup heduled exch increases roll mul add similar roll dup reasons exch increasing roll mul time add quan srgb tum bind length shd dup dup re- currentrgbcolor sults roll mul greater roll slo mul wdo roll wns mul srgb bind drawsplinesection exch found exch parallel exch applications exch slo exch dramatically exch cally heduled mul add mul add parallel applicatio mul cosc add heduling parallel mul applica- add tions guaran lineto tees acceptable curveto lev psbegin erformance psdict begin regard- psenteredstate save psend psenteredstate restore comp end eting application psbegin cosc setmiterlimit heduling polyline allo clp col shd polyline longer time quan clp col shd amortize cac slw polyline ects heduling cols erheads slw polyline coscheduling clp previous col shd section cols assumed polyline erfect cosc heduling clp con col text switc hes pro cessors egan shd ended precisely cols polyline momen suc cosc hedulin clp col shd ossible cols mpp polyline ecause common clo clp col shd distributed cols polyline des clp unlik ely col shd mec cols hanism polyline er- clp col starttexfig shd begindocument cols figures polyline skewfinal eps gnudict dict gnudict begin color clp true col solid shd false cols gnulinewidth vshift slw polyline mul hpt cols vpt moveto bind lineto bind cols rmoveto bind rlineto bind vpt vpt mul cols hpt slw hpt mul polyline lshow currentpoint stroke vshift clp show col rshow shd currentpoint stroke cols dup stringwidth polyline pop neg vshift show col cshow shd currentpoint stroke cols dup stringwidth polyline pop div vshift show col shd color setrgbcolor solid cols pop polyline setdash pop pop pop col solid shd pop setdash ifelse cols polyline color setrgbcolor solid pop col shd setdash pop pop pop cols solid polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols slw open spline drawsplinesection drawsplinesection drawsplinesection drawsplinesection cols open spline drawsplinesection drawsplinesection drawsplinesection drawsplinesection cols slw polyline cols clp setgray cols polyline clp col shd cols polyline clp col shd cols slw polyline cols cols cols polyline cols cols cols polyline cols cols cols slw polyline col shd cols polyline col shd cols times-roman findfont scalefont setfont repeat colshow polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols slw polyline pop setdash ifelse stroke cols gnulinewidth polyline mul setlinewidth stroke gnulinewidth div cols setlinewidth slw polyline stroke gnulinewidth setlinewidth ltb col shd lta cols polyline setdash setrgbcolor col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols polyline col shd cols slw polyline cols slw polyline col shd cols open spline drawsplinesection drawsplinesection drawsplinesection drawsplinesection drawsplinesection drawsplinesection drawsplinesection cols clp setgray cols times-roman findfont scalefont setfont local computation colshow times-roman findfont scalefont setfont load imbalance colshow times-roman findfont scalefont setfont processes dup stringwidth pop div neg rmoveto colshow times-roman findfont scalefont stroke setfont setdash currentlinewidth div communication currentlinewidth colshow stroke times-roman stroke findfont scalefont setdash copy vpt setfont add optional hpt colshow neg vpt neg hpt times-roman vpt neg findfont hpt scalefont vpt hpt setfont neg vpt closepath time stroke dup stringwidth pop div stroke neg setdash rmoveto vpt colshow vpt times-roman currentpoint stroke findfont scalefont hpt neg vpt setfont neg hpt granularity stroke colshow stroke times-roman setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg findfont hpt scalefont vpt setfont stroke stroke setdash colshow copy times-roman vpt mul add findfont scalefont hpt neg vpt mul setfont hpt mul hpt colshow neg vpt times-roman mul findfont closepath scalefont stroke copy setfont end gnudict begin computation gsave colshow times-roman translate scale findfont setgray scalefont helvetica setfont findfont scalefont setfont newpath variation lta colshow times-roman ltb findfont scalefont setfont end rshow opening barrier colshow times-roman findfont rshow scalefont setfont begin opening rshow barrier colshow times-roman findfont scalefont rshow setfont closing barrier colshow rshow times-roman findfont scalefont setfont rshow optional colshow psend rshow restore enddocument endtexfig skew cshow figure bulk-synchr skew spmd cshow del synthetic par- skew lel cshow applic ations eac pro currentpoint cess gsave translate parallel rotate job slowdown executes cshow grestore cshow coscheduling skew cshow ltb cholesky rshow rha currentpoint stroke separate pro cessor alternates een mnx tuz cvkl eaz -pw oasw 
col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale clp closepath bind eofill bind grestore bind gsave bind lineto bind moveto bind newpath bind stroke bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit slw polyline clp col times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow ellipse drawellipse cols ellipse drawellipse cols times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow polyline cols polyline cols polyline clp cols times-roman findfont scalefont setfont colshow polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont colshow polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont web colshow polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont colshow begin arrows line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width line width end arrows psend restore enddocument endtexfig starttexfig begindocument figures destinations oracle eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind computation col srgb bind comm unication phases col srgb pro bind cesses compute col srgb bind time col srgb bind efore col executing srgb bind ening barrier col srgb bind comm uni- col srgb cation bind phase col srgb ariation bind computation col pro srgb cesses bind col uniformly srgb distributed bind col terv srgb bind col srgb bind comm col srgb unication bind phase eac col pro srgb cess bind computes col srgb small bind end time save translate scale clp een closepath bind eofill bind phase grestore bind close gsave bind lineto bind barrier moveto bind newpath programming bind del stroke bind slc setlinecap bind slj opular setlinejoin bind single-program slw setlinewidth ultiple-data bind spmd srgb setrgbcolor bind programming rot rotate bind del scale bind parallel translate job bind tnt consists dup dup currentrgbcolor roll dup exch ess roll mul add pro roll cessor dup exch static roll mul add roll dup exch pro cessors roll mul add through- srgb bind shd execution dup dup currentrgbcolor roll een mul roll exp mul erience roll mul srgb ell bind drawellipse endangle exp exch erience startangle exch yrad exch xrad exch exch structure exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end man psbegin parallel applicatio setmiterlimit slw bulk-synch polyline ono clp phases col times-roman purely findfont scalefont cal computation setfont alternate phases colshow times-roman findfont ter- scalefont pro setfont cessor comm colshow times-roman unication findfont scalefont figure setfont demonstrates colshow times-roman pro- findfont gramming scalefont del setfont colshow times-roman study findfont eac scalefont setfont co- erating pro cesses parallel job executes separate pro cessor eac pro cess computes cally time selected colshow times-roman uniform findfont scalefont distributio setfont colshow terv ellipse drawellipse cols ellipse drawellipse cols times-roman findfont scalefont setfont colshow times-roman findfont scalefont adjusting setfont del colshow parallel times-roman programs findfont scalefont eren setfont computation colshow gran polyline ularities arying cols polyline hange cols polyline load-im balan pro arcto pop cessors comm repeat arcto unication pop phase repeat consists arcto pop ening repeat arrier arcto pop repeat follo clp cols polyline optional se- arcto quence pop pairwise repeat comm arcto unication pop repeat separated arcto pop small repeat amoun arcto pop repeat clp cal cols computation polyline nally arcto optional pop clos- repeat ing arcto pop arrier repeat arcto pop ary repeat arcto pop patterns repeat clp cols comm times-roman unica- findfont tion scalefont phase setfont adjust degree colshow polyline ter-pro cess dep arcto endencies pop repeat completing arcto pop comm unication repeat phase arcto eac pop pro cess repeat arcto pop repeat gins clp cols cal times-roman computation findfont phase scalefont setfont exibilit database colshow begin comm arrows unication allo line width capture line ric width ariet line programming width dels line width pairwise comm unication line width slw polyline sync hronous cols async hronous sends receiv distributed-memory mac clp hine setgray remote reads cols writes shared address line width space slw study polyline cus cols erations suc built clp setgray top activ cols messages line width erativ line width line width barrier slw implemen polyline ted assuming hardw cols supp ort pro cess reac clp hing setgray barrier cols sends message line width slw polyline pro cess cols handles message incremen clp setgray coun cols ter line width coun ter slw reac polyline hes cols broadcasts barrier-completion clp mes- setgray sage cols broadcast line width slw polyline cols clp setgray cols end arrows times-roman findfont scalefont setfont colshow psend restore enddocument endtexfig figure message destinations width bar proportional number messages node node make diagram maximal arro nodes implemen ted messages pair-wise xchanged messages in- web stead nodes tree-based structure pro cesses tree lea ould ait ltb pro cesses termediate des hed- uled note ecause curren tly del erhead sending messages broadcast free pro cess shared memory column rshow read eration request-resp onse message pair constructed sending request 
pro cesy sor con taining desired memory cation rha destination pro cess reads cal data sends resp onse bac requester del read request sery viced pro cess job heduled pro cesses heduled sim ultaneousl pro cessors requester ait unpredictable amoun time read resp onse simulation rameters dev elop sim ulated vironmen study eha vior syn thetic parallel applicatio eren heduling approac hes blo king algorithms explore impact conditions suc haracteristics parallel applications erformance comm unication net ork cost con texty switc sim ulator driv syn thetic parallel applicatio adhering del figure eac parallel job eciy arriv time pro cesses job comm unication eha vior job ned computation time een comm unication phases load-im balance time een reads comm nication phase comm unication phases execute efore termination comm unication pattern estigate eren comm unication patterns barrier news transpose barrier pattern cony sists ening barrier con tains addiy tional dep endencies pro cesses patterns consist sequence reads surrounded ening closing barrier comm unication phase transpose con tains reads -th read pro cess reads data pro cess eac pro cess dey ends pro cesses news grid comm unication pattern xchange eac pro cess dep ends messages nally database neighy nodes ors send comm unication messages sim ulator gures del scaled ects pac base number sizes limited message readily comparable ery ing eop due page bop time constrain centered examine disks ects attached exp erimen discussed belo simplicit eac read make requests workload single pac ske wed traf data pattern estigate nodes impact nodes net ork latency communicate latency nodes ned messages total time deliv pac disk source source tree attached destination pro node cessor message traf cal scheduling non-uniform olicies web workload cal heduler gure signi nodes impact special erformance interest parallel applications obtain realistic results presence constructed cal xternal network heduling interface comy node onen eals sim traf ulator closely hea matc serv unix system cluster release gate svr heduler oth internet functiony alit http structure request fact signi routed ortions copied directly solaris source jectiv time-sharing heduler hedule eac pro cess fairly cien tly goal realized svr dynamic priorit allo cation heme job priorit ered runs time quan rey linquishi pro cessor job priorit round-robin raised selection sleeps nodes frequen determining tly node handles request fetching requested node routes message back back requester hot-spot web workload service access point serv sap-serv manages global port space connection opened closed communication sap-serv node occur con guration sap-serv runs single node practice distrib uted program node managing portion space co-locating sap-serv nodes xternal connections lessen message traf reducing local inter 
-process communication finally database workload traf centered disk database resides realistic vironment spread disks nodes lead enly balanced traf patterns balance achie access patterns naturally balanced solaris takes xplicit action balance system load cluster pre vious gures sho message communication spread cluster sho man bytes currentpoint stroke node figure weights pre vious graph total bytes width arro proportional total number bytes workstation total includes user payload orb headers fundamental operation system transport headers implementation speci make workload traf reason node plays role serv xperiment nodes ltb request connect rshow blocks modi blocks entually return node workload incoming traf node totals workstations rha ethernet connections xperiment traf routed alternati con guration allo tcp messages return network interface nodes eop page bop starttexfig begindocument figures weighteddest make eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind svr heduler main tains fairness starv ation timer runs ery job completed time quan tum efore starv ation timer expires priorit raised priorit eop page bop starttexfig begindocument figs bar coschedgranvarbarrier epsim fffe fffe ffff ffff fffc fffe fffe abab fffe fffe eeee fffe fffe babb fffe fffe eeee fffe fffe abab fffe fffe eeee fffe fffe bbba fffe fffe fffe ffff ffff fffc ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfeff ffa fec fec ffa ffb fed fed ffa ffb fec fed ffa ffb fed fed ffa ffa fec fec ffa ffa ffa ffb fed fed ffb ffa ffa ffa fec fec ffb ffa ffa ffb fed fed ffb ffa ffa ffa fec fec ffa ffa ffa ffb fed fed ffb ffa ffa ffb fec fed ffb ffa ffa ffb fed fed ffb ffa ffa ffa fdff fec fec ffa ffbfe fdff feffa feffa ffa ffbfed fdff feffb feffb ffb ffbfe fdff feffa feffa ffa ffbfec fdff feffa feffb ffb ffbfe fdff feffa feffa ffa ffbfed fdff feffb feffb ffb ffbfe fdff feffa feffa ffa ffbfec fdff feffa feffa ffbfec ffbfe fdff feffa feffa ffbfe ffbfed fdff feffb feffb ffbfed ffbfe fdff feffa feffa ffbfe ffbfec fdff feffa feffb ffbfec ffbfe fdff shy lds hgs yrq edn clk uih ehy xjd tcc biz zpgh jis qdi rdgta csl mcm xye mcm xqb gvx faf vaf oau cbs haf jel xqby ake pfx fpd pll jtc vvb jmm eay wfx fzs mzt ogf khu foc wvb qpy xewb iohdx dtwey ezb -cl hzb hn-b wcyd tkd rjy rjyd glf fbc fyb myu muj exer ohn xym vaf ygem xjh fqs mzl rut xqb dnn hecm fmf amr gdsd pbsb szj pdsb bsb bsb quy lvf zkq xjod iood shq hth vjy trvy kzj xvm xgi btj uuo eys pdz wgl bigd hsot cwpq upb jel hbq kyg kwv msd iad lyis wsyv xrx rha mnb tsyfef djfq xpm irz qcb yfo qcb bxg kvw rgg tlt q-feu onh hdc imy cjh hmr qyz grf glf drx wkd dzg bwb xup bfc mzy rjy rjydl zfyv qnv fmt jta hqqtl qja -ivc rkgw blb tgkmy riv ylg xth gxn qwb dyi jyi fzg jeq ddqv den uxc qtw lej sij bnt desq sdz fexb yoi -lz mzj obm qbu feffa feffa ffbfe ffbfed fdff feffb feffb ffbfed ffbfe fdff feffa feffa ffbfe ffbfec fdff feffa feffa ffbfec ffbfe fdff yek feffa feffa aht ffbfe ffbfed fdff zfy feffb feffb ffbfed ffbfe fdff feffa feffa ffbfe ffbfec fdff feffa feffb ffbfec ffbfe fdff feffbfd feffbfe ffbfe ffbfeffb fdff feffbfd feffbfed ffbfed ffbfeffa fdff feffbfd feffbfe ffbfe ffbfeffa fdff feffbfd feffbfec fdff ffbfec ffbfeffa fdff feffbfd feffbfe fdff ffbfe ffbfeffb fdff feffbfd feffbfed fdff ffbfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc ffbfeffa fdff feffbfd feffbfec fdff ffbfeffc ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc ffbfeffb fdff feffbfd feffbfed fdff ffbfeffd ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc ffbfeffa fdff feffbfd feffbfec fdff ffbfeffc ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfe ffbfeffb fdff feffbfd feffbfed fdff ffbfeffd fdfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfe ffbfeffa fdff feffbfd feffbfec fdff ffbfeffc fdfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfe ffbfeffb fdff feffbfd feffbfed fdff ffbfeffd fdfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfe ffbfeffa fdff feffbfd feffbfec fdff ffbfeffc fdfec ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfe ffbfeffb fdff feffbfd feffbfed fdff ffbfeffd fdfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfe ffbfeffa fdff feffbfd feffbfec fdff ffbfeffc fdfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfe ffbfeffb fdff feffbfd feffbfed fdff ffbfeffd fdfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfe ffbfeffa fdff feffbfd feffbfec fdff ffbfeffc fdfeffa ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfeffa ffbfeffb fdff feffbfd feffbfed fdff ffbfeffd fdfeffb ffbfeffa fdff feffbfd feffbfe fdff ffbfeffc fdfeffa ffbfeffa fdff fdfec feffbfdff feffbfeffa fdff ffbfeffc fdfeffa ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffc fdfeffa ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffd fdfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffc fdfeffa ffbfeffbfec fdff fdfec feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffffd fdfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfed fdff fdfec feffbfdff feffbfeffa fdff ffbfeffffd fdfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffffd fdfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfec fdff fdfec feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffffd fdfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfec fdff fdfec feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffa ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffffd fdfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffbfe ffbfeffbfec fdff fdfec feffbfdff feffbfeffa fdff ffbfeffffd fdfeffbfec ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd fdfeffbfe ffbfeffbfed fdff fdfeffb feffbfdff feffbfeffb fdff ffbfeffffd fdfeffbfed ffbfeffbfe fdff fdfeffa feffbfdff feffbfeffbfe fdff ffbfeffffd fdfeffbfe ffbfeffbfeffb fdff fdfeffa feffbfdff feffbfeffbfed fdff fdfec ffbfeffffd fdfeffbfec ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffdff fdfeffbfe ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfed fdff fdfed ffbfeffffdff fdfeffbfed ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffdff fdfeffbfe ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfec fdff fdfec ffbfeffffdff fdfeffbfec ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffdff fdfeffbfe ffbfeffbfeffb fdff fdfeffb feffbfdff 
feffbfeffbfed fdff fdfed ffbfeffffdff fdfeffbfed ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffdff fdfeffbfe ffbfeffbfeffb fdff fdfeffa feffbfdff feffbfeffbfed fdff fdfec ffbfeffffdff fdfeffbfec ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffdff fdfeffbfe ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfed fdff fdfed ffbfeffffdff fdfeffbfed ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffdff fdfeffbfe ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfec fdff fdfec ffbfeffffdff fdfeffbfec ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffdff fdfeffbfeffa ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfed fdff fdfed ffbfeffffdff fdfeffbfeffb ffbfeffbfeffa fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfe ffbfeffffdff fdfeffbfeffa ffbfeffbfeffb fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffa fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfeff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfeff tsv nmn hwpb ntj bvv ybv xngxk currentpoint stroke zdi uhn fzz cqra izm fyb kzi mhv mzx agefna rav kcc rev qqt atj cze brh iux ltb rshow rha yvqtnjd spx tmv ghl ghu bls gfi gpc bvx owhm agg currentpoint stroke pkh xxm vfi rt-f ocf lvfz bxmq upq hgt oge v-l zhg col srgb bind ltb sample rshow col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb rha bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale clp closepath bind eofill bind grestore bind gsave bind lineto bind moveto bind newpath bind stroke bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit slw polyline clp col times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow ellipse drawellipse cols ellipse drawellipse cols times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont ajd colshow polyline cols polyline cdf cols polyline arcto pop lyis repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline arcto pop repeat arcto pop repeat arcto pop zvg repeat arcto pop repeat clp cols polyline jdb arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman hsib findfont scalefont setfont colshow polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont make colshow begin arrows line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols line width slw polyline cols clp setgray cols end arrows times-roman findfont scalefont setfont colshow psend restore enddocument endtexfig starttexfig begindocument figures weighteddest eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind currentpoint stroke col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale clp closepath bind eofill bind grestore bind gsave bind lineto bind moveto bind newpath bind stroke bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll stroke grestore end showpage enddocument endtexfig figure cosche duling skews eac parallel application cosc mul heduled roll mul srgb sim bind ulated parallel drawellipse job endangle exch startangle time exch yrad quany exch tum xrad exch exch exch slo wdo savematrix mtrx wns currentmatrix applications xrad yrad startangle cosc endangle arc heduling closepath ews savematrix setmatrix psbegin psdict begin rep psenteredstate save orted fect cosc psend heduling psenteredstate restore exist end psbegin ysically distributed setmiterlimit nety slw polyline ork orkstations clp col con text times-roman switc findfont hes scalefont setfont ordinated colshow broadcasting times-roman signal findfont scalefont master setfont orkstay colshow tion times-roman eren findfont pro scalefont cesses setfont receiv colshow signal times-roman findfont eren scalefont setfont times colshow ordination times-roman exists findfont ecause scalefont setfont clo colshow times-roman orkstation findfont scalefont een sync hronized lamp ort lik ely clo exists orkstations section quan tify ect imprecise cosc heduling parallel application erformance osche dulin skew maxim erence een quan tum start times pro cessors setfont sim ulations colshow cosc ellipse hedule parallel drawellipse application cols ellipse sim ulated drawellipse parallel job cols setting times-roman findfont start scalefont time setfont eac proy colshow cessor time times-roman quan findfont scalefont setfont random amoun figure colshow sho times-roman findfont scalefont setfont time quan tum colshow polyline execution time cols polyline applicatio increases cols cosc polyline heduling clp cols applications times-roman findfont slo scalefont setfont colshow polyline compared erfectly cosc arcto pop heduled time repeat increasing arcto pop time quan repeat tum arcto pop eliminates repeat arcto trend pop repeat clp rising execution cols times polyline arcto applicati pop slo repeat arcto pop repeat arcto pop conclusion repeat arcto pop repeat clp cols large times-roman time findfont quan scalefont setfont sec small colshow cosc polyline heduling arcto pop hiev negligibl repeat slo arcto pop wdo wns repeat arcto pop smaller repeat quany tum arcto pop repeat clp cols larger times-roman findfont scalefont slo setfont wdo web felt colshow polyline parallel programs arcto dep pop ending repeat arcto pop pary ticular circumstances repeat arcto pop repeat arcto pop repeat acceptable clp cols daemon times-roman pro findfont scalefont cesses setfont net colshow ork begin arrows orkstations dev oid line teractiv width slw users polyline serial pro cesses cols asso ciated eraty ing system whic clp ust run setgray erio cols dical line sho width slw meay suremen polyline erage cols run time ter-arriv times clp frequen setgray tly running cols daemons decstation line width running slw polyline cols clp setgray cols line width slw polyline cols ultrix measuremen daemon pro cess runs appro ximately ery seconds millisecond eac orkstation assuming daemon pro cesses execute orkstations clp setgray nony cols erlapping terv als line width cluster slw polyline orkstations daemon cols pro cess executing time due clp comm setgray unication dep cols endencies parallel application line width slw eop polyline page bop cols starttexfig begindocument 
clp figures duration setgray daemon eps cols gnudict dict gnudict begin color line false width solid false slw gnulinewidth polyline vshift mul cols hpt vpt moveto bind lineto bind rmoveto clp bind setgray rlineto bind cols vpt vpt mul hpt hpt line mul width 
lshow currentpoint slw stroke polyline vshift show rshow cols currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint clp stroke dup setgray stringwidth pop cols div vshift show line color width setrgbcolor solid pop slw polyline setdash pop pop pop solid pop cols setdash ifelse stroke gnulinewidth mul setlinewidth stroke clp gnulinewidth div setgray setlinewidth cols stroke gnulinewidth setlinewidth ltb line width lta slw setdash setrgbcolor polyline cols clp setgray cols line width line width end arrows psend restore enddocument endtexfig starttexfig stroke setdash begindocument figures currentlinewidth div weighteddest oracle eps currentlinewidth psdict stroke dict psdict stroke begin setdash copy psdict vpt mtrx add matrix hpt put neg vpt coldef neg col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg col srgb closepath bind stroke col stroke srgb setdash bind exch hpt exch col vpt add srgb bind hpt vpt neg col currentpoint srgb stroke bind hpt neg hpt col vpt srgb stroke bind stroke col setdash srgb copy bind vpt mul add hpt col neg srgb vpt bind mul hpt col mul srgb hpt bind neg vpt mul col closepath srgb bind stroke copy col srgb end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow bind col srgb bind ugu qaxl rshow rshow col srgb bind rshow col srgb bind col srgb rshow bind col srgb bind rshow col srgb bind rshow col srgb bind col srgb bind rshow col srgb bind col srgb rshow bind col srgb bind cshow col srgb bind col srgb bind cshow col srgb bind end save cshow translate scale clp closepath bind eofill bind cshow grestore bind gsave bind lineto bind cshow moveto bind newpath bind stroke bind slc setlinecap bind cshow slj setlinejoin bind slw setlinewidth bind srgb currentpoint setrgbcolor gsave bind translate rot rotate rotate bind scale bind slowdown translate bind tnt bnr dup dup currentrgbcolor roll dup exch cshow roll mul nnlm grestore add roll frequency dup exch seconds roll nnpc cshow mul add duration roll dup cshow exch djf roll mul column add srgb rshow bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch connect dmyk yrad exch rshow xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix cholesky psbegin rshow psdict begin psenteredstate save ajf psend psenteredstate weh restore end psbegin setmiterlimit ynk slw polyline hsc clp ejh col rcb times-roman findfont scalefont qcb setfont colshow times-roman qcb findfont scalefont ejp setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow ellipse drawellipse cols ellipse drawellipse cols times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont hifqs bqv iit fpc setfont pts colshow times-roman findfont scalefont setfont lef colshow polyline cols polyline cols polyline arcto pop hur repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline arcto pop repeat arcto pop repeat arcto pop snc repeat arcto pop repeat clp cols polyline dtgyd arcto pop jsj repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont colshow polyline arcto pop dtf repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont database colshow begin arrows rgbt line width line width line width line width line width slw polyline cols clp setgray cols key line width slw polyline cols lxgs ijd glw clp setgray cols line width line width line width slw polyline ydb cols iid clp setgray cols ljo line width slw polyline cols eos pqm clp setgray -vei cols line width slw polyline cols -oww hjju clp setgray cols line width slw polyline cols qcc clp setgray dws cols end arrows times-roman findfont nvfvc scalefont setfont colshow psend tlbs restore enddocument endtexfig figure eighted message destinations width wua bar proportional number bytes node fqa node number messages make lar gest arro node represents communication traf web workload arro represents traf database workload xjbnv highest node jbp highest widths scaled bfvd factor gures comparable eop page bop out-bound communication indicating bytes read written web workload byte-weighted diagram eals data nodes nodes ebj qsb zsa node etd hea byte ngr nih hsne mentioned sap-serv traf note total bytes workload signi cantly make msgs msgs etl hlf qbi yix msgs jmx ouj eyz ovp jtw gxz rshow ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff sample rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures duration daemon fdfeffbfeffbfe eps ffbfeffbfeffbfc fdff fdfeffbfe gnudict dict feffbfdff fdff gnudict begin feffbfeffbfeff color fdff false fdfeff solid ffbfeffffdff false fdfeffbfeffbfe gnulinewidth vshift ffbfeffbfeffbfc fdff fdfeffbfe mul feffbfdff fdff hpt feffbfeffbfeff vpt fdff fdfeff moveto ffbfeffffdff bind lineto bind fdfeffbfeffbfe ffbfeffbfeffbfc rmoveto fdff bind fdfeffbfe 
feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe rlineto feffbfdff fdff feffbfeffbfeff fdff bind fdfeff ffbfeffffdff vpt vpt mul hpt fdfeffbfeffbfe hpt mul ffbfeffbfeffbfc fdff lshow fdfeffbfe currentpoint feffbfdff stroke fdff vshift feffbfeffbfeff show fdff rshow fdfeff currentpoint ffbfeffffdff stroke dup stringwidth pop fdfeffbfeffbfe neg vshift ffbfeffbfeffbfc show fdff fdfeffbfe cshow feffbfdff currentpoint fdff stroke feffbfeffbfeff dup stringwidth fdff pop fdfeff div ffbfeffffdff vshift show fdfeffbfeffbfe color setrgbcolor ffbfeffbfeffbfc solid fdff pop fdfeffbfe setdash feffbfdff pop fdff pop pop feffbfeffbfeff solid fdff pop fdfeff setdash ffbfeffffdff ifelse stroke gnulinewidth fdfeffbfeffbfe mul ffbfeffbfeffbfc setlinewidth fdff stroke fdfeffbfe feffbfdff gnulinewidth div fdff setlinewidth feffbfeffbfeff fdff stroke fdfeff gnulinewidth ffbfeffffdff setlinewidth ltb fdfeffbfeffbfe lta ffbfeffbfeffbfc fdff fdfeffbfe setdash feffbfdff setrgbcolor fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff stroke setdash currentlinewidth div currentlinewidth stroke stroke fdfeffbfe setdash copy feffbfdff vpt fdff add hpt feffbfeffbfeff neg vpt fdff neg fdfeff hpt vpt ffbfeffffdff neg fdfeffbfeffbfe hpt vpt hpt neg vpt ffbfeffbfeffbfc closepath fdff stroke fdfeffbfe feffbfdff fdff stroke setdash feffbfeffbfeff vpt fdff vpt fdfeff currentpoint ffbfeffffdff stroke hpt neg vpt fdfeffbfeffbfe neg hpt ffbfeffbfeffbfc fdff stroke fdfeffbfe feffbfdff stroke fdff setdash copy feffbfeffbfeff exch fdff hpt fdfeff exch vpt ffbfeffffdff add vpt neg fdfeffbfeffbfe hpt vpt ffbfeffbfeffbfc fdff hpt neg fdfeffbfe closepath feffbfdff stroke fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe stroke ffbfeffbfeffbfc setdash fdff exch hpt fdfeffbfe exch feffbfdff vpt add fdff hpt feffbfeffbfeff vpt neg fdff currentpoint fdfeff stroke ffbfeffffdff hpt neg hpt fdfeffbfeffbfe vpt ffbfeffbfeffbfc stroke fdff fdfeffbfe stroke feffbfdff setdash fdff copy feffbfeffbfeff vpt mul fdff add fdfeff hpt ffbfeffffdff neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb fdfeffbfeffbfeff rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate slowdown cshow grestore frequency seconds cshow duration cshow column rshow connect rshow cholesky rshow rshow sample rshow stroke grestore end showpage enddocument endtexfig figure slowdown indep enden daemon esses duration daemon pro cesses left-most graph righ t-most graph ter-arriv time daemon pro cesses aried een seconds haracteristic daemon activit ter-arriv times seconds durations parallel application exp erience slo wdo wns daemon run time terv cron update routed xdec init negligibl negligibl daemon ctivity decstation running ultrix table sho erage execution times terv als een cations daemon pro cesses measured hour erio mac hine idle user activit cron runs jobs erio ically update syncs disks routed net ork routing daemon xdec serv lastly init paren pro cesses mak progress daemon executing orkstations ene cial cosc hedule dae- mon pro cesses section examine ects cally-sc hed daemon pro cesses parallel application erformance sim ulate ect daemons arriving indep enden tly orkstations terv als seconds durations results figure sho parallel applicatio slo in- terruptions haracteristic curren daemon activit ter- estingly larger terruption durations application signi increase execution time extreme case application slo factor erio dic system activ- ccurs execution times ecec results cosc heduling suc cccc activit erhaps ironic note increased activit caused daemons required build monitor orkstation ailabil ccccc cal-area net rks bus-based cal-area net dcfcfc orks initdictcount countdictstack gsave save mark newpath showpage dict begin arrowheight arrowwidth null numgraphicparameters stringlimit begin save numgraphicparameters dict begin end end restore setb dup type nulltype pop false brushrightarrow idef false brushleftarrow idef true brushnone idef brushdashoffset idef brushdasharray idef brushrightarrow idef brushleftarrow idef brushwidth idef false brushnone idef ifelse setcfg fgblue idef fggreen idef fgred idef setcbg bgblue idef bggreen idef bgred idef setf printsize idef printfont idef setp dup type nulltype pop true patternnone idef patterngraylevel idef patterngraylevel patternstring idef false patternnone idef ifelse bspl begin storexyn newpath true subspline false subspline exch dup dup add dup add dup false subspline dup dup dup copy false subspline dup dup copy copy false subspline patternnone brushleftarrow brushrightarrow ifill brushnone istroke leftarrow dup dup rightarrow end dup dict put circ newpath arc patternnone ifill brushnone istroke cbspl begin dup storexyn newpath dup true subspline exch dup dup add dup add dup false subspline dup dup dup false subspline dup dup false subspline patternnone ifill brushnone istroke poly ifelse end dup dict put elli begin newpath roll translate scale arc patternnone ifill brushnone istroke end dup dict put line begin storexyn newpath moveto lineto brushnone istroke leftarrow rightarrow end dup dict put mline begin storexyn newpath moveto exch lineto patternnone brushleftarrow brushrightarrow ifill brushnone istroke leftarrow dup dup rightarrow end dup dict put poly roll newpath moveto add lineto repeat closepath patternnone ifill brushnone istroke rect begin exch exch exch exch newpath moveto lineto lineto lineto closepath patternnone ifill brushnone istroke end dup dict put text ishow idef dup pop pop pop exch ifelse ifill begin gsave patterngraylevel fgred bgred fgred patterngraylevel mul add fggreen bggreen fggreen patterngraylevel mul add fgblue bgblue fgblue patterngraylevel mul add setrgbcolor eofill eoclip originalctm setmatrix pathbbox exch exch exch exch ceiling cvi ceiling cvi imagebytewidth div ceiling cvi imageheight bgred bggreen bgblue setrgbcolor eofill fgred fggreen fgblue setrgbcolor translate scale true neg patternproc imagemask ifelse grestore end dup dict put istroke gsave brushdashoffset setdash setgray brushdasharray brushdashoffset setdash fgred fggreen fgblue setrgbcolor ifelse brushwidth setlinewidth originalctm setmatrix stroke grestore ishow begin gsave fgred fggreen fgblue setrgbcolor fontdict printfont findfont printsize scalefont dup setfont descender fontdict begin fontbbox fontmatrix end transform exch pop vertoffset descender printsize printfont courier printfont courier-bold add vertoffset moveto show vertoffset vertoffset printsize forall grestore end dup dict put patternproc begin patternbytelength patternstring length patternheight patternbytelength mul sqrt cvi patternwidth patternheight patternbytewidth patternwidth idiv imagebytemaxlength imagebytewidth imageheight mul stringlimit patternbytewidth min imagemaxheight imagebytemaxlength imagebytewidth idiv patternheight idiv patternheight mul patternheight max imageheight imageheight imagemaxheight store imagestring imagebytewidth imagemaxheight mul patternbytewidth add string imagemaxheight exch patternrow patternbytewidth mul patternbytelength mod patternrowstring patternstring patternrow patternbytewidth getinterval imagerow imagebytewidth mul patternbytewidth imagebytewidth exch imagestring imagerow add patternrowstring putinterval imagestring end dup dict put min dup roll dup roll exch pop max dup roll dup roll exch pop arrowhead begin transform originalctm itransform taily exch tailx exch transform originalctm itransform tipy exch tipx exch tipy taily tipx tailx angle atan ifelse gsave originalctm setmatrix tipx tipy translate angle rotate newpath moveto arrowheight neg arrowwidth div lineto arrowheight neg arrowwidth div neg lineto closepath patternnone originalctm setmatrix padtip arrowheight exp arrowwidth exp mul add sqrt brushwidth mul arrowwidth div padtail brushwidth div tipx tipy translate angle rotate padtip translate arrowheight padtip add padtail add arrowheight div dup scale arrowheadpath ifill brushnone originalctm setmatrix tipx tipy translate angle rotate arrowheadpath istroke grestore end dup dict put arrowheadpath newpath moveto arrowheight neg arrowwidth div lineto arrowheight neg arrowwidth div neg lineto closepath leftarrow begin exch taily exch exch tailx exch exch tipy exch exch tipx exch brushleftarrow tipx tipy tailx taily arrowhead end dup dict put rightarrow begin exch tipy exch exch tipx exch exch taily exch exch tailx exch brushrightarrow tipx tipy tailx taily arrowhead end dup dict put midpoint begin exch exch exch exch add div add div end dup dict put thirdpoint begin exch exch exch exch mul add div mul add div end dup dict put subspline begin movetoneeded exch exch exch exch exch 
exch exch exch exch exch exch exch exch exch exch exch exch thirdpoint exch exch thirdpoint exch exch thirdpoint midpoint exch exch thirdpoint midpoint exch exch movetoneeded moveto curveto end dup dict put storexyn exch array array exch roll put roll put idraw begin cfg cbg suc make messages table presents data gures number requests doesn equal number responses dif ference number messages dropped finally pictorial vie database workload byte transfer eals traf uniform frequenc capacity message sizes rst section sho data aggre gate communication cluster section xact distrib ution message sizes workloads dif ferences workstations cluster reiterate message size sum user payload orb headers figures sho node distrib ution message sizes node nodes workloads graph depicts cumulati distrib ution message sizes node xperiment line graph weights distrib ution size message man messages size size eop page bop starttexfig begindocument figures length make eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent cshow grestore message size bytes cshow message size breakdown make cshow cumulative message count rshow cumulative message size rshow concat originalctm matrix currentmatrix type plot -help information begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat compute text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat comm text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat sync text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat barrier text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat switch text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat idle text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin stroke grestore end showpage enddocument text cfg endtexfig black setcfg helvetica-medium-r helvetica setf starttexfig begindocument concat figures length text make end begin eps text gnudict cfg dict black gnudict setcfg begin color false helvetica-medium-r solid false gnulinewidth vshift mul helvetica setf hpt vpt concat moveto bind text end lineto bind begin text rmoveto cfg bind black rlineto setcfg bind vpt helvetica-medium-r vpt mul helvetica hpt setf hpt mul lshow currentpoint stroke vshift concat show fractionoftime rshow text currentpoint end stroke begin dup text stringwidth cfg pop neg black vshift setcfg show helvetica-medium-r cshow currentpoint stroke helvetica setf dup stringwidth pop div concat vshift text end begin text show cfg black setcfg color setrgbcolor helvetica-medium-r solid pop helvetica setf setdash pop pop pop concat solid text pop end setdash begin ifelse text cfg stroke black gnulinewidth setcfg mul helvetica-medium-r setlinewidth helvetica stroke setf gnulinewidth div concat setlinewidth text stroke end gnulinewidth begin setlinewidth text cfg ltb black setcfg helvetica-medium-r lta helvetica setf setdash setrgbcolor concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end stroke setdash begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline currentlinewidth setb div cfg black setcfg currentlinewidth cbg white stroke setcbg setp stroke setdash copy concat vpt mline add end hpt begin neg mline vpt neg hpt vpt neg setb cfg hpt vpt black hpt setcfg neg cbg vpt white closepath setcbg stroke setp stroke setdash concat vpt vpt currentpoint mline stroke end begin hpt mline neg vpt neg setb hpt cfg black stroke setcfg cbg white stroke setcbg setdash setp copy exch hpt concat exch vpt add mline end vpt begin neg mline hpt setb vpt cfg hpt black setcfg neg cbg closepath white stroke setcbg setp stroke setdash concat exch hpt 
exch vpt add hpt vpt neg currentpoint stroke mline hpt end neg begin text hpt cfg vpt black stroke setcfg helvetica-medium-r stroke helvetica setdash setf copy vpt mul add hpt concat neg vpt text end mul begin mline hpt mul setb hpt cfg neg black setcfg vpt cbg mul white closepath setcbg stroke setp copy end concat gnudict begin gsave translate mline scale end setgray begin helvetica mline findfont scalefont setb cfg setfont black newpath setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin lta mline ltb setb cfg black setcfg cbg rshow white setcbg setp rshow concat rshow mline end rshow begin mline setb cfg rshow black setcfg cbg white setcbg rshow setp concat mline cshow cshow cshow cshow cshow end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp cshow concat mline end begin mline cshow setb cfg black setcfg cbg white cshow setcbg setp concat currentpoint gsave mline translate end begin rotate mline percent cshow setb grestore cfg message black size setcfg bytes cbg white cshow setcbg message size setp breakdown make concat cshow cumulative mline message end count begin mline rshow setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end cumulative begin message mline size setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r rshow helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures length make eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke cfg black dup setcfg stringwidth cbg pop white div setcbg vshift show setp color setrgbcolor solid concat pop setdash pop pop pop solid pop mline end setdash begin ifelse mline stroke gnulinewidth setb mul cfg setlinewidth black setcfg stroke cbg gnulinewidth white div setcbg setlinewidth setp stroke gnulinewidth setlinewidth concat ltb mline end begin lta mline setdash setrgbcolor setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp stroke setdash concat currentlinewidth div currentlinewidth mline stroke end begin mline stroke setdash copy vpt setb add cfg hpt black neg setcfg vpt neg cbg hpt white vpt setcbg neg hpt setp vpt hpt neg vpt concat closepath stroke mline end stroke begin setdash mline vpt vpt currentpoint setb stroke cfg hpt black neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent cshow grestore message size bytes cshow message size breakdown make cshow cumulative message count rshow setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg ethernet fddi supp ort aggregate bandwidth latency needed man mpp applications reay son setp historically run coarse-grained concat parallel programs recen mline tro end duction begin mline switc h-based setb lans cfg suc black setcfg cbg biagioni white setcbg switc setp hed ethernet concat anderson mline end begin mline myrinet setb cfg den black setcfg cbg white setcbg increases feasibili setp running concat general-purp ose parallel mline end application begin text cfg black setcfg helvetica-medium-r deliv ered helvetica setf bandy width synoptics concat ore text end cisco begin mline equipy men setb cfg comparable black setcfg deliv ered cbg white setcbg bandwidth setp thinking mac hines concat cmb similarly mline end myrinet begin mline ectiv ely setb cfg mpp bac black setcfg kplane cbg 
repac white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline aged lan ers bandwidth oth vironmen comm unication erheads latencies lans app ear lag mpp net orks generation ned logp culler del overy length time pro cessor engaged transmission reception message latency upp ound dela setb cfg source black pro setcfg cbg cessor white setcbg destinay setp tion concat comm unication proto cols suc tcp mline end add begin mline unnecessary erhead setb cfg base black hardw setcfg cbg cost white curren setcbg setp researc implemen ting concat activ messages eic mline end begin mline setb cfg sho black setcfg cbg white erheads setcbg setp reduced appro concat ximately mline end begin eic mline setb cfg black setcfg cbg martin white setcbg whic setp closer concat mline activ end begin message text erhead cfg black setcfg cme millisecon helvetica-medium-r helvetica erhead setf tcp implemen tations concat text end lik begin ewise mline latencies app setb ear cfg black setcfg cbg cony white erging setcbg mpp setp routers concat latency curren mline end begin switc mline hes setb cfg black balance setcfg cbg partially white setcbg amey liorated setp concat fact mpp routers mline end begin ypically mline setb smaller lan cfg switc black hes setcfg cbg white hops setcbg setp rey quired cross concat mpp net ork mline scaling end begin parallel applicatio execution time accoun erence comm unication erformance nony trivial problem requiring kno wledge length message mline transfers setb cfg black setcfg erlap cbg white setcbg een setp comm unication computation concat urthermore scaling tak mline accoun end begin mline increased pro setb cfg cessing black setcfg cbg white dern setcbg orkstations setp compared pro concat cessing mline eop end page bop begin mline setb cfg starttexfig black setcfg begindocument cbg figures white setcbg onenonidle eps setp gnudict dict gnudict begin concat color false solid false mline end gnulinewidth begin text vshift cfg black mul setcfg helvetica-medium-r hpt helvetica vpt setf moveto bind lineto bind concat rmoveto bind text end rlineto begin bind text vpt cfg vpt black mul setcfg hpt hpt helvetica-medium-r mul lshow helvetica currentpoint setf stroke vshift show rshow currentpoint stroke concat dup stringwidth text pop end neg vshift begin mline show setb cshow cfg currentpoint stroke black setcfg dup cbg stringwidth pop white div setcbg vshift show setp color setrgbcolor solid concat pop setdash pop pop pop mline solid end pop begin setdash mline ifelse stroke setb gnulinewidth mul setlinewidth cfg stroke black gnulinewidth setcfg div cbg setlinewidth white setcbg stroke gnulinewidth setp setlinewidth ltb concat lta mline setdash end setrgbcolor begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat stroke mline setdash end currentlinewidth begin div mline currentlinewidth stroke setb cfg stroke black setcfg setdash copy cbg vpt white add setcbg hpt neg vpt setp neg hpt vpt neg concat hpt vpt hpt neg mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke setb cfg stroke setdash black exch setcfg cbg hpt white setcbg exch vpt add setp hpt vpt neg 
currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate slowdown cshow grestore percent parallel cshow non-idle cshow column rshow connect rshow cholesky rshow rshow sample rshow slow rshow concat wsln bkq ko-o woe cnw wrt cnq bkqu ffzt ptxd kda rty lhz ptq lbi qbk gkm khk ilh ihbr lkl pvw vlh qfv -dc upty jas kzd jzv bfv-u zoymt efz dhg qfel rnn dhi ydpe --r qbz bax elt kob kwc zqsm btws bfu fvu pka sdo kd-u cpdt jcw ege tdof eyb nbj cyxj rdg mettk efyd pbku med orm xgq gwqqy ytv mcs hcc goa ezh icn jhqr ubk gwa efz dfk etl zra -qf rbh qbr bax iqy hiyx oxj-s gds int kwc zqsm btws jhn rxj det rxj eyf kd-u cpdt eti yde- hacdc hqjl rdo eppri fpd shp msh vdl qdtv zpe fyg qstv ter lkl pvw vlh qfv -dc upty jas pdu yad tar izdjo mline end begin mline sal qby mdj fch -tn setb cfg black setcfg cbg white setcbg setp concat igsd nsd mline end begin mline setb cfg black setcfg cbg white setcbg setp concat xws mline end begin mline setb cfg black setcfg krg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg lgs setp concat mline end begin mline setb cfg black setcfg cbg white setcbg sjbw setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg xyg setp bmcq concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat gxc mline end nmgo begin kdu mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat zza mline end doc begin mline setb cfg black setcfg cbg white setcbg setp pom concat gmw mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp ekt concat mline end begin mline diis setb cfg black setcfg cbg white setcbg setp xcuc concat mline end begin text cfg wit black setcfg helvetica-medium-r helvetica setf lyoduoi concat text evb dop pni end begin mline mpf setb cfg black setcfg cbg white setcbg setp jhz concat mline end begin mline aqla setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline lrl setb cfg black setcfg cbg white setcbg setp bnc concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf mdvbd concat exq text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat zom jkov mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat jhv mline end begin mline setb cfg black setcfg cbg white setcbg setp dlo concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg ccpt white setcbg setp concat mline end begin mline setb cfg black setcfg 
cbg white setcbg tlcf setp mtz concat mline end begin mline setb cfg mxcv black setcfg cbg white setcbg setp concat jqi mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline mdi setb cfg pizi black setcfg cbg white cspq setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg qzx black setcfg helvetica-medium-r vdu helvetica setf mgt concat text tnc rmgt ljt ihj jfh bdg myd mwf hjs rvk bro fjz rubd fho zom jkov jhv dlo ccpt end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg tlcf white setcbg mtz setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg mxcv cbg white setcbg setp concat mline jqi end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg tllbe cbg white setcbg setp concat mline end begin mline phs setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat hhh mline end begin mline setb rxm cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mdkc zxm mline end begin mline setb cfg black setcfg cbg white setcbg setp concat etl mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mfy mline end begin mline setb cfg black setcfg cbg white setcbg setp tnc concat mline end begin mline zxe setb cfg black setcfg cbg white setcbg setp concat mline end begin text mbej cfg black setcfg helvetica-medium-r helvetica setf ftn jqv concat text end begin mline tfu setb cfg black setcfg cbg iidrf white setcbg setp lhx concat tbd mline gxd end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin fxi mline setb cfg black setcfg cbg white elz 
setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline gpd setb cfg black setcfg cbg white setcbg setp concat mline end begin gzdv mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat currentpoint stroke ipa wcz rld iji jdac hhh eby sba text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline fqy setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mur mline xdi setb cfg black setcfg cbg white setcbg setp concat khf mline end begin z-o mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg hbk black setcfg cbg white setcbg setp concat acn mline end begin text gxh cfg black setcfg helvetica-medium-r nqg helvetica setf concat currentpoint text stroke end begin mline setb cfg black setcfg cbg white setcbg setp sgg concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline tjwy end begin mline setb cfg black setcfg cbg axr white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat etl mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mgyt mline end begin mline setb cfg black setcfg cbg white setcbg xxmr setp concat mline end begin tnc mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin biv mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white zdt setcbg setp aqla concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat vtl mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp jidlk concat dxp mline end lfuz begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb 
cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg lxh black setcfg viu cbg white setcbg setp concat wkp mline end begin c-r mline setb cfg black setcfg cbg white setcbg setp ydv concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat ivq mline end begin mline jmp setb cfg black setcfg cbg rnc white setcbg setp concat mline end uhz begin mline setb cfg k-u black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica ddrw setf kte qgeo ppv concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white fqy setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline mur xdi setb cfg black setcfg cbg white setcbg setp concat khf mline end begin mline z-o setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb hbk cfg black setcfg cbg white setcbg setp concat acn mline end begin text cfg black gxh setcfg helvetica-medium-r helvetica nqg setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat sgg mline end begin mline setb cfg black setcfg cbg white setcbg setp concat hwd mline end begin mline wpx setb cfg black setcfg cbg fmpt white setcbg setp concat rigmx vdq mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp xqj concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline xxe ein setb cfg black setcfg cbg white setcbg setp epdx concat mline end begin mline xwd setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg kfg cbg white setcbg pbsb setp sdh concat jhj sdhr rsc mline end begin mline setb cfg black setcfg cbg white setcbg setp concat jqv mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black ezs setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat fhg mline end begin text cfg black setcfg kdwk helvetica-medium-r helvetica setf concat text end begin uva mline kdse setb cfg i-it black setcfg cbg white setcbg setp concat fmuq mline end acm begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline pxj setb cfg black setcfg cbg white setcbg setp concat ajhb mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white yed setcbg setp concat dve mline end begin mline setb cfg black setcfg cbg white qgeo setcbg setp ppv concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline fqy setb cfg black setcfg cbg white setcbg stroke grestore end showpage enddocument endtexfig figure non-id workstation parallel applica- tion time-sliced round-robin mur xdi fashion sequen tial pro cess khf orkstation sequen tial z-o pro- cess alw giv time quan tum x-axis ercen tage time parallel applicatio runs non-idle hbk des mpps acn culties feel scaling gxh parallel program execution times ould result nqg arti cial results adv ances lan tec hnolo- gies lead mpp-lik net ork erformance reducing tro duce sgg scaling factors con- sider teresting area researc non-dedicated system -bhe maxkg step apdf building realistic mpp tegrate heduling jobs teractiv users parallel application follo wing sections sho teractiv jobs ect erformance paral- lel applicatio demonstrating migrate parallel pro cesses non-idle orkstations explore ect migration time throughput zfx parallel jins ap- plications finally quan tify ect bit cruitment thr eshold parallel program throughput ade interactive user assume users demand qfehy teractiv erformance orkstations sharing resources eab eij parallel applications biz olicy resulting est compromise een serial-job resp onse time parallel- application throughput lik ely dep end yce mbi qbq factors suc idle orkstations ade to- tal serial bqr orkload haracteristics parallel application kiv rst step determining zhz est olicy resource bif sharing examine tefe ect mbq terruptions execution mtc time rdm parallel enc hmarks direct sim ulation figure plots slo wdo parallel application executes orkstations orkstation shared sequen tial user parallel applicatio runs time idle xwf orkstations time-sliced round-robin lvjh fashion tzb scu sequen tial abb pro cess non-idle orkstation found applicatio eha vior falls w-o cate- gories ylb ork distributed enly pro cessors starttexfig begindocument figures summaryfinal eps gnudict dict gnudict begin color false solid false gnulinewidth vshift hiy msh mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint cvh stroke vshift kvg show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift ldp show color setrgbcolor solid nmzd pop setdash pop pop pop solid ddl pop setdash ifelse stroke gnulinewidth mul setlinewidth setp stroke gnulinewidth div setlinewidth concat stroke gnulinewidth setlinewidth ltb mline end lta begin mline setdash setrgbcolor setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white stroke setdash currentlinewidth div currentlinewidth stroke setcbg stroke setdash copy vpt setp add hpt neg vpt neg hpt vpt concat neg hpt vpt hpt mline neg end vpt begin closepath text stroke cfg black stroke setcfg setdash vpt helvetica-medium-r vpt helvetica currentpoint setf stroke hpt neg vpt neg hpt stroke concat stroke setdash text copy end exch begin hpt mline exch vpt add vpt neg setb hpt cfg vpt black hpt setcfg neg cbg closepath white stroke setcbg stroke setp setdash exch hpt exch vpt add concat hpt vpt neg currentpoint stroke hpt mline end neg begin hpt vpt mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg stroke setp stroke setdash copy concat vpt mul add hpt neg vpt mul hpt mline mul end hpt begin neg vpt mline mul closepath stroke setb copy cfg end black gnudict begin setcfg gsave cbg translate white scale setcbg setgray helvetica findfont setp scalefont setfont newpath lta concat ltb mline end begin mline rshow setb cfg black setcfg rshow cbg white setcbg setp rshow concat rshow mline end begin mline rshow setb cfg black setcfg cbg rshow white setcbg cshow setp cshow concat noon mline cshow end begin text cfg black setcfg cshow helvetica-medium-r helvetica setf cshow concat currentpoint text gsave end translate begin rotate mline percent cshow setb grestore cfg time black day setcfg cshow cbg workstation white availability setcbg cshow setp aggressive peak concat lshow condor peak lshow mline condor end begin rshow mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat jde dxbw aggressive rshow gbzc rhqd jgyv yoga yge stroke grestore end showpage enddocument endtexfig figure machine eub vailability dep ending nition ipe ailable cpt -rl mwt mac hines vqb ailable zqq giv time ggr essive nition requires min ute cpu eyb oard activit condor nition aits min utes efore declaring mac hine idle column global sync hronization erformed frey quen tly pro cessors ust ait slo est pro cessor complete forces applicati run rate non-idle orkstation sho graph hand load-im balance exists pro cessors kvhr pro cessor ork aae erio dicall terrupted application slo mwn eed slo est taxu bhe orkstation case cholesky load-im balan exists connect sample terrupted orkstation slo est erformance curv follo pro cessor orkstation een pic slo ould een summarize running parallel pro cess egins executing serial job parallel pro cess idle orkstation erformance efy fect sev ere applications migration main tain acceptable parallel program execuy tion times detrimen tal ects sequen tial resp onse times presen parallel program migrated migration viable solution idle orkstation ailable figure sho suc ailabil lik ely mline end traced begin cluster mline result setb cfg direct con black trast setcfg cbg opular white setcbg elief idle setp mac hines concat ailable mline end hours begin lazo mline wsk setb cfg black setcfg cbg ytime white hours setcbg setp orkstations concat ailable mline end giv begin text momen cfg black setcfg migration costs helvetica-medium-r orkstation qbid helvetica cycles setf ailable concat times text end begin bin mline system setb kgn migration junt cfg erhead black setcfg cbg utilize white setcbg ery setp cycles concat mline end begin mline setb cfg black setcfg cbg white setcbg rmu setp concat migration mline end costly begin mline examine setb ect cfg migration black setcfg costs cbg hky white parallel setcbg throughput setp ene concat migration yls dep ends mline end begin mline factors suc setb cfg remaining black setcfg execution cbg time white mft setcbg parallel application setp cost migrating concat pro mline end cess begin mline time setb til cfg black pro setcfg cess cbg white migrated setcbg setp understand concat teractions mline end begin feed mline high-lev setb sim cfg black setcfg lator cbg actual white setcbg setp orkstation parallel concat job traces meay mline eop end page begin bop text cfg black setcfg starttexfig helvetica-medium-r begindocument figures helvetica migfinal setf eps gnudict dict gnudict begin color false concat solid false text gnulinewidth end vshift mul hpt begin mline vpt moveto bind setb cfg lineto bind black setcfg rmoveto cbg bind rlineto bind vpt white vpt mul setcbg hpt setp hpt mul lshow concat currentpoint stroke vshift mline end begin show mline rshow setb cfg currentpoint black stroke setcfg cbg dup white stringwidth setcbg pop neg vshift setp show cshow concat xnd currentpoint stroke dup stringwidth mline pop end div begin vshift mline 
setb cfg black setcfg cbg show white setcbg color setp setrgbcolor solid pop concat nfc setdash pop pop pop gce solid pop mline end setdash begin ifelse mline stroke gnulinewidth mul setb setlinewidth cfg black stroke setcfg cbg gnulinewidth div white setlinewidth setcbg stroke setp gnulinewidth setlinewidth concat ltb lta mline end setdash begin setrgbcolor mline setb cfg black setcfg cbg white setcbg setp lqx concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg stroke helvetica-medium-r setdash currentlinewidth helvetica div setf currentlinewidth stroke stroke setdash copy concat vpt add text hpt end neg begin vpt neg mline hpt setb oae vpt cfg neg black hpt setcfg vpt cbg hpt neg white vpt setcbg closepath stroke setp stroke setdash vpt concat vpt currentpoint stroke hpt neg mline vpt neg end begin hpt mline stroke stroke setb setdash cfg copy exch black hpt setcfg exch vpt cbg add white vpt setcbg neg vwqjl hpt setp vpt hpt neg closepath concat stroke stroke mline setdash end exch begin yeb hpt mline exch vpt add hpt setb vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt dal mul add hpt neg vpt mul hpt mul hpt neg vpt mul ycy closepath stroke copy end gnudict begin gsave ekn translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow yon rshow rshow rshow cshow cfg cshow black setcfg cbg white setcbg cshow setp concat cshow cshow wdd cshow cshow cshow cshow cshow currentpoint gsave translate rotate slowdown cshow grestore migration time seconds cshow migration cost cshow workstations rshow amfnz workstations rshow gus nihf workstations rshow srtjv stroke grestore end showpage enddocument mline endtexfig end begin mline starttexfig setb cfg begindocument black figures setcfg recfinal eps cbg gnudict white dict setcbg gnudict begin color false setp solid false gnulinewidth concat vshift mul hpt mline end vpt begin mline moveto bind lineto setb bind 
cfg uyak rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow yhbs currentpoint stroke black vshift setcfg show cbg rshow white currentpoint setcbg stroke setp dup stringwidth pop neg concat vshift show cshow mline currentpoint end stroke begin dup mline stringwidth pop div vshift setb show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta cfg setdash black setcfg cbg white setrgbcolor setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r hbf stroke helvetica setf setdash currentlinewidth div concat currentlinewidth text stroke end begin stroke mline setdash copy vpt add setb cfg hpt neg black vpt setcfg neg cbg hpt vpt white neg setcbg hpt vpt setp hpt neg vpt closepath concat stroke xllrtrke mline end stroke begin setdash vpt mline vpt setb currentpoint stroke cfg hpt tba black neg setcfg vpt neg cbg hpt xet white setcbg stroke jqs setp stroke setdash copy exch concat hpt exch vpt mline add xuh end begin mline vpt neg hpt setb cfg bun vpt black hpt setcfg neg cbg closepath white stroke setcbg setp stroke setdash exch concat hpt exch vpt add mline z-z end hpt begin vpt neg mline currentpoint stroke setb hpt neg zxe hpt vpt cfg stroke black setcfg stroke cbg setdash white copy ses setcbg vpt mul add setp hpt neg vpt mul concat hpt mul mline hpt end neg begin vpt mul mline closepath stroke setb copy cfg black end setcfg gnudict cbg begin gsave white setcbg translate scale setp pff setgray helvetica findfont concat scalefont setfont newpath lta mline ltb end begin mline setb rshow cfg black setcfg cbg white rshow setcbg setp concat rshow mline xsh end begin mline rshow setb cfg black setcfg cbg white setcbg lwi bwk fcq ywqk gmq myy kli arc 
abstract empirical evaluation cray compiler perspective appeared isca remzi arpaci david culler arvind krishnamurthy steve steinberg kathy yelick recent mpp systems employ fast microprocessor surrounded shell communication synchronization logic cray-t elaborate shell support global-memory access prefetch atomic operations barriers block transfers provide detailed empirical performance characterization primitives micro-benchmarks evaluate utility compiling parallel language found raw performance machine impressive effective forms communication prefetch write shell provisions bulk transfer engine external annex register set cumbersome evaluating system context language implementation shed light important trade-offs pitfalls machine architecture full paper postscript compressed postscript 
cumulative message size rshow setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate slowdown cshow grestore recruitment threshold seconds cshow recruitment threshold cshow workstations rshow setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black workstations setcfg cbg rshow white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg workstations rshow setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat currentpoint mline stroke end begin mline setb stroke cfg black setcfg cbg white setcbg grestore end setp showpage enddocument endtexfig concat figure mline end begin mline ess migr ation setb cfg black cruitment setcfg thr cbg esholds white setcbg gure setp left demonstrates concat parallel program slo mline wdo end begin mline function setb cost cfg black pro setcfg cess cbg migration white setcbg results setp ere generated concat trace-driv mline end sim begin mline ulator clusters setb cfg black setcfg cbg white des setcbg setp -no load concat lanl jobs note mline end parallel begin jobs mline migrated setb cfg rst black detection setcfg user cbg activit white setcbg setp orkstation concat righ mline gure end sho begin mline parallel program slo setb wdo cfg black function setcfg cbg white recruitmen setcbg threshold setp assuming concat o-second migration mline cost end begin mline est slo wdo setb cfg hiev black setcfg thresholds cbg white mac setcbg hine lik setp ely remain idle concat long erio time asting man idle cycles starttexfig begindocument figures periodfinal eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke currentpoint stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow day cshow currentpoint gsave translate rotate percent time cshow grestore idle time minutes cshow idle time distribution cshow minutes lshow minutes lshow frequency rshow currentpoint stroke mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp currentpoint stroke concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg currentpoint white stroke setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end end eop end showpage countdictstack initdictcount end repeat cleartomark restore grestore enddocument endtexfig starttexfig begindocument figs bar coschedgranvarnews epsim fffe fffe ffff ffff fffc fffe fffe abab fffe fffe eeee fffe fffe babb fffe fffe eeee fffe fffe abab fffe fffe eeee fffe fffe bbba fffe fffe fffe ffff ffff fffc ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff 
ffbfeffffdff fdfeffbfeffbfeff ffa fec ffa ffb fed ffa ffb fec fed ffa ffb fed fed ffa ffa fec fec weighted rshow ffa ffb fed fed ffa ffa fec fec ffa ffb fed fed ffb ffa aaa ffa fec fec ffa ffb fed fed ffa ffb fec fed ffa ffb fed fed ffa aaa ffa fdff fec fec ffbfe fdff feffa feffa ffbfed fdff feffb fed ffbfe fdff feffa fea ffbfec fdff feffa fed ffbfe fdff feffa feffa ffbfed fdff feffb feffb ffbfe fdff feffa feffa aaa ffbfec fdff feffa feffa bfec ffbfe fdff feffa feffa ffbfed fdff feffb feffb ffbfe fdff feffa feffa ffbfec fdff feffa feffb ffbfe fdff feffa feffa ffbfed fdff feffb feffb ffbfe fdff feffa feffa aaaa ffbfec fdff feffa feffa ffbfe fdff feffa feffa ffbfed fdff feffb feffb ffbfe fdff feffa feffa ffa ffbfec fdff feffa feffb ffb ffbfeffa fdff feffbfd feffbfe ffa ffbfeffb fdff feffbfd feffb ffb fed ffbfeffa fdff feffbfd feffaa fdff ffaa ffbfeffa fdff feffbfd feffbfec ffb ffc ffbfeffa fdff feffbfd feffbfe ffa ffbfeffb fdff feffbfd feffbfed ffb ffbfeffa fdff feffbfd feffbfe ffa aac ffbfeffa fdff feffbfd feffbfec ffb ffbfeffa fdff feffbfd feffbfe ffa ffbfeffb fdff feffbfd feffbfed ffb ffb ffbfeffa fdff feffbfd feffbfe ffaa aaaa ffbfeffa fdff feffbfd feffbfec ffb ffbfeffa fdff feffbfd feffbfe ffa ffbfeffb fdff feffbfd feffbfed ffb ffbfeffa fdff feffbfd feffbfe fda ffbfea ffbfeffa fdff feffbfd feffbfec fdff ffbfed ffbfeffa fdff feffbfd feffbfe fdff ffbfe ffbfeffb fdff feffbfd feffbfed fdff ffbfed ffbfeffa fdff feffbfd feffbfe fdff ffbfea aaaa ffbfeffa fdff feffbfd feffbfec fdff ffbfed ffbfeffa fdff feffbfd feffbfe fdff ffbfe ffbfeffb fdff feffbfd feffbfed fdff ffbfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeaac ffbfeffa fdff feffbfd feffbfec fdff ffbfed ffbfeffa fdff feffbfd feffbfe fdff ffbfe bfe ffbfeffb fdff feffbfd feffbfed fdff ffbfed ffbfeffa fdff feffbfd feffbfe fdff ffbfea aaaaa ffbfeffa fdff feffbfd feffbfec fdff ffbfed ffbfeffa fdff feffbfd feffbfe fdff ffbfeffffd ffbfeffb fdff feffbfd feffbfed fdff ffbfeffd ffbfeffa fdff feffbfd feffbfeffa fdff ffbfeffea ffbfeffa fdff fdfec feffbfdff feffbfed fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfe fdff ffbfeffc ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffe aaaaa ffbfeffbfec fdff fdfec feffbfdff feffbfeffa fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffc affa ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffe ffbfeffbfed fdff fdfec feffbfdff feffbfeffa fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffc ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffe aaaaa ffbfeffbfec fdff fdfec feffbfdff feffbfeffa fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffc ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffea aaa ffbfeffbfec fdff fdfec feffbfdff feffbfeffa fdff ffbfeffd bfe ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffc dff ffbfeffbfed fdff fdfed feffbfdff feffbfeffb fdff ffbfeffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff fdfe ffbfeffffd aaaaa aff ffbfeffbfec fdff fdfec feffbfdff feffbfeffa fdff ffbfeffffd ffbfeffbfe fdff fdfe feffbfdff feffbfeffa fdff ffbfeffffd ffbfeffbfed fdff fdfeffb feffbfdff feffbfeffbfed fdff ffbfeffffd ffbfeffbfe fdff fdfeffa feffbfdff feffbfeffa fdff ffbfeffffda ffbfeffbfeffb fdff fdfeffa feffbfdff feffbfeffbfed fdff ffbfeffffd ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff ffbfeffffd ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfed fdff ffbfeffffd ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fda ffbfeffffd aaaaa ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfec fdff ffbfeffffd ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff ffbfeffffd ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfed fdff fdfed ffbfeffffd ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffd aaa ffbfeffbfeffb fdff fdfeffa feffbfdff feffbfeffbfed fdff fdfec ffbfeffffd ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffd ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfed fdff fdfed ffbfeffffd ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfeff ffbfeffffd aaaaa ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfec fdff fdfed ffbfeffffdff ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff fdfe ffbfeffffdff ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfed fdff fdfed ffbfeffffdff ffbfeffbfeffa fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfea ffbfeffffdff ffbfeffbfeffb fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfed ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfe ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfed ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfea ffbfeffffdff fdfeaaaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfed ffbfeffffdff fdfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfea aaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfea ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeaaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa aff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff deconstructing storage arrays timothy denehy john bent florentina popovici andrea arpaci dusseau remzi arpaci dusseau department computer sciences wisconsin madison abstract introduce shear user-level software tool characterizes raid storage arrays shear employs set controlled algorithms combined statistical techniques automatically determine important properties raid system including number disks chunk size level redundancy layout scheme illustrate correctness shear running numerous simulated con gurations verify real-world applicability running shear software-based hardware-based raid systems finally demonstrate utility shear case studies show shear storage management environment verify raid construction detect failures demonstrate shear extract detailed characteristics individual disks array show operating system shear automatically tune storage subsystems speci raid con gurations categories subject descriptors storage management storage hierarchies general terms measurement performance keywords storage raid introduction modern storage systems complex highend storage array tens processors hundreds disks array con gured ways commonly raidraid- raidhowever internal complexity raid arrays expose simple interface consisting linear array blocks internal complexity hidden large array exports interface single disk encapsulation advantages important transparent operation unmodi systems top storage device transparency cost users applications easily obtain information storage system storage systems reveal data blocks mapped underlying disks permission make digital hard copies part work personal classroom granted fee provided copies made distributed pro commercial advantage copies bear notice full citation rst page copy republish post servers redistribute lists requires prior speci permission fee asplos october boston massachusetts usa copyright acm raid con guration large impact performance reliability fact con guring modern array dif cult error-prone administrators verifying correctness setup paper describe shear user-level software tool automatically identi important properties raid tool characterize raid developers higher-level software including systems database management systems tailor implementations speci array run administrators shear understand details arrays verifying con gured raid expected observing disk failure occurred common microbenchmarking general approach shear generate controlled request patterns disk measure time requests complete applied generally similar techniques single-disk storage systems carefully constructing patterns shear derive broad range raid array characteristics including details block layout strategy redundancy scheme building shear applied number general techniques critical successful realization important application randomness generating random requests disk shear control experimental environment avoiding multitude optimizations common storage systems crucial shear inclusion variety statistical clustering techniques techniques shear automatically conclusions avoid human interpretation demonstrate effectiveness shear running simulated real raid con gurations simulation demonstrate breadth shear running variety con gurations verifying correct behavior show shear discover interesting properties real systems running shear linux software raid driver uncover poor method parity updates raidmode running shear adaptec raid controller card unusual left-asymmetric parity scheme finally demonstrate utility shear tool case studies rst show administrators shear verify correctness con guration determine disk failure occurred raid array demonstrate shear enables existing tools extract detailed information individual disks array show system knowledge underlying raid improve performance speci cally show modi linux ext system performs stripe-aware writes improves sequential performance hardware raid factor pppp striping raid stripe size pattern size pppp ppp pppp pppp parity raid left symmetric stripe size pattern size striping zig zag stripe size pattern size mirroring raid stripe size pattern size mirroring chained declustering stripe pattern pppp parity raid stripe size pattern size pppp pppp pppp parity raid left asymmetric stripe pattern pppp pppp pppp pppp qqqqpppp qqqpppp qqqqpppp qqqqpppp parity stripe size pattern size figure examples terminology picture displays number disk arrays layout patterns discussed paper numbers represent blocks parity blocks redundant data denoted italics case chunk size blocks stripe size pattern size blocks listed array depicts full patterns layout scheme rst shaded gray rest paper organized section describe shear illustrating output variety simulated congurations redundancy schemes section show results running shear software hardware raid systems section show shear improve storage administration system performance case studies finally discuss related work section conclude section shear describe shear software identifying characteristics storage system multiple disks begin describing assumptions underlying storage system present details raid simulator verify shear give intuition behavior finally describe algorithms compose shear assumptions paper focus characterizing block-based storage systems composed multiple disks speci cally assumptions shear determine mapping logical block numbers individual disks disks mirrored copies parity blocks model storage system captures common raid levels variants chained declustering assume storage system properties data allocated disks block level block minimal unit data system reads writes storage system chunk set blocks allocated contiguously disk assume constant chunk size stripe set chunks data disks shear assumes mapping logical blocks individual disks repeatable unknown pattern pattern minimum sequence data blocks block offset pattern located disk likewise pattern mirror parity blocks disks note con gurations pattern size identical stripe size raidand raidleft-symmetric pattern size larger raidleft-asymmetric based assumption shear detect complex schemes autoraid migrate logical blocks physical locations redundancy levels figure illustrates number layout con gurations analyze paper con guration disks chunk size blocks vary layout algorithm level redundancy raid systems typically signi amounts memory caching shear attempt identify amount storage memory policy replacement techniques developed applicable due random accesses steady-state behavior shear operates correctly presence cache long cache small relative storage array assumption shear initiate read requests cached perform writes overwhelm capacity cache framework makes additional assumptions assume disks homogeneous performance capacity random accesses makes shear robust heterogeneity detail assume shear access raw device access blocks directly storage system bypassing system buffer cache finally assume traf processes system found shear robust small perturbations techniques basic idea shear accessing sets disk blocks timing accesses detect blocks located disks infer basic properties block layout intuitively sets reads slow assumed located disk sets reads fast assumed located disks basic approach shear employs number techniques key operation randomness key insight employed shear random accesses storage device random accesses important number reasons random accesses increase likelihood request disk cached prefetched raid performance random access dominated number disk heads servicing requests shear easily identify number disks involved random accesses saturate interconnects hide performance differences finally random accesses tend homogenize performance slightly heterogeneous disks historical data disk bandwidth improves year seek time rotational latency improve year result disks generations similar terms random performance sequential performance steady-state shear measures steady-state performance storage system issuing large number random reads 
writes approximately outstanding requests examining steadystate performance ensures storage system prefetch cache requests important write operations temporarily buffered writeback raid cache statistical inferences shear automatically identi parameters storage system statistical techniques shear graphical presentations results veri cation human user required interpret results automatic identi cation performed clustering observed access times k-means x-means clustering shear determine access times similar blocks correlated safe operations operations shear performs storage system safe accesses read operations writes performed rst reading existing data memory writing data result shear run storage systems live data shear inspect raids disk failures performance anomalies time simulation framework demonstrate correct operation shear developed storage system simulator simulate storage arrays variety striping mirroring parity con gurations simulate raidraid- raidraid- left-symmetric left-asymmetric right-symmetric rightasymmetric layouts redundancy chained declustering con gure number disks chunk size disk storage array include cache disks storage array con gured perform similarly ibm lzx disk simulation disk storage array fairly detailed accurately modeling seek time rotation latency track cylinder skewing simple segmented cache con gured disk simulator combination methods issuing scsi commands measuring elapsed time directly querying disk values provided manufacturer speci cally simulate rotation time head switch time cylinder switch time track skew sectors cylinder skew sectors sectors track disk heads seek time curve modeled two-function equation proposed ruemmler wilkes short seek distances cylinders seek time proportional square root cylinder distance endpoints longer distances seek time proportional cylinder distance endpoints algorithm shear steps step parameter storage system identi shear determines pattern size shear identi boundaries disks chunk size shear extracts detailed information actual layout blocks disks finally shear identi level redundancy shear behaves correctly striping mirroring parity examples section begin assuming storage system redundancy show shear operates redundancy additional simulations section describe algorithmic steps detail pattern size rst step shear identi pattern size pattern size ned minimum distance blocks located disk shear operates testing assumed pattern size varying assumed size single block prede ned maximum slight unimplemented nement simply continue desired output results shear divides storage device series non-overlapping consecutive segments size shear selects random segment offset random segments issues parallel reads offset segment workload random requests repeated times completion times averaged increasing effect concurrently examining segments disk increasing conducts trials random offsets intuition algorithm nition match actual pattern size requests disks equal requests disk requests serviced parallel disks response time storage system expected requests serviced disk illustrate behavior disk raidarray block size chunk size blocks blocks blocks blocks blocks blocks blocks blocks blocks figure pattern size detection sample execution disks chunk size blocks shaded blocks read shear increments assumed pattern size compactness gure starts assumed pattern size blocks increases time blocks gure highlights blocks stride reality random blocks read pattern size detection raid disks chunks pattern size assumed time pattern size detection raid disks chunks pattern size assumed time pattern size detection raid disks chunks pattern size assumed time figure pattern size detection simulations graphs show results running pattern size detection algorithm raidwith chunks disks actual pattern size blocks figure shows location reads assumed pattern size increased sample execution top graph figure shows timings workload run simulator sample execution shows assumed pattern blocks requests disks result timings stride minimum sample execution shows assumed pattern blocks requests disks result timing slightly higher finally assumed pattern size blocks requests disk stride results highest time detect pattern size automatically shear clusters observed completion times variant x-means cluster algorithm clustering algorithm require number clusters priori shear selects cluster greatest completion time correct pattern size calculated greatest common divisor pattern size assumptions cluster demonstrate shear detect pattern sizes con gure simulator disks remaining graphs figure desired blocks stride disks disks located disk mark length pattern boundaries chunk size step shear identi data boundaries disks chunk size data boundary occurs blocks block allocated disk block chunk size ned amount data allocated contiguously single disk shear operates assuming data boundary occurs offset pattern shear varies pattern size determined previous step shear selects patterns random creates read request offset pattern shear selects random patterns creates read request offset mod requests issued parallel completion times recorded workload repeated trials times averaged intuition correspond disk boundary requests disk workload completes slowly correspond disk boundary requests split disks complete quickly due parallelism illustrate disk raidarray figure shows portion sample execution chunk size detection algorithm top graph figure shows timings sample execution shows equal requests disks values requests disk timing data validates result requests offset faster shear automatically determines chunk size dividing observed completion times clusters k-means algorithm selecting cluster smallest completion time data points cluster correspond disk boundaries raid chunk size calculated difference boundaries show shear detect chunk sizes striping variants begin raidand constant pattern size examine disks chunks disks chunks graphs figure desired accesses slow intervals stress boundary detection zigzag striping alternating stripes allocated reverse direction scheme shown figure graph shows rst chunks stripe large expected layout previous steps shear determine pattern size chunk size step shear infers chunks repeating pattern fall disk determine chunks allocated disk shear block block block block block block block block figure chunk size detection sample execution disks block chunks shaded blocks read shear increments offset pattern requests shown accessing pattern selected random chunk size detection raid disks chunks boundary offset assumed time chunk size detection raid disks chunks boundary offset assumed time fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff 
fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfeff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc ps-adobecreator fdff fdfeffbfe dvips feffbfdff fdff copyright feffbfeffbfeff radical fdff eye fdfeff software ffbfeffffdff title fdfeffbfeffbfe dvi pages pageorder ffbfeffbfeffbfc ascend fdff fdfeffbfe feffbfdff boundingbox fdff endcomments feffbfeffbfeff dvipscommandline fdff dvips fdfeff pre ffbfeffffdff dvipsparameters fdfeffbfeffbfe dpi comments ffbfeffbfeffbfc fdff removed fdfeffbfe dvipssource feffbfdff tex fdff feffbfeffbfeff output fdff beginprocset fdfeff tex pro ffbfeffffdff texdict dict fdfeffbfeffbfe texdict begin ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff bind fdfeff ffbfeffffdff exch fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff translate fdfeffbfeffbfe isls ffbfeffbfeffbfc false vsize mul fdff fdfeffbfe hsize mul feffbfdff fdff landplus false feffbfeffbfeff fdff rigin fdfeff isls ffbfeffffdff landplus fdfeffbfeffbfe ifelse concat ffbfeffbfeffbfc fdff resolution fdfeffbfe div feffbfdff vresolution fdff div neg feffbfeffbfeff scale fdff isls fdfeff landplus ffbfeffffdff vresolution div vsize mul fdfeffbfeffbfe exch resolution ffbfeffbfeffbfc fdff div hsize fdfeffbfe mul feffbfdff ifelse fdff feffbfeffbfeff resolution fdff vresolution vsize fdfeff ffbfeffffdff div add fdfeffbfeffbfe mul matrix currentmatrix dup ffbfeffbfeffbfc dup fdff round fdfeffbfe feffbfdff abs fdff round feffbfeffbfeff forall fdff round fdfeff exch round ffbfeffffdff exch setmatrix landscape fdfeffbfeffbfe isls true ffbfeffbfeffbfc fdff manualfeed fdfeffbfe statusdict feffbfdff manualfeed fdff true feffbfeffbfeff put fdff copies fdfeff copies ffbfeffffdff fmat fdfeffbfeffbfe fbb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff ctr fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff df-tail fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff dict fdff feffbfeffbfeff begin fdff fonttype fdfeff fontmatrix ffbfeffffdff fntrx fontbbox fbb fdfeffbfeffbfeff string base array bitmaps buildchar charbuilder encoding end dup foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop dup definefont setfont ch-width ch-data dup length ch-height ch-data dup length ch-xoff ch-data dup length ch-yoff ch-data dup length ch-dx ch-data dup length ch-image ch-data dup type stringtype ctr ctr ctr add charbuilder save roll dup base index bitmaps ch-data pop ctr ch-dx ch-xoff ch-yoff ch-height ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true ch-xoff ch-yoff ch-image imagemask restore dup type stringtype base ctr put bitmaps ctr dup dup length dup index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag array string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter note legal scaleunit hscale scaleunit div hsc vscale scaleunit div vsc hsize clip vsize clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform stroke roll grestore itransform end roll showpage itransform enddocument roll curveto endtexfig closepath pathforall newpath counttomark array astore xdf pop starttexfig put begindocument figures length make courier fnt eps invertflag gnudict paintblack dict txpose gnudict pxs begin pys color scale false ppr aload solid pop false por noflips gnulinewidth pop neg vshift pop scale mul xflip yflip hpt pop neg vpt rotate moveto scale bind ppr lineto ppr bind neg neg rmoveto ppr bind ppr rlineto neg bind neg vpt xflip vpt yflip mul hpt pop hpt neg mul lshow pop currentpoint rotate stroke ppr vshift ppr neg show neg rshow currentpoint yflip stroke xflip dup stringwidth ppr pop neg neg vshift ppr show neg cshow noflips currentpoint pop stroke pop dup rotate stringwidth pop scale div xflip vshift yflip show pop color pop setrgbcolor rotate solid scale pop ppr setdash ppr pop pop neg pop solid neg pop ppr setdash ppr ifelse neg neg stroke gnulinewidth xflip mul yflip setlinewidth pop pop stroke rotate gnulinewidth ppr div setlinewidth ppr stroke neg gnulinewidth neg setlinewidth yflip xflip ltb pop pop lta rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts setdash div setrgbcolor starttexfig psf savedstate save userdict maxlength dict begin magscale true normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf stroke psf setdash div psf currentlinewidth ury div showpage currentlinewidth stroke erasepage copypage stroke setdash copy macsetup vpt add doclip psf hpt neg llx vpt psf neg lly hpt psf vpt urx neg psf ury hpt currentpoint vpt roll hpt neg newpath vpt copy closepath roll stroke moveto roll stroke lineto setdash vpt lineto lineto vpt closepath clip currentpoint newpath stroke moveto hpt endtexfig neg end vpt psf neg savedstate hpt restore stroke beginspecial sdict begin stroke specialsave setdash save copy exch gsave hpt normalscale exch currentpoint vpt add specialdefaults vpt neg count ocount hpt dcount vpt countdictstack hpt neg setspecial closepath clip stroke newpath moveto stroke setdash rlineto exch hpt rlineto exch neg vpt rlineto add closepath clip hpt vpt neg hsc vsc currentpoint scale stroke ang hpt rotate neg rwiseen hpt rwi vpt urx stroke llx div rhiseen stroke rhi ury setdash lly copy div vpt dup mul add ifelse scale hpt llx neg neg vpt lly mul neg hpt rhiseen mul rhi ury hpt lly neg div dup vpt scale mul llx closepath neg lly stroke neg copy ifelse clip end newpath gnudict llx begin lly moveto gsave urx lly lineto translate urx scale ury setgray lineto helvetica llx ury findfont lineto scalefont closepath setfont clip newpath showpage lta erasepage copypage ltb newpath endspecial count ocount pop repeat countdictstack rshow dcount end repeat grestore specialsave restore end rshow defspecial sdict begin fedspecial end lineto rshow rlineto rcurveto savex currentpoint rshow savey setlinecap newpath stroke savex savey moveto fil rshow fill rshow cshow cshow savex savey cshow moveto ellipse endangle startangle cshow yrad xrad savematrix matrix currentmatrix xrad yrad cshow scale startangle endangle arc savematrix setmatrix cshow end endprocset texdict begin cshow disks barad-dur tic split-c doc final cshow dvi start currentpoint gsave translate rotate percent cshow grestore message size bytes cshow message size breakdown make cshow cumulative message count rshow currentpoint stroke currentpoint stroke ecec cccc ccccc dcfcfc initdictcount countdictstack gsave save mark newpath showpage dict begin arrowheight arrowwidth null numgraphicparameters stringlimit begin save numgraphicparameters dict begin end end restore setb dup type nulltype pop false brushrightarrow idef false brushleftarrow idef true brushnone idef brushdashoffset idef brushdasharray idef brushrightarrow idef brushleftarrow idef brushwidth idef false brushnone idef ifelse setcfg fgblue idef fggreen idef fgred idef setcbg bgblue idef bggreen idef bgred idef setf printsize idef printfont idef setp dup type nulltype pop true patternnone idef patterngraylevel idef patterngraylevel patternstring idef false patternnone idef ifelse bspl begin storexyn newpath true subspline false subspline exch dup dup add dup add dup false subspline dup dup dup copy false subspline dup dup copy copy false subspline patternnone brushleftarrow brushrightarrow ifill brushnone istroke leftarrow dup dup rightarrow end dup dict put circ newpath arc 
patternnone ifill brushnone istroke cbspl begin dup storexyn newpath dup true subspline exch dup dup add dup add dup false subspline dup dup dup false subspline dup dup false subspline patternnone ifill brushnone istroke poly ifelse end dup dict put elli begin newpath roll translate scale arc patternnone ifill brushnone istroke end dup dict put line begin storexyn newpath moveto lineto brushnone istroke leftarrow rightarrow end dup dict put mline begin storexyn newpath moveto exch lineto patternnone brushleftarrow brushrightarrow ifill brushnone istroke leftarrow dup dup rightarrow end dup dict put poly roll newpath moveto add lineto repeat closepath patternnone ifill brushnone istroke rect begin exch exch exch exch newpath moveto lineto lineto lineto closepath patternnone ifill brushnone istroke end dup dict put text ishow idef dup pop pop pop exch ifelse ifill begin gsave patterngraylevel fgred bgred fgred patterngraylevel mul add fggreen bggreen fggreen patterngraylevel mul add fgblue bgblue fgblue patterngraylevel mul add setrgbcolor eofill eoclip originalctm setmatrix pathbbox exch exch exch exch ceiling cvi ceiling cvi imagebytewidth div ceiling cvi imageheight bgred bggreen bgblue setrgbcolor eofill fgred fggreen fgblue setrgbcolor translate scale true neg patternproc imagemask ifelse grestore end dup dict put istroke gsave brushdashoffset setdash setgray brushdasharray brushdashoffset setdash fgred fggreen fgblue setrgbcolor ifelse brushwidth setlinewidth originalctm setmatrix stroke grestore ishow begin gsave fgred fggreen fgblue setrgbcolor fontdict printfont findfont printsize scalefont dup setfont descender fontdict begin fontbbox fontmatrix end transform exch pop vertoffset descender printsize printfont courier printfont courier-bold add vertoffset moveto show vertoffset vertoffset printsize forall grestore end dup dict put patternproc begin patternbytelength patternstring length patternheight patternbytelength mul sqrt cvi patternwidth patternheight patternbytewidth patternwidth idiv imagebytemaxlength imagebytewidth imageheight mul stringlimit patternbytewidth min imagemaxheight imagebytemaxlength imagebytewidth idiv patternheight idiv patternheight mul patternheight max imageheight imageheight imagemaxheight store imagestring imagebytewidth imagemaxheight mul patternbytewidth add string imagemaxheight exch patternrow patternbytewidth mul patternbytelength mod patternrowstring patternstring patternrow patternbytewidth getinterval imagerow imagebytewidth mul patternbytewidth imagebytewidth exch imagestring imagerow add patternrowstring putinterval imagestring end dup dict put min dup roll dup roll exch pop max dup roll dup roll exch pop arrowhead begin transform originalctm itransform taily exch tailx exch transform originalctm itransform tipy exch tipx exch tipy taily tipx tailx angle atan ifelse gsave originalctm setmatrix tipx tipy translate angle rotate newpath moveto arrowheight neg arrowwidth div lineto arrowheight neg arrowwidth div neg lineto closepath patternnone originalctm setmatrix padtip arrowheight exp arrowwidth exp mul add sqrt brushwidth mul arrowwidth div padtail brushwidth div tipx tipy translate angle rotate padtip translate arrowheight padtip add padtail add arrowheight div dup scale arrowheadpath ifill brushnone originalctm setmatrix tipx tipy translate angle rotate arrowheadpath istroke grestore end dup dict put arrowheadpath newpath moveto arrowheight neg arrowwidth div lineto arrowheight neg arrowwidth div neg lineto closepath leftarrow begin exch taily exch exch tailx exch exch tipy exch exch tipx exch brushleftarrow tipx tipy tailx taily arrowhead end dup dict put rightarrow begin exch tipy exch exch tipx exch exch taily exch exch tailx exch brushrightarrow tipx tipy tailx taily arrowhead end dup dict put midpoint begin exch exch exch exch add div add div end dup dict put thirdpoint begin exch exch exch exch mul add div mul add div end dup dict put subspline begin movetoneeded exch exch exch exch exch exch exch exch exch exch exch exch exch exch exch exch exch thirdpoint exch exch thirdpoint exch exch thirdpoint midpoint exch exch thirdpoint midpoint exch exch movetoneeded moveto curveto end dup dict put storexyn exch array array chunk exch size detection roll raid put disks roll chunks put boundary offset assumed idraw time begin cfg cbg concat originalctm matrix currentmatrix chunk size type detection plot zig -help zag disks chunks information boundary begin offset assumed mline time setb cfg black setcfg cbg white setcbg setp concat figure chunk size detection simulations rst mline graphs end raidcon begin gurations text disks cfg black chunks setcfg disks chunks helvetica-medium-r disks helvetica setf chunks graph concat zig-zag striping con compute guration text end begin alternating stripes mline allocated reverse setb direction cfg disks black setcfg chunks cbg examines turn white setcbg pair chunks setp pattern shear concat randomly selects patterns creates read requests mline end begin text chunk cfg black pattern setcfg shear selects helvetica-medium-r patterns helvetica creates setf read requests concat pattern comm text end requests begin mline pair issued setb parallel cfg black completion setcfg times cbg recorded white setcbg workload repeated setp trials concat results averaged shear examines mline end pair begin figure text shows cfg black results setcfg visualized helvetica-medium-r interesting helvetica setf experiments con gure simulator concat model sync raidand text zig-zag end begin disks text chunks cfg point black setcfg graph corresponds helvetica-medium-r pair helvetica light setf points slow access times concat fall news text disk end begin diagonal mline line graph corresponds setb pairs cfg black setcfg fall cbg white disk setcbg raidno chunks pattern allocated disk pairs shown chunk chunk chunk chunk figure read 
layout detection setp simulations rst graph concat raidthe graph zig-zag con gurations mline disks end begin chunks points text graph cfg correspond black pairs setcfg chunks pattern helvetica-medium-r accessed helvetica simultaneously setf lighter points workload nished concat slowly switch chunks text reside end begin disk mline con ict zig-zag setb cfg half black setcfg pattern con cbg icts white blocks setcbg rst setp half shown upper-left concat lower-right diagonal line automatically determine mline chunks end begin disk text shear cfg divides black completion setcfg times clusters helvetica-medium-r k-means helvetica selects setf cluster largest concat completion time shear idle infers text end chunk begin pairs text cluster cfg black setcfg physical disk dividing helvetica-medium-r chunks helvetica associative setf sets shear infer concat number primary text data disks end begin system text cfg algorithm elicits black read setcfg dependencies pairs helvetica-medium-r chunks running helvetica setf algorithm writes reads concat shear identify text write end dependencies begin text occur cfg due rotating black mirrors setcfg chained helvetica-medium-r declustering shared helvetica parity block setf raidor raidfor concat text end raidleft-asymmetric begin array text figure writing cfg blocks black setcfg time helvetica-medium-r result short helvetica response setf time operations concat spread text disks end writing begin blocks text cfg result black setcfg longer response time helvetica-medium-r share helvetica parity setf disk similarly writing blocks concat text longer end begin parity block text cfg block resides black setcfg disk helvetica-medium-r block write helvetica layout setf results reinforce conclusions read layout concat results fractionoftime text stroke distinguish end grestore begin end text raidraid- showpage cfg enddocument black endtexfig setcfg helvetica-medium-r raidand figure chained helvetica declustering setf discuss time write layouts distribution concat provide text day results end begin text section cfg redundancy black quency setcfg line helvetica-medium-r sho helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r fourth step shear identi redundancy helvetica managed setf eren array idle generally concat ratio erio text random end read distributed begin bandwidth text random cfg write line black bandwidth setcfg indicating determined helvetica-medium-r disk array idle helvetica manages setf redundancy erio detect concat redundancy min managed text shear utes end begin compares text cfg bandwidth dur black random ation reads setcfg line writes helvetica-medium-r shear creates ultiplies helvetica frequency block-sized setf random reads issues duration concat parallel times rom text end pattern begin size text detection cfg raid black pattern setcfg size idle assumed time helvetica-medium-r time helvetica setf erio chunk size detection concat raid boundary text offset assumed time time end figure pattern size chunk size detection raidwe simulate raidwith disks chunks begin rst text graph cfg con rms black setcfg pattern size helvetica-medium-r graph con helvetica rms setf chunk size concat completion shear times text end random writes begin issued text parallel cfg writes black setcfg performed safely helvetica-medium-r needed rst reading data min storage system utes writing values extra intervening traf ush caches ratio read write bandwidth compared longer expectations determine amount type redundancy measure- storage arrays men redundancy ere tak raidthe read write bandwidths eekda expected approximately activit equal storage systems single cad mirror group helvetica cluster raidthe read suring setf bandwidth parallel expected program concat throughput text write end function bandwidth begin reads mline cost balanced setb mirrored pro disks cfg cess black writes migration setcfg propagate cbg note white disks setcbg sim generally ulator setp ratio mak read bandwidth write concat conserv bandwidth exposes ativ number assumption mirrors mline systems end begin pro raidparity mline cess write bandwidth roughly setb cfg fourth eing black read setcfg mi- bandwidth cbg grated small white write setcbg requires pro reading setp cesses existing disk contents parallel concat applicatio parity mak writing mline end begin values progress back mline disk setb raidarrays othesis cfg black bandwidth setcfg ratio migration cbg varies white number setcbg rare disks case setp single ea- parity ger disk concat bottleneck makes douglis raidmore dif ousterhout mline cult end identify begin mline discuss erformance setb section cfg problem black arises optimized setcfg cbg redundancy figure detection white sho algorithm setcbg setp parallel solely reads pro- shear concat grams writes writes -no conjunction cluster mline reads end high essential begin migration shear mline costs observe setb cfg difference slo black wdo case setcfg cbg block white read setcbg case block parity mirrors committed disk depending speci storage system test writes buffered time written stable storage setp systems risk concat data loss mline desktop end drive begin mline reporting enabled setb higher-end cfg arrays black setcfg amount cbg non-volatile ram white setcbg setp safely delay writes concat acknowledged case shear mline end avoid begin effects text buffering cfg move black setcfg steady-state domain helvetica-medium-r inducing disk helvetica setf writes issued manner shear concat achieves text simple end adaptive begin technique mline basic idea setb redundancy cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp detection algorithm shear monitors concat write bandwidth write phase mline write end performance begin mline 
fast setb previously cfg observed black read setcfg performance cbg shear concludes white setcbg pattern size setp detection raid left symmetric concat pattern size assumed time mline end begin mline setb cfg black setcfg cbg white setcbg setp pattern size detection concat raid left asymmetric pattern size mline assumed end time begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline pattern size end begin detection raid text cfg symmetric black pattern setcfg size assumed helvetica-medium-r time helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black pattern setcfg size cbg detection raid white setcbg asymmetric pattern setp size assumed time concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline figure pattern size detection raidwe simulate raidwith left-symmetric left-asymmetric right-symmetric right-asymmetric layouts con guration disks chunk size pattern size raidleft-symmetric rest writes buffered written disk round writes initiated eventually writes ood write cache induce storage system desired steadystate behavior writing data disk shear detects transition observing writes longer faster reads slower explore issue experimentation section identifying layouts finally shear pattern size chunk size read layout write layout redundancy information attempt match observations schemes raidleft-asym- metric match found shear rst re-evaluates number disks system instance number disks doubled raidand incremented raidshear completes reporting total number disks array chunk size layout observed match found shear reports discovered chunk size number disks reports speci algorithm unknown assuming chunks allocated sequentially disks shear produce suspected layout based observations figure read write layout detection raidwe simulate left raidleft-symmetric left-asymmetric right-symmetric right-asymmetric disks rst row displays read layouts row shows write layout graphs pattern size detection raid pattern size assumed time read layout chunk size detection raid boundary offset assumed time write layout figure pattern size chunk size layout detection raidwe simulate raidwith disks chunks rst graph con rms pattern size detected graph shows chunk size detected read layout graph resembles raidbut write layout graph uniquely distinguishes raidfrom parity-based schemes redundancy simulations section describe shear handles storage systems redundancy begin showing results systems parity speci cally raidraid- mirroring variants raidand chained declustering simulations storage array disks chunk size purpose comparison present base case raidin figure parity shear handles storage systems parity blocks form redundancy demonstrate variants raidraid- redundancy raidraid- calculates parity block stripe data location parity block rotated disks raidcan number layouts data parity blocks disks left-symmetric left-asymmetric right-symmetric right-asymmetric left-symmetric deliver bandwidth layout pattern size equal stripe size raidin raidlayouts pattern size times stripe size pattern size detection pattern size assumed time read layout chunk size detection boundary offset assumed time write layout figure pattern size chunk size layout detection present simulated results redundancy disks chunk size rst graph con rms pattern size detected graph shows chunk size detected read layout graph resembles raidbut write layout graph distinguishes schemes pattern size results raidsystems shown figure rst graph shows pattern size leftsymmetric identical raidthe graphs show left-asymmetric right-symmetric right-asymmetric pattern sizes chunks expected note apparent noise graphs x-means clustering algorithm correctly identify pattern sizes chunk size algorithm behave differently raidversus raidtherefore omit results figure shows read layout write layout graphs raidnote raidvariants leads distinct visual image light points correspond dependent chunk pairs slow points dark correspond independent chunk pairs offer fast concurrent access read dependence occurs chunks located disk write dependencies occur chunks reside disk share parity disk interference parity disk instances result overburdened disk longer response time graph depicts pattern-sized grid accounts pairs chunks raidleft-asymmetric read layout graph chunk chunk grid points pair chunk chunks light color chunks located disk knowledge shear identify storage system standard raidvariants calculate number disks raidraid- calculates single parity block stripe data parity blocks reside single disk pattern size chunk size read layout write layout results raidare shown figure pattern size parity disk invisible read-based workload read layout graph resembles raidresult pattern size equal stripe size disk occurs pattern hand write layout graph raidis unique parity disk bottleneck writes pairs chunks limited single disk exhibit similar pattern 
size detection raid pattern size assumed time read layout chunk size detection raid boundary offset assumed time write layout figure pattern size chunk size layout detection raidwe present simulated results raidwith disks chunk size rst graph con rms pattern size detected graph shows chunk size detected read layout write layout graphs resemble raidcompletion times bottleneck produces raidwrite layout graph allowing distinguish raidfrom parity schemes demonstrate shear handles parity schemes show results detecting pattern size chunk size redundancy raidin parity scheme stripe parity blocks calculated reed-solomon codes layout left-symmetric raidin figure rst graph shows pattern size detected graph shows chunk size figure shows read layout write layout graphs read layout graph resembles raidthe write layout graph exhibits distinct performance regions slowest time occurs requests chunk disk repeating pattern fastest time occurs requests parity updates spread evenly disks instance pairing chunks middle performance region occurs parity blocks chunk con ict data blocks chunk testing chunks half parity updates chunk fall disk chunk unique write layout distinguish parity-based schemes mirroring algorithms shear handle storage systems mirrors impact mirrors greater parity blocks read traf directed mirrors key assumption make reads balanced mirrors reads primary copy shear detect presence mirrored copies demonstrate shear handles mirroring simple raidand chained declustering raidthe results running shear disk raidsys- tem shown figure note pattern size raidis half raidgiven chunk size number disks rst graph shows raidpattern size inferred shear reads offsets pattern requests mirrors desired worst performance occurs request offset equal real pattern size case requests serviced pattern size detection chained declustering pattern size assumed time read layout chunk size detection chained declustering boundary offset assumed time write layout figure pattern size chunk size layout detection chained declustering present simulated results chained declustering disks chunk size rst graph con rms pattern size graph shows chunk size detected wider bands read layout write layout graphs show neighboring chunks mirrored total disks uniquely identi chained declustering disks illustrated end endprolog beginsetup feature resolution dpi texdict begin endsetup page bop empirical aluation cra y-t compiler ersp ectiv remzi arpaci vid culler arvind krishnam urth stev stein erg katherine elic computer science division univ ersit california berk eley abstract recen mpp systems emplo fast micropro cessor surrounded shell comm unication sync hroniza- tion logic cra y-t pro vides elab orate shell supp ort global-memory access prefetc atomic erations barriers blo transfers pro vide detailed empir- ical erformance haracterization primitiv cumulative times message size rshow systems micro-b enc mi- gration costs slo wdo attributed hmarks larger dead time parallel program exp eriences proy gram aits migration complete efore con tin uing ersions condor system require min utes migration litzk solomon correy onding slo aluate wdo cluster high migration costs negativ ects utilit iny teractiv compiling users parallel language ait found longer parallel pro erfor- cesses mance evicted mac hine orkstations impressiv efore rey suming ec- tiv ork forms note comm unication ect prefetc write dramatic shell clusters pro visions suc orkstations bulk transfer resources idle mac hines ailable miy gration ccurs stroke grestore end showpage minimizing enddocument endtexfig figure impact message size distrib cost ution make engine workload external lines annex count register number set cum messages ersome node message aluating smaller system bytes con text messages language smaller implemen tation bytes shed ligh imp recruitment ortan trade-o threshold pitfalls ypical mac nition data hine arc mac transferred hine hitecture big chunks ailabil intro duction data shipped units load erage lac large-scale packets parallel transferred mac eyb hines oard ere activit data figure announced similar sho follo mutk breakdo shell livn approac make douglis including workload ousterhout observing thinking mac cumulati hines quan distrib cme titativ ution tel ely aragon deriv message sizes meik cruitment csh thr eshold cra y-t amoun diagrams approac time upper core -most system line eac aits efore harv messages realized esting state-of-the-art small ailable commercial fact micro- hine pro cessor workstations tuitiv ely memory messages system osing surrounded small bytes shell erhaps request-response -second traf additional logic encourages rey supp cruitmen ort global threshold xtent ould erations suc maximize parallel program direction com- unication ery request-response formance sync transfer douglis hronizati lar ousterhout based chunk douglis data announced ousterhout note designs demonstrate simple message mac parallel smaller hines extension bytes language speci recen support tly designed messages idle goal size extracting oided full domain erformance capabilit lik ely wer line graphs ecome mac weights una hines distrib ailabl ution basic sim ulations message con size ap- proac rey sult messages pro figure vide 
full eac erating cal memory augmen ted ric set assignmen erations collectiv global address space an- nouncemen ere follo deliv ery mac hines exp erimen implemen ting language mac hine ork supp orted part adv anced researc pro jects agency -co abt -co depart- men energy de-f national sci- ence oundation ccrb authors reac hed remzi culler arvindk sgs berkeley cra y-t registered trademark cra researc app ear ternational symp osium computer arc hitecture june assessing erformance conducted umery ous reasons pro vides ery teresting case study shell extremely elab orate seman tics hardy primitiv global erations essen tially lev language primitiv man distinct mec hanisms exist erform function cult arc hitecturally teresting design presen language implemen tation o-fold map language primitiv hardw compilation framew ork ose est primitiv establish erformance whic result complex teractions een microy pro cessor shell language implemen tation approac egins establishing actual erformance mac hine minimize additional costs follo gra y-b metho dology dey sign cumen establish functional haracy teristics hardw set micro-b enc hmarks haracterize erformance empirically ogether dictate de-generation strategy pap cumen results gra y-b language-impl emen tati study cra y-t lany guage split-c constructed extension gcc study ould apply man languages similar goals suc hpf remainder section outline language basic mac hine arc hitecture section explain micro-b enc hmarkin metho dology haracterize data access erformance individ ual including comparison standard orkstation micropro cessor dec alpha section explain language concept global address mapp analogous hardw concept iden tify erformance concerns arise extend micro-b enc hmarkin haracterize reads writes global address space section iden tify seman tic problems attributable alpha shell section memory erations erlap comm unication computation section estigate mec hanisms bulk transfer setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg plots parallel program slo wdo function small recruitmen threshold traces rey cruitmen data threshold maximizes parallel program throughput clusters alue ensures fact mac hine lik ely transferred remain lar ailable messages lead system squander ruths large amoun computer science time data een transferred lar run parallel objects objects programs figure small giv insigh nodes eop page bop -min ute ait erio starttexfig efore recruitmen begindocument figures length tolerable eps gnudict dict gnudict ytime begin hours color false half solid false idle gnulinewidth erio vshift mul min utes hpt vpt moveto bind lineto idle bind time rmoveto bind rlineto bind terv vpt als vpt mul hpt min hpt utes mul lshow currentpoint stroke eop vshift show page bop starttexfig fact worstcase time workload raidis half raidi seconds graph figure shows rshow chunk size currentpoint inferred stroke dup shear stringwidth pop neg boundary vshift show disks requests cshow currentpoint stroke dup mirrors stringwidth shear pop div automatically vshift detects show disk color boundary setrgbcolor solid workload pop time setdash increases pop pop pop requests disks disks mapping chunks disks solid single pop pattern setdash ifelse con stroke icts gnulinewidth read mul layout setlinewidth write layout graphs stroke figure gnulinewidth resemble div raidchained setlinewidth declustering stroke chained gnulinewidth declustering setlinewidth redundancy ltb scheme disks lta exact mirrors setdash setrgbcolor disk primary instance block copy block neighbor results running shear disk system chained declustering shown figure rst graph shows pattern size detected desired stroke setdash raideach read currentlinewidth request div serviced currentlinewidth disks stroke pattern size stroke identi setdash copy vpt add requests hpt disks neg vpt system neg note hpt vpt neg chained hpt declustering vpt pattern hpt size neg vpt closepath raidsince stroke disk unique stroke set setdash data vpt blocks vpt graph currentpoint figure stroke shows hpt neg block vpt chunks neg hpt detected stroke ratio stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent cshow grestore message size bytes cshow message size breakdown cshow cumulative message count rshow cumulative message size rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures length eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt 
neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cbg cshow white setcbg setp cshow cshow cshow cshow cshow cshow cshow concat mline end begin mline setb cfg black setcfg cbg white currentpoint setcbg gsave setp translate rotate percent cshow concat grestore message size bytes mline cshow end begin message mline size setb breakdown cfg black setcfg cshow cbg white cumulative setcbg message count setp rshow concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf cumulative message size rshow concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg stroke grestore white end setcbg showpage enddocument setp endtexfig concat starttexfig mline begindocument end figures begin length mline eps gnudict setb dict cfg gnudict black begin color setcfg false cbg solid white false setcbg setp gnulinewidth vshift concat mul hpt vpt mline end begin mline begindocument figures delayfinal eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow 
cshow currentpoint gsave translate rotate percent users delayed times cshow grestore number delays cshow user delays cshow cpu rshow condor rshow stroke grestore end showpage enddocument endtexfig figure delays day x-axis sho times user dela y-axis sho ercen times user dela times cpu line nition runs jobs mac hines cpu activit condor line conserv ativ nition sensitiv oth cpu eyb oard input time-sha red system section ects parallel pro- grams teractiv users parallel pro cesses migrated user re- turns orkstation lik ely notice hea parallel orkload form extra paging activit slo resp onse times decreased applicatio erformance section quan tify users notice extra parallel load estimate oten tial costs terrup- tion prop ose cial ontr act reducing anno ances teractiv users tolerable lev user interruptions order successful user dela ust ept bare minim user delays ned times teractiv users return orkstation parallel job running mac hines orkstation state hanged par- allel job ran completion dela consist comp onen time imp ort user previous con text time exp ort parallel job mac hine running time user return mac hine cruitment olicy iden orkstation ailable run parallel job olicy migh mac hine ailable erage cpu uti- lization min ute figure sho cum ulativ graph recruit- men olicies ect dela teractiv users rst recruitmen olicy cpu classi mac hine ailable erage cpu utilization min ute erio suc olicy unluc user ould dela times measured orkload recruitmen olicy metho similar condor mutk livn mac hine ailable erage cpu utilization eyb oard activit oth minim min utes user-sensitiv olicy signi tly etter starttexfig begindocument figures reclaim final eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid examine pop setdash pop pop pop family solid pop sync setdash hronization ifelse issues stroke section gnulinewidth mul setlinewidth nally stroke gnulinewidth div setlinewidth close stroke section gnulinewidth setlinewidth ltb illustrate lta nal program erformance setdash setrgbcolor scalable application ery nel eac sections outline requiremen language del stroke setdash ell currentlinewidth div structure constrain currentlinewidth stroke stroke erformance setdash copy haracteristics vpt add hpt mac neg vpt hine neg hpt dictate vpt neg hpt vpt hpt language neg vpt implemen closepath stroke ted stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg eop hpt vpt page bop stroke stroke language setdash copy vpt mul overview add hpt neg vpt split-c mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont simple newpath parallel lta extension ltb program- ming rshow distributed memory mac hines rshow global address space rshow abstraction een implemen ted rshow cm- aragon spf rshow ariet net orks rshow orksta- tions activ cshow messages implemen global cshow ad- dress space cshow language follo wing salien cshow features program cshow comprised thread con trol eac pro cshow cessor single image cshow threads teract reads cshow writes shared data referenced currentpoint gsave translate glob rotate percent ointers cshow spr grestore message arr size ays bytes cshow message size system breakdown ensures cshow compiler cumulative distiny message count guish rshow cal accesses global accesses global access address cal proy cessor threads sync hronize global barriers allo long latency remote access mask cumulative message split-phase size non-blo rshow kin arian read write called put pro vided giv global oin ter cal ariable initiates global address stroke grestore end initiy ates showpage put enddocument left-hand side unde ned til sync statemen issued sync aits completion endtexfig ending puts bulk transfer global address starttexfig space begindocument figures length eci eps gnudict blo dict gnudict begin king color false non-blo solid false king forms gnulinewidth vshift form mul write hpt called vpt stor moveto bind pro lineto vided bind exp rmoveto bind ose rlineto bind ciency vpt vpt one-w mul hpt comm hpt unication mul lshow currentpoint stroke algoy rithms vshift show comm rshow unication currentpoint stroke pattern dup stringwidth kno pop neg vshift adv show ance cshow threads currentpoint stroke sync dup hronize stringwidth pop div vshift completion show phase color setrgbcolor solid stores pop data-parallel setdash pop programs pop pop solid pop recipien setdash ifelse stored stroke alues gnulinewidth mul setlinewidth ait stroke gnulinewidth eci div setlinewidth amoun stroke gnulinewidth data setlinewidth ltb message-driv programs lta giv setdash one-to-one setrgbcolor nature threads con trol pro cessors refer pro cessor confusion cra y-t cra y-t massiv ely parallel pro cessor consisting alpha des memory eac shell supp ort circuitry stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow pro rshow vide global memory rshow access sync hronizati rshow part terface cshow net ork cshow cshow discuss cshow features design cshow erview cshow complete functional cshow description dec alpha cshow -bit dual-issue currentpoint sec- gsave ond translate generation rotate risc percent cshow pro cessor grestore clo message size bytes mhz cshow message size breakdown cycle cshow instruction cumulative data message cac count hes rshow eac yte lines alpha setb cfg black setcfg cbg white setcbg setp concat cumulative message size mline rshow end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black stroke setcfg grestore erates end helvetica-medium-r showpage -bit enddocument data helvetica setf endtexfig alues figure concat teger message size text oating distrib end begin oin ution mline web setb workload ord cfg black setcfg bit cbg white long setcbg ord setp -bit memory concat erations accesses smaller mline data end begin mline erful setb cfg yte black manipulation setcfg cbg instruc- white setcbg tions stores non-blo lines count kin number setp loads concat stores reordered mline end begin 
mline setb cfg black setcfg cbg white setcbg worstcase setp performance messages differs concat case raidand node raidin chained mline message end declustering begin smaller ratio mline bytes raidand setb raidthe cfg ratio black setcfg messages chained cbg declustering smaller white setcbg adjacent requests setp bytes located disk boundary machines concat requests serviced disks messages mline end considered begin raidwhen lar mline requests located case setb lar cfg chunk black setcfg ger cbg requests white setcbg serviced setp disks attrib mapping uted con icts concat chained synthetic declustering nature mline end interesting begin shown workload mline remaining graphs roughly setb figure cfg chained black data declustering setcfg pair transferred cbg chunks white blocks located setcbg setp lar disks ger results concat node distinct performance regimes number mline end case begin shared text disks cfg occurs black chunks message setcfg sizes helvetica-medium-r cyclically adjacent case helvetica setf chunks directly resulting uenced wider bands sizes pre read concat vious write studies layout text end begin mline graphs sizes unix raid-ls setb vironments cfg raidraid- black setcfg sho operations cbg millions white shear setcbg overhead redundancy setp read similar pattern write les concat pattern chunk size pattern size total mline small end begin data mline raid-la lar figure shear overhead graph shows les number setb distrib cfg generated ution black phase setcfg shear cbg figure simulated white redundancy schemes setcbg shown setp raidraid- message raidleft- sizes symmetric raidleft-asymmetric web workload numbers disks gular chunks make workload dif ferent message sizes lifetime xperiment nodes bar plots number phase shear rightmost bar identical shows distrib total utions raidleft-asymmetric results predicted plotted log scale graphs y-axis roughly overhead examine messages overhead shear showing bytes scales dif disks ference added system figure plots total number bytes transferred shear generates simulation considered variety disk con gurations x-axis vary con guration y-axis plot number generated tool note raidleft-asymmetric results shown log scale y-axis graphs make observations lar messages total number case issued note simple schemes highly raidraid- dependent raidleft-symmetric http low request millions xperiment scales requests slowly disks -byte added system erse raid schemes eop page bop shear scales larger arrays starttexfig begindocument figures length run oracle raidwith eps gnudict dict leftasymmetric layout gnudict shear begin color generates false solid false gnulinewidth redundancy concat schemes vshift total number mul hpt mline scale end vpt begin reason moveto mline bind poor scaling lineto behavior bind setb cfg rmoveto bind black setcfg read cbg layout white rlineto write bind setcbg layout vpt detection setp vpt bars mul account hpt hpt mul concat traf lshow currentpoint illustrated stroke figure vshift mline show raidleft- end rshow asymmetric begin currentpoint pattern mline stroke size grows dup stringwidth setb square pop neg cfg vshift number black show disks setcfg cbg cshow layout currentpoint white algorithms stroke setcbg issue dup requests stringwidth setp pop pairs div vshift chunks show concat pattern large color patterns lead setrgbcolor solid large numbers pop mline requests setdash end pop begin pop pop mline solid serviced pop parallel setdash setb ifelse cfg raidleft-asymmetric black represents stroke setcfg extreme gnulinewidth cbg case mul white setlinewidth shear setcbg stroke setp gnulinewidth current div form shear setlinewidth concat roughly stroke gnulinewidth days setlinewidth mline complete end ltb read begin layout mline write lta layout detection setb cfg setdash black memory setcfg barrier cbg instruction required white setcbg setp serialize memory supp orts -bit virtual address space address ysical memory cra researc designed shell micro- pro cessor shell pro vides sev eral features supp ort global eration primarily shared-memory paradigm simplest lets pro cessor access memory cation mac hine standard load store instruction ysical concat mline address end begin space text cfg small black setcfg remote pro helvetica-medium-r cessor helvetica setf obtained external concat registers text called end begin dtb mline annex indexed bits ysical address additional elds eac annex con trol setb cfg remote black setcfg eration cbg alpha white load-lo setcbg setp store-conditional instructions concat read write mline end begin annex mline registers shell setb cfg supp black orts setcfg atomic-sw cbg white setcbg een shell setp register memory concat fetc incremen registers mline end pro begin mline cessor ell setb cfg global-or black setcfg global-and cbg barriers white setcbg alpha setp fetc hin concat instruction terpreted mline end begin mline setb cfg black shell setcfg cbg white setcbg binding prefetc setp prefetc concat fif whic mline end opp begin mline setb proy cessor loads memory-mapp address alpha memory barrier instruction ensures writes prefetc hes een deliv ered shell cfg additional black status setcfg bit cbg white setcbg remote setp accesses outy concat standing shell mline pro end vides begin mline system-lev blo setb cfg transfer black setcfg engine cbg white setcbg whic setp dma-transfer large blo concat con tiguy ous mline strided end begin data text cfg black remote setcfg memories finally helvetica-medium-r helvetica setf shell pro vides user-lev message concat send fif text end begin arriv mline setb cfg black setcfg cbg message white setcbg setp receiv places concat message mline user-lev end begin message mline queue setb cfg black setcfg eci cbg white user setcbg thread setp pro cessors group concat pairs share net mline end begin mline setb cfg black setcfg ork cbg white setcbg terface setp blo k-transfer concat engine -pro cessor mline end des begin mline cony nected setb cfg three-dimensional torus net black ork setcfg cbg links white setcbg net setp ork dimension-orde concat routing incurs mline end ery begin small mline latency setb hop cfg black mac setcfg hine cbg features white setcbg setp discussed detail concat sections mline end begin mline cal-no erfo setb cfg rmance black setcfg cbg section white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat tro duce micro-b enc hmarkin metho ology examine structure costs cal memory system results pro critical undery standing costs consistency issues global eray tions ecause memory system primary gatew shell micro-b enchma rking benc hmarking massiv ely parallel pro cessors refers measuring execution time set applicatio suc arkbenc erfect club designed represen meaningful orkload measures erformance system includin pro cessor memy ory system compiler whic taking xed results erformance individual comp onen system whic imp ortan dev eloping compiler man cases optimizing applications pap tak eren path ard erfory mance aluation inspired saa edra micro-b enc hmarks treat system gra admitting priori kno wledge system oth incomplete eri simple prob determine parameters haracteristics mac hine ork ottom-up analyzing simplest primitiv rst results understand increasingl complex mec hanisms prob written assem bly language measurey men ect actual hardw costs erhead icted compiler message passing library eop page bop starttexfig begindocument newfigures final local cray eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color 
setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time nanoseconds cshow grestore stride bytes cshow cray alpha local memory hierarchy cshow cache lshow main memory lshow off-page access lshow off-page access bank lshow rshow mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat 
mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg rshow setp concat rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument newfigures final local dec eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat raidleft-asymmetric disks mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat reduce text end factor begin ten mline issuing fewer disk setb pairwise cfg trial black reducing setcfg run time cbg decreasing white con setcbg dence layout setp results real platforms concat section present results applying shear mline end begin real platforms mline rst linux setb software raid cfg device black driver setcfg cbg white adaptec setcbg hardware raid setp controller understand concat behavior shear real systems ran mline end large begin variety mline software hardware con setb urations cfg varying black number setcfg disks cbg chunk white size setcbg redundancy scheme setp results expected concat revealed slightly surprising mline properties end begin systems mline test setb raidmode cfg black setcfg cbg white setcbg setp hardware concat controller employs left-asymmetric mline end begin parity mline read write ratio setb region size cfg black setcfg cbg effect white region setcbg size quantum setp atlas ibm ultrastar lzx concat seagate cheetah figure mline end sensitivity begin region mline size gure plots setb bandwidth cfg ratio black series setcfg cbg random read requests compared white series setcbg random write setp requests x-axis varies concat size region mline end experiment begin run text cfg run black sector-sized read write requests issued lines plotted disks quantum atlas wls ibm lzx setcfg seagate cheetah bandwidth amount written effect write buffering figure avoiding write buffer gure plots performance writes top raidhardware writebuffering enabled x-axis varies number writes issued y-axis plots achieved bandwidth placement due space constraints concentrate challenging aspect shear redundancy detection experimenting redundancy detection uncovered issues addressed produce robust algorithm rst size helvetica-medium-r region helvetica setf test run figure plots read concat write ratio text single end disk begin text size cfg region black varied setcfg gure size region test conducted strongly uence outcome tests quantum disk desired ratio roughly achieved small region sizes ratio grows disk helvetica-medium-r reason helvetica undesirable setf ation large settling concat time text quantum end disk begin conclude mline redundancy setb detection cfg algorithm black run setcfg cbg small white portion setcbg disk setp odds desire run concat small portion disk mline issue end begin presence mline writeback cache setb cfg raid black setcfg adaptec cbg card white setcbg congured perform setp write buffering host concat writes complete quickly mline disk end begin mline time note presence setb cfg black buffer setcfg cbg white affect data setcbg integrity setp buffer non-volatile concat redundancy detection algorithm issue mline write end requests begin disk mline compare read request setb timings cfg shear black setcfg cbg white raid-la setcbg setp raidraid- raidr ratio concat read write bandwidth ratios software raid mline hardware end raid begin figure mline redundancy detection gure setb plots cfg ratio black read setcfg write cbg bandwidth white variety setcbg disk con setp gurations x-axis varies concat number disks con mline end guration begin raidraid- mline raidor setb raidleft-asymmetric cfg black setcfg software cbg hardware white raid setcbg circumvent setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp 
concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat translate scale setgray helvetica mline end findfont begin scalefont setfont mline newpath lta setb ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time nanoseconds cshow grestore stride bytes cshow dec workstation memory hierarchy cshow cache lshow cache lshow main memory lshow main memory tlb lshow cache tlb lshow rshow rshow rshow cfg black setcfg cbg white setcbg setp concat rshow rshow rshow rshow rshow rshow rshow rshow rshow stroke grestore end showpage enddocument endtexfig figure memory hier chy comp arison erage read latency cra y-t dec alpha cal read latency rst exp erimen haracterizes latency cal read idea generate con trolled stream addresses memory system stim ulus observ re- onse terms erage latency memory access arying parameters address stream arying stim ulus observing ariations resp onse infer eci prop erties memory system prob deriv sligh ca- tions simply steps arra giv size giv stride increasing size arra increase range addresses stream increasing stride increase frequency whic address aries high stim ulus wto oth describ pseudo-co arraysize arraysize arraysize stride stride arraysize stride arraysize stride memory operation surround innermost additional rep eats exp erimen mitigate timer gran ularit obtain suitable con dence lev address calculation erhead subtracted rep orted time ects time requisite memory er- ation separate prob reads memory cation writes memory cation note yte ord eac case plot erage la- tency curv function stride range arra sizes results read exp erimen sho left ortion figure graph sho reads tak erage nanoseconds arra sizes matc hing cycle time mhz micropro cessor published size on-c hip rst-lev data cac resp ectiv ely note read issues cycle result accessible cycles size arra exceeds size data cac reads egin generate misses erage access time eigh ted sum hit time miss time ection oin ccurs ery read generates miss oin rev eals cac he-line size ytes full memory access time roughly cycles cac direct mapp ecause access time drop cac he-hit time large strides cac asso ciativit ould een drop stride half arra size addresses eing accessed ould single set arra size stride con tin increase rise latency ect due ternals dram strides greater result -page dram accesses eac subsequen load net result additional cycles latency strides ect sligh tly orse due organization memory system memory banks ery access stride accesses bank exp osing full memory-cycle time brings total orst-case memory access cycles systems secondary increase latency indicativ translation ok-aside tlb whic cac hes limited virtual ysical translations rise ccurs small arra size caused tlb costs ould imply -en mline end tlb smallest ossible page size absence rise latency attributable tlb designers hosen ery large page sizes ossibly ecting heritage supp orting virtual memory resolv begin oten mline tially cult setb cfg de-generation black issue setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg global setp oin ters concat discussed mline end begin section mline graph setb sho cfg black setcfg cbg white second-lev setcbg setp cac concat cac mline end begin ould text rev eal cfg black setcfg helvetica-medium-r termediary helvetica latency setf een cac concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cost cbg white setcbg full memory setp access time comparison figure sho read latency pro dec alpha orkstation whic con tains concat micropro cessor dec mline end begin mline setb cfg eren black memory setcfg system cbg white graph setcbg sho setp distinct concat sets curv corresp onding mline end begin -kb mline cac setb cfg -kb black setcfg cac cbg white main setcbg memory setp concat ection oin stride mline end begin due mline tlb misses setb cfg black setcfg cbg page size white setcbg setp orkstation concat notice main mline memory end access begin require mline setb cfg cyy cles black setcfg cbg orkstation white setcbg setp cycles concat supp mline end orts begin text endors cfg claim black setcfg eliminatin helvetica-medium-r helvetica cac setf allo higher memory concat bandwidth text end begin mline streamy ing setb cfg black ery setcfg large cbg data white sets setcbg setp ypical ector-st concat yle scien mline des end begin mline deliv roughly setb cfg black setcfg cbg memory white setcbg pro cessor setp orkstation concat half mline amoun end begin mline eop page bop setb cfg black setcfg cal cbg white rites setcbg setp prob whic concat dates arra mline end begin mline pro setb duces cfg black write setcfg latency cbg pro white setcbg sho setp figure concat erence een mline read end begin write mline pro les setb dramatic cfg black setcfg cbg surprising white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text muc cfg black setcfg erence helvetica-medium-r due helvetica setf write hiding concat latency text writes end begin memory mline setb cfg black setcfg cbg white starttexfig setcbg begindocument setp newfigures final concat local write eps gnudict dict mline gnudict end begin begin color mline false solid false setb cfg gnulinewidth black vshift setcfg cbg mul white setcbg hpt vpt setp moveto bind concat lineto bind rmoveto bind mline rlineto end bind begin vpt mline vpt mul hpt setb hpt mul cfg lshow black currentpoint setcfg stroke cbg white vshift setcbg show setp rshow currentpoint stroke dup concat stringwidth pop neg vshift show cshow 
mline end currentpoint begin stroke mline dup stringwidth pop div setb vshift cfg show black setcfg color cbg setrgbcolor white solid setcbg pop setp setdash pop pop pop solid concat pop setdash ifelse stroke mline gnulinewidth end mul begin setlinewidth stroke gnulinewidth div setlinewidth mline stroke gnulinewidth setb setlinewidth cfg ltb black setcfg cbg lta white setcbg setdash setp setrgbcolor concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat stroke setdash currentlinewidth div mline currentlinewidth end stroke begin mline stroke setdash copy setb vpt cfg add hpt black neg setcfg vpt neg cbg hpt white setcbg setp concat mline end begin vpt neg mline hpt vpt hpt neg vpt closepath stroke setb cfg stroke setdash black vpt setcfg vpt cbg currentpoint stroke white setcbg hpt neg vpt setp neg hpt stroke concat mline end begin text cfg stroke black setdash setcfg copy exch hpt helvetica-medium-r exch vpt helvetica add setf vpt neg hpt vpt concat hpt neg text end closepath begin stroke text cfg stroke black setdash setcfg exch hpt helvetica-medium-r exch vpt add helvetica setf hpt vpt neg currentpoint stroke concat hpt neg text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin hpt mline vpt stroke stroke setb setdash cfg copy vpt black mul setcfg add cbg hpt neg white vpt setcbg mul setp hpt mul hpt neg concat vpt mul closepath mline stroke end begin mline copy end gnudict setb begin cfg gsave black setcfg translate cbg white setcbg scale setgray setp helvetica findfont scalefont setfont concat newpath lta mline end begin ltb mline setb cfg rshow black setcfg cbg white setcbg rshow setp concat rshow rshow rshow cshow cshow mline end begin cshow mline setb cfg cshow black setcfg cbg white setcbg setp concat cshow mline end begin mline cshow setb cfg black setcfg cbg cshow white setcbg setp cshow concat mline end begin cshow mline setb cfg cshow black setcfg cbg white setcbg cshow setp concat cshow mline end begin mline setb currentpoint gsave cfg translate black rotate setcfg cbg time white nanoseconds setcbg cshow grestore setp stride bytes concat cshow local write mline performance end begin cshow mline write merging setb cfg lshow black setcfg cbg merging white lshow setcbg off-page setp access lshow concat rshow mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb 
cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end end eop end showpage countdictstack initdictcount end repeat cleartomark restore grestore enddocument endtexfig starttexfig begindocument figs bar coschedgranvartrans epsim caching effects recall shear simple adaptive scheme detect bypass buffering issuing successive rounds write requests monitoring performance point write bandwidth decreases indicating raid system moved steady-state writing data disk setrgbcolor memory reliable result generated figure demonstrates technique 
adaptec hardware raid adapter write caching enabled enhancements place study redundancy detection stroke software setdash hardware raid currentlinewidth systems div figure plots currentlinewidth read stroke bandwidth write bandwidth stroke ratio setdash number copy vpt con gurations recall add read write hpt neg ratio vpt neg key hpt vpt differentiating neg hpt redundancy vpt scheme hpt neg vpt closepath ratio stroke stroke redundancy setdash vpt ratio vpt mirrored scheme currentpoint stroke hpt neg vpt neg ratio hpt stroke raidstyle parity stroke encoding setdash note copy exch hardware hpt raid exch card vpt add support vpt neg raidand hpt con vpt gure hpt raidon neg disks closepath stroke gure shows shear stroke setdash redundancy exch detection hpt good exch job vpt identifying scheme add hpt expected vpt neg read write currentpoint ratios stroke approximately hpt neg raidnear hpt vpt raidand stroke stroke setdash raidthere copy vpt mul add points hpt make neg vpt bandwidth mul ratios hpt mul raidscale hpt neg number vpt disks mul due parity disk bottleneck closepath makes stroke dif cult identify copy raidarrays end gnudict rely begin gsave write layout translate test scale setgray previously helvetica exhibits findfont scalefont setfont bottleneck newpath write lta performance unique results ltb write layout test rshow distinguish raidfrom parity-based schemes rshow note performance software raidon rshow rshow rshow rshow cshow disks expected read write ratio measure ratio tracing disk activity inspecting source code revealed linux software raid controller utilize usual raidsmall write optimization reading block cshow parity writing block cshow parity read entire stripe cshow blocks write cshow block parity finally graph shows cshow raidwith disks -disk mirrored system cshow distinguishable disks raidand mirroring cshow converge shear applications section illustrate bene currentpoint gsave shear translate begin rotate showing percent cshow shear grestore message detect size raid bytes conguration errors cshow disk message failures size breakdown show shear database cshow discover cumulative information message individual count disks rshow array finally present storage system paramefigure detecting miscon gured layouts raidleft-symmetric left-asymmetric right-symmetric rightasymmetric upper graph shows cumulative read message layout size graph rshow raid ibm disks correctly con gured lower graphs show read layout logical partitions miscon ured stroke grestore end showpage enddocument endtexfig physical device chunk starttexfig size begindocument detection figures raid length boundary oracle offset assumed eps gnudict time dict gnudict begin color false solid false gnulinewidth vshift figure detecting mul heterogeneity hpt rst graph vpt shows output moveto bind chunk size lineto detection bind algorithm run rmoveto bind array rlineto single bind heterogeneous vpt fast vpt mul rotating disk hpt hpt mul row lshow gures currentpoint shows stroke vshift results show read rshow layout currentpoint algorithm stroke dup stringwidth pop simulated neg disk vshift con show gurations cshow currentpoint con stroke guration dup single stringwidth disk pop capability div fast vshift rotating show slow rotating fast color seeking setrgbcolor solid slow seeking pop disk setdash depicted pop pop pop solid gures ters pop uncovered setdash shear ifelse stroke tune gnulinewidth mul system setlinewidth speci cally stroke show gnulinewidth div setlinewidth system improve stroke sequential gnulinewidth bandwidth setlinewidth writing data ltb full stripes lta shear management setdash intended setrgbcolor shear administrative utility discover con guration performance safety problems figure shows failure identify scheme suggest storage miscon guration upper set graphs expected read layout graphs common raidlevels lower resulting read layout graphs disk array miscon gured logical partitions reside physical disk graphs generated disk arrays comprised logical disks built linux software raid ibm disks visualization makes obvious manual inspection shear automatically stroke setdash determines currentlinewidth div results match currentlinewidth existing stroke schemes shear stroke setdash copy vpt add detect unexpected hpt neg performance vpt neg heterogeneity hpt vpt disks 
neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent cshow grestore message size bytes cshow message size breakdown database cshow cumulative message count rshow cumulative message size rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures length oracle eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent cshow grestore message size bytes cshow message size breakdown database cshow cumulative message count rshow cumulative message size rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures length oracle eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor experiment run shear range simulated heterogeneous disk con gurations exchunk size detection raid left symmetric boundary offset assumed time chunk size detection raid left symmetric boundary offset assumed time figure detecting failure chunk size detection algorithm shear discover failed devices raid system upper graph shows initial chunk size detection results collected building disk software raid system solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor ibm disks lower graph system fth disk removed periments disk slower faster rest figure shows results run heterogeneous con gurations gure stroke setdash faster currentlinewidth slower div disk makes currentlinewidth presence stroke obvious ways stroke setdash read copy layout vpt graphs add hpt neg vpt chunk neg size hpt detection vpt output neg hpt pattern vpt size hpt detection neg vpt unaffected closepath stroke administrator view stroke setdash outputs vpt observe vpt currentpoint stroke hpt neg unexpected vpt neg performance differential hpt stroke disks action stroke setdash correct copy exch problem hpt finally exch chunk vpt size add detection vpt algorithm neg shear hpt vpt identify hpt safety neg hazards closepath determining stroke redundant array stroke setdash operating exch hpt degraded mode exch vpt figure add shows hpt chunk vpt size neg detection currentpoint results stroke ten hpt disk neg software hpt raid vpt system stroke ibm disks stroke upper setdash graph copy shows vpt mul chunk add size detection hpt neg correctly vpt working mul array hpt mul rst hpt built neg vpt lower mul graph closepath shows stroke chunk size copy detection changed end gnudict begin physically remove gsave fth translate disk scale setgray helvetica array recall findfont scalefont setfont chunk newpath size detection lta works guessing ltb boundaries timing sets requests sides rshow boundary vertical downward spikes rshow half height plateaus rshow guessed boundary correct requests rshow serviced parallel disks rshow plateaus false boundaries requests rshow sides guessed boundary incurred cshow disk lower graph identi cshow array operating degraded mode cshow cshow cshow cshow cshow cshow boundary points missing disk disappear plateau higher due extra overhead performing on-they reconstruction shear disk characterization related projects concentrated extracting speci properties individual disk drives techniques built top characteristic knowledge aligning les track boundaries free-block scheduling shear enables optimizations context storage arrays shear expose boundaries currentpoint gsave disks translate rotate existing tools percent cshow determine grestore speci message properties size bytes individual cshow disks message size demonstrate breakdown ability database skippy cshow disk characterization cumulative tool message skippy count rshow sequence write operations inwrite time request number skippy disk write time request number skippy raiddisks write time cumulative request message number size skippy rshow raiddisks figure skippy gures plot results running skippy disk characterization tool single quantum disk disk raidarray disk raidarray creasing strides determine disk sector stroke grestore track end ratio showpage rotation enddocument time head endtexfig positioning time figure head message size distrib ution database workload lines count number messages node switch time message cylinder switch smaller time number bytes recording surfaces rst graph figure messages shows smaller pattern generated skippy bytes single quantum disk data transferred graph big figure chunks shows results data running modi shipped version units skippy raidarray disks non-synthetic version skippy workload array directly information correlate provided shear map block erse stream message pattern logical blocks note residing rst disk message array smaller results pattern identical running single disk allowing extract individual disk parameters nal graph figure shows results technique applied disk raidarray results identical single disk pattern small perturbations bytes traf coming comprised small messages node relays requests nodes affect replies analysis carry lar limitations ger payload approach traf case raidthe slightly dif ferent skippy rest write workload performs attrib expected ute read workload produces spurious sap-serv results due presence fact leads reads small balanced message disks conversely xchanges reads work manage raidwhereas writes global port due space update parity information database additionally workload parity figure blocks raidcannot directly accessed additional characterization data tools point obtain incomplete spectrum set data message distrib limitations utions tested bears read-based similarity version skippy make raidand workload successfully extracted roughly parameters individual messages disks shear small performance stripe bytes size disk array large impact performance effect important raidstorage writes lar messages complete stripe require additional data previous work data focused selecting transferred optimal stripe size blocks workload show system adapt size alignment writes function stripe size bandwidth hand average file size effects stripe-alignment distinct stripe-aligned message default sizes figure similar bene web workload eop page bop case stripe roughly alignment gure plots message bandwidth sizes series creations average size realistic varied database workload x-axis run variants shown disks system generates stripe-sized writes default signi linux cantly alter workload consists message creating size les distrib x-axis utions node size perform les uniformly distributed request-responses basic simply idea serv system balance adjust writes stripe aligned optimization occur multiple places modi linux device scheduler properly coalesces divides individual requests raid stripe-sized units modi cation traf nodes equally message rates xamining message size distrib utions observ size urstiness straight-forward traf lines man code added small kernel protocol simple messages change make system ery stripe-aware lar leads data tremendous cce performance packet improvements experiments shown section figure run establish hardware raidcon guration quantum time disks urstiness chunk size xists results show figures stripe-aware system noticeably depict improves bandwidth number moderately-sized les messages improves bandwidth larger les node factor related work idea life providing software automatically uncover xperiment behavior ccec underlying software set hardware layers graphs explored number workload domains earliest diagrams work area targeted memory subsystem workstation measuring time make reads workload amounts node communicates strides saavedra relati smith reveal ely interesting aspects ursty manner memory hierarchy including details orkstations caches tlbs periods similar techniques hundreds applied messages identify aspects tcp protocol stack determine processor cycle quarter time cpu scheduling policies work related targeted characterizing single disk storage system worthington identify characteristics disks send mapping west logical block messages numbers physical time locations costs low-level operations 
erage size prefetch window prefetching algorithm caching policy schindler talagala build similar portable tools achieve similar ends shown shear conjunction low-level tools discover properties single disks inside arrays evaluations storage systems focused measuring performance workload fffe uncovering underlying fffe properties ffff interesting synthetic ffff benchmark adapts behavior fffc fffe underlying storage system benchmark examines sensitivity parameters size requests fffe read write ratio amount concurrency abab finally idea detailed storage-systems knowledge system fffe storage client investigated schindler investigate concept fffe track-aligned placement single disk systems work modi eeee system allocates medium-sized les track boundaries avoid rate head switches deliver low-latency access les systems messages lfs atropos respecti augment ely array interface fffe noted provide information individual nodes disks lfs knowledge disk workers boundaries dynamically allocate nodes writes partake based fffe babb make fffe special responsibilities dif fffe fers make master eeee ecuting fffe additional messages rexec system calls fffe distrib ute work abab nodes fffe erages message performance control redundancy xperiment finally perle basis fffe atropos volume manager eeee extends serv storage interface expose disk boundary fffe strain track information provide cient respond semi-sequential access man two-dimensional fffe requests data structures shear enables les information multiple readily bbba disk systems fffe graph erages messages notably nodes web workload sho workload-sensiti traf patterns figure observ nodes constantly sending messages time seconds onward xperiment gan qualitati dif ference quantity rshow sends messages routes traf sap-serv sends worker nodes eraging messages database rshow workload pro similar vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time replace seconds cshow grestore amount memory replaced cshow cost replacing memory cshow dec ultrix rshow sun ipx sunos rshow stroke grestore end showpage enddocument endtexfig figure potential cost interruption program whic utilized arying amoun memory run stopp cleaner ysical memory run completed original program cony tin ued time page orking set measured monitoring cal disk activit program original slo wdo run time oth make gzip user eplac ement cts table displa ects cleaning cac memory oth run time eac enc hmarks formatted ord set input les make built tcsh distriy bution gzip compressed user shell script comp osed ypical unix commands exp erimen ere erformed decstation ultrix remain users dela times sho eac dela oten tially length rshow otential cost interruption users return orkstation migh ait parallel programs acate mac hine ust ait previous con texts rshow rey stored rshow main resources orkstation cpu main memory disk net ork terface reclaimy ing cpu inexp ensiv restoring state registers cac tlb costs millisecon similar argumen made net ork terface state hanges con text switc considerably state asso ciated orkstation main memory cac figure sho replacing main memory pages costly rshow teractiv users quic kly ecome frusy trated exp ect near-instan taneous resp onse times ust ait state rshow rshow rshow rshow rshow app bac eac time resume ork stroke grestore end showpage orkstation enddocument endtexfig figure quany ect ushing mac hine main memory eop page bop starttexfig begindocument figures socialfinal eps gnudict dict gnudict begin color false solid false write gnulinewidth cost vshift mul alpha hpt vpt moveto write-through bind read-allo lineto bind cate data rmoveto bind cac rlineto bind vpt vpt mul observ hpt hpt mul lshow presence currentpoint stroke vshift write show rshow currentpoint stroke dup stringwidth noting pop neg vshift show ery cshow currentpoint stroke dup write stringwidth pop cac div vshift show color incur setrgbcolor solid full pop memory setdash pop latency pop pop solid note pop setdash ifelse ection stroke oin gnulinewidth mul setlinewidth stride stroke gnulinewidth div ccurs setlinewidth ecause stroke eac gnulinewidth setlinewidth successiv ltb store lta arra setdash setrgbcolor -page dram access memory con troller ery small strides erage access time nanoseconds cycles stride ytes blo stroke size setdash currentlinewidth cac div currentlinewidth stroke erage access stroke time setdash copy vpt add hpt neg vpt neg nanoseconds hpt vpt neg hpt vpt dra hpt neg vpt closepath conclusions stroke stroke setdash measuremen vpt vpt currentpoint stroke ery hpt small neg vpt strides neg successiv hpt stroke writes stroke setdash copy exch line hpt exch written vpt add vpt neg hpt vpt hpt write neg closepath stroke stroke setdash feature exch hpt exch kno vpt add hpt vpt write-mer neg ging currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add sec- hpt neg vpt ond mul main hpt memory mul access hpt neg time vpt mul roughly closepath stroke nanosec- onds copy dividin end gnudict begin gsave nanoseconds giv translate scale setgray estimated helvetica findfont write scalefont setfont size newpath lta ltb corrob orated alpha rshow man ual rshow section pro vided rshow detailed examination rshow cal memory system rshow determined cost rshow hip rshow memory access cycles cshow large page size cshow essen tially eliminates tlb costs cshow write con cshow tains supp orts cshow write-merging sec- tions cshow discuss costs mec cshow hanisms ect language implemen tation cshow global ointers cshow section turn rst de-generation hallenges represen tation oin ters global ad- dress space erations currentpoint gsave translate oin rotate ters slowdown cshow issue grestore social contract olv cshow complex social asp contract cshow ect workstations shell rshow whic pro vides lev ysical address workstations translation rshow teracts tlb language sto workstations rage rshow del requirements split-c stroke grestore pro end cessor showpage enddocument endtexfig access figure cation global address space cial eac contr pro act cessor esults wns graph eci sho re- slo gion wdo global parallel space programs function cal region cial con- cal tract region con tains sim stac ulation assumes automatic -second ariables migration static cost cac extery nal flushing ariables ortion signi heap ect glob execution ointers time ypical unix programs tire address de- space ending standard application oin slo wdo ters wns ere ortion ob- cal serv accessing pro problem man cessor follo ossible wing solutions oiding re- cruitmen mac hines large amoun activ mem- ory pinning imp ortan erations memory pages supp orted global oin ters der efer enc cation referenced oin ter read written ansfer oin ter passed parameter stored ject rithmetic serv manipulated emacs pages ery forming bulk address parallel arithmetic reco forms teractiv user state quic kly ady idea essing recruiting treats remote memory global address fast space bac king segmen store ted pro cessors dahlin acts elten global zahorjan oin ter ving xed-memory corresp partition onding addressing een parallel erations ould se- quen act tial 
standard jobs oin ashok ter zahorjan ossible ernel incremen ted cations oin ter plan exploring refers alternativ cation part future pro ork cessor glob cial contract ady essing subsection treats global demonstrate address space ery linear simple hedul- pro ing cessor mec comp hanism onen astly arying reduce fastest orst-case addresses wrap user dela pro adv cessor ersely ecting set erformance parallel rst programs pro cessor cial ontr act guaran extr tees action in- onstruction dividual global oin dela ter tak eci obtain pro times cessor user loy cal een address dela comp onen threshold global oin ter times user orkstation constructed longer comp onen candidate run parallel nul programs test figure sho global oin slo ter wdo parallel tested programs ull hea lanl standard orkload oin ter function cial equalit con- tract alue high resource demands parallel ork- load forces tradeo design tolerated user in- constraints terruptions decreases parallel erformance implemen orsens tation alpha -no arc hitecture cluster users supy orts -bit tolerate virtual addresses daily -bit ter- ysical ruptions addresses parallel program additional slo high wdo bits supp ort memory reasonable mapp factor devices signi -no impact cluster users ust mac hine supp tolerate orts suc shared memory terruptions man hiev shared-memory mac slo hines map equal memory cluster size accessible previous subsections demonstrate pro cess target clus- virtual ter address orkstations space comfortably supp virtual ort address parallel translated orkload glob ysical ady dress memory system extracts ysical cation global submitted ysiy cal -no partition lanl cmy ailable orkstations decreases parallel orkload increases oth terruptions teractiv users run time parallel programs increases dramatically address erforms urthery cal memory ailable access resources tigh pro cess migration cost ecomes increasingl imp ortan erall system ery formance similar pattern holds system recruity men threshold orkstations ailable recruitmen threshold ust hosen carefully main tain erall system throughput summary eac bination sequen tial pary allel orkloads system web designers workload ust nodes requisite communicating orkstations eep constant rates terruptions teractiv attrib uted users message acceptable lev transaction nature main remote workload taining memory con reasonable troller resp node onse times continually performs fully parallel con transactions gured jobs nodes target ould net require send ork bits messages orkstations rule ysical app ears address serv apply node cluster sends man appro bits times ximately ailable mac hines shell node sustain erforms oth responding additional lev sequen requests tial address parallel transy nodes lation orkload clusters set exhibiting eop hea segmen vier page bop registers load kno haracteristics xed dtb starttexfig annex figure unipro begindocument eac figures cessors rate dedicated make annex register eps running gnudict eci sequen dict tial pro gnudict jobs begin color cessor false solid false added function gnulinewidth vshift net annex ork registers mul oth hpt dated increase vpt parallel user moveto job lev bind erformance lineto bind reduce rmoveto bind revised terrupy store-conditiona rlineto tions bind instruction vpt teractiv vpt mul hpt users measured hpt cost mul related ypical lshow hip currentpoint stroke access vshift cycles show een annex rshow abundance currentpoint register stroke studies alw dup stringwidth refers pop neg vshift orkstation cal show pro clusters cshow cessor currentpoint stroke page oten dup tial stringwidth pop supp div vshift ort show distributed color setrgbcolor pary allel solid pop computing theimer setdash pop pop colleagues estimated erage one-third v-system orkstations ere free busiest times theimer lan nic hols measured orkstations aily butler system tables whic constructed increased pro roughly vide shared nigh stac nic pop hols solid pop heap douglis segmen setdash ifelse con taining oustery stroke hout gnulinewidth regions found mul setlinewidth o-thirds mac hines stroke gnulinewidth sprite eac div setlinewidth ere stroke gnulinewidth ailable annex setlinewidth register ltb erage douglis virtual-to-ph lta ysica ousterhout translation setdash mutk setrgbcolor erformed livn alpha carries annex mutk register livn index found similar translates results remainder address erence bit een ysical widely address arying whic results ust nition alid mac hine pro ailabil cessors ust butler view virtual stroke dey address nes setdash currentlinewidth mac div temp hines ary currentlinewidth stroke global ailable stroke address setdash copy vpt logged add hpt neg vpt meaning neg sprite hpt dep vpt aits neg enden hpt vpt hpt min neg con ute vpt guration closepath inactivit stroke efore annex stroke claiming setdash vpt vpt orkstation currentpoint job stroke hpt alternativ neg vpt previous neg ould cluster hpt studies stroke een stroke pro tended setdash vide copy exch concen hpt 
global exch vpt add vpt neg hpt vpt hpt neg closepath stroke enhanced stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul interface conclusions hpt presented mul shear hpt tool neg vpt automatically mul detects closepath stroke important characteristics modern copy storage arrays end gnudict including begin number gsave disks translate chunk scale size setgray level helvetica redundancy findfont scalefont layout setfont scheme newpath keys lta shear ltb randomness extract steady-state performance rshow statistical techniques deliver rshow automated reliable detection veri rshow shear works desired series rshow simulations variety layout redundancy schemes subsequently applied shear trate software aggregate system hardware raid ailabil systems revealing properties sho speci cally found linux facy software tors raid exhibits relev poor performance raidparity distribution updates idle times adaptec raid adapter implements idle erio raidleft-asymmetric layout short shown idle shear time case studies storage administrators shear verify properties large storage arrays monitor terv als performance relev detect disk failures shear rshow extract individual parameters een disks large rshow array enabling performance studies enhancements previously rshow limited uly single tipro disk cessor systems finally heduling rshow tec shown hniques factor improvement rshow een performance based system shared-memory tuning arc writes hitectures rshow stripe size raid storage rshow syny storage thetic systems inputs computer systems driv general parallel cshow program complex eha vior layers interacting cshow oustery components hout remain rst concealed veil tro duced simplicity cshow hope idea techniques developed osche dulin shear cshow reveal ousterhout true power future idea systems cshow subsequently make een included manageable man composable cshow studies cient acknowledgements ultipro cessor currentpoint heduling gsave bradford tec translate beckmann nathan rotate hniques burnett messages vijayan cshow prabhakaran gupta muthian grestore sivathanu time cro seconds anonymous ella cshow reviewers messages excellent time feedback eitelson make cshow work sponsored rudolph nsf leutenegy ccrccr- ger ernon ccrngs- ousterhout itritr- assumed ibm emc cosc wisconsin alumni heduly ing research foundation idea bray implemen bonnie file ted system compared benchmark http textuality algorithms bonnie matrix algorithm burnett bent simplest arpaci-dusseau close arpaci-dusseau exploiting gray-box cien knowledge buffer-cache contents reason proceedings hose usenix annual technical implemen conference usenix pages trace-driv monterey sim california ulator june gupta chen lee gupta striping raid level found disk array cosc heduling proceedings acm sigmetrics conference measurement modeling virtual addresses erating system space-sharing manage metho annex kno transy paren tly ess stroke grestore page ontr end tables showpage ould enddocument asso ciate endtexfig addresses time quan tum curren tly long mapp remote pro milliseco cessors nds annex indexes fault amortize ould cac ccur ects un-mapp studied remote pro cessor detery mine whic eop pro page cessors bop man fffe pro cessors fffe allo starttexfig starttexfig ffff cate begindocument figures begindocument rate newfigures ffff parallel make annex application eps fffc eps sev gnudict arrowhead dict begin gnudict transform naik originalctm chiy itransform eop taily exch page bop begin color tailx ang exch transform originalctm false solid ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfeff ffa fec ffa ffb ffa ffb ffa ffb ffb ffa aaa ffa ffa ffb ffa ffa ffa affa ffb fed ffa aabfe aaaa ffa fec ffa ffb fed bfed ffa ffb fec ffa ffb fed ffb ffa feffa aaaa aaaa ffc aaaaa ffa ffa fdff fed ffbfe fdff ffbfed fdff fed fed ffbfe fdff feaaa fea aabfe ffbfec fdff fed fed ffbfe fdff dff ffbfed fdff fed fed ffbfe fdff fea feaaa aaaa aaaaa ffbfec fdff fed fed ffbfe fdff ffbfed fdff fed fed ffbfe fdff fea fea aac ffbfec fdff feffa fed ffbfe fdff feffa ffbfed fdff feffb fed ffd ffbfe fdff feffa feaaa aaaa aaaaa ffbfec fdff feffa fed bfec ffbfe fdff feffa ffbfed fdff feffbfd fed ffbfe fdff feffa fea aaa ffbfec fdff feffb fed ffbfeffa fdff feffa ffbfeffb fdff feffb feffb ffbfeffa fdff feffa feffaa aaaa aaaaa aff ffbfeffa fdff feffb feffb ffbfeffa fdff feffa feffa ffbfeffb fdff feffb feffb ffbfeffa fdff feffaa feffa aae ffbfeffa fdff feffb feffb ffbfeffa fdff feffa feffa ffbfeffb fdff feffbfd feffb ffbfeffa fdff feffbfd feffaa aaaa aaaaa ffbfeffa fdff feffbfd feffb ffbfeffa fdff feffbfd feffa ffbfeffb fdff feffbfd feffb ffbfeffa fdff feffbfd feffa aaa ffbfeffa fdff feffbfd feffb ffbfeffa fdff feffbfd feffa ffbfeffb fdff feffbfd feffbfed ffbfeffa fdff feffbfd feffbfe aaaa aaaaa ffbfeffa fdff feffbfd feffbfec ffbfeffa fdff feffbfd feffbfe ffbfeffb fdff feffbfd feffbfed ffbfeffa fdff feffbfd feffbfe aae ffbfeffa fdff feffbfd feffbfeffa ffbfeffa fdff feffbfd feffbfe ffbfeffb fdff feffbfd feffbfed ffbfeffa fdff feffbfd feffbfea aaaa aaaaa ffbfeffa fdff feffbfdff feffbfed ffbfeffa fdff feffbfd feffbfe ffbfeffb fdff feffbfd feffbfed ffbfeffa fdff fdfe feffbfda feffbfea aaa ffbfeffa fdff fdfec feffbfd feffbfed ffbfeffbfe fdff fdfe feffbfd feffbfe ffbfeffbfed fdff fdfed feffbfd feffbfed ffbfeffbfe fdff fdfe feffbfd feffbfea aaaa aaaaa ffbfeffbfec fdff fdfec feffbfd feffbfed ffbfeffbfe fdff fdfe feffbfd feffbfe aff ffbfeffbfed fdff fdfed feffbfdff feffbfed ffbfeffbfe fdff fdfe feffbfdff feffbfeaaa aae ffbfeffbfed fdff fdfec feffbfdff feffbfed ffbfeffbfe fdff fdfe feffbfdff feffbfe ffbfeffbfed fdff fdfed feffbfdff feffbfed ffbfeffbfe fdff fdfe feffbfdff feffbfeffa aaaa aaaaa ffbfeffbfec fdff fdfec feffbfdff feffbfeffa ffbfeffbfe fdff fdfe feffbfdff feffbfeffbfe ffbfeffbfed fdff fdfed feffbfdff feffbfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffaa aaa ffbfeffbfec fdff fdfec feffbfdff feffbfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa ffbfeffbfed fdff fdfed feffbfdff feffbfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa aaaa aaaaa aff ffbfeffbfec fdff fdfec feffbfdff feffbfeffb ffbfeffbfe fdff fdfe feffbfdff feffbfeffa ffbfeffbfed fdff fdfeffb feffbfdff feffbfeffb ffbfeffbfe fdff fdfeffa feffbfdff feffbfeffa aae ffbfeffbfeffb fdff fdfeffa feffbfdff feffbfeffb fdff ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffa fdff ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffb fdff ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffa fdff aaaa aaaaa ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffb fdff ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffa fdff ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfeff fdff ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfea fdff aaa ffbfeffbfeffb fdff fdfeffa feffbfdff feffbfeffbfed fdff ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff 
ffbfeffbfeffb fdff fdfeffb feffbfdff fdff feffbfeffbfed fdff ffbfeffbfeffa fdff fdfeffa feffbfdff fda feffbfeffbfeaa fdff aaaa aaaaa ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfed fdff ffb ffbfeffbfeffa fdff fdfeffa feffbfdff feffbfeffbfe fdff ffa ffbfeffbfeffb fdff fdfeffb feffbfdff feffbfeffbfed fdff ffb ffbfeffbfeffa fdff fdfeffbfe feffbfdff feffbfeffbfea fdff ffa aae ffbfeffbfeffb fdff fdfeffbfe feffbfdff feffbfeffbfed fdff ffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff feffbfeffbfe fdff ffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfed fdff ffbfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeaa fdff fda ffbfea aaaaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff ffbfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff ffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff ffbfeffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff ffbfeffea aaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff ffbfeffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfe ffbfeffc ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfed ffbfeffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfea ffbfeffe aaaaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfed ffbfeffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfe ffbfeffc ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfed ffbfeffffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfea ffbfeffffda ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfed ffbfeffffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfe ffbfeffffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffd aaaaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffd ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff aaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff aaaaa aff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff aaaaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff aaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffaa ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfed ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffb ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfeff ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff 
fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfe ffbfeffbfeffbfc fdff fdfeffbfe feffbfdff fdff feffbfeffbfeff fdff fdfeff ffbfeffffdff fdfeffbfeffbfeff ecec cccc ccccc dcfcfc initdictcount countdictstack gsave save mark newpath showpage dict begin arrowheight arrowwidth null numgraphicparameters stringlimit begin save numgraphicparameters dict begin end end restore setb dup type nulltype pop false brushrightarrow idef false brushleftarrow idef true brushnone idef brushdashoffset idef brushdasharray idef brushrightarrow idef brushleftarrow idef brushwidth idef false brushnone idef ifelse setcfg fgblue idef fggreen idef fgred idef setcbg bgblue idef bggreen idef bgred idef setf printsize idef printfont idef setp dup type nulltype pop true patternnone idef patterngraylevel idef patterngraylevel patternstring idef false patternnone idef ifelse bspl begin storexyn newpath true subspline false subspline exch dup dup add dup add dup false subspline dup dup dup copy false subspline dup dup copy copy false subspline patternnone brushleftarrow brushrightarrow ifill brushnone istroke leftarrow dup dup rightarrow end dup dict put circ newpath arc patternnone ifill brushnone istroke cbspl begin dup storexyn newpath dup true subspline exch dup dup add dup add dup false subspline dup dup dup false subspline dup dup false subspline patternnone ifill brushnone istroke poly ifelse end dup dict put elli begin newpath roll translate scale arc patternnone ifill brushnone istroke end dup dict put line begin storexyn newpath moveto lineto brushnone istroke leftarrow rightarrow end dup dict put mline begin storexyn newpath moveto exch lineto itransform tipy exch tipx exch tipy taily tipx tailx angle atan ifelse gsave originalctm setmatrix tipx tipy translate angle rotate newpath arrowheight neg arrowwidth div moveto lineto arrowheight neg arrowwidth div neg lineto patternnone originalctm setmatrix padtip arrowheight exp arrowwidth exp mul add sqrt brushwidth mul arrowwidth div padtail brushwidth div tipx tipy translate angle rotate padtip translate arrowheight padtip add padtail add arrowheight div dup scale arrowheadpath ifill brushnone originalctm setmatrix tipx tipy translate angle rotate arrowheadpath istroke grestore end dup dict put arrowheadpath newpath arrowheight neg arrowwidth div moveto lineto arrowheight neg arrowwidth div neg lineto leftarrow begin exch taily exch exch tailx exch exch tipy exch exch tipx exch brushleftarrow tipx tipy tailx taily arrowhead end dup dict put rightarrow begin exch tipy exch exch tipx exch exch taily exch exch tailx exch brushrightarrow tipx tipy tailx taily arrowhead end dup dict put arrowheight arrowwidth idrawdict dict idrawdict begin reencodeiso dup dup findfont dup length dict begin index fid pop pop ifelse forall encoding isolatin encoding currentdict end definefont isolatin encoding notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma minus period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef 
dotlessi grave acute circumflex tilde macron breve dotaccent dieresis notdef ring cedilla notdef hungarumlaut ogonek caron space exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis helvetica reencodeiso null numgraphicparameters stringlimit begin save numgraphicparameters dict begin end end restore setb dup type nulltype pop false brushrightarrow idef false brushleftarrow idef true brushnone idef brushdashoffset idef brushdasharray idef brushrightarrow idef brushleftarrow idef brushwidth idef false brushnone idef ifelse setcfg fgblue idef fggreen idef fgred idef setcbg bgblue idef bggreen idef bgred idef setf printsize idef printfont idef setp dup type nulltype pop true patternnone idef dup patterngraylevel idef patternstring idef patterngraylevel idef ifelse false patternnone idef ifelse bspl begin storexyn newpath true subspline false subspline exch dup dup add dup add dup false subspline dup dup dup copy false subspline dup dup copy copy false subspline patternnone brushleftarrow brushrightarrow ifill brushnone istroke leftarrow dup dup rightarrow end dup dict put circ newpath arc patternnone ifill brushnone istroke cbspl begin dup storexyn newpath dup true subspline exch dup dup add dup add dup false subspline dup dup dup false subspline dup dup false subspline patternnone ifill brushnone istroke poly ifelse end dup dict put elli begin newpath roll translate scale arc patternnone ifill brushnone istroke end dup dict put line begin storexyn newpath moveto lineto brushnone istroke leftarrow rightarrow end dup dict put mline begin storexyn newpath moveto exch lineto patternnone brushleftarrow brushrightarrow ifill brushnone istroke leftarrow dup dup rightarrow end dup dict put poly roll newpath moveto add lineto repeat closepath patternnone ifill brushnone istroke rect begin exch exch exch exch newpath moveto lineto lineto lineto closepath patternnone ifill brushnone istroke end dup dict put text ishow idef dup pop pop pop exch ifelse ifill begin gsave patterngraylevel fgred bgred fgred patterngraylevel mul add fggreen bggreen fggreen patterngraylevel mul add fgblue bgblue fgblue patterngraylevel mul add setrgbcolor eofill eoclip originalctm setmatrix pathbbox exch exch exch exch ceiling cvi ceiling cvi imagebytewidth div ceiling cvi imageheight bgred bggreen bgblue setrgbcolor eofill fgred fggreen fgblue setrgbcolor add translate neg scale true neg patternproc imagemask ifelse grestore end dup dict put istroke gsave brushdashoffset setdash setgray brushdasharray brushdashoffset setdash fgred fggreen fgblue setrgbcolor ifelse brushwidth setlinewidth originalctm setmatrix stroke grestore ishow begin gsave fgred fggreen fgblue setrgbcolor fontdict printfont printsize scalefont dup setfont descender fontdict begin fontbbox fontmatrix end transform exch pop vertoffset printsize descender vertoffset moveto show vertoffset vertoffset printsize forall grestore end dup dict put patternproc begin patternbytelength patternstring length patternheight patternbytelength mul sqrt cvi patternwidth patternheight patternbytewidth patternwidth idiv imagebytemaxlength imagebytewidth imageheight mul stringlimit patternbytewidth min imagemaxheight imagebytemaxlength imagebytewidth idiv patternheight idiv patternheight mul patternheight max imageheight imageheight imagemaxheight store imagestring imagebytewidth imagemaxheight mul patternbytewidth add string imagemaxheight exch patternrow patternbytewidth mul patternbytelength mod patternrowstring patternstring patternrow patternbytewidth getinterval imagerow imagebytewidth mul patternbytewidth imagebytewidth exch imagestring imagerow add patternrowstring putinterval imagestring end dup dict put min dup roll dup roll exch pop max dup roll dup roll exch pop midpoint begin exch exch exch exch add div add div end dup dict put thirdpoint begin exch exch exch exch mul add div mul add div end dup dict put subspline begin movetoneeded exch exch exch exch exch exch exch exch exch exch exch exch exch exch exch exch exch thirdpoint exch exch thirdpoint exch exch thirdpoint midpoint exch exch thirdpoint midpoint exch exch movetoneeded moveto curveto end dup dict put storexyn exch array array exch roll put roll put ssten fgred fggreen fgblue setrgbcolor dup true exch roll matrix astore fsten dup roll dup roll exch newpath moveto dup exch lineto exch dup roll exch lineto lineto closepath bgred bggreen bgblue setrgbcolor eofill ssten rast exch dup roll roll matrix astore idraw grid begin cfg cbg concat originalctm matrix currentmatrix begin rect setb cfg black setcfg cbg white setcbg setp concat rect end begin pict cfg cbg setp concat begin rect setb cfg black setcfg cbg white setcbg setp concat rect end begin line setb cfg black setcfg cbg white setcbg setp concat line end end eop begin pict cfg cbg setp concat begin rect setb cfg black setcfg cbg white setcbg setp concat rect end begin line setb cfg black setcfg cbg white setcbg setp concat line end end eop begin rect setb cfg black setcfg cbg white setcbg setp concat rect end begin pict cfg cbg concat begin rect setb cfg black setcfg cbg white setcbg setp concat rect end begin text cfg black setcfg helvetica setf concat alpha text end end eop begin false pict cfg gnulinewidth cbg vshift mul hpt concat vpt begin moveto rect bind lineto bind setb cfg rmoveto bind black setcfg rlineto bind cbg vpt white vpt mul setcbg hpt hpt setp mul lshow currentpoint concat stroke vshift rect show end rshow begin currentpoint text stroke cfg dup stringwidth black pop setcfg neg vshift show cshow currentpoint stroke dup helvetica stringwidth setf pop div vshift show concat color shell setrgbcolor text solid end pop end setdash eop pop begin pop pop rect solid pop setdash setb ifelse cfg stroke black gnulinewidth setcfg mul cbg setlinewidth white stroke setcbg gnulinewidth setp div setlinewidth stroke gnulinewidth concat setlinewidth ltb rect end begin lta rect setdash setb setrgbcolor cfg black setcfg cbg white setcbg setp concat rect end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg stroke setdash currentlinewidth helvetica div setf currentlinewidth stroke concat stroke text setdash end copy vpt begin add text hpt cfg neg vpt neg black hpt setcfg vpt neg hpt vpt hpt neg vpt closepath helvetica stroke setf stroke setdash concat vpt byte vpt currentpoint text stroke end hpt begin neg vpt text neg cfg hpt black stroke setcfg stroke setdash copy exch hpt helvetica exch vpt setf add vpt neg hpt concat vpt page hpt text neg end closepath begin stroke text cfg stroke black setdash exch setcfg hpt exch vpt add hpt vpt neg helvetica currentpoint setf stroke hpt neg concat hpt vpt offset stroke text end stroke begin setdash text copy vpt cfg black setcfg helvetica setf concat index text end begin text cfg black setcfg helvetica setf concat seg text end begin text cfg black setcfg mul add hpt neg vpt helvetica mul setf hpt mul concat hpt neg text vpt end mul begin closepath line stroke copy setb cfg end gnudict black begin setcfg gsave cbg translate white scale setcbg setgray setp helvetica findfont scalefont setfont newpath concat lta line ltb end begin line rshow setb cfg black setcfg cbg rshow white setcbg setp rshow concat line rshow end begin line rshow setb cfg black 
rshow setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin text cfg black setcfg helvetica setf concat index text end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin rect setb cfg black setcfg cbg white setcbg setp concat rect end begin pict cfg cbg setp begin rect setb cfg black setcfg cbg white setcbg setp concat rect end begin line setb cfg black setcfg cbg white setcbg setp concat line end end eop begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf concat text end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin pict cfg cbg concat begin elli setb cfg black setcfg cbg white setcbg setp concat elli end begin text cfg black setcfg helvetica setf concat dtb annex text end end eop begin line setb cfg black setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin text cfg black setcfg helvetica setf concat address translation text end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin text cfg black setcfg helvetica setf concat offset text end begin text cfg black setcfg helvetica setf concat page text end begin text cfg black setcfg helvetica setf concat byte text end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf concat text end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin text cfg black setcfg helvetica setf concat text end begin line setb cfg black setcfg cbg white setcbg setp concat line end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf concat text end begin text cfg black setcfg helvetica setf rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate messages cshow grestore time seconds cshow messages time make cshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures rate make eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate messages cshow grestore time seconds cshow messages time make cshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures rate make eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth concat div offset text currentlinewidth end begin stroke text cfg stroke setdash black copy setcfg vpt add hpt neg vpt neg hpt vpt helvetica neg setf hpt vpt hpt neg concat vpt closepath page stroke text end begin stroke setdash vpt text cfg vpt black currentpoint setcfg stroke hpt neg vpt neg hpt helvetica stroke setf stroke setdash copy concat byte text end end eop showpage end enddocument endtexfig figure dtb nnex -bit virtual address translated -bit ysical address follo index annex eac annex eci function remote pro cessor bits supp ort memory-mapp devices remote access olv storing destination annex accessing desired set corresp onding segmen virtual address space annex presen set reg- isters compiler ust manage short sequence instructions required erform remote access global ointer rep resentation erations natural hoice global oin ter represen tation bit tit cal address stored bits pro cessor stored upp bits size cal address transfer cien alpha erful yte manipulatio instructions ex- tracting comp onen global oin ter erforming arithmetic fast fact virtual memory mapping bit virtual address cal address arithmetic erformed global oin ters cal oin ters re- sult nev pro cessor ortion address meaning global oin ter indep enden pro cessor dereferences freely shared data structures dereference pro cessor extracted stored annex register annex inserted biteld generate alid virtual address load store instruction lo- cal arithmetic erformed ternal global oin ter ultiple made incur- ring cost annex setup annex register management question underlying global oin ters compiler manages annex registers simplest ap- proac annex register date eac global access skipping annex date com- piler determine successiv accesses pro cessor alternativ sev eral annex registers eep run time table table okup added eac global access bined compiler analysis eliminate table okup cien static information oin ters surface ultiple annex registers app ears etter alternativ leads subtle semany tic problems end clear erformance adv tage seman tic problem ccurs annex regy isters ecify pro cessor annex ery forms address translation ysical addresses allo synon yms ysical addresses annex index map cation cac write ysical addresses determine accesses cation synon yms ten tially lead inconsisten copies inconsistencies cac hing arise ecause annex app ears high order bits address cac direct-mapp synon yms alw map cac line write admit iny consistencies reads ypass writes write foly read synon read stale alue memory write caugh write pro duced prob exhibit unpleasan phey nomenon order ultiple annex registers compiler ust recognize aliases een global oin ters ust generate run time hec prev synon yms run time table annex ept annex register selected hashing pro cessor ortion global oin ter simple table okup requires memory read branc vings relativ -cycle annex date small nal consideration ultiple annex registers teracts orly asp ects memy ory system annex register app ears high order bits virtual address remote accesses consume tlb concerns oin aly determined pro cessor con gured uge pages tlb summa global oin ters easily represen ted form iden tical cal oin ters address arithy metic global oin ters extremely fast capabily due -bit arc hitecture alpha ell erful yte manipulati instructions small ysical address space presen problem large shared memory ultipro cessors compiler explicitly manages global ady dress space external segmen registers extend ectiv ysical addressing teracts orly memory system complicates generation proy vision man external segmen registers app 
ears small alue remote reads rites shell pro vides large set mec hanisms reading writing global address space eac seman tics costs compiler writer ust determine whic mec hanisms impley men language primitiv ose fastest section describ implemen tation simplest splity remote access primitiv write seman tics required split-c haracterize erformance similar mec hanisms describ resulting eop page bop starttexfig begindocument newfigures final uncached read eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath computer systems sigmetrics pages ottawa mccann canada zahorjan chen lee parallel gibson jobs katz study require patterson raid xed high-performance reliable secondary storage des acm computing life-times surveys assigning stroke exch hpt smaller exch copy vpt add end vpt gnudict neg begin des hpt gsave vpt translate hpt scale neg setgray closepath helvetica stroke findfont job scalefont setfont stroke newpath setdash ossible exch lta hpt finally exch vpt ltb add hpt vpt assume neg currentpoint stroke priori rshow hpt kno neg wledge hpt vpt stroke ailable rshow stroke paralleli setdash copy vpt mul add pro- hpt grams rshow neg vpt mul hedule hpt mul hpt impact rshow neg memory vpt mul managemen closepath stroke rshow een copy scruti- end gnudict nized begin gsave ultipro translate cessor scale rshow setgray vironmen helvetica findfont chandra scalefont setfont newpath cshow lta ashok zahorjan ltb ashok cshow zahorjan studied rshow mix- ing cshow teractiv rshow batc cshow orkload parallel rshow shared- cshow memory ercomputer rshow found cshow partitioning mem- rshow ory statically cshow een batc rshow teractiv cshow jobs erforms rshow etter cshow olicies rshow ary cshow dynamically study rshow ers cshow batc rshow teractiv cshow jobs nev rshow share eris colleagues conclude mem- cshow ory managemen imp ortan cshow issue eris cshow currentpoint noticeable gsave impact translate cshow pro rotate cessor time allo nanoseconds cation cshow hemes grestore cshow stride bytes man cshow uncached des cshow remote read cshow giv split-c currentpoint rshow gsave appli- translate rotate cation messages cshow assume grestore time seconds pro cshow cessors messages time completely make decided cshow requesting application erating system fora merging parallelism cal area net ork vironmen een made ort rshow een directed bringing ne-grained parallel applicatio desktop classic bringing parallelism arallel virtual mac hine sunderam etter kno pvm pvm allo users run parallel ap- plications heterogeneous net ork mac hines pvm allo programs man separate pro cesses rshow run feasibly run jobs comm unicate sync hronize frequen tly ecause high message la- tencies erheads douglas study mixing parallel programs ork- station cluster leutenegger rshow sun sim ulation study parallel application run non-dedicated vironmen suc demon- strating stroke grestore ossible end showpage enddocument signi endtexfig figure rshow im- pact message rate parallel programs make ork workload graph discuss sho number oten messages tial impact workstation sends teractiv users urther xperiment sim ulations driv syn usiest thetic dels serv oth source les orksta- tion rshow parallel nodes program eha vior conclusions parallel make master large literature nodes harv esting idle cy- cles workers sequen vironment tial load sharing equally ell usy ex- peak ecuting parallel end programs rshow due dedicated link building stage earlier compilation ork eop examined page bop feasibilit bin- ing starttexfig sequen tial begindocument parallel figures rate jobs eps single gnudict dict platform gnudict begin color sho false solid false parallel programs gnulinewidth vshift rshow tolerate mul hpt dif- vpt culties presen moveto bind distributed lineto bind systems suc rmoveto bind cosc rlineto bind hedul- vpt ing vpt mul hpt cal hpt mul daemon pro lshow currentpoint cesses stroke vshift show erformance rshow currentpoint degradation stroke dup idle stringwidth pop neg vshift show rshow cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div cycles ere presen cluster rshow traced ectiv ely supp ort oth sequen tial parallel orkloads giv setlinewidth reasonable stroke gnulinewidth cruitment setlinewidth thr ltb eshold cien lta implemen tation setdash pro setrgbcolor cess migration success prop osed system hinges main taining resp onse time teractiv sequen tial users clus- ter parallel jobs ere run inactiv mac hines stroke setdash rshow currentlinewidth div ecause currentlinewidth secondary stroke memory ects stroke setdash copy ving vpt add parallel hpt pro neg vpt cess neg hpt vpt neg hpt vpt orkstation hpt neg vpt closepath stroke ten tially stroke setdash vpt costly vpt teractiv rshow currentpoint stroke users hpt neg vpt neg hpt re- turn stroke stroke cial setdash copy ontr exch act hpt exch vpt add vpt neg minimize hpt vpt hpt neg closepath terruptions stroke stroke grestore end stroke showpage setdash sequen enddocument exch tial hpt user endtexfig exch vpt add hpt main- vpt neg taining parallel currentpoint starttexfig stroke throughput hpt begindocument neg figures hpt cached traces vpt read latency stroke eps found gnudict stroke dict setdash gnudict copy rule begin vpt color mul applies false add hpt solid neg false cluster vpt mul gnulinewidth mac hpt hines vshift mul hpt sustain neg mul vpt mul hpt -no closepath vpt parallel stroke orkload moveto bind copy addition lineto end bind gnudict sequen begin tial rmoveto load bind rlineto bind teractiv vpt users vpt mul ackno hpt hpt mul wledgements lshow currentpoint ould stroke lik vshift show jerry delapp rshow currentpoint lanl stroke dup stringwidth cmy pop traces neg vshift ell show brad cshow krebbs currentpoint stroke cad dup gsave group stringwidth pop translate div vshift assistance show scale gathering setgray color helvetica orkstation setrgbcolor findfont solid scalefont haracteristics setfont pop newpath setdash pop pop lta ould pop lik solid pop setdash doug ltb ifelse ghormley stroke gnulinewidth detailed mul study setlinewidth daemon stroke pro gnulinewidth cesses div lastly setlinewidth ould stroke lik gnulinewidth setlinewidth ltb ann cherv enak lta vid culler mik setdash setrgbcolor dahlin john oustery hout rshow ric martin commen rshow arious drafts rshow pap anderson rshow anderson owic rshow saxe thac high stroke setdash eed currentlinewidth switc div heduling currentlinewidth stroke cal area stroke net setdash orks copy vpt add hpt neg ansactions vpt neg hpt computer vpt systems neg hpt vpt hpt neg ashok vpt zahorjan closepath ashok stroke zahorjan stroke setdash vpt heduling mixed vpt teractiv currentpoint stroke batc rshow hpt neg vpt orkload neg hpt stroke araly lel stroke shared-memo setdash copy exch ercomp rshow hpt ute exch vpt add vpt neg rshow hpt vpt dings hpt neg closepath omputing rshow stroke stroke setdash exch hpt rshow exch vpt add hpt biagioni vpt neg rshow currentpoint stroke biagioni hpt neg hpt vpt cshow stroke sansom stroke designing setdash copy practical cshow vpt mul add lan hpt neg vpt ieee mul network cshow 
june chen cshow patterson maximizing performance striped disk cshow array proceedings annual international cshow symposium computer architecture isca pages cshow seattle washington chen currentpoint patterson gsave translate approach rotate performance messages evaluation self-scaling cshow benchmarks predicted grestore time performance seconds proceedings cshow acm messages sigmetrics time conference measurement cshow modeling computer systems sigmetrics pages santa clara california denehy arpaci-dusseau arpaci-dusseau bridging hpt mul hpt neg vpt mul closepath stroke copy end gnudict marc patternnone begin gsave brushleftarrow blello translate brushrightarrow scale setgray helvetica ifill findfont brushnone blello scalefont istroke setfont newpath leftarrow leiserson lta dup dup ltb maggs rightarrow end dup dict comparison put sorting poly rshow roll algorithms newpath moveto add lineto repeat cony closepath nection patternnone rshow mac ifill hine brushnone cmb istroke rect symp rshow begin osium exch par exch exch lel rshow exch lgorithms newpath moveto chite lineto ctur lineto rshow lineto closepath july patternnone ifill brushnone blumric istroke end dup dict put blumric text ishow idef dup pop alp pop pop ert exch ifelse ifill begin duby gsave nic patterngraylevel fgred bgred fgred elten patterngraylevel mul add fggreen sandb bggreen erg fggreen patterngraylevel mul virtual add fgblue bgblue memy fgblue ory patterngraylevel mapp mul add net rshow setrgbcolor eofill eoclip originalctm setmatrix pathbbox exch cshow exch exch exch cshow ceiling cvi ceiling cvi imagebytewidth cshow div ceiling cvi imageheight bgred bggreen cshow bgblue setrgbcolor eofill fgred fggreen ork fgblue setrgbcolor cshow terface translate shrimp scale true muly cshow ticomputer neg patternproc imagemask ifelse grestore end dings cshow dup dict put istroke gsave international brushdashoffset symp cshow osium setdash setgray computer brushdasharray brushdashoffset setdash chite fgred cshow ctur fggreen fgblue setrgbcolor april ifelse brushwidth setlinewidth originalctm cshow den setmatrix stroke grestore ishow begin den gsave fgred cshow fggreen cohen fgblue setrgbcolor fontdict elderman printfont findfont cshow printsize scalefont kula dup wik setfont descender fontdict seitz begin currentpoint gsave fontbbox seizo translate vic fontmatrix rotate end transform time exch nanoseconds pop vertoffset myrinet gigab et-p cshow er-s eco grestore descender stride printsize bytes cal-area printfont net courier cshow cached printfont ork read courier-bold ieee latency cshow add micr vertoffset moveto show rshow vertoffset ebruary vertoffset printsize forall carriero grestore end gelern dup ter dict put patternproc carriero begin patternbytelength patternstring gelern length ter patternheight patternbytelength linda mul sqrt cvi con patternwidth text patternheight communic patternbytewidth ations patternwidth idiv imagebytemaxlength imagebytewidth imageheight april mul stringlimit patternbytewidth chandra min imagemaxheight imagebytemaxlength chandra imagebytewidth idiv patternheight devine idiv patternheight mul erghese patternheight max imageheight gupta rshow imageheight imagemaxheight rosen store imagestring blum imagebytewidth imagemaxheight mul heduling 
age migration multipro cessor computer serv ers dings international confer enc chite ctur supp ort amming anguages ating systems octob chiang chiang mansharamani ernon application characteristic limited preemption run-t o-completion araly lel pro cessor heduling olicies dings sigmetrics confer enc ebruary ark adas keleher jamon aenep soft ery sus hardw shared-memo implemen atio case study dings international symp osium computer chite ctur april cro ella cro ella das dubnic leblanc mark atos multiprogramm ing ultipro cessor hnical rep ort univ ersit hester computer science departmen ebruary revised eop page bop culler culler dusseau goldstein kry ishnam urth lumetta eic elic arallel programmin split-c dings omputing culler culler karp atterson saha hauser san tos subramoni eic logp ards realisy tic del arallel computation ourth sigplan symp osium principles actic par lel amming culler culler dusseau martin hauser portability performanc par aly lel essing hapter ast arallel sorting logp theory practice john wiy ley sons dahlin dahlin ang anderson atterson erativ cac hing remote clien memory impro file system erformance ding confer enc aty ing systems design implementation delisle delisle ersonal comm unicati octob douglas douglas mattson ultz arallel programming systems orkstation clusters hnical rep ort ale univ ersit computer science departmen august douglis ousterhout douglis ousterhout ransparen pro cess migration design alternativ sprite implemen tat ion softwar actic exp erienc august eager eager lazo wsk zahory jan adaptiv load shating homogeneous disy tributed systems ieee ansactions softwar engine ering eitelson rudolph eitelson rudolph gang heduling erformance bene finey grained sync hronizat ion journal par lel distribute computing decem elten zahorjan elten zahorjan issues implemen tat ion remote aging system hnical rep ort univ ersit stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures rate eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray ashingy helvetica findfont scalefont setfont newpath lta ltb rshow rshow ton departmen computer rshow science marc gelern rshow ter gelern rshow ter arallel programming rshow linda ding rshow international confer enc rshow rshow pary lel essing rshow august gupta rshow gupta cshow urushibara impact erating cshow system heduling olicies cshow sync hroniz atio metho cshow erformance arallel cshow applications cshow cshow currentpoint gsave translate rotate messages cshow grestore time seconds cshow messages time cshow dings sigmetrics confer enc krishnam urth krishnam urth lumetta culler katherine connected comy information rshow gap storage protocol stacks proceedings usenix patternbytewidth add string imagemaxheight exch patternrow patternbytewidth mul stroke patternbytelength grestore mod end showpage patternrowstring enddocument patternstring endtexfig patternrow patternbytewidth getinterval imagerow imagebytewidth starttexfig mul begindocument figures rate patternbytewidth eps imagebytewidth gnudict dict exch gnudict imagestring begin color imagerow false add solid patternrowstring false putinterval gnulinewidth imagestring vshift end mul hpt vpt moveto bind lineto dup dict put bind min rmoveto dup bind roll dup rlineto roll bind exch vpt vpt pop mul max hpt dup hpt roll mul dup roll lshow exch currentpoint pop stroke arrowhead vshift begin show transform originalctm rshow itransform currentpoint taily stroke exch dup tailx stringwidth exch pop neg transform vshift originalctm show itransform tipy cshow exch currentpoint tipx stroke exch dup tipy stringwidth taily pop div tipx vshift tailx show angle color setrgbcolor solid pop atan setdash ifelse pop pop gsave pop solid originalctm pop setmatrix tipx setdash tipy ifelse translate angle rotate stroke newpath moveto gnulinewidth arrowheight mul neg arrowwidth setlinewidth div lineto arrowheight neg stroke arrowwidth div gnulinewidth neg div lineto setlinewidth closepath patternnone stroke gnulinewidth originalctm setlinewidth setmatrix padtip ltb arrowheight exp lta arrowwidth exp mul add sqrt setdash brushwidth mul setrgbcolor arrowwidth div padtail brushwidth div tipx tipy translate angle rotate padtip translate arrowheight padtip add padtail add arrowheight div dup scale arrowheadpath ifill brushnone originalctm setmatrix tipx tipy translate angle rotate arrowheadpath istroke grestore end dup dict put arrowheadpath newpath moveto arrowheight neg arrowwidth div lineto arrowheight neg arrowwidth div neg lineto closepath leftarrow begin exch taily exch exch tailx exch exch tipy exch exch tipx exch brushleftarrow stroke setdash onen currentlinewidth div distributed currentlinewidth memory stroke mac hines stroke setdash copy vpt add thir hpt dima neg vpt neg international lgorithm hpt vpt neg implemeny tation hpt vpt chal hpt lenge neg kronen vpt erg kronen closepath erg stroke stroke setdash vpt levy vpt tipx currentpoint stroke strec hpt neg vpt neg hpt stroke axclusters closely-coupled stroke distributed setdash copy system exch hpt exch vpt add ansactions vpt neg hpt comy puter vpt systems hpt tipy neg tailx closepath taily arrowhead stroke end lamp dup ort dict stroke put setdash lamp exch hpt rightarrow ort begin exch vpt exch add tipy hpt concurren exch vpt neg exch reading currentpoint tipx stroke exch riting hpt exch neg clo hpt taily vpt exch stroke exch stroke ansactions setdash tailx copy computer vpt mul systems add hpt neg vpt mul april hpt mul hpt lazo neg wsk vpt mul lazo wsk closepath stroke copy orkstation end gnudict begin nety gsave ork alk translate presen scale setgray helvetica ted findfont scalefont setfont sixth newpath lta ternationa ltb cony ference arc hitectural supp ort rshow programming languages erating rshow systems octob leigh rshow ton leigh rshow rshow rshow rshow rshow rshow rshow ton rshow tigh bounds complexit cshow arallel sorting ieee cshow ansactions computers april cshow leiserson leiserson cshow net ork cshow arc hitecture connection cshow mac hine cmb symp osium cshow par lel lgorithms currentpoint gsave translate chite rotate ctur april messages leutenegger cshow sun grestore time leutenegger seconds cshow sun messages exch time brushrightarrow distributed tipx cshow computing tipy tailx easibilit taily arrowhead end dup nony dict put dedicated midpoint begin homogenous exch distributed exch system exch suy exch omputing add div add div leutenegger end ernon dup dict put leutenegger thirdpoint begin exch ernon exch exch erformance exch mul ultiprogr amm add div mul uly add tipro div cessor end dup heduling dict put olicies subspline stroke begin grestore movetoneeded end exch showpage dings enddocument exch endtexfig exch sigmetrics confer enc starttexfig begindocument figures rate eps litzk gnudict dict solomon gnudict begin litzk color false solid false solomon gnulinewidth vshift supy orting mul chec hpt oin ting vpt pro moveto bind cess migration lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke exch dup stringwidth pop exch neg vshift exch show outy side exch unix cshow exch currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor rshow stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg rshow vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke rshow stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow annual technical rshow conference usenix pages monterey california rshow june emc corporation symmetrix enterprise information storage rshow systems http emc glaser rshow tcp stack fingerprinting principles http sans cshow newlook resources idfaq tcp ngerprinting htm cshow october cshow grochowski cshow emerging trends data storage magnetic cshow hard disk drives datatech september cshow hsiao dewitt chained declustering availability cshow strategy multiprocessor database machines proceedings currentpoint gsave international conference translate data rotate engineering messages icde cshow pages los grestore angeles time california seconds cshow february messages katcher time postmark cshow file system benchmark technical report trnetwork appliance october lee katz performance consequences parity placement exch exch exch exch exch exch exch exch exch thirdpoint exch exch thirdpoint exch exch thirdpoint midpoint exch exch thirdpoint midpoint exch exch movetoneeded moveto disk curveto arrays end proceedings dup dict put international storexyn conference exch stroke architectural grestore array support end programming showpage array enddocument languages endtexfig exch operating figure systems roll asplos put roll put message idraw rate begin cfg cbg web workload pages santa graph clara sho concat california originalctm matrix april number currentmatrix lumb messages schindler ganger workstation nagle type plot sends riedel -help higher disk information head begin utilization mline xperiment extracting free gate setb bandwidth cfg busy black disk internet drives setcfg cbg proceedings white setcbg symposium operating setp systems design implementation concat osdi usiest pages san machine diego follo mline california wed end begin october text norcutt iozone filesystem cfg benchmark black http setcfg home iozone helvetica-medium-r sap-serv padhye helvetica setf floyd identifying tcp concat behavior nodes web serv compute servers text end proceedings begin workers mline sigcomm eop setb page cfg bop black 
setcfg cbg white setcbg setp concat kernel winter usenix confer enc starttexfig begindocument figures rate oracle eps mline gnudict dict end gnudict begin begin color text false cfg solid black false setcfg gnulinewidth helvetica-medium-r vshift helvetica setf mul hpt concat vpt comm moveto text bind end begin lineto mline bind rmoveto bind setb cfg rlineto bind black setcfg vpt vpt cbg mul white hpt setcbg hpt mul setp lshow currentpoint stroke concat vshift show rshow currentpoint mline stroke end dup begin stringwidth text pop cfg neg black vshift setcfg show helvetica-medium-r cshow currentpoint helvetica stroke setf dup stringwidth pop concat div sync vshift text end show begin text color cfg setrgbcolor black solid setcfg pop helvetica-medium-r setdash pop pop helvetica pop setf concat transpose text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat switch text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat idle text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat fractionoftime text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg solid pop setdash ifelse jan uary martin martin activ message net ork orkstations dings hot inter onne cts confer enc july mccann zahorjan mccann zahorjan proy cessor allo cation olicies message-p assing araly lel computers dings sigy metrics confer enc ebruary mutk livn mutk livn aily capacit priv ately owned orkstation eny vironmen performanc evaluation july naik naik setia squillan erformance analysis job heduling olicies arallel ercomp utin vironmen ings omputing nic hols nic hols idle orkstations shared computing vironmen dings eleventh symp osium ating systems principles ousterhout ousterhout heduling hniques concurren systems thir international confery enc distribute computing systems eris eris squillan naik analysis impact memory distributed ary allel pro cessing systems dings sigmetrics confer enc ebruary reinhardt reinhardt larus emp est ypho user-lev shared memory dings international symp osium computer chite ctur april sev cik sev cik characterizati ons arallelism applications heduling ings sigmetrics perf ory mance confer enc asur ement deling computer systems sunderam sunderam pvm ramew ork arallel distributed computing concurr ency actic exp erienc decem theimer lan theimer lan finding idle mac hines orkstation-ba sed disy tributed system ieee ansactions softwar engine ering eop page bop theimer theimer landtz cheriton preemptable remote execution acilities system dings symp osium ating systems principles decemy gupta gupta pro cess con trol heduling issues ultiprogra shared-memor ultipro ssor ating systems eview eic eic culler goldstein hauser activ messages mec anism tegrated comm unication computay tion dings international symy osium computer chite ctur gold coast ausy tralia eic eic avula basu buc w-latency comm unicatio neto wrks activ messages dings hot inter onne cts stanford august zhou zhou ang zheng delisle utopia load sharing acilit large heteroy geneous distributed computing systems hnical rep ort csrif univ ersit oron eop trailer end userdict end-hook end-hook eof 
rshow rshow rshow rshow rshow stroke grestore end showpage enddocument endtexfig figure emote atency uncac hed cac hed read latency implemen tation end discussion seman tic mismatc hes discrepancies een eha vior ned language implemen ted mac hine required wkw ard ork arounds split-c global memo access assignmen statemen global oin ter righ hand side remote global oin ter left-hand side remote write reads writes blo king erations read aits requested alue arriv remote pro cessor write aits kno wledgemen write complete there- fore erations app ear sequen tially consisten programmer remote reads pro vides remote reads cac hed uncac hed standard alpha load instruction global address function dtb annex eci read cac hed read dates requested line ytes cac places requested ord eci register uncac hed read fetc hes requested ord dify cac determine latency remote reads difying cal micro-b enc hmark strides remote memory results sho figure uncac hed read costs roughly cycles cac hed read costs cycles cal-memory erations strides greater -page dram access time emote memory con- troller whic increases erage access time cycles cost cac hed reads dep ends con ten cal cac micro-b enc hmark arra sizes cac result cal-cac memory-access times rst time arra brings data cal successiv iterations cac hed reads erform sligh tly eren tly strides ytes bringing tire cac lines cac hed reads essen tially prefetc accesses note measuremen adjacen pro cessor activ mea- suring additional latency net ork rev eals roughly cycle cost hop put costs ersp ectiv remem rey mote uncac hed read times slo read cal memory fact latency remote memory higher main memy ory access including tlb miss dec orkstation signi tly faster similar mpps cost read remote ash ultipro cessor roughly ksr remote rites primitiv examine remote write remote read extension load instruction remote writes alpha store instruction global address stores handled write-bu non-blo kin ust explicitly oll rey mote kno wledgemen order matc seman tics language kno wledgemen automatically sen hardw bit cal shell stay tus register cleared figure sho write-latency pro blo king remote writes completing roughly nanoseconds cycles subtlet arose implemen ting blo king write illustrates ted teractions ccur een custom shell commo dit core remote-write status bit set writes left pro cessor returned clear ending remote writes write oll bit ust rst guaran tee corresp onding write left issuing memory barrier instruction cien writes whic ectiv ely increases cost eration compiler implications immediately vious whic mec hanism implemen split-c primitiv cac hed reads higher bandwidth cult mac hine guaran tee coherence cac hed alues pro cessor wns cac line dates hange ected remote pro cessors cac hing line reads cac line ould obtain stale data cac hed reads ere reading remote alues cac line ould eop page bop starttexfig begindocument newfigures final write ack eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt 
vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke isca stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt oto add hpt vpt neg currentpoint stroke xljm hpt neg hpt vpt stroke stroke setdash copy vpt mul hjy add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont iego setfont newpath lta ltb bul qmg rshow rshow rshow rshow fakc rshow rshow cshow cshow adr cshow cshow iajx cshow dqs cshow fsr cshow cshow cshow cshow cshow cshow pwv currentpoint gsave translate rotate time nanoseconds cshow grestore stride bytes cshow blocking remote write latency cshow split-c rshow lcuv tkfu rshow ick ein jcl -zf rshow a-l qgv woc baq ccg dgrz rshow rshow xny san diego california august patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod conference management data sigmod pages chicago illinois june pelleg moore x-means extending k-means cient estimation number clusters proceedings international conference machine learning june regehr inferring scheduling behavior hourglass proceedings usenix annual technical conference freenix track monterey california june ruemmler wilkes introduction disk drive modeling ieee computer march saavedra smith measuring cache tlb performance effect benchmark runtimes ieee transactions computers savage wilkes afraid frequently redundant array independent disks proceedings usenix annual technical conference usenix pages san diego california january schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon november schindler grif lumb ganger track-aligned extents matching access patterns disk drive characteristics proceedings usenix symposium file storage technologies fast monterey california january schindler schlosser shao ailamaki ganger atropos disk array volume manager orchestrated disks proceedings usenix symposium file storage technologies fast san francisco california april staelin mcvoy mhz anatomy micro-benchmark proceedings usenix annual technical conference usenix pages orleans louisiana june talagala arpaci-dusseau patterson microbenchmark-based extraction local global disk characteristics technical report csd- california berkeley varki merchant qiu issues challenges performance analysis real disk arrays ieee transactions parallel distributed systems june wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february worthington ganger patt wilkes on-line extraction scsi disk drive parameters proceedings acm sigmetrics conference measurement modeling computer systems sigmetrics pages ottawa canada 
cbg stroke white setcbg gnulinewidth mul setp setlinewidth stroke gnulinewidth concat div setlinewidth stroke gnulinewidth mline setlinewidth end begin ltb mline lta setb cfg black setdash setcfg setrgbcolor cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg stroke setp setdash currentlinewidth div concat currentlinewidth stroke stroke mline setdash end begin mline copy vpt setb add cfg hpt neg black vpt setcfg neg cbg hpt white vpt neg setcbg hpt vpt hpt neg vpt closepath setp stroke stroke setdash concat vpt vpt currentpoint stroke mline hpt end neg vpt begin neg mline hpt stroke setb stroke cfg setdash black copy exch setcfg hpt cbg exch vpt white add setcbg vpt neg setp hpt vpt concat hpt neg closepath stroke stroke setdash exch mline hpt end exch begin vpt add mline hpt vpt neg currentpoint stroke hpt setb neg cfg hpt vpt black stroke setcfg cbg stroke white setdash copy setcbg vpt mul setp add concat mline end begin mline hpt neg vpt setb mul cfg hpt black mul setcfg hpt cbg neg vpt white mul setcbg closepath stroke setp copy concat end gnudict begin mline gsave end begin translate mline scale setgray helvetica setb findfont cfg scalefont black setcfg cbg white setcbg setfont setp newpath lta concat ltb mline end begin text rshow cfg black setcfg helvetica-medium-r rshow helvetica setf rshow concat text end begin mline setb cfg rshow black setcfg cbg white setcbg setp rshow concat rshow mline end begin mline rshow setb cfg black setcfg cbg rshow white setcbg setp rshow concat mline rshow end begin mline setb rshow cfg black setcfg cbg white setcbg setp cshow concat cshow mline end begin cshow mline setb cfg black cshow setcfg cbg white setcbg setp cshow concat cshow mline end begin mline currentpoint setb gsave cfg translate black rotate setcfg messages cbg cshow white setcbg grestore time setp seconds cshow concat messages time mline database end cshow begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb stroke cfg grestore end black setcfg showpage cbg white setcbg setp enddocument concat endtexfig starttexfig begindocument figures rate oracle eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt mline vpt mul end begin hpt hpt mline mul lshow setb currentpoint stroke cfg vshift black setcfg show cbg rshow white currentpoint setcbg stroke setp dup stringwidth pop concat neg vshift show mline cshow end begin mline currentpoint stroke setb cfg dup black setcfg cbg stringwidth white setcbg pop setp div vshift concat show color setrgbcolor mline solid end begin pop mline setdash pop 
pop pop solid pop setdash setb ifelse cfg stroke black setcfg gnulinewidth cbg mul white setlinewidth setcbg stroke setp gnulinewidth div setlinewidth concat stroke gnulinewidth mline setlinewidth end begin ltb mline setb lta cfg black setcfg cbg setdash white setrgbcolor setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg stroke cbg white setdash setcbg setp currentlinewidth div concat mline end currentlinewidth begin stroke mline stroke setb setdash cfg copy vpt black add setcfg hpt cbg neg white vpt setcbg setp neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg concat hpt stroke stroke mline setdash end copy begin exch mline hpt exch vpt add setb cfg vpt neg black hpt setcfg cbg vpt white hpt setcbg neg closepath setp stroke stroke concat setdash exch hpt exch mline vpt add end begin hpt vpt mline neg currentpoint stroke setb hpt cfg neg black hpt setcfg vpt cbg stroke white setcbg setp stroke setdash copy concat vpt mul add hpt mline neg vpt end begin mul hpt mul hpt text neg cfg vpt black mul setcfg closepath stroke helvetica-medium-r copy helvetica setf end gnudict begin gsave translate concat scale setgray helvetica findfont scalefont text setfont end newpath begin text lta cfg black setcfg ltb helvetica-medium-r helvetica setf rshow concat text end begin rshow mline rshow setb cfg black setcfg cbg rshow white setcbg setp rshow concat rshow rshow mline end begin mline rshow setb cfg black setcfg cbg white setcbg rshow setp concat mline end begin rshow mline setb cfg black setcfg rshow cbg white setcbg setp cshow concat mline end begin cshow mline setb cfg black setcfg cshow cbg white setcbg setp cshow concat mline cshow end begin mline setb cfg cshow black setcfg cbg white setcbg setp currentpoint gsave translate concat rotate messages mline end cshow begin mline grestore time setb seconds cfg cshow black messages setcfg cbg time white setcbg database cshow setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline stroke grestore end showpage setb cfg enddocument black endtexfig setcfg cbg white setcbg setp starttexfig concat begindocument figures rate oracle eps mline end gnudict begin dict mline gnudict begin setb cfg black color setcfg false cbg white setcbg solid setp false gnulinewidth vshift concat mul hpt vpt mline end moveto begin bind mline lineto bind setb rmoveto cfg bind black rlineto setcfg bind cbg vpt white vpt setcbg mul hpt setp hpt mul concat lshow currentpoint stroke vshift mline end show begin mline rshow currentpoint stroke setb dup cfg stringwidth black pop neg setcfg vshift cbg show white setcbg cshow setp currentpoint stroke dup stringwidth concat pop div vshift mline end show begin mline color setrgbcolor solid setb pop cfg black setdash setcfg pop cbg pop pop white solid setcbg pop setp setdash ifelse concat stroke gnulinewidth mul setlinewidth mline end begin stroke text gnulinewidth cfg div setlinewidth black setcfg stroke gnulinewidth helvetica-medium-r setlinewidth ltb helvetica setf lta setdash concat setrgbcolor text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline 
setb cfg black setcfg cbg white stroke setcbg setdash currentlinewidth div setp currentlinewidth stroke concat stroke setdash copy vpt add hpt mline neg end vpt neg begin hpt mline vpt neg hpt setb vpt cfg hpt black neg setcfg vpt cbg closepath white stroke setcbg setp stroke setdash vpt vpt concat currentpoint stroke mline end hpt begin neg mline vpt neg hpt setb stroke cfg black setcfg stroke cbg setdash copy exch hpt white setcbg exch vpt add setp vpt neg concat hpt vpt hpt neg closepath mline stroke end begin mline stroke setdash setb exch hpt cfg exch black vpt setcfg add cbg hpt white vpt setcbg neg currentpoint setp stroke hpt neg concat hpt vpt stroke mline end begin stroke mline setdash copy vpt setb mul cfg add black hpt setcfg neg vpt cbg white mul setcbg hpt setp mul hpt neg vpt concat mul closepath mline end begin stroke text cfg black copy setcfg end helvetica-medium-r gnudict helvetica setf concat text end begin mline setb begin cfg gsave black setcfg translate cbg scale setgray helvetica white setcbg findfont scalefont setp setfont newpath lta concat ltb mline end begin mline rshow setb cfg black setcfg cbg rshow white setcbg setp concat rshow mline end begin mline rshow setb cfg rshow black setcfg cbg white setcbg setp rshow concat rshow mline end begin mline setb rshow cfg black setcfg cbg white rshow setcbg setp concat rshow mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline rshow setb cfg black setcfg cbg white setcbg cshow setp concat cshow mline end begin text cfg black cshow setcfg helvetica-medium-r helvetica setf cshow concat text cshow end begin mline setb cfg black cshow setcfg cbg white setcbg currentpoint gsave setp translate rotate messages concat cshow grestore mline time end seconds begin mline cshow messages setb cfg black time setcfg cbg database white cshow setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg stroke grestore white end setcbg showpage setp enddocument concat endtexfig mline starttexfig end begin begindocument mline figures rate oracle setb eps cfg gnudict black dict setcfg cbg gnudict begin white color setcbg false setp solid false concat gnulinewidth vshift mline end mul begin mline hpt vpt setb cfg moveto bind black setcfg cbg white setcbg lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate messages cshow grestore time seconds cshow messages time database cshow stroke grestore end showpage enddocument endtexfig figure message rate database workload graph sho number messages workstation sends xperiment rate machines xcept machine housing disk workload machine surprisingly times usy eop page bop xample conserv ation communication implications section workload highly uences message traf cluster xample elopment type vironment modeled make workload message traf highly non-uniform message traf hot-spots disks system message sizes vironment highly ariable strongly uenced size les rele ant workload ith system anticipate breakdo man small messages lar messages data web serv traf patterns dependent number users web service web workload pro vides steady stream requests models constantly usy serv type workload message traf spread enly nodes xception node running sap-serv sap-serv contacted time port number bound potential bottleneck man small messages payload message deli ered ratio partly attrib uted tcp inef fecti support http simple http requires tcp open connection send message recei message close connection dependent design networking subsystem database workload gular strongly correlated fact workstation running simple debit credit script ith node constantly performing transactions message traf clustered disks implication message layer support medium-sized messages sizes bytes important note -byte message size supported early acti message layers vironment dif cult deem workload typical workloads made xtensi medium-sized messages speci cally make web database workloads messages bytes traf request-response latenc messaging important reducing latenc message round-trip times directly lead impro performance estigate section studying simple request-response xample nal observ ation arises xperiments pertains distrib uted system design bene eop page bop adv anced striping system apparent solaris nodes easily hot-spots performance bottlenecks simply serv les current workload system stripes blocks set nodes load balance system automatically addition nodes serv serv ers send lar blocks data important optimize lar message sends nodes support zero-copy message layers sense important path optimize disk network direct dma disk vice network vice pose dif culty current hardware technologies eop page bop chapter message dependencies pre vious section xamined nature message traf number workloads lea questions unanswered xample long simple request-response cost due transport request-response orkload workloads xcellent dri ving system aggre gate measurements instrument system ner granularity ran workloads produce mountain data hard dif ferentiate queuing delays fundamental costs reason dri system simple test program -ef hardware set-up simpli workstations olv system-v based unix including solaris command proc system obtain information processes system whene process created assigned unique process identi pid information process resource utilization status opening proc pid calling 
correct ioctl command -ef lists information processes system rst opens directory proc les processes system opens performs ioctl nally closes solaris proc combining global system sum local proc systems cluster open ioctl close generate message traf eop page bop starttexfig begindocument figures requestresponse eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale clp closepath bind eofill bind grestore bind gsave bind lineto bind moveto bind newpath bind stroke bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin 
mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg ftk rshow qjcm byurx rshow rshow mhx rshow rshow oqbnb bgm pvi uzs rshow rshow stroke grestore end showpage qtxz enddocument endtexfig figure emote write atency time write ord net ork kno wledgemen vgd ushed read restriction mak cac hed reads adv tageous cac he-line ush costs extra fir cycles equiv alen accessing smolm main memory languages suc hpf migh erform pee global analysis determine data-sharing ido ccurs ush ossible c-lik language split-c implemen tation elp uncac ffaj hed reads figure sho total latency kvbf programmer whic cycles jwt jorit attributed remote read annex fpvzd kqp set-up time split-c write primitiv write chb mec hanism follo olling requires total latency cycles figure eration subtle asso wte ciated cost pro cessor initiates remote write ject eing written migh cac hed phf vrx lpz atbw qtwn gdz remote pro cessor wns ject order pke main tain coherence allo cac hes eqq op- erated ache-inva lid xjr ate remote write request receiv corresp onding cac line ushed hqj cac line isn curren tly cac hed ords forced erate ab- sence higher-lev information ptn generate spurious cac ushes order preserv coherence opw semantic mismatches idiosyncrasies reads writes iuxd caused tension een mac hine shell core led seman tic mismatc qfl hes een mac hine language byte writes alpha supp ort yte store erations designers hose simplify memory in- terface supp orting yte read write erations gbo pro vided family yte manipulation instructions erate register alues yte store era- tion uibj implemen ted read-mo dify-write lib sequence ultipro cessor lik fsu guaran tee correct execution yte-store era- tion ultiple pro cessors dating ord pro cessors attempt date yte time date clobb note solution us- ing epl load-lo store-conditional instructions longer xzd ossible instructions ere consumed jck annex manipulati section oks azp alternativ supp ort yte dates glob al-l consistency issues rites global oin ters ait eration complete irresp ectiv cation eing accessed cal remote gzf jvz wji xay lqn goo writes normal cal oin ters whic app ear standard alpha store erations ered write result access order violations global address space qky accessible standard loy cal oin ters qon cik okj jjy cal oin ter -ee ertak write eration kfmj issued earlier cal oin ter eren cation suc situation proy cessor nucq observ reordering accesses resulting violation -dbi sequen tial consistency seman tics oid consistency violations vdi ensure writes cal oin ters caugh write memory barrier instruction explicitly priy atizing global address space curren tly ose require programmer insert explicit calls vvyn akg region shared global data accessed cal oin ters split-phase accesses split-c twtl put erations split-c put primitiv split-phase cmq nony blo asj king vizz rfl erations erlap comm unicay tion computation eration initiates prefetc remote address cal address put xog eray tion initiates zic non-blo king write remote cation sync eration aits outstanding ytv split-phase accesses complete put erations -nq lead eak consisy tency seman tics ecause accesses initiated een syncs gvr longer xch ordered binding prefetch prefetc vvq mec hanism alpha fetc qrw instrucy tion pro vide non-blo king reads remote addresses fetc instruction informs supp ort circuitry fetc ord remote pro cessor con tin ues comy putation fetc request write tually sen oji eci remote pro cessor pro cessor requested data ust sdc ord -en memory-mapp prefetc queue issuing load instruction examine erformance prefetc mec hanism simple bmk enc hmark measures erage lay tency prefetc hing eciu ords enc hmark groups noe remote idi read tng requests ewv series prefetc iny structions ops results prefetc queue stores cal memory results gth exten whic prefetc mec hanism erlap remote kgh access costs figure prefetc lqx queue store sequence slo blo king read cycles issuing prefetc hes opping queue xax wjip times storing hho results cal memory signi nfx tly faster btu blo king reads prefetc essen tially allo net ork pip elined thereb masking latency imp ortan conclusion dra figure remote latency tirely hidden size group approac cuo hes fsl hoice bfsr size prefetc queue reasonable note prefetc hes issued memory pkv barrier ust inserted efore queue guaran tees prefetc pbwi left pro cessor eop page bop starttexfig begindocument newfigures final prefetch ial eps gnudict ils white setcbg setp concat dict gnudict begin color mline false end jxb begin solid false mline gnulinewidth vshift setb cfg jap mul black setcfg hpt cbg white vpt setcbg moveto bind setp lineto eqb bind concat rmoveto nff bind rlineto bind vpt mline vpt end mul begin hpt mline hpt mul lshow setb currentpoint iag stroke cfg black vshift setcfg show cbg rshow white currentpoint setcbg stroke dup setp stringwidth pop neg vshift concat show cshow hpq currentpoint stroke mline dup end stringwidth begin pop text cfg black div vshift setcfg show helvetica-medium-r color qjj setrgbcolor helvetica solid setf pop setdash pop pop pop solid concat text end pjr begin mline pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth bvg stroke gnulinewidth setlinewidth ltb ren lta rpz setb setdash cfg setrgbcolor black setcfg cbg white setcbg setp wjr concat mline end qkb begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add zhdd hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt setcbg vpt setp currentpoint stroke hpt concat neg vpt neg mline hpt end begin stroke mline stroke setdash setb copy cfg exch hpt black exch setcfg vpt cbg add white vpt neg setcbg hpt setp vpt hpt neg concat closepath stroke stroke setdash exch hpt mline end begin mline wiy setb cfg black setcfg exch cbg white vpt add setcbg hpt vpt setp neg currentpoint stroke concat hpt neg hpt vpt mline end stroke begin mline stroke setdash copy setb vpt mul cfg add black hpt setcfg neg vpt mul cbg hpt white mul setcbg hpt neg setp vpt mul closepath stroke concat copy end mline end begin text cfg gnudict black begin setcfg gsave helvetica-medium-r translate scale helvetica setgray setf helvetica findfont scalefont setfont newpath concat lta text end qih begin ltb mline bzz setb cfg black rshow xds setcfg zix cbg rshow heto idqp rshow kwv rshow rshow rshow aywf rshow cshow cshow cshow cshow ohy cshow rzo nhz cshow white setcbg setp cshow ope concat cshow mline end begin mline cshow 
cwk setb cfg black jlvj setcfg yvm currentpoint cbg gsave white translate setcbg rotate setp time nanoseconds cshow concat grestore prefetch group size mline end cshow begin prefetch mline latency cshow pop setb cfg queue black gjs lshow setcfg cbg memory barrier white setcbg prefetch issue setp lshow split-c rshow nhm aay prefetch rshow awq concat stroke grestore mline end end showpage begin enddocument mline endtexfig figure setb cfg black efetch setcfg cbg atency white setcbg erage latency setp prefetc hes concat based mline end begin mline issued fsd urther setb instrumen cfg tation black setcfg cbg prefetc white mec setcbg hanism setp re- eals ipf follo concat wing cost breakdo mline end begin mline prefetch issue setb cycles cfg memory black barrier setcfg cbg kot cycles white round setcbg trip setp cycles prefetch concat pop cycles howl mline end begin mup breakdo text cfg sho black setcfg prefetc helvetica-medium-r mec hanism helvetica setf al- concat cost text end begin remote fetc mline eration setb cfg black setcfg cbg erlapp ays white setcbg setp ork vvj prefetc concat ggll hes issued mline groups end begin mline end cycles setb cfg prefetc black setcfg cbg white setcbg setp concat cyr iywk aju klhm aqm vln iteb qqub byk eok ziy eration subtracting cycles required cycles required prefetc issue lea cycles net ork latency address manipulati er- head non-blo cking rites alpha store instruction non-blo king write era- tion pro cessor simply issues store write-bu con tin ues computation figure sho results familiar micro-b enc hmark write remote pro cessor rites stride ytes rev eal write-merging eha vior alpha similar figure larger strides sho erage cost nanoseconds cycles write sensi- tivit remote-memory dram page misses compiler implications implemen split-c eration prefetc mec hanism additional ork required eration eci cal address serv target fetc hed alue target address stashed fetc issued accomplished compiler cien information matc prefetc hes corresp onding sync whic migh ossible presence unstructured con- trol constructs general case main tain table storing cal addresses target address stored table prefetc initiation time sync op- eration encoun tered outstanding fetc erations reac hes memory barrier issued starttexfig begindocument newfigures final write noack eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate time nanoseconds cshow grestore stride bytes cshow non-blocking remote write latency cshow split-c rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow rshow stroke grestore end showpage enddocument endtexfig figure non-blo cking write atency erage time write remote pro cessor kno wledgemen alues prefetc queue dequeued stored target addresses obtained table split-c implemen tation tro duces additional pieces erhead hardw prefetc mec hay nism table date store cal address prefetc complete cost table date okup eration cycles cost cal store eration cycles figure rev eals nal split-c cost whic includes annex set-up time table managey men erheads implemen tation put straigh t-forw ard non-blo king write requires annex setup ell additional hec erformance split-c primitiv sho figure rom put erage latency cycles bulk erations language provisions bulk transfers ccur split-c eren ors imy plicitly tire remote structure accessed read write put single assignmen explicitly calls bulk bulk write bulk bulk put cop ying con tiguous regions global memory comy piler transforms structure assignmen erations explicit bulk erations blo ransfer engine blo k-transfer engine essen tially dma dey vice giv remote pro cessor rtk sdw h-o hqb uzdcl zpr hkq xvu chk sivs llg aky paw yhb dez onp idi rjumkd awd rxr fer geg cfg pgi wacy wyrp iks xkj rlg trg cpv zzm pyb zpn ybt hcy yfx trz hxg rmk nig hvdn kie thw bcz uovopy utz ktd -sga ooi hwh qpb yxg phqe zgl pji xqec vrb n-h jtv eps rdc guk irg bjg wze sreqd s-n adr vjs vle mgr rvt kjh lwhh vri rbx hnob ara zke stu qtp jyfd ljg hgm drh sgzp vfr hkn deel bzix gkjn lzh gzd ssk ghs akoa cyx eej rpc gasr 
mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin mline setb cfg black setcfg cbg white setcbg setp translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind drawellipse endangle exch startangle exch yrad exch xrad exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit times-roman findfont scalefont setfont orb invoke method handle request colshow times-roman findfont scalefont setfont orb unpack message prepare act colshow times-roman findfont scalefont setfont orb results prepare return colshow times-roman findfont scalefont setfont msg send message colshow times-roman findfont scalefont setfont msg process ack colshow slw ellipse drawellipse cols ellipse drawellipse cols polyline cols clp setgray cols polyline cols clp setgray cols polyline cols oin ter clp 
setgray cols polyline cols clp setgray cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline clp cols polyline clp cols times-roman findfont scalefont setfont msg receive message send ack colshow polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont context switch colshow polyline clp cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols polyline clp cols times-roman findfont scalefont setfont msg send message colshow times-roman findfont scalefont setfont msg process ack colshow times-roman findfont scalefont setfont msg receive message send ack colshow times-roman findfont scalefont setfont orb process response colshow times-roman findfont scalefont setfont user invocation complete colshow times-roman findfont scalefont setfont orb prepare send colshow times-roman findfont scalefont setfont user invoke colshow times-roman findfont scalefont setfont request initiator colshow times-roman findfont scalefont setfont request handler colshow times-roman findfont scalefont setfont context switch colshow psend restore enddocument endtexfig figure cumulative request handling costs user refers solaris programmer orb object substrate msg transport layer leftmost graph depicts requesting-side costs simple request-response rightmost side handling-side costs note handling costs sho requesting side graph time waiting response return order fetch global information follo wing xperiment focus messages discuss details xperiment xplain steps olv simple requesty response mentioned solaris uilt object substrate kno orb object request broker orb turn uilt reliable transport layer communication solaris performed layers form object ocations ocation orb marshals guments request hands transport reliably deli ers message handling node handling side transport recei message hands orb orb recei message interprets okes method speci request results gathered nally shipped back request initiator orb initiating side unmarshals response puts results place returns control user case solaris programmer process diagrammed figure vie wed object-oriented functional equi alent remote procedure call beneath orb transport layer transport pro vides reliable send arbitrary fer chain node system implemented streams module pro vides reliable message transport top streams-based vice dri mbit ethernet myrinet date eop page bop starttexfig begindocument figures requestcosts eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind end save translate scale clp closepath bind eofill bind grestore bind gsave bind lineto bind moveto bind newpath bind stroke bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind srgb setrgbcolor bind rot rotate bind scale bind translate bind tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind length argumen drawellipse endangle exch engine startangle exch initiates yrad exch transfer xrad abstract micro-benchmarking cray theory practice class project remzi arpaci steve steinberg present employ methodology understanding performance parallel machine architectures technique assumes limited priori knowledge machine specifics makes simple set probes expose underlying machine characteristics apply approach cray massively parallel processor analyzing communication memory primitive draw conclusions merit found prefetch effective hiding latency achieving high bandwidth bulk transfer engine suffers debilitating overhead network appears flat full paper text 
een micro-benchmarking cray theory practice remzi arpaci steve steinberg abstract present employ methodology understanding performance parallel machine architectures technique assumes limited priori knowledge machine specifics makes simple set probes expose underlying machine characteristics apply approach cray massively parallel processor analyzing communication memory primitive draw conclusions merit found prefetch effective hiding latency achieving high bandwidth bulk transfer engine suffers debilitating overhead network appears flat introduction evaluations massively parallel processors traditionally paths measuring execution time real applications splash perfect suites measuring time simple primitives saxpy all-to-all broadcasts methods satisfying results fast program run make run faster empirically suspect ignoring question constitutes real applications question difficult mpp market diverse benchmarking large applications limited service benchmarks machine fastest impossible disentangle single number effects memory hierarchy processor compiler information needed programmers compiler writers system designers benchmarking primitive operations closer providing information flawed hoc methodology standard suite tests paper introduces set incompletely variation ping-pong messaging test results difficult duplicate due unspecified parameters unstated assumptions lend comparison machines paper path performance evaluation treat system gray box admitting priori knowledge system incomplete unverified simple probes similar saavedra microbenchmarks saav determine parameters characteristics machine work bottom-up analyzing simplest primitives results understand increasingly complex mechanisms probes written assembly language measurements reflect actual hardware costs overhead inflicted compiler message passing library probes simple assembly overly burdensome leads measurements empirically epistemologically well-grounded empirically measuring epistemologically measurements physically meaningful commensurable machines results language designers compiler writers understand hardware characteristics order weight tradeoffs section paper briefly describe architecture cray section apply methodology memory communication subsystem cray current generation massively parallel processors off-the-shelf microprocessors custom communication network order provide distributed memory growing consensus commodity microprocessors mpps design implementation distributed memory remains unclear solution designers chosen provide mechanisms remote memory access users sort aim paper gray-box methodology accurately asses costs benefits mechanism section results draw conclusions mechanisms cray-t cray massively parallel processor consisting hundreds thousands processing elements connected three-dimensional torus cray processing nodes consist processing elements -bit alpha microprocessor sites local memory support circuitry alpha dual-issue generation risc processor clocked mhz microprocessor performs instructions -bit data values integers floating point numbers chip reported kilobyte instruction data caches on-board -byte lines local memory processor range megabytes depending drams purchases cray designed memory system provide low-latency high-bandwidth path local memory processor support circuitry employs multitude features favoring kitchen sink approach building system providing remote read write operations prefetch queue bulk-transfer engine direct access network interface examine paper three-dimensional torus glues node acting router routing dimension-ordered packets traveling directions micro-benchmarks section details micro-benchmarks giving methodology results analysis begin local node performance stressing aspects microprocessor revealing hardware intrinsics slowly work remote memory paths remote memory remote read prefetch bulk copy costs performance characteristics lastly probe network simple topological experiments contention patterns local memory experiment derived saav slight modifications premise straightforward step array varying size stride plot average latency memory access step arrays increasing size pseudocode kilobytes pair address pair remote memory detected top bits interpreted index translated destination node number remote processed bits determine annex entry nodes hundreds thousands nodes systems depending communication patterns annex entries modified remote measured cost inserting annex entry cycles comparable penalty paid off-chip memory access determined section remote read bottom-up methodology deconstruct simplest remote memory access primitives remote read load misses cache off-chip dtb annex translation processor number occurs destination processor processor executed instruction load handled packet read request send correct destination types remote reads cached uncached cached read fetches remote cache line places line local cache places requested word register uncached read brings requested word modify cache determine latency remotes reads modifying micro-benchmark previously local memory memory accesses remote results expose local mechanisms cache tlb network latency shown figure parallel programs traditionally written remote memory bursty making network bandwidth important latency measure bandwidth routines fetch large amounts data processor memory stores reply local memory issuing processor figure shows uncached reads result peak memory-memory bandwidth roughly megabytes uncached reads difference attributed fact cached reads bring times data outstanding band figure shows time processor nodes message size slight variation band due network topology nodes closer proximity attain slightly higher throughput important observation blocking reads pipelined issued result brought computation continue severely impact performance precluding possibility high-bandwidth transmission remote write primitive examine remote write remote read extension load instruction remote writes generated alpha store instruction mechanisms addressing remote memory local virtual addresses translated dtb annex pairs important difference store non-blocking operation processor wait stores complete continuing computation bottleneck size write buffer fills flushed requires processor stall figure familiar latency micro-benchmark graph shows large strides register remote memory store operations incur penalty stride small write buffer groups words cache line resulting average latency minimal note higher local write time due fact flushing write buffer network expensive flushing local memory true reads peak write bandwidth important metric figure shows results analogous bandwidth micro-benchmark revealing peak roughly higher read performance obvious reason writes wait completion give control back cpu reason write bandwidth insensitive topology prefetch distinct mechanism provided remote memory prefetch operation essentially non-blocking read processor informs support circuitry fetch word remote node processor continues computation processor requested data perform steps issue memory barrier tells support circuitry bring outstanding requests pop word -entry prefetch queue examine performance prefetch operation measuring costs component steps results interesting machine architecture implications mechanism programmers language designers benchmark derive average latency prefetching words data benchmark consists grouping njremote read requests series prefetch instructions memory barrier finally storing results processors local memory figure shows experiments results prefetch-memory barrier-store sequence slower blocking requests bundled batches average latency read drops dramatically issuing prefetches performing memory barrier popping queue storing results local memory significantly faster alternative blocking reads surprising prefetch network pipelined masking latency remote read important conclusion draw figure size group approaches remote latency fully hidden choice size prefetch queue reasonable support black-box methodology micro-benchmark successful unveiling size outstanding prefetches issued machine grind halt crash experiment inserts instructions prefetch memory barrier pop queue determine costs step prefetch sequence discover instructions execute remote read performed figure shows instructions successfully hidden prefetch memory barrier pop affecting latency entire operation analysis results 
cycle counts issuing prefetch roughly data fetch memory barrier pop result queue prefetch typically employed latency hiding technique increase effective read bandwidth figure results usual bandwidth micro-benchmark bundling large read requests groups prefetches memory barrier pops stores achieve peak memory-to-memory bandwidth surpasses blocking cached-read bandwidth roughly bulk copy unlike hardware primitives tested mechanism remote memory access bulk-transfer engine blt invoking operating system stated methodology goals micro-benchmarks reveal hardware intrinsic behavior impossible longer access hardware directly probes result picture masked overhead section rests shakier epistemological ground results understood approximate latency initiating bulk transfer routine completely determined system overhead varies hundred microseconds seemingly independent size impending transfer surprising pointer length pair enact blt understand severe latency remember instructions executed space hundred microseconds measured bandwidth bulk copy reading writing shown figure blt operations non-blocking timing destination processor spin waiting memory updated admittedly imprecise technique measured peak writing reading explain apparent discrepancy topology determine affects topology network latency measured time one-word remote read processor issues request processor round-robin fashion waits reply figure shows results processing nodes node identical performance graph shows network low latency hop requiring cycles exact numbers difficult pin estimate router time cycles hop link latency roughly cycle contention communication mechanism measured isolation section examines performance degrades multiple processors contend network memory system determine additional aspects machine architecture model contention processor performs series uncached memory address processor processors spin number cycles varying offered loads modeled progressive diagrams figure show affects increasing number processors contending processor memory axis represents throughput percentage raw uncontended throughput remove affect network proximity figure shows processor local memory bandwidth unaffected contention local memory surprising remote memory transactions interrupting source processor figure shows nodes begin heavily contend memory throughput drops considerably percent peak conclusions set goals present methodology evaluating mpp performance methodology fully characterize memory communication performance cray methodology gray box technique simple probes expose hardware costs parameters results measurements physically meaningful easily duplicated comparisons mechanisms machines technique suited cray large set communication mechanisms measurements point main lessons interest system designers users prefetch mechanism important component machine read bandwidths significantly higher achieved remote cases remote correct mechanism prefetch choice machine aggressive clock rate overhead operating system call intolerable result blt engine dubious utility lastly communication network flat network topology insignificant cray hardware manual cray research incorporated numrich springer peterson measurement communication rates cray interprocessor network proceedings hpcn europe munich april saavedra-barrera cpu performance evaluation execution time prediction narrow spectrum benchmarking thesis berkeley technical report ucb csd february saavedra gaines carlton micro benchmark analysis ksr supercomputing november sites richard alpha architecture manual digital equipment corporation 
abstract combining parallel sequential workloads technical report remzi arpaci amin vahdat tom anderson dave patterson paper examines plausibility network workstations mixture parallel sequential jobs trace-driven simulation study identifies number results interest system designers sufficient workstation resources provide supercomputer night parallel programs significant number lengthy delays interactive users finally simple scheduling techniques identify availble workstations minimize user delays providing parallel program performance comparable dedicated massively parallel processor scheduling policies employed parallel programmers interactive users peacefully coexist full paper compressed postscript 

pro concat cessors memories eration mline end begin ecy mline setb cfg read black setcfg cbg write white setcbg setp capable concat erforming strided-arra accesses ould ould natural matc mline end begin mline setb cfg black setcfg cbg white setcbg setp concat mline end begin text cfg black setcfg helvetica-medium-r helvetica setf concat text end begin mline setb cfg black setcfg cbg white setcbg setp split-c bulk concat routines unlik mline end begin hardw mline primitiv setb cfg black setcfg tested cbg white setcbg mec setp hanism remote memory concat acy cess mline end ailable begin mline erating system setb cfg black setcfg cation cbg white high setcbg soft setp erheads language implemen tors concat compare remote access eop page bop mec hanisms shell pro vides answ ob- vious question whic mec hanism implemen ting bulk transfer routines compare eren mec hanisms implemen ting bulk transfers metric mline end begin mline bandwidth at- tained setb cfg mec black setcfg hanisms cbg large white setcbg reads setp eac mec concat hanisms describ efore uncac mline end hed begin reads mline cac hed reads setb cfg prefetc black setcfg queue cbg white bulk-transfer setcbg engine setp imple- men concat ted micro-b mline enc end hmark begin mline bulk read setb cfg erations black setcfg left cbg white setcbg side setp figure compares concat resultan bandwidths mline eac end begin implemen text tation cfg black setcfg gure helvetica-medium-r helvetica setf ery large reads greater concat text end begin size mline bulk-transfer engine setb hiev cfg black setcfg cbg highest transfer white setcbg rate eaking setp roughly concat reads mline end een begin mline ytes prefetc queue at- tains maxim bandwidth oin er- head incurred ercomes erior maxim setb cfg transfer black rate setcfg cbg cac white hed setcbg reads bring setp concat ords time mline prefetc end hes begin mline bring setb cfg black setcfg latency-hidin cbg white abilit setcbg setp prefetc mec hanism concat mak strictly etter mline end begin cac mline hed reads setb cfg case black setcfg cbg white setcbg setp concat ytes mline end begin oin mline cac hed setb read cfg bring black setcfg cbg white setcbg cac 
line thereb hiev est erformance lastly ery small transfers ytes uncac hed read optimal bulk writes mec hanisms ailable non-blo king store instruction figure sho net erence een cal data written cac erformance non- blo king writes erior initiatin bulk-transfer en- gine bandwidth writes cal memory remote memory cal cac eaks apparen tly bus limited compiler implications implemen tation split-c bulk bulk write routines vious progression micro-b enc hmarks cross-o oin ccurs transfer size 
size bulk transfer engine prefetc queue simplicit prefetc queue yte transfers switc hing cac hed reads ould increase erformance figure sho split-c erformance attained implemen bulk put erations compare initiation time arious mec hanisms implemen ting bulk ait duration initiating eration erlap actual transfer cal computation prefetc mec hanism implemen ing bulk remo ving restriction com- pletion esp ecially ene cial follo fact prefetc queue maxim outstanding requests ca- tion erhead egregiously high ust prefetc mec hanism implemen ting bulk transfer sizes cost initiating bulk transfer sec prefetc mec hanism read ytes time terv split-c bulk prefetc mec hanism transfer sizes ytes larger transfers sim- ilar reasoning implemen tation bulk put alp erformance bulk transfers cac hed reads in- ection oin ccurs ecause cac line ushes 
re- quired main tain coherence batc hed tire cac ush eration whic exp ensiv pha non-blo king stores transfer sizes ytes larger transfers summa shell cac hed uncac hed reads writes prefetc hing bulk transfer prefetc write prefetc ould ideal read mec hanism larger y-load brough prefetc cien oth cac hed uncac hed reads cac hed reads esp ecially cult utilize due lac hardw coherence blo transfer engine cum ersome ould greatly impro access ere user lev lastly writes simplest cien data emen mec hanism hieving oth w-latency high-bandwid data transy fer bulk-synchronous message-driven computation section estigate optimizations ailable application structured comm unication syny hronization patterns ypically structure arises ell-understo global view computation aly wing information pushe needed stencil calculation oundary rey gions ust exc hanged een steps comm unicay tion patterns prede ned bulk sync hronous yle program pro ceeds phase purely cal computay tion follo phase whic pro cessors store data oundary regions logical neigh ors global barriers een phases enforce dep 
endences requiring ne-grain completion individ ual stores message driv yle pro ceed phase computation receiv oundary data language pro vides means expressy ing lenien sync hronization requiremen structured application oten tially enabling arious optiy mizations mac hine lev language supp signaling sto res split-c allo programmer reason global abstract lev effects non-dedicated environment parallel ecifying applications class global project remzi address space arpaci andrea dusseau partiy lok tioned liu modern networks pro workstations cessors exhibit traits massively discussed parallel processors section cost performance ratios remote multitude idle pro cycles exist cessor workstations cal mau running parallel applications paper assigny men direct simulation erator analyze called performance stor parallel applications stores running alue type non-dedicated environment global direct loy simulation cation study performance effects issuing interrupting pro real cessor parallel applications thinking necessarily machine informed cmwith simulated serial completion parallel jobs effects skewing parallel time quanta results non-idle workstation reduces performance parallel applications degree extremely migrating affected eak process completion idle semany workstation tics beneficial store benefits coscheduling parallel one-w applications comm environment unication verified parallel rey processes quired coscheduled smaller time quanta kno result wledgemen performance ignoring cache stores behavior finally effects skewing time hea quanta workstations ily shown pip elin tolerable full paper compressed postscript 
detecting completion stores form global barrier stor sync returns stores issued efore barrier completed cien supp ort bulk-sync hronous execution alternay tiv ely completion detected cally stor sync whic returns eci amoun data een stored region address space wned cal pro cessor supp orts message-driv execution man split-c implemen tations signaling stores cien form comm unication applicabl design constraints ers store mec hanism oids kno wly edgemen completion view completion eop page bop starttexfig begindocument figures bulk read eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate bandwidth cshow grestore transfer size bytes cshow bulk read bandwidth cshow bulk transfer engine rshow prefetch queue rshow cached read rshow uncached read rshow split-c rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures bulk write eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow exch exch exch savematrix mtrx currentmatrix xrad yrad startangle endangle arc closepath savematrix setmatrix psbegin psdict begin psenteredstate save psend psenteredstate restore end psbegin setmiterlimit slw polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop 
repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp col shd cols polyline setdash cols setdash polyline setdash cols setdash polyline setdash cols setdash slw polyline cols clp setgray cols slw polyline setdash cols setdash polyline setdash cols setdash polyline setdash cols setdash polyline setdash cols setdash polyline setdash cols setdash polyline cols clp setgray cols polyline cols clp setgray cols polyline cols clp setgray cols polyline cols clp setgray cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont context switch colshow polyline setdash cols setdash ellipse drawellipse cols times-roman findfont scalefont setfont context switch colshow ellipse drawellipse cols times-roman findfont scalefont setfont request initiator colshow times-roman findfont scalefont setfont request handler colshow polyline setdash cols setdash times-roman findfont scalefont setfont msg receive message send ack colshow times-roman findfont scalefont setfont orb prepare message colshow times-roman findfont scalefont setfont orb unpack message prepare act colshow times-roman findfont scalefont setfont user invoke method handle request colshow times-roman findfont scalefont setfont orb results prepare send colshow times-roman findfont scalefont setfont msg send message colshow times-roman findfont scalefont setfont msg process ack colshow times-roman findfont scalefont setfont msg receive message send ack colshow times-roman findfont scalefont setfont orb process response colshow times-roman findfont scalefont setfont msg process ack colshow times-roman findfont scalefont setfont msg send message colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont colshow times-roman findfont scalefont setfont driver receive message pass transport colshow times-roman findfont scalefont setfont driver receive message pass transport colshow psend restore enddocument endtexfig figure request handling costs orb refers time spent orb msg time spent transport layer driver time spent vice dri user time spent handler oked ransport costs sho green lighter shading black white orb costs red darker shading cost object ocation white note conte switch time folded transport costs xperiment machines system requests generated handled xperiment gins enabling trace fers kernel machines command -ef run finally dump kernel trace fers log les machine total request-response pairs traced figure sho results requesting side entitled request initiator handling side request handler box scaled lengthwise represent total cost microseconds note orb costs red darker shading black white transport costs green lighter shading rst conclusion dra simple request-response takes roughly milliseconds fast network ethernet myrinet time wire gligible time eop page bop xamine request-initiating node messages orb spends roughly preparing request point orb hands message transport layer cost message wire costly erage note high cost due xpensi streams-based utilities locking protocols request side waits ackno wledgment recei waits response request request-handle side takes place request-initiator waiting packet recei dri passed transport layer cost estimate time accounted fairly accurate transport layer rst sends ackno wledgment back requesting side strips transport headers decides packet destined orb passes message orb takes erage costly sum rst conte switch occurs orb message interpretation set orb nally performs requested ocation cost ocation viously application-speci case note request response work absolutely request-response times xpensi minimal cost ocation orb prepares response analogous request side prepare sends response back incurring lar transport erhead finally request side response back dri estimated transport nally orb interprets message places results correct place nishes request item discuss latenc network xperiment -mbit ethernet employed time-on-the-wire -byte packet modern switch-based network latenc wire insigni erhead matters domain implications micro-e xperiments section cost request-response high culprits high-latenc hijinks transport layer orb transport layer surprisingly lar tcp-like erheads total send recei erhead eop page bop dri ers altogether accounts roughly total olv simple request-response total time orb costs total time substantial compare real cost remote ocation ith nitely fast network protocol place orb responsible time optimization work desperately needed areas eop page bop chapter anatomy message pre vious data discussion paper focused message sizes destinations request-response timings section brings structure message scrutin resume workloads make web database xamining construction message detail hope shed light potential areas communication layer network interface optimize attempt understand erhead object system requires terms bytes buffer chains figure sho structure prototypical message message solaris comprised list fers similar structure ufs found older unix systems mblks streams ernacular message arbitrarily lar number fers rst measurement sho case sho percent messages fer 
chains consisting fers workloads note message consisting fers starttexfig begindocument figures message portrait eps psdict dict psdict begin psdict mtrx matrix put coldef col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb bind col srgb cshow bind col srgb bind cshow col srgb bind cshow col srgb bind col cshow srgb bind col srgb bind cshow col srgb bind end save cshow translate scale clp closepath bind eofill bind cshow grestore bind gsave bind lineto bind moveto bind newpath bind stroke bind slc setlinecap bind slj setlinejoin bind slw setlinewidth bind cshow srgb setrgbcolor bind rot rotate bind scale bind cshow translate bind tnt dup dup currentrgbcolor roll cshow dup exch roll mul add roll dup exch roll mul add currentpoint roll gsave dup exch translate rotate roll mul add bandwidth srgb bind cshow shd dup dup grestore transfer size bytes currentrgbcolor roll cshow mul bulk roll write mul bandwidth roll cshow mul srgb bind write psbegin psdict cache begin psenteredstate rshow save psend psenteredstate restore end psbegin setmiterlimit slw arc clp setgray cols arc cols arc clp setgray cols write memory arc cols rshow polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols arc clp setgray cols arc cols polyline arcto pop repeat arcto pop repeat arcto pop repeat arcto pop repeat clp cols times-roman findfont scalefont setfont bulk transfer engine message head rshow colshow polyline arcto pop repeat arcto pop repeat arcto pop split-c memory rshow repeat arcto pop repeat clp cols polyline cols clp setgray cols psend restore enddocument endtexfig figure generic message message list potentially non-contiguous fers eop page bop buf fer buf fers buf fers make web database buf fer chains percent messages fers stroke chain grestore end showpage enddocument workloads endtexfig messages figure bulk write comp fers arison chain left totals eren remote access make mec workload hanisms messages implemen bulk read righ bulk writes implemen single ted fer messages consist fers fers imbalance increases store instruction seman tics pro vided mac hine stronger eci language oten tial erfor- mance gain signaling stores essen tially puts aiting completion deferred man workloads web workload database workload otocol erheads stores oten fer tially size distrib issued utions efore workloads aiting figure problem remote reads rst writes fer erformed chain directly hardw bigger bytes recipien half data rst fers informed bytes data size fact presen fer required message-driv underlying object programs con trast man split-c implemen tation global memory era- tions constructed activ messages store han- dler incremen coun ter ust construct essen tially equiv alen activ messages pro vide noti atio recipien ac- tual data transfer brings signi com- onen shell picture explicit messages fetc incremen registers fuzzy barriers user-level message queue pro vides direct access net ork mes- sage queue mec hanism straigh t-forw ard ord message comp osed call issued atomically put message cac he-line sized transfer ec- destination pro vided alpha arc hitected terface micro ded functions measure time inject message net ork cycles comparable time erform remote read send cost fast part mes- sage transfer message reception pro cessor in- terrupted message user-lev queue follo wing 
actions tak place con trol returned original thread transferred eci message handler measured cost terrupt microseconds cycles switc message handler adds microseconds cycles top etch increment registers giv high cost message receipt due erating sys- tem terv tion led constructing message transfers fast shared memory primitiv approac eac pro vide dedicated iny put queue ery case send simple hec ailabili remote queue store data store determining message arriv requires searc hing queues required n-toy queue bring incoming messages noti cations toy gether whic ysical net ork pro vides set fetc incremen registers aly suc ulti-access data structures constructed efy cien tly fetc incremen eration essen tially cost remote read microsecond dey osit message data system fer size distrib ution follo pattern similar message size distrib utions figures fer holds user payload surprisingly sho greatest ariation size finally fer occasionally object system send object protocol information node workloads fer smaller fer xceeding bytes leads vious question erhead percent total bytes object system require sho breakdo workloads make database workloads send man lar messages payloads lar object starttexfig begindocument figures buf make eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent messages cshow grestore message size bytes cshow buffer chain distribution make cshow buffer rshow buffer rshow currentpoint stroke currentpoint stroke ords con trol ord remote queue essen tially equiv alen cmam acy tiv message call tak dispatc hing receiving end accessing message tak pro vides full oll-based activ mesy sages pro vides basis supp orting message-driv stor sync ell abilit execute function atomy ically remote pro cessor pro vide correct implemen tation byte write mec hanism disy cussed section uzzy rriers bulk-sync hronous execution supp orted ell issuing stor slo put global barrier aits outstanding stores complete erforms starty barrier instruction olls message queue til pro cessors reac hed start-barrier efore completing barrier fuzzy barrier giv abilit place een start-barrier whic notiy pro cessors sync hronization oin een reac hed end-barrier whic resets global-or bit barrier allo fast hardy barrier supp orting remote memory access user-lev message passing man platy forms split-c implemen tation unable fast nativ barriers ecause comp ose ell erations case study section bring arious comp onen language implemen tation erformance eop page bop starttexfig begindocument newfigures final eps gnudict dict gnudict begin color false solid false gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate naneseconds link cshow grestore percent non-local edges cshow performance cshow simple rshow bundle unoptimized rshow bundle optimized rshow rshow put rshow bulk rshow stroke grestore end showpage enddocument endtexfig figure performanc erformance obtained sev eral ersions syn thetic ernel graph des degree pro cessors study scalable split-c applicatio dels propagation electro-magnetic jects dimensions prepro cessing step casts problem simple computation irregular bipar- tite graph con taining des represen ting electric mag- netic eld alues computation consists series leapfrog tegration steps alternate half time steps hanges electric eld calculated linear func- tion neigh oring magnetic eld alues vic versa eci call alue eac dated eigh ted sum neigh orin des des similarly dated des dep endencies een des form bipartite graph parallel er- sion graph represen ted directly global oin ters spread pro cessors dev elop ersions application arying degrees optimizations capabilities of- fered split-c collection syn thetic graphs ertices eac pro cessor eac ertex ving degree inputs comm uni- cation requiremen problem scaled adjusting fraction edges graph cross pro cessors syn thetic graph erformance metric scal- ing oth problem mac hine size erage time edge sho figure corresp onds reading alue neigh oring oating-p oin ultiply-add gure horizon tal axis ercen tage remote edges simplest ersion simple alue asso ciated edge simply read blo king memory read is- sued fetc ossibly remote alue alue fetc hed ultiple times required single time-step ersions rectify problem tro ducing cal ghost des serv temp orary cac he-sites non-lo cal alues computation divided phases rst phase fetc hes remote alues cal ghost des phase erforms eigh ted sum computation based ghost al- ues hange bundle ene reuse cac hed alues etter generation comm uni- cation compute phases separated optimize compute phase program unrolling soft pip elin ersion pip eline remote reads ghost alues split-c put resp onsibil lling ghost cal pro cessor main tains ghost rey mote pro cessor main tains actual alue put erations date optimization gathers alues sen pro cessor pro cessor single bulk put transfer ghost alues tro ducing ghost des optimizing cal computation reduce cost pro cessing edge sec edges cal corresp onds oating oin erformance mflops pro cessor oating oin erations olv pro cessy ing edge ersions ect cal erformance primarily cus decreasing comm nication costs exp ected decrease comm unication costs pip elini reads ersion put ersion erforms etter ersion ecause puts erhead finally bulk ersion est erformance oids rep eated annex set-up erations analysis conclusions goal study deriv cien implemeny tation parallel language split-c large-scale ultipro cessor cra y-t systematic microy enc hmarking metho dology approac arran ted pro vides elab orate shell sophisy ticated micropro cessor dec alpha supp ort global erations whic critical parallel language erformance man shell erations previy ously cumen ted teractions een ere oten tially non-trivial shell pro vides loads stores rey mote addresses requires manipulati external segy men registers expand ysical address cony taining full pro cessor external registers managed compiler usage strategy oten tially teracts tlb alpha tak exy treme osition eak ordering memory erations writes kno een committed explicit memory barrier instruction reads ypass iny dep enden writes shell pro vides additional erations detect completion remote 
erations arious forms cac he-abilit supp orted cac hing remote memory coheren alpha pro vides prefetc hin whic shell terprets binding load hip prefetc queue shell pro vides erful blo transfer engine whic data remote memory requires erating system terv tion start-up supp orts explicit messaging user-lev output fif receiv requires erating system tery tion handle terrupt shell pro vides extremely fast global fuzzy barrier ecial registers supp ort fetc incremen erations remote des large men primitiv ere ten tially man eren realize language primitiv mac hine careful assessmen erfory mance trade-o required select een making selection pro vided empiry ical haracterization erformance man primy itiv supp orted mac hine erformance remote memory erations ery impressiv sigy tly faster absolute terms previous large eop page bop scale design remote access erformed times latency cal cac miss dep ending cal dram access -page fast clo k-rate alpha means roughly cycles prefetc supp ort ery ectiv capable reducing ectiv remote latency remaining time lled ork issue additional prefetc hes man cases found erformance har- acteristics subtle teractions een language hardw eliminated man oten tial options ur- ther arc hitectural ersigh oth shell mi- cropro cessor ere limiting factors ten tial hazards arising ysical synon yms write prev compiler man external seg- men registers ecial situations oten tial degradation tlb ciency leads conclusion dating con guration external registers fast roughly cycles explicit hec out- eigh cost simply reloading ligh single annex remote access ced lac partial ord stores mak shared data structure data ord haracter arra ery cum ersome actual teraction individu elemen prefetc mec hanism fast erformance adv an- tage pro viding load trac king implicit hardw managemen prefetc queue costly start-up cost blo k-transfer engine large prefetc hes non-blo king writes est er- form bulk transfer ery large transfers excess finally cost message receipt large generally etter construct remote message queue shared memory primitiv fast sync hro- nization supp ort ackno wledgements ould lik mark otts bill carlson vid knaak assistance exp ertise oth andrea dusseau vid bader pro viding aluable commen barton wnie mclaren message passing meik csb par lel computing april bbn adv anced computers chnic duct summary berry chen koss vid kuc er- fect club enc hmarks ectiv erformance aluation ercompu ter hnical rep ort chandy kesselman comp ositional comp ositional arallel programming international workshop anguages compilers par lel com- puting pages august cra researc incorp orat cra har dwar efer enc manual vid culler andrea dusseau seth cop goldstein arvind krishnam urth stev lumetta thorsten eic katherine elic arallel programming split- omputing pages ortland oregon digital equipmen corp oration decchip -aa micr essor har dwar efer enc manual groscup tel aragon ercomput dings ecmwf workshop par lel essors mete olo pages high erformance ortran orum high erformance ory tran language eci catio ersion draft jan uary kendall square researc ksr chnic summary kessler arzmeier cra diy mension cra researc digest pap ers compcon spring pages san rancisco ebruary eninger urtney alk sharedy memory mpp cra researc digital chnic joury nal john kubiato wicz anan agarw anatom mesy sage alewife multipro cessor internay tional confer enc omputing july rey kuskin vid ofelt mark heinric john heiny lein ric hard simoni kourosh gharac horlo john chapin vid nak ahira baxter mark horo witz ano gupta mendel rosen blum john hennessy stanford flash multipro cessor international symp osium comy puter chite ctur pages april leiserson abuhamdeh douglas eynman ganm ukhi hill hillis kuszmaul pierre ells ong ang zak net ork arc hitecture cmy symp osium par lel distribute lgorithms pages june lenoski laundon gharac horlo gupta hennessy directory based cac coherance proy col ash multipro cessor dings international symp osium computer chite ctur pages stev luna implemen ing cien global memory ortabilit distributed memory multipro cessors master thesis univ ersit california berk eley niel madsen div ergence preserving discrete surface iny tegral metho maxw ell curl equations nony orthogonal unstructured grids hnical rep ort ria ebruary ric hard martin activ message nety ork orkstations hot inter onne cts august arkb enc committee arkbench committe ortp hnical rep ort cs- computer sciy ence departmen univ ersit ennesse kno xville saa edra gaines carlton micro benc hmark analysis ksr omputing saa edra-bar rer cpu performanc evaluation exe cution time diction narr ctrum benchy marking phd thesis berk eley computer science diy vision ebruary singh hennessy gupta empirical comparison kendall square researc ksry stanford ash multipro cessor omputing pages ortland oregon ric hard sites lpha chite ctur efer enc manual digy ital equipmen corp oration jim smith standard micropro cessor mpps prey sen tation isca thorsten eic vid culler seth cop goldy stein klaus erik hauser activ messages mec anism tegrated comm unicatio computation international symp osium computer chite ctur pages eop trailer end userdict end-hook end-hook eof 
buffer rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures buf eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent messages cshow grestore message size bytes cshow buffer chain distribution cshow buffer rshow buffer rshow buffer rshow stroke grestore end showpage enddocument endtexfig starttexfig begindocument figures buf oracle eps gnudict dict gnudict begin color true solid true gnulinewidth vshift mul hpt vpt moveto bind lineto bind rmoveto bind rlineto bind vpt vpt mul hpt hpt mul lshow currentpoint stroke vshift show rshow currentpoint stroke dup stringwidth pop neg vshift show cshow currentpoint stroke dup stringwidth pop div vshift show color setrgbcolor solid pop setdash pop pop pop solid pop setdash ifelse stroke gnulinewidth mul setlinewidth stroke gnulinewidth div setlinewidth stroke gnulinewidth setlinewidth ltb lta setdash setrgbcolor stroke setdash currentlinewidth div currentlinewidth stroke stroke setdash copy vpt add hpt neg vpt neg hpt vpt neg hpt vpt hpt neg vpt closepath stroke stroke setdash vpt vpt currentpoint stroke hpt neg vpt neg hpt stroke stroke setdash copy exch 
hpt exch vpt add vpt neg hpt vpt hpt neg closepath stroke stroke setdash exch hpt exch vpt add hpt vpt neg currentpoint stroke hpt neg hpt vpt stroke stroke setdash copy vpt mul add hpt neg vpt mul hpt mul hpt neg vpt mul closepath stroke copy end gnudict begin gsave translate scale setgray helvetica findfont scalefont setfont newpath lta ltb rshow rshow rshow rshow rshow rshow cshow cshow cshow cshow cshow cshow cshow cshow currentpoint gsave translate rotate percent messages cshow grestore message size bytes cshow buffer chain distribution database cshow buffer rshow buffer rshow buffer rshow stroke grestore end showpage enddocument endtexfig figure buf fer chain sizes gures plot distrib ution sizes fer message note ulk data fer chain eop page bop buf fer buf fer buf fer make web database object otocol overheads table sho percentage bytes fer fer chain totals erheads relati ely small ith web workload erheads substantial figure absolutely lar ger workload lar gest payloads fairly small bytes man small messages object erhead noticeable fraction implications section inspected structure solaris message rst fers object system protocol information payload solaris programmer messages chain non-contiguous fers size distrib ution distinct fers radically dif ferent rst fer small fer ranges small hundred bytes lar make workload xistence fer chains implies message layer support gather interface perform xtra copy fer allocation sending data gathering interface present today fast messaging layers alternati signi cantly restructure code allocate xtra space object anticipation object system demands gather cost directly proportional memory copy costs cost fer allocation substantial restructuring code worth pursuing made fer chains finally message requires bytes object header information web workload bytes transferred orb eop page bop chapter conclusions futur ork paper measured performance arious workloads prototype cluster operating system solaris measurements ealed interesting results message-layer design distrib uted system design perspecti systems perspecti solaris design decisions adv ersely fect performance xample non-striped system lead bottlenecks occurring disks system node data nodes system global services network port name-space manager suf fer similar bottlenecks distrib uted lastly nodes house disks sending lar messages optimizing path disk network pro worthwhile ith message layer design mind message traf highly workload dependent cluster compute serv database engine web serv scenarios system beha dif ferently performance optimization system depends intended clear support medium-sized messages important workloads messages workloads range bytes instrumenting object subsystem prototype implementation solaris suf fers unusually high request-response times attrib uted slo streamsy based transport contrib utes high erhead high latenc current cost object infrastructure high ideal case transport layer fast erhead object system signi finally support gathering interface limited bene object system eop page bop attaches header request separate fer implementation fort potentially remo future remains xamined perspecti workloads web database workloads realistic xample web workload trace-dri usage patterns popular web-site make web serv netscape serv database workload disks standard database benchmarks tpc-c tpc-d system olving repeating measurements yield insight problems solv persist clear fast lightweight transport great enue xploration place tuning orb costs spread orb code path early measurements memory allocation impro cases erhead signi cantly impro erall system performance light vie report prototype continued series ned aluations eop page bop bibliograph anderson dahlin neefe atterson ang serv erless network file systems ifteenth symposium oper ating systems principles pages copper mountain resort usa dec anderson owicki sax thacker high-speed switch scheduling local-area networks ansactions computer systems baker hartman upfer shirrif ousterhout measurements distrib uted file system oceedings thirteenth symposium oper ating systems principles pages aci gro usa oct baskett ward communicaton demos oceedings symposium oper ating system principles pages reading usa bernebeu matena khalidi extending raditional object-oriented echniques coo boden cohen felderman ula wik seitz myrinet gigabit-per -second local area network ieee micr feb cheriton vmtp ransport protocol generation communication systems oceedings sigcomm pages sto 
noon percent jobs submitted hour time day mpp submission times percent jobs finish minutes length job minutes mpp job length distribution frequency weighted frequency communication behavior distributed operating system remzi arpaci department electrical engineering computer science computer science division california berkeley abstract present measurements communication behavior prototype distributed operating system solaris employ server workloads drive study build solaris source tree synthetic web server parallel database measurements reveal number facts implications design solaris prototype implementation solaris design message layer find message traffic centered nodes house disks potential bottleneck file system striped data cluster avoid problem messages medium sized range bytes indicating message-layer support messages crucial messages structured chain buffers suggesting gather interface avoid additional buffer allocation memory copies finally request-response time high due overhead current message layer fact indicative prototype status system case low-overhead message layer substantially improve performance contents introduction background experimental setup solaris experimental method hardware tracing workloads workload characterization performance cpu utilization system calls context switches summary message traffic message destinations message sizes message rates implications message dependencies request-response workload implications anatomy message buffer chains protocol slowdown overheads number competing parallel jobs local scheduling cholesky column connect sample implications conclusions future work acknowledgements people making report advisor dave patterson insight guidance friendship insistence completed report reader david culler advice sort facets arbitrary design decisions fundamental remember long time extended members group learned years berkeley difficult single bunch amin vahdat rich martin alan mainwaring making soda hall slightly tolerable place extend extra note alan owning excellent recording beethoven work time effort entire solaris group sun labs yousef khalidi giving great opportunity willingness lend ear moti thadani excellent explanations vagaries streams enjoyable discussions assistance jose bernebeu patience gave vlada matena expert knowledge parts solaris finally ken shirriff time friendship single member group time extend special double co-worker keith vetter helped gather measurements presented keith introducing magic bob greenberg music lectures parents support love encouragement years graduate studies direction advice invaluable achieved finally fiance andrea dusseau person indebted levels academically excellence profoundly influenced co-worker learned uncountable lessons rigorous careful pursuit truth sounding board expert reader follow personally love support terrific friendship alive happy past years lucky found wonderful person forward years chapter introduction finite unknown infinite intellectually stand islet midst illimitable ocean inexplicability business generation reclaim land -thomas huxley distributed systems long active area research distributed system comprised components including process management networking file systems requirements services eclectic common communicate lines early work achieving high network performance paramount attaining good distributed system performance surprisingly researchers focused efforts design implementation fast communication protocols recent arrival high-speed switch-based local-area networks improved communication performance order magnitude bandwidth networks range making lightweight communication protocols one-way end-to-end times range microseconds quantum leap shared-medium ethernet previous systems designed radical change underway important understand characterize modern distributed systems make communication technologies performance characteristics underlying network functionality message layer provide measurements fact implication message traffic centered disks striping file system valuable medium-sized messages account traffic message-layer support medium-sized messages request-response time high low-overhead message layer messages chain buffers message-layer support gathering interface table column present main findings measurements communication behavior solaris column shows potential implications design implementation system message layer structure distributed system begin answer questions instrumented communication layer distributed operating system system scrutiny solaris prototype cluster operating system number ways extends real commercial kernel solaris distributed system building top distributed object system based corba extends file system process management networking subsystems unix provide users single-system image interesting measurement testbed early stages development aspects system optimized directly affects measurements timing-sensitive load message subsytem high measurements including sizes destinations messages affected bearing mind attempt separate results poor implementation design decisions fundamental drive traces communication behavior employ server workloads build solaris source tree web server responding synthetic stream http requests database performing series debit credits analysis consists progressive steps trace resource usage statistics characterize workloads trace aggregate communication nodes cluster data derive message distributions rates communication solaris based requests subsequent responses instrument higher level system unveil communication dependencies conclude examining structure individual message understand type interface message layer provide measurements reveal number facts highlighted table discuss results implications design solaris prototype implementation design message layer find message traffic cluster centered disks striped file system avoid potential disk bottlenecks global services network port name-space manager distributed suffer similar bottlenecks find messages roughly workloads range bytes support message sizes critical design message layer surprisingly data larger messages frequently avoiding memory copies actions function message size beneficial instrumenting object subsystem find prototype implementation solaris suffers unusually high request-response times simple request-response attributed high-overhead streams-based transport implication case obvious system desperate low-overhead transport layer current cost object infrastructure high accounting roughly ideal case transport layer fast overhead object system significant finally find messages formed chain buffers gathering interface benefit saving cost memory-to-memory copy buffer allocation messages chains by-product design object subsystem attaches header separate buffer message implementation effort potentially remedy situation outline rest paper section overview solaris operating system describes hardware configuration methodology study section describe workloads drive study section begin measurements aggregate summaries communication patterns section understand higher level viewing communication request-response pairs finally section detail structure message implications layers conclude give future directions section chapter background experimental setup section describe solaris system give high-level overview concepts philosophy system outline particulars experimental environment solaris solaris prototype multi-computer operating system multi-computer cluster homogeneous computers connected high-speed interconnect solaris single-system image constructing illusion single machine users applications external network existing solaris api abi preserved existing solaris applications device drivers run modification finally support high availability solaris comprised major subsystems file system process management networking extensions made components normal solaris kernel order attain aforementioned goals briefly explain component underlying object substrate solaris file system pxfs proxy file system extends local unix file system distributed environment pxfs file access location transparent process system open file located disk system pxfs accomplishes interposing vnode layer pxfs intercept file operations forward correct physical node nodes single path hierarchy accessible files ensure unix file system semantics coherency protocols employed performance pxfs makes extensive caching based techniques found spring eventually provide zero-copy bulk large data objects major subsystem process management solaris process management globalized location process transparent user threads process restricted physical node process system system makes remote execution facilities run jobs nodes system process management implemented virtual 
layer vproc top existing solaris process management code tracking state parent children processes process groups sessions supports posix process semantics access information processes solaris extends proc file system debuggers global proc covers processes system solaris provide migration facilities remote fork capability global networking subsystem solaris network applications creates single system image respect network devices system process node system network connectivity process location key components involved achieving end global management network space distributed multiplexing distributed de-multiplexing distributed program sap-server manages global network space sapserver prevents simultaneous allocation tcp ports processes spread nodes cluster outgoing packets processed node application forwarded network interface similarly packet filter intercepts incoming packets directs correct node final subsystem solaris global subsystem extends solaris cross-node device access accomodate cross-node functionality made device configuration loading unloading kernel modules device naming providing process context drivers subsystems built top runtime environment distributed objects object request broker orb orb viewed object communication backplane performs work support remote object invocations solaris orb features counting objects support one-way communication full description orb experimental method section describes experimental method describe hardware software platform experiments explain instrumented solaris performance effects arose instrumentation finally give details workloads drive simulations hardware cluster machines consists sparcs sparcs sparcs running copy modified version solaris includes support solaris experiments performed -cpu -node cluster sparcs memory machine ethernet connection world connection fast intra-cluster network myrinet local-area network possibly extra disk acts part global file system section cluster configuration slightly explained tracing trace communication behavior solaris make extensive tnf tracing facility solaris utility events kernel time-stamped logged kernel buffer easily extracted analyzed call log event takes roughly microseconds insertion calls critical path alter results performing timing measurements judiciously inserted logging statements measuring events long timing overhead insignificant cases care subtract timing overhead workloads paper utilize workloads drive system illustrated figure workloads slightly hardware configurations workload make performs large parallel make solaris source tree shell ona starts make rexec system call distribute jobs nodes system disk holding source tree attached workload stresses remote execution facilities pxfs workload web based spec benchmark benchmark external stream http requests generated cluster node running copy ncsa httpd server requests connected ethernet network interface request received networking subsystem redirects traffic connection nodes system similar mach packet filter responses forwarded responding cluster node back original source disk http files connected workload heavily utilizes networking sub-system potentially caching features file system lastly database workload performs series transactions oracle parallel databasea simple debit credit transactions performed parallel nodes disk database attached workload stresses aspects global file system make rexec rexec rexec web tcp traffictcp traffic tcp traffic external http requests database transactions transactions transactions figure workload setup upper-left diagram shows experimental setup make workload note workstation processors circled symbol parallel make started remotely executes jobs workstations disk solaris source tree attached upper-right diagram depicts web workload setup external http requests streaming traffic distributed machines round-robin fashion responses proceed back source disk requested file attached lower diagram shows database workload setup disk attached experiment machines perform transactions fixed time period chapter workload characterization process gathering workloads study distributed system important concentrate finding programs stress system services section characterize workloads drive study show make operating system services present performance workloads give insight nature workloads give breakdowns cpu usage measures system system calls context switches performance section shows workloads perform tracing activated table run time rate operation workloads run-time workloads chosen experimenter run-time make workloads determined fixed amount work rate make reveals number compilations case web workload external clients perform http operations fetch file rate measures number http operations database workload clients system perform simple debit credit operations due legal issues rate workload revealed prototype system performance system spectacular skew skew tuned skew performance slowdown section coscheduling skew cholesky column main connect reason sample workloads run fixed minute period workload time rate make mins secs compiles sec web mins secs http ops sec database mins secs table benchmark performance total performance time rate benchmark cpu utilization figure shows cpu utilization workload lifetime experiment collect data user-level daemon awakens collects statistics cpu usage consists distinct parts user percent time spent running program system percent time spent operating system wait percent time spent waiting disk return idle remaining difference note graphs cumulative system line sum system user time cpu percentage time seconds cpu profile make wait system user cpu percentage time seconds cpu profile wait system user cpu percentage time seconds cpu profile database wait system user figure cumulative cpu utilization cumulative cpu utilization split user system wait time displayed time workload rest idle maximum cpu percentage moment cpus peak utilization note graphs cumulative system time sum system user time wait time sum white space top-most line wait time idle time make workload utilization time makefile runs sequential portion utilization seconds low roughly processors worth cpu parallel portion begins constant utilization processors spikes peak finally make ends long link phase roughly seconds average workload spends time user mode time system mode total cpu usage machine cpu number time seconds individual cpu traces make machine cpu number time seconds individual cpu traces machine cpu number time seconds individual cpu traces database figure individual cpu utilization cpu utilization sum user system time time displayed cpu cluster axis shows cpu machines impliesa cpu web workload displays significantly behavior workload starts -second mark ends minutes quarters cpu utilized times run item interest dips graph seconds times transport layer lost message hiccup message times retransmitted mishap system continues web workload sensitive type failure ifa stops forwarding http requests nodes system nodes work time remain idle main point interest large percentage time spent system roughly total time non-idle time finally figure reveals database workload makes cpu small fraction utilized spent system time total time non-idle time user time accounts total time workload spends time waiting disk requests show load balanced cluster figure presents cpu utilization processor set graphs view sum user system time make workload load fairly balanced nodes finish sooner note busiest node houses disk source tree located diagram web workload shows processors utilized benchmark note dips cpu graphs packet lost lastly database workload note low constant cpu usage machines case busiest 
node due presence disk system calls time seconds system call profile make system calls time seconds system call profile web system calls time seconds system call profile database figure system calls aggregate system calls workstations context switches time seconds context switch profile make context switches time seconds context switch profile context switches time seconds context switch profile database figure context switches aggregate context switches workstations system calls context switches cpu utilizations workloads making operating system show operating system duress show number system calls context switches figure aggregate number system calls performed workloads workloads make fairly heavy operating system services workloads make performs fewest average calls file system related web workload intense performing aggregate average syscalls workload makes file system networking subsystem frequently crossing user-space kernel boundary finally database shows constant system call rates cluster stressing file system sparcrunning solaris trapping returning kernel takes roughly workload performs system calls rate spent crossing user-kernel boundary time spent kernel call overhead small noticeable fraction examine total number context switches workstations cluster counts number times low-level context switch routine called inside kernel process sleep system call force context switch figure correlated figure data figure evidence operating system strain execution workloads general trends previous figure make web database workloads average context switches interesting point context switch rate intensity context switch takes switches implies time spent switching milliseconds switch time time summary section number measures system usage cpu utilization system call rates context switch rates workloads operating-system intensive non-idle time spent operating system make web database workloads workloads perform heavy number system calls spending time trapping kernel system switches contexts frequently workloads section gain insight frequency switches characterization workloads order purposes study mind leave future work chapter message traffic section introduced workloads drive study section trace messages nodes cluster workloads trace destinations messages cluster bytes node node give cumulative breakdowns message sizes finally rate node sends messages presented measurements kernel-kernel traffic messages intra-cluster interconnect kernel-user traffic server implemented user space amount traffic negligible note nodes workers performing fraction work complete workload hand addition nodes serve special purpose workload message destinations figure shows pictorial representation message destinations width arrow proportional total number messages workstation note data found table discern number facts diagrams foremost number messages node node equal number messages conservation communication holds due request-response nature traffic request node met response node note one-way communication time measurements case communication traffic make imc web database figure message destinations width bar proportional number messages node node make diagram maximal arrow nodes messages exchanged web nodes exchange messages finally database nodes send messages figures scaled base number readily comparable centered disks attached discussed make workload skewed traffic pattern nodes nodes communicate nodes messages disk source tree attached node message traffic non-uniform web workload figure nodes special interest presence external network interface node reveals traffic heavy serves cluster gateway internet http request routed througha round-robin selection nodes determining node handles request fetching requested file node routes message back back requester hot-spot web workload service access point server sap-server manages global port space connection opened closed communication sap-server node occur configuration sap-server runs single node practice distributed program node managing portion space co-locating sap-server nodes external connections lessen message traffic reducing local inter-process communication finally database workload traffic centered disk database resides realistic environment spread disks nodes lead evenly balanced traffic patterns balance achieved access patterns naturally balanced solaris takes explicit action balance file system load cluster previous figures show message communication spread cluster show bytes node figure weights previous graph total bytes width arrow proportional total number bytes workstation total includes user payload orb headers fundamental operation system transport headers implementation specific make workload traffic reason node plays role file server experiment nodes request file blocks modified file blocks eventually return node workload find incoming traffic node totals workstations ethernet connections experiment traffic routed alternative configuration tcp messages return network interface nodes make imc web database figure weighted message destinations width bar proportional number bytes node node number messages make largest arrow node represents communication traffic web workload arrow represents traffic database workload highest node highest widths scaled factor figures comparable out-bound communication indicating bytes read written web workload byte-weighted diagram reveals data flows toa nodes nodes node heavy byte flow mentioned sap-server traffic note total bytes workload significantly make msgs msgs msgs make table messages table presents raw data figures number requests doesn equal number responses difference number messages dropped finally pictorial view database workload byte transfer reveals traffic uniform frequency capacity message sizes section shown data aggregate communication cluster section exact distribution message sizes workloads differences workstations cluster reiterate message size sum user payload orb headers figures show node distribution message sizes node nodes workloads graph depicts cumulative distribution message sizes node experiment line graph weights distribution size message messages size size percent message size bytes message size breakdown make cumulative message count cumulative message size percent message size bytes message size breakdown make cumulative message count cumulative message size percent message size bytes message size breakdown make cumulative message count cumulative message size percent message size bytes message size breakdown make cumulative message count cumulative message size figure message size distribution make workload lines count number messages node message smaller bytes messages smaller bytes data transferred big chunks data shipped units packets transferred data figure shows breakdown make workload observing cumulative distribution message sizes diagrams upper-most line messages small fact workstations messages bytes request-response traffic encourages extent direction request-response transfer large chunk data note message smaller bytes specific support messages size domain lower line graphs weights distribution message size messages small data fact transferred large messages truths computer science data transferred large objects objects small nodes percent message size bytes message size breakdown cumulative message count cumulative message size percent message size bytes message size breakdown cumulative message count cumulative message size percent message size bytes message size breakdown cumulative message count cumulative message size percent message size bytes message size breakdown cumulative message count cumulative message size figure message size distribution web workload lines count number messages 
node message smaller bytes messages smaller bytes machines messages considered large case larger attributed synthetic nature workload roughly data transferred blocks larger node number message sizes case directly influenced file sizes previous studies file sizes unix environments shown similar files small data large files distribution figure message sizes web workload regular make workload message sizes lifetime experiment nodes identical distributions predicted graphs roughly messages bytes difference bytes transferred considered large messages case note highly dependent http request experiment requests -byte file diverse percent message size bytes message size breakdown database cumulative message count cumulative message size percent message size bytes message size breakdown database cumulative message count cumulative message size percent message size bytes message size breakdown database cumulative message count cumulative message size percent message size bytes message size breakdown database cumulative message count cumulative message size figure message size distribution database workload lines count number messages node message smaller bytes messages smaller bytes data transferred big chunks data shipped units non-synthetic workload directly correlate diverse message pattern note message smaller bytes traffic coming comprised small messages node relays requests nodes replies carry larger payload traffic slightly rest attribute sap-server presence leads small message exchanges manage global port space database workload figure additional data point spectrum message distributions bears similarity make workload roughly messages small bytes large messages move data data transferred blocks hand distinct message sizes similar web workload case roughly message sizes realistic database workload run disks significantly alter message size distributions node perform request-responses simply serve balance traffic nodes equally message rates examining message size distributions observed size burstiness traffic small protocol messages large data packet section establish time burstiness exists figures depict number messages node life experiment set graphs workload diagrams workstation make workload node communicates bursty manner workstations periods hundreds messages quarter send fewest messages time average rate messages noted nodes workers nodes partake make special responsibilities differs make master executing additional messages rexec system calls distribute work nodes averages message experiment finally file server strain respond requests files readily graph averages messages notably nodes web workload shows workload-sensitive traffic patterns figure observe nodes constantly sending messages time seconds onward experiment began qualitative difference quantity sends messages routes traffic sap-server sends worker nodes averaging messages database workload proves similar web workload nodes communicating constant rates attributed nature workload node continually performs transactions nodes send messages file server node sends times node responding requests nodes messages time seconds messages time make messages time seconds messages time make messages time seconds messages time make messages time seconds messages time make figure message rate make workload graph shows number messages workstation sends experiment busiest serves source files nodes parallel make master nodes workers environment equally busy peak end due link stage compilation messages time seconds messages time messages time seconds messages time messages time seconds messages time messages time seconds messages time figure message rate web workload graph shows number messages workstation sends experiment gateway internet busiest machine bya home sap-server nodes serve workers messages time seconds messages time database messages time seconds messages time database messages time seconds messages time database messages time seconds messages time database figure message rate database workload graph shows number messages workstation sends experiment rate machines machine housing disk workload machine surprisingly times busy conservation communication implications section workload highly influences message traffic cluster development type environment modeled make workload message traffic highly non-uniform message traffic hot-spots disks system message sizes environment highly variable strongly influenced size files relevant workload system anticipate breakdown small messages large messages data web server traffic patterns dependent number users web service web workload steady stream requests models constantly busy server type workload message traffic spread evenly nodes exception node running sap-server sap-server contacted time port number bound potential bottleneck small messages payload message delivered ratio partly attributed tcp ineffective support http simple http requires tcp open connection send message receive message close connection dependent design networking subsystem database workload regular strongly correlated fact workstation running simple debit credit script node constantly performing transactions message traffic clustered disks implication message layer support medium-sized messages sizes bytes important note -byte message size supported early active message layers environment difficult deem workload typical workloads made extensive medium-sized messages specifically make web database workloads messages bytes traffic request-response latency messaging important reducing latency message round-trip times directly lead improved performance investigate section studying simple request-response final observation arises experiments pertains distributed system design benefits advanced striping file system apparent solaris nodes easily hot-spots performance bottlenecks simply serve files current workload system stripes blocks set nodes load balance system automatically addition nodes serve file servers send large blocks data important optimize large message sends nodes support zero-copy message layers sense important path optimize disk network direct dma disk device network device pose difficulty current hardware technologies chapter message dependencies previous section examined nature message traffic number workloads leaves questions unanswered long simple request-response cost due transport request-response workload workloads excellent driving system aggregate measurements instrument system finer granularity ran workloads produce mountain data hard differentiate queuing delays fundamental costs reason drive system simple test program -ef hardware set-up simplified workstations involved system-v based unix including solaris command proc file system obtain information processes system process created assigned unique process identifier pid find information process resource utilization status opening file proc pid calling correct ioctl command -ef lists information processes system opens directory proc find files processes system opens file performs ioctl finally closes file solaris proc combining global file system sum local proc file systems cluster open ioctl close generate message traffic orb invoke method handle request orb unpack message prepare act orb results prepare return msg send message msg process ack msg receive message send ack context switch msg send message msg process ack msg receive message send ack orb process response user invocation complete orb prepare send user invoke request initiator request handler context switch figure cumulative request handling costs user refers solaris programmer orb object substrate msg transport layer leftmost graph depicts requesting-side costs simple request-response rightmost 
side handling-side costs note handling costs show requesting side graph time waiting response return order fetch global information experiment focus messages discuss details experiment explain steps involved simple requestresponse mentioned solaris built object substrate orb object request broker orb turn built reliable transport layer communication solaris performed layers form object invocations invocation orb marshals arguments request hands transport reliably delivers message handling node handling side transport receives message hands orb orb receives message interprets invokes method request results gathered finally shipped back request initiator orb initiating side unmarshals response puts results place returns control user case solaris programmer process diagrammed figure viewed object-oriented functional equivalent remote procedure call beneath orb transport layer transport reliable send arbitrary buffer chain node system implemented streams module reliable message transport top streams-based device driver mbit ethernet myrinet date context switch context switch request initiator request handler msg receive message send ack orb prepare message orb unpack message prepare act user invoke method handle request orb results prepare send msg send message msg process ack msg receive message send ack orb process response msg process ack msg send message driver receive message pass transport driver receive message pass transport figure request handling costs orb refers time spent orb msg time spent transport layer driver time spent device driver user time spent handler invoked transport costs shown green lighter shading black white orb costs red darker shading cost object invocation white note context switch time folded transport costs experiment machines system requests generated froma handled ona experiment begins enabling trace buffers kernel machines command -ef run finally dump kernel trace buffers log files machine total request-response pairs traced figure shows results requesting side entitled request initiator handling side request handler box scaled lengthwise represent total cost microseconds note orb costs red darker shading black white transport costs green lighter shading conclusion draw simple request-response takes roughly milliseconds fast network ethernet myrinet time wire negligible time examine request-initiating node messages orb spends roughly preparing request point orb hands message transport layer cost message wire costly average note high cost due expensive streams-based utilities locking protocols request side waits acknowledgment receives waits response request request-handle side takes place request-initiator waiting packet received driver passed transport layer cost estimate time accounted fairly accurate transport layer sends acknowledgment back requesting side strips transport headers decides packet destined orb passes message orb takes average costly sum context switch occurs orb message interpretation set orb finally performs requested invocation cost invocation application-specific time case nanoseconds stride bytes note cray alpha local memory hierarchy request cache response main memory off-page work access absolutely off-page access request-response bank times expensive minimal cost invocation orb prepares time response nanoseconds analogous stride bytes dec request workstation side memory prepare hierarchy cache cache main memory main sends memory tlb response cache back tlb incurring large transport overhead finally request side response back driver estimated transport finally orb interprets message places results correct place finishes request item discuss latency network experiment -mbit ethernet employed time-on-the-wire -byte packet modern switch-based network latency wire insignificant overhead matters domain implications micro-experiments section cost request-response high culprits high-latency hijinks transport layer orb transport layer surprisingly large tcp-like overheads total send receive overhead drivers altogether accounts roughly total involved simple request-response total time orb costs total time substantial compare real cost remote invocation infinitely fast network protocol place orb responsible time optimization work desperately needed areas chapter anatomy message previous data discussion paper focused message sizes destinations request-response timings section brings structure message scrutiny resume workloads make web database examining construction message detail hope shed light potential areas communication layer network interface optimize attempt understand overhead object system requires terms bytes buffer chains figure shows structure prototypical message message solaris comprised list buffers similar structure mbufs found older unix systems mblks streams vernacular message arbitrarily large number buffers measurement shows case table shows percent messages buffer chains consisting buffers workloads note message consisting buffers message head figure generic message message list potentially non-contiguous buffers buffer buffers buffers make web database table buffer chains percent messages buffers chain workloads messages buffers chain row totals make workload messages single buffer messages consist buffers buffers imbalance increases workloads web workload database workload protocol overheads give give buffer size distributions workloads figure buffer chain bigger bytes half buffers bytes size buffer underlying object system buffer size distribution pattern similar message size distributions figures buffer holds user payload surprisingly shows greatest variation size finally buffer occasionally object system send object protocol information node workloads buffer smaller buffer exceeding bytes leads obvious question overhead percent total bytes object system require table shows breakdown workloads make database workloads send large messages payloads large object percent messages message size bytes buffer chain distribution make buffer buffer buffer percent messages message size bytes buffer chain distribution buffer buffer buffer percent messages message size bytes buffer chain distribution database buffer buffer buffer figure buffer chain sizes figures plot distribution sizes buffer message note bulk data buffer chain buffer buffer buffer make web database table object protocol overheads table shows percentage bytes buffer buffer chain row totals overheads small web workload overheads substantial figure absolutely larger workload largest payloads fairly small bytes small messages object overhead noticeable fraction implications section inspected structure solaris message buffers object system protocol information payload solaris programmer messages chain non-contiguous buffers size distribution distinct buffers radically buffer small buffer ranges small hundred bytes large make workload existence buffer chains implies message layer support gather interface perform extra copy buffer allocation sending data gathering interface present today fast messaging layers alternative significantly restructure code allocate extra space object anticipation object system demands gather cost directly proportional memory copy costs cost buffer allocation substantial restructuring code worth pursuing made buffer chains finally message requires bytes object header information web workload bytes transferred orb chapter conclusions future work paper measured performance workloads prototype cluster operating system solaris measurements revealed interesting results message-layer design distributed system design perspective systems perspective key solaris design decisions adversely affect performance non-striped file system lead bottlenecks occurring disks system node data nodes system global services network port name-space manager suffer similar bottlenecks distributed lastly nodes house disks sending large messages optimizing path disk network prove worthwhile message layer design mind find 
message traffic highly workload dependent cluster compute server database engine web server scenarios system behave differently performance optimization system depends intended clear support medium-sized messages important workloads messages workloads range bytes instrumenting object subsystem prototype implementation solaris suffers unusually high request-response times attributed slow streamsbased transport contributes high overhead high latency current cost object infrastructure high ideal case transport layer fast overhead object system significant finally support gathering interface limited benefit object system attaches header request separate buffer implementation effort level potentially remove future remains examined perspective workloads web database workloads realistic web workload trace-driven usage patterns popular web-site make web server netscape server database workload disks standard database benchmarks tpc-c tpc-d system evolving repeating measurements yield insight problems solved persist clear fast lightweight transport great avenue exploration place tuning orb costs spread orb code path early measurements memory allocation improved cases low overhead significantly improve system performance light view report prototype continued series refined evaluations bibliography anderson dahlin neefe patterson wang serverless network file systems fifteenth acm symposium operating systems principles pages copper mountain resort usa dec anderson owicki saxe thacker high-speed switch scheduling local-area networks acm transactions computer systems nov baker hartman kupfer shirriff ousterhout measurements distributed file system proceedings thirteenth symposium operating systems principles pages pacific grove usa oct baskett howard task communicaton demos proceedings acm symposium operating system principles pages reading usa bernebeu matena khalidi extending traditional object-oriented techniques coots boden cohen felderman kulawik seitz myrinet gigabit-per-second local area network ieee micro feb cheriton vmtp transport protocol generation communication systems proceedings acm sigcomm pages stowe aug cheriton distributed system communications acm mar cheriton williamson network measurement vmtp request-response protocol distributed system proceedings acm sigcomm pages stowe aug chu zero-copy tcp solaris proceedings usenix technical conference pages san diego usa jan douglis ousterhout kaashoek tanenbaum comparison distributed systems amoeba sprite computing systems fall finkel scott experience charlotte simplicity function distributed operating system ieee transactions software engineering june hartman ousterhout zebra striped network file system proceedings fourteenth symposium operating systems principles pages ashville usa dec kaashoek van renesse van staveren tanenbaum flip internetwork protocol supporting distributed systems technical report department mathematics computer science vrije universiteit july khalidi bernebeu matena shirriff thadani solaris multi-computer winter usenix pages usenix jan khalidi nelson extensible file systems spring proceedings fourteenth symposium operating systems principles ashville usa dec mainwaring active message application programming interface communication subsystem organization master thesis california berkeley martin hpam active message layer network workstations proceedings hot interconnects july matena bernabeu khalidi high availability support solaris technical report sun microsystem laboratories moutain view mcvoy staelin lmbench portable tools performance analysis proceedings winter usenix jan mogul rashid accetta packet filter efficient mechanism user-level network code proceedings eleventh symposium operating systems principles pages austin usa nov mullender rossum tanenbaum renesse van staveren amoeba distributed operating system ieee computer magazine ncsa httpd development team ncsa httpd http hoohoo ncsa uiuc apr ousterhout cherenson douglis nelson welch sprite network operating system ieee computer feb popek walker editors locus distributed system architecture pages computer systems series mit press ritchie thompson unix time-sharing system communications acm july schmidt suda transport system architecture services high-performance communications systems ieee journal selected areas communications spec design committee specweb http specbench osg web apr sunsoft technical writers tnf manual page solaris answerbook tibbitts corba common touch distributed applications data communications international van rennesse tanenbaum amoeba world fastest operating system operating systems review dec von eicken basu buch vogels u-net user-level network interface parallel distributed computing proceedings fifteenth acm symposium operating systems principles pages copper mountain resort usa von eicken culler goldstein schauser active messages mechanism integrated communication computation proc international symposium computer architecture pages gold coast australia welch comparison distributed file system architectures vnode sprite plan computing systems spring 
time nanoseconds stride bytes local write performance write merging merging off-page access slowdown frequency seconds duration column connect cholesky sample slowdown frequency seconds duration column connect cholesky sample slowdown percent parallel non-idle column connect cholesky sample slow noon percent time day workstation availability aggressive peak condor peak condor aggressive alpha shell bytepageoffsetindexseg index dtb annex address translation offset page byte offset page byte slowdown migration time seconds migration cost workstations workstations workstations slowdown recruitment threshold seconds recruitment threshold workstations workstations workstations day percent time idle time minutes idle time distribution minutes minutes frequency weighted percent users delayed times number delays user delays cpu condor time replace seconds amount memory replaced cost replacing memory dec ultrix sun ipx sunos time nanoseconds stride bytes uncached remote read split-c time nanoseconds stride bytes cached read latency slowdown social contract social contract workstations workstations workstations appears proceedings annual conference file storage technology fast march ata versus scsi question addressed paper phrased terms ata drives versus scsi drives accurate ata versus scsi debate groups drives interface interface significant difference differences mechanics materials electronics firmware make real distinctions drive considerable number employees directly impact business operations normal operation faster drives service requests employees supported productive workers key requirements key requirements manifested drives market interface scsi ata dave anderson jim dykes erik riedel seagate technology abstract paper sets clear misconception prominent storage community today scsi disc drives ide ata disc drives technology internally differ external interface suggested retail price classes drives represent product lines aimed markets fact classes range products address variety features usage patterns simply interface talk device target market final product specification account earliest design decision manufacturing testing process paper attempts clarify differences illuminating design choices consequences final device characteristics community build storage systems knowledge trade-offs made performance characteristics result introduction manufacturer product families aimed customer segments smart city coupe daimlerchrysler mercedes e-class sedan apparent technology gasoline engine round wheels similar disc drives traditionally sold personal computer systems distinct appearance performance cost sold larger computer systems refer personal storage enterprise storage classes disc drives portable computers consumer electronics devices disc drives differ important ways classes discuss leave future work comparing unique features drives larger cousins families product lines choosing drive application system designers underlying factors assume interface distinction sufficient interface difference categorize drives correctly fact instances drives equipped scsi interface drives high-end personal computers inherent reason drive ata interface personal storage important quality drives drive cost commensurate cost system installed cost pressure personal computer market gave rise low-cost hard discs continued put pressure drive pricing discuss drives back point repeatedly low cost dominates design drives personal computers appeared hard drive drives day big expensive customer demand hard drive based personal computer drove development small-sized low cost drive enterprise storage invention disc drives large computer systems time systems tended big expensive employed access large quantities data cost support users simultaneously environment gave rise essential properties drives tend configured groups aggregation opposed drives drive system randomly access small portions large data spaces reliability performance critical characteristics failure idle cost constant pressure reduce drive costs drives complex build due resulting demands encoding schemes error correction servo processing takes considerably logic control basic reading writing areal density improvement requires greater precision lower tolerances noise interference kind component drive complex order deliver state-of-the-art capacity time pushed costly build seek performance improving seek performance continuous struggle head move location faster previous generation product involves expensive components higher performance magnetic circuits faster microprocessors lower-mass actuator assemblies process designing drive involves sophisticated modeling analysis optimize structures seek movements vibrational modes structure negatively affect seek performance fast seeks depend ability rapidly follow servo patterns media predictable design preclude drive seeking throttled obscure resonance head disc assembly ibm rotational latency latency improved spinning media faster drives slower adopt performance improvements introduced drives performance enhancements made incur marginal cost capability drives years practical move models cost penalty development cost eliminated volume market figure shows history rpm adoption mainstream products years fact history illustrates general characteristic relationship drives drives tend drive costly innovation achieving levels performance reliability function drives adopt technology cheap model puts drives difficult pricing position compared drives growth market depends added capabilities innovation drives terms cost savings making rpm motor cheaper building rpm motor time drive cost form higher cost materials larger research development investment aggregation notable difference operating environment drives drives groups simply interface issue electrically interconnect multiple drives property fibre channel scsi serial attached scsi sas efficiently attach drives host drive limit traditional ide controller aggregation drives housed time interactions occur dramatically decrease performance compensation included drive seek simply stay track nearby drives spinning energy transfer rotational vibration seeking drive drives cabinet reliability reliability varies significantly usage patterns operating environment personal computers designed active hours day enterprise systems active hours day day means design choices made drives cost reasons make perform operational stresses designed history interfaces traditionally difference interface based work host drive years ago ide controllers programmed main system processor responsible interactions disc drive interrupts direct memory access dma offload data transfer scsi external control chip drive handled independent operation drive standards group adding command queuing function similar scsi serial ata sata protocol ata historically added major features scsi multiple cpu support failover simultaneous operation variable block size support figure adoption higher rotational speeds data control data product guides seagate product guides year introduction spindle speed rpm rpm ability format drive nonbyte block sector dual porting note type drive functionality accretes drives complexity implementation increases technology differences differences drives far-reaching start earliest design choices diagram figure illustrates basic components modern disc drive section items turn note market disc drives cost-sensitive drive designers spend extra penny material assembly cost target device specifications mechanics basic component choices mechanical portion drive affect reliability seek time acoustics resistance temperature shock vibration environmental variations head disc assembly head disc assembly hda consists base casting heads actuator spindle discs air handling system top cover drive operates higher rpm maintaining higher tolerance external disturbance external disturbances influence neighboring drives rotational vibration environmental factors temperature complicated fact higher rpm faster seeking drives put energy drive cabinet creating disturbance time drives required affected requires rigidity mechanical structure drive mass higher bandwidth servos cases special support circuitry offset effects decimate drive performance higher rpm drives require power operate creating heat affect drive neighbors cabinet achieving million hour mtbf drive easy thing failure mode addressed drives tighter tolerances design rules control externally internally generated particles outgassing rules include things avoiding holes greater environmental control higher quality sealing drive typically environmental protection drive filter particles desiccant control humidity active carbon absorbent eliminating organic substances inside hda spindle motors o-ring seals drive cover gasketing things adds cost improves reliability individually addresses minor failure mode achieve hour mtbf drives designed reliability tend compromise components eliminated save cost o-rings desiccant eliminated drives drive shrouding air control devices manage air flow inside hda eliminates air turbulence make harder 
head track optimize seek performance directs air actuator cool adds cost size stiffness base casting top cover impact acoustic characteristics drives susceptibility rotational vibration problems acute higher spindle speeds actuator larger magnets key achieving faster seek times bring additional requirements higher cost order seek performance stay tight power budget actuator coils resistance requires thicker coil material fewer windings mentioned special hda design features promote cooling actuator prevent overheating interesting complex interactions arises latch inside drive latch hold actuator power common method latching involves magnetic circuit latch magnetic field affect seek performance actuator operating latch drive compensation seek performance critical achieve optimum seek performance drives bi-stable latch affect performance expensive solution performance coil bearing cartridge independently bonded arm special epoxy drive drive coil attached arm single molded connector expensive technique makes rigid structure achieving maximum seek performance figure diagram major components disc drive head disc assembly cover discs actuator e-block flex circuit flex circuit connector power connector printed circuit board base casting spindle read write heads drive seek performance high priority drive typically drive design achieve cost targets seek performance opposite priority holds drives actuator design prevent bending modes resonances impacting seek settle time performance presence rotational vibration spindle years drives spun faster rpm drives sped rpm rpm rpm recently rpm spinning faster tremendous engineering challenge read write head track increasingly difficult rpm off-track head reading mis-read rotational miss requiring full rotation read re-tried off-track head writing mis-write introduces noise overwrites adjacent tracks higher rpm requires expensive motors tracks inch tpi increases motor bigger challenge disturbances windage air movement disk arm vibration increase rpm time drives affected order random performance cost reasons drives cantilever motor design motor shaft captured base deck end motor shaft captured ends attachment top cover today tpi fluid bearing motors preferred minimize runout acoustical noise discussion runout years thought impossible fluid dynamic bearing motor captured ends seagate solved unique conical design drives benefits fluid bearings motor supported ends expensive design performance electronics on-drive electronics integrated improvements processor technology matsumoto means fewer components required provide basic functionality control processor drive servo system read write head track moves track drive determines position reading small fields information interspersed data blocks track servo bursts time head crosses servo burst microprocessor suspends takes task identifying head wandering track slightly move head direction distance back middle track seeks actuator constantly reads servo bursts crosses tracks information determine close actuator target location close decelerate actuator servo processor tpi higher servo processing needed head neighboring tracks hard tracks perfect repeatable circles motor variation platter waviness circumferentially radially stacking tolerances factors give rise repeatable non-repeatable runout runout variation radius circumference track occurs head unable follow current track stay position repeatable runout inherent track rotation making easier compensate non-repeatable runout due external influences vibration varies time servo processor adjust head follow track wandering underneath servo capability higher capacities require servo bursts requires processing works minimizing cost increasing capacity drive constant balancing act minimizing cost including processing power tracking higher tpi achieve maximum capacity interface significantly silicon products comparison study asic gate count drive embedded sram space program code permanent flash memory program code data sram cache sram space complexity scsi interface compared ide ata interface shows due part complex system architectures drives find interfaces support multiple initiators hosts drive track separate sets information host attached maintaining processor pointer sets multiple initiators tagged commands capability scsi efficiently process commands tasks parallel resulted higher overhead kernel structure firmware complexities richer command set result expensive pcb carry electronics drive processor busy servo work read write tasks interface work order drive offer maximum performance equipped processors dedicated servo interface read write handling maximizing random access performance rotational vibration depend dedicated servo processor drive single processor handle basic processor tasks drive run interface support reading writing data servo processing memory firmware scsi command set large ata requiring permanent flash code increased sram runtime complex command set larger command queues require additional memory space scsi command set vendor-specific extensions require additional code space allowing greater flexibility configuration magnetics magnetic componentry similarity drives strive stretch areal density boundary differences stem performance goals drives higher rpm drives delivers higher data rates heads magneto-resistive head technology made profound change data read drive writing inductive process sensitive linear velocity higher rpm improves latency data rate reason drives tend stretch writing capability demand constant innovation high rpm higher areal density drives adopt writer technology proven previous generations drives reading opposite read data rate generally insensitive linear velocity cases adversely affected higher rotational speed signal amplitude increase inductive heads noise means drives higher rpm data rate targets difficult magnetic environment read data key property system read write reliably signal noise ratio snr harder reach snr high rpm drive makes task extracting data read signal significantly difficult referred recording stress pronounced drive drives expensive read write electronics cope difficult magnetic environment higher data rate materials traditional substrate material media aluminum layer magnetic material deposited recent glass substrates greater uniformity magnetic surface greater stiffness ibm magnetic layer harder deposit glass making difficult expensive achieve read densities walker shock tolerance glass traded lower density data rate addition glass textured actuator removed media land load unload ramp landing media contact start stop ibm requires landing zone outer edge disc case contact heads leave platters precisely area highest density data rate recent change media structure anti-ferromagnetically coupled media magnetic layer oriented opposite primary layer reinforce magnetic orientation ibm achieve higher densities cost increased complexity materials manufacturing process walker diagram figure illustrates layering manufacturing build test times drives considerably longer drives increased test time make drive reliable time drives undergo detailed characterization learning precisely irregular individual tracks heads track normal operation time spent analyzing media flaws results lower probabilities flaws causing unrecoverable read errors field performance differences outlined design choices designing disc drive target market choices affect performance attempt quantify impact specific choices capacity basic media structures drive types highest areal density time choice number disc platters size platters capacity figure diagram media layers base substrate consists aluminum glass topped layer magnetic material anti-ferromagnetically coupled 
afc media additional layer magnetic material layer ruthenium added layers reinforcing magnetic stability higher density substrate aluminum glass rpm drives platters support faster spindle speeds rpm drives platters size platters drives spin faster performance power increases cube rpm smaller diameter platters drive power acceptable level cost drive platters achieve capacity drive areal density smaller platters brings performance advantages ability spin faster faster seeking average seek times head traverse smaller recording band greater investment actuator capability discussed earlier makes drives perform random access faster counterparts equivalent areal densities larger diameter platters lower rpm give drive clear advantage delivering capacity consistent primary market requirement lowest cost combination minimizing parts cost delivering highest capacity yields lowest dollar gigabyte data figure compares drive capacity date introduction years number platters drives manufactured fewer platters performance matters capacity chart figure illustrates trend depopulated drives recent depopulated heads platter surface save cost additional read write head fewer platters translates faster seeks heads actuator lower total mass move fraction millisecond faster significant subms average seek times matches marketplace users requirement performance buy drives lower capacity spread data actuators data rate fastest drives higher data rate contemporary drive due large part higher rpm explained earlier drive advantage media size typically drives platters compared rpm rpm drives larger media size helps drives follow closely data rate factor favoring drive models tend frequently drives introduction drive generation double capacity previous generation successive models years drives hand deliver appreciable increase capacity doubling introduced platter higher frequency enables drives stay closer drives data rate jumps happen drives data table compares data rates drives shows underlying spindle speed areal density platter size figure comparison capacities capacity introduction date years seagate drives seagate maysep- janjun- octmar- juldec- aprsep- date introduction drive capacity capacity capacity figure trend depopulated drives users choosing drives platters trading capacity time nanoseconds stride bytes blocking remote write latency split-c performance calendar year fraction drives sold platters platters platters platters heads single platter single head cap speed density dia int ext rpm calc spec atlas wls deskstar cheetah cheetah cheetah table comparison drives increasing data rates capacities speeds densities published spec sheets diameters typical spindle speeds internal bandwidths calculated speed diameter tpi shown spec sheets external bandwidths measured linuxhardware augustus table shows components sequential data rate rotational speed areal density diameter platters higher speed drives smaller platters lower energy consumption faster seeks resulting lower data rates drives table arranged order externally-measured sequential throughput rpm deskstar faster rpm atlas due higher areal density larger platter diameter deskstar cheetah close data rate increased rpm cheetah overcome density disadvantage smaller platter diameter cheetah rpm gains data rate loses due reduced platter diameter finally generation cheetah increases areal density outperforms smallest diameter platter diagram figure illustrates trade-off data rate capacity seek time power consumption choosing platter size random performance random performance describes ability drive location unpredicted address service request components performance movement seek performance controller overhead rotational latency seek times mechanical items mentioned section directly affect ability drive seek quickly stay servo track response environmental factors data figure compares seek time drives date introduction seek performance drives lags drives improves slower rate drives expected squeeze gain generation drives entire mechanical design drive focused achieving highest random access performance critical target market table shows seek performance drive workload comparison barracuda cheetah drive system table details experimental setup mechanical details drives close higher density barracuda compensates higher spindle speed cheetah higher spindle speed account improvement random performance drive figure diagram basic drive parameters smaller media lower sacrifices bandwidth capacity shorter seeks lower power additional platter adds capacity power consumption seek dis cetan data rate rate density rpm power power rpm drag drag platter spindle capacity cap density figure comparison seek times seagate maysep- janjun- octmar- juldec- aprsep- data introduction aver age seek seek seek queue depth read write requests req req req req requests req req req req requests req req req req requests req req req req requests req req req req requests req req req req table comparison random request rates increasing queue depth request stream drives drives run write caches enabled write cache drive disabled improvement larger queue depth larger observed previous study white server dell poweredge operating system windows pro scsi controller adaptec ata controller promise ultra drive seagate cheetah specs rpm seek drive seagate barracuda specs rpm seek benchmark iometer jan code release table experimental drive testbed seek scheduling queue depths seek sorting impacts performance drives generally shorter queues fact shorter queue lengths ata interface direct impact drive mechanics fact seeks aggressively scheduled drives average seek distance closer theoretical average disc radius drives aggressive scheduling bring low radius average means mechanical duty cycle total amount time spent seeking stressing mechanical components drives higher similar request stream data table compares random performance drive drive queue depth drive increases queue pending requests drive achieve random performance single queued request drive improves throughput reads barely writes similar results earlier study white performance increase performance improvement seeks smaller leads performance reliability additional scheduling sophistication included drive require additional electronics discussed earlier controller overhead controller overhead optimized processor performance interpret schedule commands arrive recently augmented custom hardware assist provide performance economically realized simply greater investments software hardware ensures data moved interface rates close internal drive data rate rotational vibration drive seek simply stay track nearby drives spinning energy transfer seeking drive drives cabinet excite drives rotate center mass throwing actuator track drive designed mitigate effect writes abort seeks fail find desired track cases manifest decrease performance aborted writes rotational misses accumulate extreme effect bad drive cease function simply stay track long complete operation key understand rotational vibration present server environment design drive withstand drives built single drive systems rotational vibration important factor cd-rom drive create amount vibration slight infrequent effect sufficient produce noticeable performance problem responsiveness measured single user retries create problem cases drives hand explicitly designed operate cabinets full spinning drives requires designing drive maintain operation presence considerable rotational vibration tracks inch tpi increases rotational vibration problem worse difficult stay track ideal conditions external vibrations difficult compensate abramovitch recent drives added rotational vibration sensor detect external 
rotation compensate servo processing earlier mentioned performance degradation due rotational vibration attempt quantify chart figure shows performance single drive test stand varying rotational vibration performance drive affected drive drive essentially stops radians external vibration drive degrades smoothly operate radians multiple drives cabinet rotation induced adjacent discs system components affects performance design cabinet mountings determines bad effect system studies drive enclosures machine designs variety manufacturers show wide range vibration characteristics designs subject drives radians minor performance consequences cabinets inducing radians hall reliability trickiest drive characteristics measure reliability arises wide range factors considfigure externally applied rotational vibration major negative impact performance individual drive cabinets vary widely amount rotational vibration transfer measured rad hall data seagate cheetah barracuda iii applied rotational vibration rad operat ions ond ops iops iops erations design manufacturing operational environment kaczeus yang elerath significant difference reliability specification drives expected power-on hours poh drive type mtbf calculation assumes poh hours day days year specification assumes hours day days year longer drive expected running lower mtbf higher annual failure rate afr chart figure shows expected increase afr due higher power-on-hours moving drive expected poh year poh year increase failure rate two-fold compensation design duty cycle addition obvious increase increased power-on hours amount mechanical work drive affected basic structure workload asked larger number platters drive increases capacity increases mechanical stresses chart figure shows increase expected afr higher duty cycle increase higher drive larger number platters platter disk duty cycle reduce failure rate seek scheduling leads shorter seeks average lower effective duty cycle set user requests preliminary measurements testbed mechanical duty cycle approximately drive drive set requests adding platters heads increases afr due additional mechanical stresses due increased internal heat generation additional head disc interfaces release particles lead negative interactions head crashes temperature reliability decreases increases ambient temperature drive temperature affected temperature components time nanoseconds prefetch group size prefetch latency pop queue memory barrier prefetch issue split-c prefetch system high-density server rack disc drives grouped close experience higher temperatures single drive mounted desktop computer chart figure shows increased afr increased temperature fifteen degree temperature rise expected increase failure rate factor increase size common assumption high-density server racks patel order prevent data corruption failure elevated temperature drives temperature sensors provide warnings temperature specification range herbst reliability factors makes individual contribution drive failure rate magnify capacity-focussed drive platters sophisticated seek scheduling higher base duty cycle workloads subject temperature variation specification seagate manufacturers varying similar assumptions power-on hours vilsbeck figure reliability reduction increased power hours ranging hours day operation cole yearly power-on-hours poh afr multiplier figure reliability decreased higher duty cycle effect greater drives larger numbers platters cole duty cycle mul single platter platters figure reliability decrease due ambient temperature variation cole temperature afr multiplier past work comparing reliability drives reported failure rate ide drives scsi drives month period talagala numbers treated controlled study due small sample size drives study data collected design phase drives reported scsi ata drives shows annual failure rate larger hughes shows design choices significant impact final drive failure rates related work previous comparison scsi ide white concluded ide slightly sequential performance lagged significantly random performance authors study compare mechanical details drives leading conclusion generalized scsi ide drives data table compares set basic characteristics drives considered study slight advantage ata drive sequential performance due density advantage ata drive higher larger platter diameter larger overcome rotational speed advantage scsi drive higher scsi drive comparable density perform significantly discussed section data table shows improvement generation drives manufacturer newer scsi drive comparing ultrastar deskstar areal density rotational speed advantage smaller diameter platters push scsi drive higher data rates higher advantage scsi drive ata drive random performance partly due smaller platters additional differences mechanics explained earlier sections note generations scsi drives seek time nanoseconds stride bytes non-blocking remote write latency split-c performance improved seek performance ata drives remained constant performance comparison windows chung shows ide drive slower scsi drive sequential throughput slower random performance shown table performance difference due mechanical differences higher density larger platters ide drive compensate faster spindle speed scsi drive seeks latencies significantly lower higher rpm drive drives introduced density higher rpm drive larger sequential throughput advantage comparison scsi ata end users dominguez makes high-level points disiface cap price speed seek density kbpi ktpi internal dia ext dsks cap spec raw ultrastar lzx scsi rpm deskstar ata rpm table comparison drives ibm white deskstar drive slight advantage sequential bandwidth ultrastar higher rpm authors previous study attribute overhead scsi interface fact closer physical discs shows explanation smaller platter size ultrastar normal reduces seek time expense lower sequential bandwidth outer tracks ultrastar lower areal density make capacity difference additional platters estimated based internal transfer rate raw capacity differences iface cap price speed seek density kbpi ktpi int dia ext disks cap calc spec raw ultrastar scsi rpm deskstar ata rpm table comparison newer generation drives ibm case ultrastar increases sequential performance deskstar due higher spindle speed areal density lower harddrive august published specification measured number version deskstar disks heads surface remains unused cap seek speed density dia int ext rpm calc spec fireball lct atlas scsi table comparison ata scsi windows chung cussed ata drives optimized simplicity low cost scsi drives optimized performance reliability ability connect multiple hosts trends speed sophistication interfaces bringing ata scsi closer ata gaining complexity moves closer scsi comparison ata scsi reliability end user perspective covering factors mentioned discussed extensively recent online article vilsbeck trends recent innovation disc drive technology details specific scsi drive design recently published disc drive maker miura aruga design disc drives complex multi-faceted process students understand engineering cost trade-offs richkus summary discussion compare individual drive models capacity point detailed device specifications impact aspect drive design determine drive performance factors turn comparing impacts capacity markets highest affordable density determined largely areal density trends variation numbers platters drive build drive chosen capacity market data rate proportional spindle speed areal density platter size data rate enterprise market higher personal storage higher spindle speeds cost interface fast seeks cost target enterprise market includes larger magnets bearings stiffer actuators challenge rapidly find target track seek stay track servo spite harsh electrical magnetic environment protection rotational vibration costs extra targets markets multiple drives sit includes motors top 
covers stiffer actuators additional mass scheduling costs extra requiring code space memory re-order queues algorithms easier scsi interface traditionally queueing mature implementation complexity exist interface fancier interface electronics cost extra scsi richer complex customer-modifiable options host connectivity takes electronics memory space difference arises solely choice interface finally high reliability costs extra considered component material choice design account duty cycle targets expected workload expected environment conclusions differences enterprise personal storage disc drives significant derive requirements respective markets offer range choices system designers simply separating products external interface ata scsi misses internal details design choices affect system performance shown external interface chosen smallest contributors performance performance reliability characteristics drive determined drive designed smallest mechanical materials choices head-disc assembly seek scheduling algorithms interface processing order find features design points application underlying trade-offs account continuum specific choices acknowledgements albertine flora performance testing benchmarking details drive internals reported due discussions zip cotter neal gunderson jim weispfenning kevin gomez mark lutwyche explaining terminology analysis comparison builds previous work led heath miller skalko contribution anonymous reviewers shepherd john wilkes detailed helpful comments abramovitch abramovitch rejecting rotational disturbances small disk drives rotational accelerometers ifac world congress july aruga aruga -inch high-performance disk drives enterprise applications alseries fujitsu scientific technical journal december augustus augustus seagate cheetah review linuxhardware features shtml linuxhardware september blount blount fluid dynamic bearing spindle motors ibm storage systems group san jose february chung chung gray worthington horst windows disk performance technical report msr-tr- microsoft research june cnet cnet hardware reviews cole cole estimating drive reliability desktop computers consumer electronics systems technology paper tpseagate technology november dominguez dominguez coligan scsi ata interface comparison technology dell computer december elerath elerath reliability disk drive industry mtbf ieee annual reliability maintainability symposium january hall hall seagate advanced multidrive system sams rotational vibration feature technology paper tpd seagate technology february herbst herbst ibm drive temperature indicator processor drive-tip helps ensure high drive reliability white paper international business machines corp october hughes hughes murray kreutz-delgado elkan improved disk drive failure warnings ieee transactions reliability september ibm ibm ibm hard disk drive load unload technology ibm storage systems division ibm ibm higher reliability ibm glass substrate disks ibm storage systems division july ibm ibm advanced servo-mechanical design facilitates improved performance reliability ibm storage systems division november ibm ibm research news ibm magnetic hard-disk-drive media delays superparamagnetic effects research ibm resources news whitepaper shtml february kaczeus kaczeus disk reliability function design manufacture computer technology review summer mason mason scsi industry workhorse working hard ieee computer december matsumoto matsumoto diskcon abuzz single-chip drives home markets times eetimes sys news oeg september miura miura information storage broadband network era fujitsu challenge hard disk drive technology fujitsu scientific technical journal december patel patel bash belady stahl sullivan computational fluid dynamics modeling high compute density data centers assure system inlet air specifications asme international electronic packaging technical conference exhibition ipack july reinsel reinsel gigabytes drive seagate barracuda idc bulletin november richkus richkus agogino tang virtual disk drive design game links math physics dissection activities asee ieee frontiers education conference san juan puerto rico november online bits berkeley mmcs disk disk html seagate seagate disk drive acoustics technology paper tpseagate technology april seagate seagate support disc drive encyclopedia seagate support disc seagate technology august talagala talagala patterson analysis error behavior large storage system technical report ucb csd- california berkeley february vilsbeck vilsbeck gefahr ide-festplatten dauereinsatz tecchannel hardware index html tecchannel june walker walker performance media tweaking magnetic capabilities technology paper tpseagate technologies august white white hillyer performance comparison ide scsi disks technical report bell labs lucent technologies january worthington worthington ganger patt wilkes on-line extraction scsi disk drive parameters sigmetrics yang yang sun comprehensive review hard-disk drive reliability ieee annual reliability maintainability symposium january appendix data table shows multiple generations drives manufacturers including ata scsi interfaces numbers serve comparisons made paper detailed data provided drives discussed text mentioned previous studies recently released drives iface intro cap price speed seek density kbpi ktpi dia int ext disks cache rpm calc spec quantum atlas scsi maxtor fireball lct ata ibm ultrastar lzx scsi seagate cheetah scsi quantum atlas scsi ibm ultrastar scsi ibm deskstar gxp ata ibm ultrastar lxz scsi seagate barracuda scsi fujitsu allx scsi seagate cheetah scsi seagate cheetah scsi fujitsu alle scsi maxtor diamondmax ata ibm deskstar gxp ata ibm deskstar gxp ata seagate barracuda ata seagate cheetah scsi seagate cheetah scsi western digital caviar ata seagate barracuda ata western digital caviar ata seagate barracuda ata table comparison multiple drive generations manufacturers numbers manufacturer specifications product manuals noted prices drives sold august dirtcheapdrives seek times average seek values density bandwidth maximums outer diameter internal bandwidth calculated rpm kbpi disc diameter values provided comparison published values version deskstar disks heads side remains unused measured linuxhardware augustus measured bell labs white measured windows chung published specifications measured numbers measured cnet hardware cnet option default cache size 

bandwidth transfer size bytes bulk read bandwidth bulk transfer engine prefetch queue cached read uncached read split-c bandwidth transfer size bytes bulk write bandwidth write cache write memory bulk transfer engine split-c memory naneseconds link percent non-local edges performance simple bundle unoptimized bundle optimized put bulk 
repeatlocal computation load imbalance processes communication optional time granularity computation variation end opening barrier begin opening barrier closing barrier optional compute comm sync barrier switch idle fractionoftime compute comm sync news switch idle fractionoftime compute comm sync transpose switch idle fractionoftime compute comm sync barrier switch idle slowdown compute comm sync news switch idle slowdown compute comm sync transpose switch idle slowdown barrier imbalance imbalanceimbalance latency latency high low medium context-switch computation granularity low low high coarsefine highlowhighlowhighlow high news imbalance imbalanceimbalance latency latency high low medium context-switch computation granularity low low high coarsefine highlowhighlowhighlow high transpose imbalance imbalanceimbalance latency latency high low medium context-switch computation granularity low low high coarsefine highlowhighlowhighlow high compute comm sync barrier switch idle slowdown compute comm sync news switch idle slowdown compute comm sync transpose switch idle slowdown compute comm sync news spin switch idle slowdown compute comm sync news spin switch idle slowdown compute comm sync news spin switch idle slowdown job opening barrier job job spin processor processor processor processor job job job job spin read spin spin barrier barrier closing barrier completescompletes load imbalance compute comm sync news switch idle slowdown compute comm sync news switch idle slowdown introduction disk drive modeling chris ruemmler john wilkes hewlett-packard laboratories palo alto research systems based disk drive simulation models good accurate simulation model emphasize performancecritical areas paper published ieee computer march supersedes labs technical reports hpl rev hpl osr copyright ieee internal personal material permitted permission reprint republish material advertising promotional purposes creating collective works resale redistribution obtained ieee receive information obtaining permission send blank message info pub permission ieee note file obtained scanning performing ocr ieee published copy result typographic errors published version minor clarifications updates made bibliography modern microprocessor technology advancing incredible rate speedups percent compounded annually norm disk storage densities improving impressively percent compounded annually performance improvements occurring percent compounded annually decade result disk system performance fast dominant factor system behavior naturally researchers improve performance large component performance disk drive research involves analytical simulation models compare alternative approaches quality models determines quality conclusions wrong modeling assumptions lead erroneous conclusions work develop describe accurate disk drive models explain commonplace simple inaccurate models room improvement article demonstrates describes calibrated highquality disk drive model error factor times smaller simple first-order model describe disk drive performance components separately show inclusion improves simulation model enables informed trade-off effort accuracy addition provide detailed characteristics disk drives description simulation environment disk drive model characteristics modern disk drives model disk drives understand behave begin overview current state art nonremovable magnetic disk drives embedded scsi small computer systems interconnect controllers widely disk drives mechanism controller mechanism made recording components rotating disks heads access positioning components arm assembly moves heads correct position track-following system place disk controller microprocessor buffer memory interface scsi bus controller manages storage retrieval data mechanism performs mappings incoming logical addresses physical disk sectors store information closely elements emphasizing features considered creating disk drive model clear features equally important model accuracy recording components modern disks range size inches diameter inches common sizes today smaller disks surface area store data larger counterparts consume power spin faster smaller seek distances historically storage densities increased gigabytes fit single disk next-smaller diameter series cost-effective preferred storage device increased storage density results improvements linear recording density determined maximum rate flux recorded read back current values bits inch approximately double end decade packing separate tracks data closely improvements occurring current values tracks inch rising tpi end decade product factors sustain growth rate percent year end decade single disk dozen platters shown figure stack platters rotates lockstep central spindle rpm facto standard years spindle rotation speed increased recently rpm median rotation speed increasing compound rate percent year higher spin speed increases transfer rates shortens rotation latencies time data rotate head power consumption increases bearings required spindle spin speed typically quoted accurate percent practice disk speeds vary slowly nominal rate perfectly reasonable disk operation makes impossible model disk rotational position revolutions operation fortunately operations occur bursts uncertainty applies request burst platter surface disk head responsible recording writing sensing reading magnetic flux variations platter surface disk drive single read-write data channel switched heads channel responsible encoding decoding data stream series magnetic phase stored disk significant fractions encoded data stream dedicated error correction application digital signal processing increase channel speeds current megabits multichannel disks support read write operation time making higher data transfer rates disks costly technical difficulties controlling cross talk concurrently active channels keeping multiple heads aligned platters simultaneously difficult track densities increase figure mechanical components disk drive top view side view arm assembly arm head spindle sector track arm head arm pivot platter cylinder positioning components data surface set store data series concentric circles tracks single stack tracks common distance spindle called cylinder today typical -inch disk cylinders track densities increase notion vertical alignment cylinders relevant track alignment tolerances simply fine essentially tracks platter independently access data stored track disk head moved attaching head disk arm lever pivoted end rotation bearing disk arms attached rotation pivot moving head move rotation pivot immune linear shocks older scheme mounting head linear slider positioning system task ensure head desired track quickly remains face external vibration shocks disk flaws nonconcentric noncircular tracks seeking speed head movement seeking limited power pivot motor halving seek time requires quadrupling power arm stiffness accelerations required achieve good seek times flexible arm twist bring head contact platter surface smaller diameter disks correspondingly reduced distances head move disks smaller lighter arms easier stiffen flexing contributing shorter seek times seek composed aspeedup arm accelerated reaches half seek distance fixed maximum velocity acoast long seeks arm moves maximum velocity aslowdown arm brought rest close desired track asettle disk controller adjusts head access desired location short seeks cylinders dominated settle time milliseconds fact seek occur head resettle position track short seeks cylinders spend time constant-acceleration phase time proportional square root seek distance settle time long seeks spend time moving constant speed taking time proportional distance constant overhead disks smaller track densities increase fraction total seek time attributed settle phase increases average seek times commonly figure merit disk drives misleading averages calculated ways situation complicated fact independent seeks rare practice shorter seeks common frequency function workload operating system driving disk disk requests completely independent average seek distance full stroke sources quote one-third-stroke seek time average simply quote full-stroke time divided sum times needed perform seek size divide sum number seek sizes commonly techniques weight seek time number seeks size single-track seeks disk cylinders full-stroke seek emphasizes shorter seeks providing approximation measured seek-distance profiles matters people building models profile encourage manufacturers include disk specifications alternative determine experimentally information required determine power apply pivot motor long seek encoded tabular form disk controller subset total stored interpolation intermediate seek distances resulting fine-grained seek-time profile sawtooth thermal expansion arm pivot-bearing stickiness factors occasionally make recalibrate tables milliseconds recalibrations triggered temperature timers occur frequently disk drive powered steady-state conditions recalibration occurs minutes difficulties real-time guaranteed-bandwidth systems multimedia file servers disk drives appearing modified controller firmware avoids visible recalibrations completely host schedule execution track fine-tuning head position end seek keeping head desired track function track-following system system positioning information recorded disk manufacturing time determine disk head correctly aligned information embedded target surface 
recorded separate dedicated surface maximizes capacity frequently disks small number platters track density increases form embedded positioning data essential fine-grained control combined dedicated surface coarse positioning data embedded-data method good coping shock vibration feedback information intermittently data sectors track-following system perform head switch controller switches data channel surface cylinder head repositioning accommodate small differences alignment tracks surfaces time switch typically half time settle end seek similarly track switch cylinder switch occurs arm moved track cylinder track takes time end-of-seek settling process settling time increases track density increases tracks platters aligned head-switching times approaching track switching nowadays disk drives aggressive optimistic approach head settling read operation means attempt read head track data unreadable settle completed lost error correction identification data misread sector ensure data wrongly interpreted hand data save entire revolution delay obvious reasons approach settle immediately precedes write difference settle times reads writes data layout scsi disk appears client computer linear vector addressable blocks typically bytes size blocks mapped physical sectors disk fixed-size data-layout units platters separating logical physical views disk means disk hide bad sectors low-level performance optimizations complicates task higher level software second-guess controller bsd unix fast file system zoning tracks longer platter inside maximize storage capacity linear density remain maximum drive support amount data stored track scale length accomplished disks technique called zoning adjacent disk cylinders grouped zones zones outer edge sectors track zones inside typically zones number double end decade data transfer rate proportional rate media passes head outer zones higher data transfer rates hewlett-packard -inch disk drive burst transfer rate intertrack head switches varies megabytes zone mbps outermost zone track skewing faster sequential access track cylinder boundaries obtained skewing logical sector track amount time required cope worst-case heador track-switch times means data read written full media speed zone track cylinder skew factors sparing prohibitively expensive manufacture perfect surfaces disks invariably flawed sectors flaws found extensive testing manufacturing list built recorded disk controller flawed sectors remapped portions disk process sparing granularity single sectors tracks simplest technique remap bad sector track alternate location alternatively slip sparing logical block map bad sector slipped sector track combinations techniques disk drive designers make complex trade-off involving performance expected bad-sector rate space utilization concrete disk drive forms track-level sparing slip-track sparing disk format time single-track remapping defects discovered operation disk controller disk controller mediates access mechanism runs track-following system transfers data disk drive client cases manages embedded cache controllers built specially designed microprocessors digital signal processing capability special interfaces control hardware directly trend powerful controllers handling increasingly sophisticated interfaces reducing costs replacing previously dedicated electronic components firmware interpreting scsi requests performing computations takes time controller microprocessor speed increasing fast stay ahead additional functions controller asked perform controller head slowly declining typically range bus interface important aspects disk drive host channel topology transfer rate overhead scsi defined bus alternative versions discussed encapsulations higher levels scsi protocol transmission media fibre channel disk drives scsi bus operation synchronous mode run maximum bus speed mbps early scsi buses differential drivers fast scsi specification increased mbps couple years ago disks appearing drive bus mbps fast wide standard defined mbps maximum bus transfer rate negotiated host computer scsi interface disk drive appears serial channel fibre channel popular transmission medium higher speeds partly fewer wires require smaller connector scsi bus device attached scsi initially supported addresses figure recently doubled wide scsi number devices bus increases contention bus occur leading delays executing data transfers matters disk drives large transfers controller overheads high addition time attributed transfer rate scsi bus interfaces host disk require time establish connections decipher commands scsi cost low-level protocol acquiring control bus order microseconds bus idle scsi protocol disk drive disconnect bus reconnect data transfer cycle devices access bus disconnected device processes data resulting higher throughput older channel architectures buffering disk drive result disk ready transfer data host interface ready disk wait entire revolution data head retry transfer scsi disk drive expected speed-matching buffer avoid delay masking asynchrony bus mechanism scsi drives data media slowly send bus drive partially fills buffer attempting commence bus data transfer amount data read buffer transfer initiated called fence size property disk controller modern scsi disk drives control command write requests data transfer disk buffer overlap head repositioning limit permitted buffer size interactions illustrated figure caching requests functions speed-matching buffer disk drive readily extended include form caching reads writes caches disk drives tend small kilobytes megabyte space limitations high cost dualported static ram needed disk mechanism bus interface read-ahead read hits cache satisfied immediately time needed controller detect hit send data back bus quicker seeking data reading disk modern scsi disks provide form read caching common form read-ahead actively retrieving caching data disk expects host request momentarily show read caching turns important modeling disk drive areas disk system behavior read partially hits cache partially serviced cache noncached portion read disk simply bypass cache altogether large read requests bypass cache block read cache controllers discard case subsequent read directed block early disk drives caches on-arrival read-ahead minimize rotation latency wholetrack transfers head arrived relevant track drive started reading cache end revolution full track worth data read host waiting data logical start point reread called zero-latency read disk cache memory called track buffer tracks longer request sizes on-arrival caching brings benefit -kbyte accesses disk -kbyte tracks maximum benefit percent rotation time on-arrival caching largely supplanted simple read-ahead disk continues compute comm sync barrier switch idle slowdown compute comm sync news switch idle slowdown compute comm sync transpose switch idle slowdown read host request left proves optimal sequential reads proceed full disk bandwidth readahead back-to-back reads delayed full revolution disk host processing time initiating read request larger inter-sector gap policy choice read-ahead aggressive crossing track cylinder boundaries stop end track reached aggressive read-ahead optimal sequential access degrades random accesses head track switches typically aborted initiated unrelated request arrives switch progress delayed figure overlap bus phases mechanism activity low-level details bus arbitration selection elided simplicity data transfer mechanism head switchseek host sends command controller disconnects bus starts seek scsi bus data transfers host status message host rotation latency controller decodes data transfer mechanism head switchseek host sends command controller starts seek scsi bus data transfer host 
status message host rotation latency controller decodes read write scsi bus disk mechanism scsi bus disk mechanism single read-ahead cache provide effective support single sequential read stream sequential read streams interleaved result benefit remedied segmenting cache unrelated data items cached -kbyte cache split separate -kbyte cache segments configuration commands disk controller write caching disk drives cache volatile losing contents power drive lost perform write caching prevent data loss kind cache managed carefully technique reporting hp-ux file system back-to-back writes user data selected writes disk reported complete written disk cache individual writes flagged immediate-reported write immediately reported write read sequential extension write technique optimizes common case large writes file system split consecutive blocks protect power failures file system disables reporting writes metadata describing disk layout combining reporting readahead means sequential data written read adjacent disk blocks disk full throughput volatile write-cache problems disk cache memory made nonvolatile technique battery-backed ram lithium cell provide -year retention equipped disk drive free accept write requests fit buffer acknowledge immediately addition reduced latency write requests throughput benefits result data write buffer overwritten place reducing amount data written mechanism large number stored writes makes controller schedule near-optimal fashion takes time perform issues discussed detail read caching policies handling write requests hit data previously written disk cache nonvolatile memory safest solution delay writes copy written disk data write cache scanned read hits case buffered copy treated primary disk written command queuing scsi support multiple outstanding requests time provided mechanism called command queuing host give disk controller requests controller determine execution order subject additional constraints provided host letting disk drive perform sequencing potential job detailed knowledge disk rotation position modeling disk drives understanding disk drive performance factors ready model behavior drives describe models sufficient detail quantify relative importance components conscious choice made detail disk drive performance model application selectively enabling features arrive model accurately imitates behavior real drive related work disk drive models disk drives storage devices nonlinear state-dependent behavior disk drives modeled analytically accuracy work area simulation nonetheless simplest models assume fixed time select times uniform distribution elaborate models acknowledge disk separate seek rotation transfer times fail model components carefully seek times modeled linear function seek distance producing poor results smaller seeks common uniform distributions rotational latency inappropriate nonindependent requests frequent media transfer times modeled fixed constant dependent transfer size bus contention multiple devices connected bus previously work detailed models avoided limitations models simulated axial rotational head positions allowing seek rotation transfer times computed drawn distribution article extension simulation work earlier simulator built event based simulator version tasking library modified locally support time double type long type tasking library simple effective simulation environment tasks represent independent units activity call delay time simulated time advances task wait low-level events easy construct variety synchronization mechanisms top primitives basic ideas readily applicable simulation environments model disk drive tasks additional control structures figure task models mechanism including head platter rotation positions task accepts requests form read seek executes time handles data layout mapping logical blocks physical sectors task direct memory access engine dma engine models scsi bus interface transfer engine task accepts requests form transfer request host disk handles time cache object buffers requests tasks classic producer-consumer style manage asynchronous interactions bus interface disk mechanism tasks disk drive model fits larger system items representing scsi bus semaphore device bus time host interface synthetic trace-driven workload generator tasks range statistics-gathering -reporting tools disk-related portions simulation system consist lines commented code lines infrastructure simulator process series model system -mhz pa-risc processor million requests serviced approximately minutes traces study selected representative week-long samples longer trace series hp-ux unix computer systems systems traces greater detail request traces included data start finish times granularity microsecond disk address transfer length flags read write request marked synchronous file system start time corresponds moment disk driver request disk finish time corresponds request completed interrupt fires results present include time spent queued disk driver table describes disks singled analysis purpose show components disk drive model contribute accuracy selected noncaching disk drive cache interfere analysis disk mechanism disk driven show effects adding caching hp-ib ieee bus scsi interface modeling perspective major difference hp-ib bus slower disk drive mechanism scsi buses faster emphasize importance bus-related effects table characteristics disk drives analyzed article disk type formatted capacity cylinders size rotational speed average access host interconnect type max speed rpm hp-ib rpm scsimb figure simulation model structure single disk disk mechanism task dmaengine task buffer cache scsi bus disk mechanism work dmaengine work disk controller data structures code internally queued requests state disk data structures disk mechanism task request perform seek settle rotation cache memory data transfer blocking buffer full data ready dmaengine task request controller cache memory data transfer scsi bus blocking releasing bus buffer full data ready disk controller code select request process queue dmaengine disk mechanism generate readahead request requests waiting evaluation comparison metric evaluate models simple execution time request calibrating model real world differentiation models plot time distribution curves real drive model output root square horizontal distance curves metric call demerit figure model present absolute terms difference milliseconds relative terms percentage time real trace demerit figure matches encourage researchers disk drive models publish demerit figures preferably calibration curves important test workload similar kind data wishes analyze synthetic random load calibrating model workloads great sequential data accesses obtained parameters models manufacturer specifications performing curve fitting traces direct measurement disk drives modeling simplest model constant fixed time figure plots typical values literature actual time week traced data model good time fixed estimate results demerit factor percent average time simple model requires remembering state information requests modeling effect length straightforward model combination features seek time linear distance single-cylinder full-stroke seek times published disk drive specification figure head-settle effects head-switching costs rotational delay drawn uniform distribution interval rotation time fixed controller overhead figure graph displays measured curve linear interpolation manufacturer published single-cylinder full-stroke seek times accompanying table shows formula model real curve seek distance cylinders seek time milliseconds linear real table seek distance seek time cylinders cylinders transfer time linear length request asymmetry transfer 
rates hp-ib bus reads run mbps writes mbps media transfer rate mbps faster hp-ib bus bus speed dominates figure shows model fares demerit percent time demerit times larger effects system designers investigate modeling head-positioning effects previous model seek time linear function distance good match figure shows difference linear seek model real percent error table figure figure time distributions models real disk time fraction time real fixed fixed fixed trivial model constant fixed time demerit fixed fixed fraction time real model transfer time proportional size seek-time linear distance random rotation time interval rotation-time demerit simulation fraction time real model adds measured seek-time profile includes headswitch time demerit simulation fraction time real model final model includes rotational position modelling detailed disk data layout demerit simulation describes model approximate measured seek-time profile disk drive computing model trivial six-line single-line calculation improving positioning calculations opportunity model costs head track switching achieved determining track cylinder request started ended adding fixed cost head track switch needed start request end figure shows demerit figure halved percent time modeling rotation position important performance components left model detailed rotational latency spare-sector placement keeping track rotational position disk explicitly calculate rotational latency drawing uniform distribution calculating times disk revolved start simulation assuming spinning nominally rated speed track cylinder skewing sector-based sparing spare sector track accounted mapping logical blocks physical sectors adding factors results data shown figure good match model fitting real disk drive percent table lists parameters final model modeling data caching discussion disk drive buffer cache cache added disk drive complications arise shown figure model incorporating features simulate scsi disk drive read-ahead reporting large disparity small completion times due caching percent requests completed caching modeled results closely matching real disk drive demerit percent acceptable figure models real disk time fraction time real model basic model includes features model demerit simulation fraction time real model adding caching readahead reporting demerit simulation added aggressive read-ahead reporting model section caching requests gave results shown figure good match demerit percent time half absolute error comparable major remaining components modeled accurately actual bus speeds achieved system drive rated speed host controller imposes lower rate detailed disk drive controller overheads frequently combination interactions previous request current overheads depend size request modeling level detail requires heroic efforts applying logic analyzers scsi buses bruce worthington greg ganger michigan approach managed fine-tune controller-overhead bus-transfer components model similar achieved demerit figures percent disk drive model summary table summarizes models bottom include line michigan model full model good match required onerous implement encourage adopt full model includes details parameters provided table host device driver cpu costs executing queuing strategy scsi bus including bus contention effects table final model parameters parameter sector size bytes bytes cylinders tracks cylinder data sectors track number zones track skew sectors sectors cylinder skew sectors sectors revolution speed rpm rpm controller interface hp-ib scsi-ii controller overhead reads writes seek time short long boundary track switch time read fence size sparing type sector track disk buffer cache size track sparing spare regions beginning end data region effect simulation performance spare sector end track giving sectors track track sparing dedicated sparing regions embedded data area table shows data regions located physically disk format cylinder track boundaries physical sector space disk disk physical cylinders store data rest spares region start end disk controller effects fixed controller overhead scsi bus disconnects mechanism delays overlapped bus transfers mechanism activity disk buffer cache including read ahead write-behind reporting producer-consumer interlocks mechanism bus transfers data layout model reserved sparing areas including sectorand track-based models zoning track cylinder skew head movement effects seek time curve derived measurements real disks settle time values read write head-switch time rotation latency model chose ignore things worthwhile model soft-error retries effects individual spared sectors tracks likewise features disk drive sparing policy important accurate understanding layout effects sparing model rotational positioning effects accurate model disk drive essential obtaining good simulation results studies failure model disk drive behavior result quantitative extreme cases qualitative errors analysis careful modeling difficult costly provided data enables designers quantitatively determine benefits gained investing effort disk drive model important feature model data-caching characteristics disk percent relative demerit important features data transfer model including overlaps mechanism activity bus transfers percent demerit seektime head-switching costs percent demerit evaluation transfer model greater effect positioning model relative importance reversed scsi drives bus generally faster disk mechanism finally modeling rotational position detailed data layout improved model accuracy factor modeling rotational position accurately important systems emphasize sequential transfers modern file systems increasingly adept good model careful calibration tuning values good fit models differ manufacturer published specifications addition space present quantitative effects modeling zoning model handles features important workload large data transfers table performance figures models disk drives show greater accuracy features added model feature demerit disk type constant time basic model add head positioning add rotation position caching add caching controller costs plan refined disk drive simulation model explore variety designs policy choices host disk drive levels hope make source code model interested researchers year calibrated model parameters longer list disk drive types space describe acknowledgments pei cao contributed greatly simulator disk model part marvin keshner provided information underlying storage technology trends tim sullivan patricia jacobson provided helpful feedback earlier drafts article work performed part datamesh research project hewlett-packard laboratories patterson hennessy computer architecture quantitative approach morgan kaufmann san mateo calif ruemmler wilkes unix disk access patterns proc winter usenix conf usenix sunset beach cali jan hewlett-packard boise idaho series -lnch scsidisk drive technical manual part number apr seltzer chen ousterhout disk scheduling revisited proc winter usenix conf usenix sunset beach calif jan jacobson wilkes disk scheduling algorithms based rotational position tech report hpl csp hewlett-packard laboratories palo alto calif feb thekkath wilkes lazowska techniques file system simulation published simultaneously tech reports hpl- hewlett-packard laboratories palo alto calif dept computer science eng univ washington seattle wash oct published software practice experience nov ruemmler wilkes disk shuffling tech report hpl- hewlett-packard laboratories palo alto calif oct holland gibson parity declustering continuous operation redundant disk arrays proc int conf architectural support programming languages operating 
systems published special issue computer architecture news vol unix system language system release selected readings select code hewlett-packard boise idaho series disk storage systems owner manual models part number feb hewlett-packard boise idaho -lnch scsi disk drives technical manual part number june worthington ganger patt scheduling algorithms modern disk drives proc acm slgmetrics conf chris ruemmler software engineer hewlett-packard works area performance analysis technical interests include architectural design system performance operating systems graduated degrees computer science california berkeley john wilkes worked researcher project manager hewlettpackard laboratories current research interest high-performance high-availability storage systems interested performance modeling interconnects resource management scalable systems enjoys interacting academic research community wilkes graduated cambridge degrees physics diploma phd computer science wilkes contacted hewlett-packard laboratories page mill palo alto e-mail wilkes hpl ruemmler address hewlett-packard pruneridge ave cupertino e-mail ruemmler cup 
appeared usenix symposium operating systems design implementation november metadata update performance file systems gregory ganger yale patt department eecs michigan ganger eecs umich abstract structural file creation block allocation consistently identified file system performance problems user environments compare implementations maintain metadata integrity event system failure require on-disk structures set schemes file system asynchronous writes passes ordering requirements disk scheduler schedulerenforced ordering schemes outperform conventional approach synchronous writes percent metadata update intensive benchmarks suboptimal due inability safely delayed writes ordering required introduce soft updates implementation asymptotically approaches memory-based file system performance percent providing stronger integrity security guarantees unix file systems metadata update intensive benchmarks improves performance factor compared conventional approach introduction file system metadata updates traditionally proceed disk speeds processor memory speeds ousterhout mcvoy seltzer synchronous writes properly order stable storage update sequencing needed maintain integrity event system failure power loss rename operation file adding link removing link system directory block written link removed written file exist system complete integrity individual update atomic partially written disk achieved forcing critical structure fully contained single disk sector disk sector protected error correcting codes flag partially written sector unrecoverable result loss structures loss integrity addition disks start laying sector sufficient power finish restarted protect metadata consistency directory entry reach stable storage directory block refer ordering requirement update dependency writing directory block depends writing block ordering constraints essentially map simple rules reset pointer resource pointer set moving objects re-use resource nullifying previous pointers point structure initialized synchronous writes metadata update ordering variants original unix file system ritchie berkeley fast file system ffs mckusick performance degradation dramatic implementations choose ignore update dependencies pointer newly allocated block added file inode block initialized stable storage ordering enforced system failure result file data previously deleted file presenting integrity weakness security hole allocation initialization synchronous writes degrade performance significantly result unix file system implementations including ffs derivatives force initialization force initialization newly allocated directory blocks order protect integrity directory hierarchy investigate performance cost allocation initializationin comparison ordering schemes previous schemes address performance penalty update ordering generally entail form logging hagmann chutani journal shadowpaging chamberlin ston chao seltzer approaches successfully applied types unix file system writes synchronous asynchronous delayed write synchronousif process issues sends device driver immediately waits complete write asynchronousif process issues immediately wait complete delayed write issued immediately affected buffer cache blocks marked dirty issued background process cache runs clean blocks exploring implementations require on-disk structures large installed base remainder paper organized section describes experimental setup measurement tools base operating system sections describe approaches safe metadata updates including implementations section describes schemes file system asynchronous writes passes ordering restrictions disk scheduler request section describes soft updates file system implementation safely performs metadata updates delayed writes section compares performance schemes section compares important nonperformance characteristics user-interface semantics implementation complexity section draws conclusions discusses avenues future research appendix describes low-level details soft updates implementation experimental apparatus experiments performed ncr mhz intel machine equipped main memory system trace buffer disk drive experiments high performance -inch scsi storage device base operating system unix svr gis production operating system symmetric multiprocessing ufs file system experiments based berkeley fast file system mckusick virtual memory system similar sunos gingell moran file system caching integrated virtual memory system scheduling code device driver concatenates sequential requests disk prefetches sequentially on-board cache command queueing disk utilized important aspect file system reliability performance syncer daemon background process executes regular intervals writing dirty buffer cache blocks syncer daemon unix svr operates differently conventional sync awakens sweeps fraction buffer cache marking dirty block encountered asynchronous write initiated dirty block marked previous pass approach reduce burstiness conventional approach run experiments network disconnected non-essential activity obtain measurements sources unix time utility total execution times cpu times instrumented device driver collect traces including per-request queue service delays traces collected trace buffer mentioned copied separate disk experiment timing resolution approximately nanoseconds tracing alters performance percent assuming trace buffer section benchmarks compare performance metadata update schemes sections concisely quantify performance impacts implementation decisions provide small amounts measurement data descriptions purpose results metadata update intensive benchmarks n-user copy benchmark user concurrently performs recursive copy separate directory tree files totaling storage author home directory n-user remove benchmark user deletes newly copied directory tree datum average independent executions coefficient variation standard deviation scheduler-enforced ordering scheduler-enforced ordering responsibility properly sequencing disk writes shifted disk scheduler generally part device driver file system asynchronous writes augments request ordering requirements examine levels ordering information simple flag list specific dependencies ordering flag straight-forward implementation scheduler-enforced ordering attaches one-bit flag disk request suggested mcvoy write requests previously synchronous ordering purposes writes require ordering respect subsequent updates issued asynchronously ordering flags set disk scheduler modified appropriately sequence flagged requests significant implementation issue semantic meaning flag represents contract file system disk scheduler ordering semantics determine subsequent requests scheduled flagged request previous requests scheduled flagged request restrictive semantics flagged request acts barrier restrictive meanings offer disk scheduler freedom require file system set flag frequently reducing scheduling flexibility general find restrictive flag semantics result improved performance allowing read requests bypass list writes waiting ordering constraints improve performance significantly endangering metadata integrity read requests locations written compare meanings ordering flag full back part ignore infull flagged request acts full barrier previous requests complete scheduled subsequent requests bypass back prevents requests issued flagged request scheduled previous request flagged request re-ordered freely previous non-flagged requests scheme restrictive full requests ordered respect request request issued flag set part relaxes constraints requiring requests issued flagged request scheduled previous non-flagged requests re-ordered freely subsequent requests flagged request flag meaning requests require ordering respect subsequent request flag set addition -nr scheme disk scheduler nonconflicting read requests bypass list writes waiting ordering restrictions finally ignore re-orders requests freely ignoring flag scheme protect metadata integrity include comparison -user copy benchmark figure performance improves reduction flag restrictiveness reducing number requests flag set improve performance increasing disk scheduler freedom re-order cases occur infrequently counter increased restrictiveness flag meaning found allowing reads bypass flagpending writes improves performance significantly disk access times figure directly display impact allowing scheduler greater freedom elapsed times figure 
show translates performance trend restrictive flag semantics results higher performance holds benchmarks comparisons section utilize part-nr -user remove benchmark figure exception rule elapsed times figure system response times observed benchmark user write requests remove directory tree issued large queue builds scheduler effect evident average driver response times times requests issued device driver complete including queue times disk access times seconds shown figure read requests bypass queue user process wastes time waiting benchmark completes waiting driver queue empty writes fit intomain memory -nr option restrictive flag semantics result lower user-observed response times fewer requests interfere read requests note viewed implementation decision part flag semantics ordering required metadata integrity pertains writes full back part part-nr ignore meaning ordering flag elapsed time seconds elapsed time seconds full back part part-nr ignore meaning ordering flag average disk access time average disk access time figure performance impact ordering flag semantics -user copy benchmark service demonstrates performance advantage sub-saturation bursts activity giving preference requests block processes ganger tying disk scheduler hands poor realizing performance improvement behave system activity exceeds memory shown scheduler chains restrictive semantics ordering flag requests constrained unnecessarily flagged writes tagging disk request unique identifier list requests depends list requests complete scheduled false dependencies avoided refer approach scheduler chains similar approaches exist systems mpe-xl file system support ordered sequences user writes writepart full-nr back-nr part-nr ignore meaning ordering flag elapsed time seconds elapsed time seconds part full-nr back-nr part-nr ignore meaning ordering flag average driver response time average driver response time figure performance impact ordering flag semantics -user remove benchmark ahead loggingprotects metadata busch kondoff cao describes method supporting request dependencies intelligent storage controller device driver dealing multiple hosts interconnection network disk scheduler support complete requests depend future requests request depend previously issued requests addition increased scheduler complexity file system maintain information dirty blocks depend outstanding requests cases straight-forward newly updated blocks depend just-issued requests exception rule block de-allocation deallocated block re-used pointer re-initialized stable storage generally de-allocation independent subsequent re-use occur separate system calls examined approaches maintaining required ordering falls back flag-based approach asynchronous write usenix association proceedings usenix conference file storage technologies san francisco usa march april usenix associationall rights reservedfor information usenix association office usenix orgwww http usenix rights individual papers remain author author employer permission granted noncommercial reproduction work educational research purposes copyright notice included reproduced paper usenix acknowledges trademarks row-diagonal parity double disk failure correction peter corbett bob english atul goel tomislav grcanac steven kleiman james leong sunitha sankar network appliance abstract row-diagonal parity rdp algorithm protecting double disk failures stores data unencoded exclusive-or operations compute parity rdp provably optimal computational complexity construction reconstruction algorithms optimal amount redundant information stored accessed rdp works single stripe blocks sizes file systems databases disk arrays utilized fixed raidor rotated raidparity placement style extend algorithm encompass multiple raidor raiddisk arrays single rdp disk array add disks existing rdp array recalculating parity moving data implementation results show rdp performance made equal single parity raidand raidperformance introduction disk striping techniques decades reduce data loss due disk failure improving performance commonly raid techniques raidand raidprotect single disk failure standard raid techniques mirrored stripes raidraid- provide protection multiple failures protect double disk failures opposing disks mirror mirrored raidand raidprotect higher order failures efficiency array measured data capacity divided total disk space reduced increasing redundancy small increments stripe cost effective adding redundancy replicating entire array dramatic increase disk sizes slower growth disk bandwidth construction disk arrays larger numbers disks reliable performant varieties disk ata combines increase rate double disk failures discussed section requires algorithms protect double disk failures ensure adequate data integrity algorithms meet information theory singleton bound protect disk failures adding disks redundancy number disks required store unprotected data good algorithms meet bound store data unencoded read directly disk multiple orders magnitude improvement reliability storage system simplify design parts system robustness improving system reliability motivates data protection algorithm protects double disk failures time desirable maintain simplicity performance raidand raidsingle parity protection paper describes algorithm called row-diagonal parity rdp protection double failures rdp applies multiple device storage system communication systems paper focus application rdp disk array storage systems raid rdp optimal computation stores user data clear requires parity disks utilizes exclusive-or operations parity construction reconstruction failures implemented easily dedicated hardware standard microprocessors simple implement compared previous algorithms difficult measure benefit implement algorithm integrate existing raid framework short product development cycle paper make case double disk failure protection increasing describe rdp algorithm proving correctness analysing performance present simple extensions algorithm showing add disks existing array protect multiple raidor raidarrays double failures single extra parity disk finally present observations experience implementing rdp give performance results implementation related work algorithms protect data disk failures array disks evenodd reed solomon erasure codes datum rdp similar evenodd distributes parity disks single stripe equivalently adds stripes parity data interspersed data stripes evenodd datum reedsolomon share property redundant information stored separately data stripe implementations dedicated redundant disks leaving disks hold data analogous raidal- parity disks call raidstyle parity placement alternatively placement redundant information rotated stripe stripe improving read write performance call raidstyle parity placement evenodd reed-solomon encoding compute normal row parity parity disk employ techniques encoding disk redundant data exclusive-or operations reed-solomon encoding computationally intensive evenodd datum encodings generate number redundant information blocks higher order failure tolerance similar reed-solomon encoding case protection disk failures rdp shares properties evenodd datum reed-solomon encoding stores redundant data parity separately disks data stored clear disks previously reported algorithms evenodd lowest computational cost protection disk failures rdp improves evenodd reducing computational complexity complexity rdp provably optimal construction reconstruction optimality construction important normal failure free operational mode optimality reconstruction important maximizes array performance degraded failure conditions double disk failure modes analysis double disk failures result combination types single disk failure individual disks fail wholedisk failure data disk temporarily permanently inaccessible media failure small portion data disk temporarily permanently inaccessible wholedisk failures result problem disk channel network connecting disk system mode duration failures vary class failures make data disk unaccessible categorized failure type purposes recovery whole-disk failures require complete reconstruction lost disk portions wanted data stresses system controller adding cpu load refer unit performs construction parity reconstruction data parity controller maintain uninterrupted service controller serve requests lost disk reconstructing requested data demand time reconstruct lost data desirable reconstruction low response time on-demand reconstruction individual blocks required service reads time exhibiting high throughput total disk reconstruction whole-disk failure rates measured arrival rate usage pattern disk assumption disk bad time failure noticed disk failure rates reciprocal time failure numbers quoted manufacturers typically range hours media failures qualitatively quantitatively whole-disk failures media failures encountered disk reads writes media failures write handled immediately disk controller relocating bad block good area disk media failures read result data loss media failure affects small amount data loss single sector critical data compromise entire system handling media failures read requires short duration recovery small amount missing data emphasis recovery phase response time reconstruction throughput generally issue disks protect media errors relocating bad blocks undergoing elaborate retry sequences extract data sector difficult read precautions typical media error rate disks manufacturers bit error bits read corresponds approximately uncorrectable error tbytes tbytes transferred actual rate depends disk construction static dynamic aspect rate represents rate unreadable sectors encountered normal read activity sectors degrade time writable readable state unreadable state failure occur reconstruction single whole-disk failure point array degraded mode reads blocks failed disk satisfied reconstructing data surviving disks commonly contents failed disk reconstructed spare space disks protect disk failure complete disk failure make reconstruction portion lost disks impossible portion failed disk reconstructed media failure reconstruction make reconstruction missing sectors blocks stripe impossible process reconstruction requires surviving disks read entirety stresses array exposing latent media failures surviving disks double disk failure combinations whole-disk whole-disk wholedisk media media media properly implemented double failure protection algorithm protects categories double failures analysis failure rates discount media media failures rare relative double failure modes whole-disk whole-disk whole-disk media failures encountered reconstruction identified whole-disk failure raid systems protect double failures due media failures periodically scrubbing disks read sector reconstructing relocating data sector unreadable single whole-disk failure occurs preempt potential whole-disk media failures 
cleansing disks accumulated media errors whole-disk failure occurs preventive techniques precaution arrays current large capacity disks media whole-disk failure rates assume uniform failure arrivals lifetime disk uniform failure arrival rates population similar disks actual whole-disk failure rates conform bathtub curve function disk service time higher failure rate encountered beginning-of-life burn-in end-of-life wear-out periods higher rate periods affect double disk failure rate disks array typically age subject usage pattern increase correlation whole-disk failures disks array disks array manufacturing batch subject variations manufacturing increase likelihood individual disk failing disks array subject temperature humidity mechanical vibration conditions subjected mechanical shocks transport result clustering failures increases double failure rate expected individual disk failures uncorrelated single disk fails period vulnerability whole-disk failure determined reconstruction time contrast vulnerability media failure fixed disk fails reconstruction require complete read surviving disks probability encountering media failure scans largely independent time reconstruction failures independent wide sense stationary derive rate occurance whole-disk failures trcn reconstruction time failed disk total number disks array whole-disk failure rate disk term reflecting correlation disk failures whole-disk failures correlated correction factor experience wholedisk failures stationary depend service time disk positively correlated factors increase rate consideration reconstruction time function total data processed reconstruction linearly related disk size related number disks total data processed product size disks small bandwidths individual disks dominate reconstruction time large aggregate bandwidth disks great saturate processing capacity controller performing reconstruction assert braceleftbigg ceilingleftbiggb ceilingrightbigg maximum rate reconstruction failed disk governed disk write bandwidth maximum rate reconstruction disk array result disk arrays larger whole-disk whole-disk failure rate cubic dependency number disks array linear dependency size disks double failure rate related square whole-disk failure rate employ disks higher failure rates ata drives expect double failure rate increase proportionally square increase single disk failure rate primary failure rate hours correlation factor reconstruction rate ten disk array gbyte disks whole-disk whole-disk failure rate approximately failures hour size disks bandwidth increasing trend years disk size increasing faster disk media rate time takes read write entire disk lower bound disk recovery result recovery time disk increasing aggravating double disk failure rate rate whole-disk media failures related disk size number disks array essentially rate single whole-disk failures multiplied probability failures result double failure due inability read sectors surviving disks single whole-disk failure rate proportional number disks array media failure rate roughly proportional total number bits surviving disks array probability bits readable probability individual bit unreadable number bits read priori rate whole-disk media double failures size disk measured bits primary failure rate hours disk array disks bit error rate whole-disk media double failure rate failures hour typical numbers rate whole-disk media failures dominates rate whole-disk whole-disk failures incidence media failures wholedisk failure uncomfortably high scrubbing disks reduce rate remains significant source double disk failures combination double inode indirect block issued part-nr barrier subsequent write request scheduled completes approach maintains information recently freed blocks re-initializedpointer reaches disk blocks reallocated time owner inode indirect block dependent write owner fact make newly allocated block dependent owner prevents data added file due untimely system failure barrier approach simpler implement unnecessary dependencies reduce performance comparison flag meanings find restrictive approach superior performance percent -user remove benchmark approach scheduler chains data reported section avoiding write locks initial implementation scheduler-enforced ordering revealed metadata writes longer synchronous processes wait cases occurs multiple updates file system metadata occur short period time write request issued device driver source memory block write-lockeduntil request completes prevents subsequent updates occurring subsystem hardware accessing data result update wait reach stable storage solution make temporary in-memory copy memory block issuing request copy source write request obviating write-lock original cost block copy operation avoid unnecessary overhead special case allocation initialization reserve zerofilled memory block system booted block source initialization writes figure compares implementations part ordering flag scheme options -nr option block copying -cb part-nr user processes spend time waiting disk requests failing include enhancement greatly reduces benefit critical source data file blocks virtual memory pages bypass safety precaution file blocks difficult performance reliability trade-off judgment call made system implementors copy-on-write superior approach plan investigate alternative expect substantially improvedthroughput increase cpu usage caused memory copying small fraction total time copy-on-write approach memory-friendly approach utilize erase operation write scsi command scsi initializing disk sectors wasting block memory transferring block zeroes host memory disk part part-nr part-cb part-nr ordering flag implementation elapsed time seconds elapsed time seconds part part-nr part-cb part-nr ordering flag implementation average driver response time average driver response time figure implementation improvements ordering flags -user copy benchmark part-nr reads bypass writes waiting due ordering restrictions part-cb block copy scheme avoid write locks part-nr combines enhancements dark region elapsed time bar represents total cpu time charged benchmark processes reason performance comparisons earlier subsections block copying implementation cpu time increases caused block copying small tend time idle processes waiting disk figure shows driver response times implementations find queue grows large processes generate requests quickly disk service -user remove benchmark figure general trends performance differences substantial queueing delays larger seconds part-nr observe general behavior scheduler chains block copying -nr holds meaning part part-nr part-cb part-nr ordering flag implementation elapsed time seconds elapsed time seconds part part-nr part-cb part-nr ordering flag implementation average driver response time average driver response time figure implementation improvements ordering flags -user remove benchmark part-nr reads bypass writes waiting due ordering restrictions part-cb block copy scheme avoid write locks part-nr combines enhancements dark region elapsed time bar represents total cpu time charged benchmark processes scheduler chains reduces elapsed time percent -user copy benchmark percent -user remove benchmark delayed metadata writes delayed metadata writes associate additional information in-memory metadata detailing ordering constraints stable storage updates complete structural change file system modifies in-memory copies affected metadata delayed writes updates dependency information dirty metadata blocks flushed syncer daemon section ordering constraints upheld process delayed metadata writes substantially improve performance combining multiple updates smaller quantity background disk writes savings sources multiple updates metadata component removal recently added directory entry significantly multiple independent updates block metadata files added single directory subsection briefly describes original approach flawed subsection describes current implementation cycles aging problems began work envisioned dynamically managed dag directed acyclic graph dirty blocks write requests issued writes depend complete practice found difficult model maintain susceptible cyclic dependencies aging problems blocks consistently dependencies written stable storage difficulties relate granularity dependency information blocks read written disk multiple metadata structures inodes directory fragments generally multiple dependency causing components block pointers directory entries result originally independent metadata easily dependency cycles excessive aging detecting handling problems increases complexity reduces performance soft updates identified coarse-grain dependency information main source cycles aging recent implementation refer soft updates maintains dependency information fine granularity information individual metadata update indicating update depends block dirty metadata written time long updates block pending dependencies temporarily undone 
rolled back block written disk consistent respect current on-disk state disk write completes undone updates re-established in-memory block accessed approach aging problems occur dependencies added existing update sequences dependency cycles occur single sequence dependent updates cyclic fact sequences original synchronous write approach main structural requiring sequenced metadata updates block allocation direct indirect block de-allocation link addition file creation link removal implement block allocation link addition undo redo approach outlined block de-allocation link removal defer freeing resources newly reset pointer written stable storage sense deferred updates undone disk writes depend complete disk write completes processing needed update remove dependency structures redo undone deal deferred work block de-allocation file removal implementation soft updates requires method performing small tasks background simple made disk completion interrupt service routine isr calls pre-defined procedure higher-level module issued request task block wait resource lock worse uncached disk block handled task handled isr preferably background process syncer daemon section purpose tasks require non-trivial processing appended single workitem queue syncer daemon awakens services workitem queue normal activities appendix describes soft updates implementation detail including main structural supported performance comparison subsections compare performance ordering schemes baseline goal ignore ordering constraints order delayed writes metadata updates baseline performance lack reliability delayed mount option ohta similar memory-based file system mckusick conventional scheme synchronous writes sequence metadata updates scheduler flag data represent part-nr scheduler-enforced ordering flag scheme scheduler chains data represent performing scheme section schedulerenforced ordering schemes block copying enhancement section soft updates data current implementation metadata throughput figure compares metadata update throughput supported implementations function number concurrent users user works separate directory result create throughput improves number users cpu time spent checking directory contents conflicts scheduler concurrent users throughput files order soft updates scheduler chains scheduler flag conventional file creates concurrent users throughput files order soft updates scheduler chains scheduler flag conventional file removes concurrent users throughput files order soft updates scheduler chains scheduler flag conventional file create removes figure metadata update throughput files data point files split users average independent executions coefficients variation allocation initialization enforced soft updates flag reduces metadata update response times compared conventional substantially improve throughput scheduler chains doubling file removal throughput users order soft updates outperform schemes differences increase level concurrency power delayed metadata writes figure created file immediately removed order soft updates proceed memory speeds achieving times throughput schemes cases soft updates performance percent order metadata intensive benchmarks table shows performance data -user copy benchmark order decreases elapsed times percent number disk requests percent compared conventional allocation initialization scheduler flag scheduler chains decrease elapsed times percent affect number disk requests performance soft updates percent order elapsed time number disk requests performance cost allocation initialization benchmark ranges percent soft updates percent conventional performance differences extreme file removal table consists metadata updates note soft updates elapsed times lower order benchmark due deferred removal approach soft updates order magnitude decrease disk activity soft updates verses scheduler chains demonstrates power delayed metadata writes lengthy response times scheduler-enforced ordering schemes caused large queues dependent background writes form device driver andrew benchmark table compares schemes original andrew file system benchmark howard consists phases create directory tree copy data files examine status file read byte file compile files expected significant differences metadata update intensive phases read-only phases practically indistinguishable compute intensive compile phase marginally improved percent non-conventional schemes compile phase dominates total benchmark time aggressive time-consuming compilation techniques slow cpu standards ordering alloc elapsed time percent cpu time disk response scheme init seconds order seconds requests time avg conventional scheduler flag scheduler chains soft updates order table scheme comparison -user copy datum average independent executions elapsed times averages users coefficients variation cpu times sums users coefficients variation disk system statistics system-wide coefficients variation ordering elapsed time percent cpu time disk response scheme seconds order seconds requests time avg conventional scheduler flag scheduler chains soft updates order table scheme comparison -user remove datum average independent executions elapsed times averages users coefficients variation cpu times sums users coefficients variation disk system statistics system-wide coefficients variation ordering create copy read read compile total scheme directories files inodes files conventional scheduler flag scheduler chains soft updates order table scheme comparison andrew benchmark seconds represents average independent executions values parens standard deviations allocation initialization enforced soft updates concurrent scripts throughput scripts hour order soft updates scheduler chains scheduler flag conventional figure scheme comparison sdet data point average independent executions coefficients variation allocation initialization enforced soft updates sdet figure compares schemes sdet spec sdm suite benchmarks benchmark gaede gaede concurrently executes scripts user commands designed emulate typical software-development environment editing compiling file creation unix utilities scripts generated randomly predetermined mix functions reported metric scripts hour function script concurrency scheduler flag outperforms conventional percent scheduler chains additional percent improvement order outperforms conventional percent soft updates throughput percent order non-performance comparisons file system semantics synchronous writes sequence metadata updates imply synchronous file system semantics general write series metadata updates asynchronous delayed cases file system call returns control caller guarantee change persistent link addition block allocation update adds pointer directory block inode indirect block requested change permanent system call returns link removal block de-allocation update modifies free maps system call returns link permanently removed blocks freed re-use scheduler-enforced ordering schemes freed resources immediately re-use links pointers permanently removed system call returns soft updates true freed resources re-use re-initialized inode indirect block reaches stable storage calls syncio flag tells file system guarantee permanent returning schemes support interface scheduler-enforced ordering schemes encounter lengthy delays long list dependent writes formed augment additional file system calls link addition link removal flag order support lock files implementation complexity schemes compare conventional synchronous write approach straight-forwardto implement moving ordering flag scheme straightforward synchronous writes asynchronous flag set device driver required lines code scheduler-enforced ordering specific request dependencies considerably difficult implementation required lines code device driver support lines file system support specific remove dependencies adds additional lines code blockcopy enhancement section required additional lines code implementation soft updates consists lines code restricted file system buffer cache modules learned key lessons initial implementation author completed soft updates implementation weeks including 
debugging conclusions future work synchronous writes order metadata updates identified file system performance problem ousterhout mcvoy seltzer direct measurement compared alternative implementations schemes file system relies disk scheduler appropriately order disk writes outperform conventional approach percent cases maximum observed difference percent withthis improvement schemes software locking schemes lock files encounter surprises fail achieve performance levels delayed writes introduced mechanism soft updates approaches memory-based file system performance percent providing stronger integrity security guarantees allocation initialization unix file systems translates performance improvement factor cases maximum observed difference factor implementations compared paper prevent loss structural integrity requires assistance provided fsck utility unix systems recovering system failure power loss file system time-consuming process reducing data system availability investigating soft updates extended provide faster recovery experiments performed unix system results applicable wider range operating environments file system operating system address issue integrity maintenance mpe-xl cms windows database techniques logging shadow-paging vms rely carefully ordered synchronous writes directly results soft updates mechanism appears promising plan compare popular methods protecting metadata integrity non-volatile ram nvram logging shadow-paging nvram greatly increase data persistence provide slight performance improvements compared soft updates reducing syncer daemon activity expensive write-ahead logging protection soft updates delayed group commit achieve performance levels shadow-paging maintain integrity difficult delayed writes combined soft updates late binding disk addresses logical blocks chao provide high performance log-structured file system seltzer special case shadow-paging integrity grouping writes atomically checksum enforce atomicity large writes resulting log-structuring utilize disk bandwidth required cleaning activity reduces performance significantly hope make non-proprietary components implementations term interested contact authors acknowledgements jay lepreau shepherd paper john wilkes bruce worthington anonymous reviewers directly helping improve quality paper remote hands summer months carlos fuentes finally research group fortunate financial technical support industrialpartners including gis hewlett-packard intel motorola ses hal mti dec gis enabled research extremely generous equipment gifts allowing generate experimental kernels source code high performance disk drives experiments donated hewlett-packard busch busch kondoff disc caching system processing units family computers journal february cao cao lim venkataraman wilkes tickertaip parallel raid failure rates time data loss mttdl hours converts annual rate data loss events disk array year due double failures type compare dominant triple failure mode media failures discovered recovery double whole-disk failures rate approximated analog equation substituting equation dominant component tertiary failure rate approximately failures hour reduction orders magnitude compared double failure rate expensive disks ata disks arrays high data integrity required increasing disks performant reliable scsi fcp disks increases reconstruction time individual disk failure rates turn increasing double failure rate arrays size row-diagonal parity algorithm rdp algorithm based simple parity encoding scheme exclusiveor operations data block belongs row parity set diagonal parity set normal configuration row parity block diagonal parity block stripe build raidor raidstyle arrays rdp locating parity blocks disks rotating parity disk disk stripes rdp array defined controlling parameter prime number greater simplest construction rdp array disks data data data data row diag disk disk disk disk parity parity figure diagonal parity set assignments disk rdp array define stripes array consist block disk stripe block holds diagonal parity block holds row parity blocks hold data bulk remainder paper describes grouping stripes includes complete set row diagonal parity sets multiple stripe groupings concatenated form raidstyle raidstyle array extension multiple row parity sets discussed section figure shows stripes disk rdp array number block diagonal parity set block belongs row parity block parity data blocks row including diagonal parity block diagonal parity block parity data row parity blocks diagonal note diagonals store parity diagonals selection diagonals store parity completely arbitrary refer diagonal store parity missing diagonal paper select diagonal missing diagonal store parity missing diagonal compute operation algorithm assume data disks failed array figure reconstruct remaining data parity disks row parity useless step lost members row parity set diagonal misses disk diagonals miss disk diagonal parity sets missing block diagonal parity sets stored parity block missing block diagonal parity sets reconstruct missing blocks reconstructed blocks row parity reconstruct missing blocks rows reconstructed diagonal blocks block diagonal data disk block diagonal data disk blocks turn diagonals diagonals diagonal reconstruction compute store parity diagonal diagonal reconstruct block diagonal data disk step reconstruct block diagonal data disk row parity block diagonal data disk finally block diagonal data disk row parity important observation compute parity diagonal require parity diagonal complete reconstruction missing blocks turns true pairs failed disks parity missing diagonal complete reconstruction safely ignore diagonal parity construction proof correctness formalize construction array construct array disks divided blocks prime number greater group blocks position device stripe groups stripes group stripes assign blocks diagonal parity sets disks numbered blocks numbered disk disk block belongs diagonal parity set mod disk special diagonal parity disk construct row parity sets disks involving disk lost block disks reconstructed row parity normal ensure store single row parity block blocks stripe loss generality disk store row parity key observation diagonal parity disk store diagonal parity diagonals array rows store diagonal parity blocks group stripes select diagonal parity blocks leave loss generality choose store parity diagonal parity set conform numbering scheme roles disks diagonal parity disk mathematically identical contribute symmetrically diagonal parity disk contribute make row parity sums stripe nondiagonal parity disks row parity require reconstruct lost block stripe diagonal parity block row parity diagonal parity block start proof correctness rdp algorithm lemma lemma sequence numbers mod 
prime endpoints equal numbers occur sequence proof number sequence definition number sequence mod mod lemma true endpoints subsequence numbers begins numbers values modulus operation repeating number sequence true mod mod means divisible prime multiple factors equal numbers sequence beginning unique numbers represented number sequence diamondmath complete proof correctness rdp theorem array constructed formal description rdp reconstructed loss disks proof classes double failures include diagonal parity disk failures include diagonal parity disk disk failed row parity section array disk reconstructed row parity row parity sets involve diagonal parity disk completion reconstruction failed disks row parity diagonal parity disk reconstructed definition diagonal parity sets leaves failures disks diagonal parity disk construction array disk intersects diagonals diagonal mod mod disk misses diagonal combination failed disks diagonals intersected disks mod mod substituting mod diagonals missing member stored diagonal parity diagonal reconstruct missing element diagonal diagonals diagonal reconstruct block missing disks diagonal parity step reconstruction failed disks reconstruct block diagonal parity diagonal parity set disk reconstruct block disk diagonal parity set mod row parity similarly reconstruct block diagonal parity disk reconstruct block disk diagonal parity set mod row parity pair diagonals potentially reconstructable failure disks reconstructable reconstruct blocks diagonal mod mod alternating row parity diagonal parity reconstructions similarly reconstructable reconstruct blocks diagonal mod mod alternating row parity diagonal parity reconstructions adjacent points sequence generated lemma reach diagonals reconstruction missing block diagonal parity set block reconstructed row parity end reconstruction chain beginning negationslash negationslash reconstruction proceeds reaching missing blocks diagonal end chain blocks reconstructed row parity diagonals reached reconstruction missing blocks diagonal reconstructed diamondmath store generate parity diagonal complete reconstruction performance analysis performance disk arrays function disk cpu memory bandwidth required construct parity normal operation reconstruct lost data parity failures section analyse rdp terms efficiency compute efficiency rdp stores data clear read performance unaffected algorithm extent disk reads writes data writes interfere data read traffic write case rdp stripes contained single stripe disk blocks section implementation optimizes write preserves property stripe disk blocks written independently stripes data writes require writing parity blocks stripe full stripe writes cost additional disk compared full stripe writes single disk parity arrays partial stripe writes computed addition recomputing parity entire stripe subtraction computing delta parity blocks change data blocks written depending number blocks written stripe writes subtraction method commonly referred small writes writing disk blocks subtraction method requires reads writes addition method requires reads writes write disk blocks reads writes cost addition method requires number disks array subtraction method requires breakpoint addition subtraction method number disk rdp minimal double failure protection algorithm writing data block requires updating parity blocks data block contribute parity blocks determine computational cost rdp total number exclusive xor operations needed construct parity data block contributes row parity block array size rows disks data blocks row xor operations required reduce blocks parity block row parity requires xors compute diagonal parity blocks diagonal total data row parity blocks requiring xors reduce diagonal parity block diagonal parity construction requires number xors row parity construction total number xors required construction theorem array data disks ratio xors block minimum number xors provide protection failures proof assume construct parity disk array groups rows minimum parity blocks row data blocks singleton bound data block contribute parity blocks parity disk ensure recover data block parity block lost pair data blocks contributes parity blocks additional information losing data blocks make parity sets contribute ambiguous construct parity blocks equations minimal formulation common pairs data blocks common subterms equations minimal formulation minimum number separately xored input terms required construct parity blocks set equations reduces terms results xors requires xors minimum number xors data block achieve double parity protection diamondmath rdp protects data blocks xors setting xors protect data blocks meets optimal ratio data rdp evenodd difference disks table row xor counts parity construction compare rdp computationally efficient previously algorithm evenodd array data disks data blocks evenodd requires xors compute row parity xors compute parity diagonals evenodd requires xors add parity distinguished diagonal parity diagonals complete calculation stored diagonal parity results total xors construct parity evenodd block array evenodd requires xors block algorithms asymptotic cost xors block difference computational cost significant small values typical disk arrays shown table ignoring fact algorithms function correctly array sizes rdp computational cost reconstruction failure optimal reconstruction single disk failure requires xors lost row parity sets diagonal parity sets size reconstruct lost block xoring surviving blocks xor operations setting recovering blocks xors xors parity block shown minimum number xors construction array double protects parity fewer operations result evenodd paper overcounts number xors required compute parity diagonal data rdp evenodd difference disks table row xor counts data reconstruction parity sets size cost repair lost disk minimum make individual parity sets smaller protect double failures reconstructing block parity set true disk lose reconstructing double failure includes diagonal parity disk cost parity construction reconstruct lost data row parity disk row parity reconstruct diagonal parity disk reconstructing data disks row parity cost contructing row parity cost reconstructing combination data row parity disks determined reconstruct blocks parity set size cost reconstruct block xors computational cost construction reconstruction cases xors optimal comparing evenodd data reconstruction algorithm evenodd paper advantage rdp shown table numbers disks typical disk arrays performance rdp evenodd construction reconstruction significantly lower compute cost reed-solomon coding rdp optimal compute efficiency efficiency construction normal operation reconstruction failure algorithm extensions single stripe implementation selecting primes meets condition define diagonal parity sets group stripes define block size rdp purposes usual system block size divided disk block sizes powers define self-contained rdp parity set single stripe blocks system disk block size select giving rdp blocks stripe rdp block bytes construct array existing software techniques reading writing single stripe adding disk diagonal parity multiple row parity groups rdp requires recover single lost block stripe row parity case block diagonal parity disk raidand raidstyle configurations row parity set stripe row parity block means portion array include diagonal disk single disk reconstruction technique including concatenation raidor raidarray declustered parity techniques define diagonal parity sets disks construct diagonal parity sets individual blocks stored parity data blocks 
cost-performance tradeoff minimizing number parity disks making reconstruction single failures faster protecting double failures wider array array double failures affect disks row parity sets repaired directly row parity technique expanding diagonal parity cover row parity group imagine rdp arrays file system block size necessarily xor diagonal parity blocks single diagonal parity block store single diagonal parity disk combination diagonal parity disks constituent arrays storing sufficient reconstruction double disk loss array failures occur subarrays recovered local row parity failures occur subarray recovered diagonal parity diagonal parity block subarray reconstructed constructing diagonal parity intact subarrays subtracting stored merged diagonal parity disk reconstructed needed diagonal parity contents normal rdp reconstruction rebuild lost blocks subarray reconstructing expandable arrays discussion implied number disks array fixed selection case underpopulate rdp array putting fewer data disks maximum allowed array simply sets maximum array size underpopulate array taking advantage fact fewer data disks fill remainder array unused disks zeros zero-filled disks contribute parity blocks change contents parity block remove array imputing zero-filled contents parity calculations expand array adding zero-filled disk adjusting parity write data disk reasoning allowable disks sizes array diagonal parity disk largest disks array rows row parity block contributions smaller disks stripes blocks disks counted zeros selecting rdp array grow data disks sufficiently large number accomodate expected disk array size implementation experience rdp implemented feature network appliance data storage system software data ontap version data ontap complete software system including operating system kernel networking storage file system file system protocols raid code raid layer manages final layout data parity raid groups volume consists raid groups raid group independently recoverable section observations made improved implementation algorithm parity construction subblocks data disk contribute row parity subblock diagonal parity subblock note contributions subblocks data disk diagonal parity disk ordered sequence architecture perform parity acm construction isca memory proceedings efficient manner modern microprocessors chamberlin process data chamberlin block pass astrahan xoring contents history row parity evaluation diagonal system parity destination communications blocks properly tuning code acm microprocessor chao work chao blocks english top level cpu cache work data block time incrementally constructing target parity blocks jacobson remain stepanov cache latency wilkes memory mime operations high-performance budget parallel completing storage xor device operations bit strong field recovery pentium guarantees optimize hewlett-packard ensuring laboratories data report bytes xored hpl-csp- rev destinations loaded november chutani processor registers chutani implementation anderson kazar instructions leverett cache line mason load complete sidebotham xors data episode integrity file checksum system calculation winter data usenix cache proceedings line january significant loss performance gaede overlap cpu execution memory operations greatly reduced effective cost computing redundant parity block rdp observation gaede tools research computer workload characterization experimental computer performance evaluation ferrari spadoni gaede gaede scaling protected technique array double comparing failures interactive remaining system vulnerability triple capacities higher order international failures conference whole-disk media management failures corrected performance evaluation encountered computer resorting systems rdp reconstruction ganger stripes ganger missing patt blocks process-flow remainder model missing disk examining reconstructed performance row parity system point diagonal view parity acm disk sigmetrics case proceedings whole-disk whole-disk failures reconstruction gingell disk gingell fail typically moran underway shannon virtual disk memory fails architecture sunos summer usenix implementation proceedings reconstruction june single disk failure starts hagmann block hagmann number reimplementing proceeds sequentially cedar file disk system block logging failure occurs stripes array missing block completed reconstruction single failure stripes run rdp reconstruction remaining stripes array stripes missing blocks reconstructed missing block reducing window group vulnerability commit acm disk sosp failure proceedings combinations disk failures published handled acm including involving operating reconstructing systems disks existing review raidand raidarrays november easily hewlett-packard upgraded rdp company constructing diagonal parity disk inch scsidisk code drive technical reconstructing single manual diagonal disk edition failures downgrading september rdp part single howard parity protection scheme simple removing howard diagonal disk kazar measured menees performance data nichols ontap version runs satyanarayanan variety sidebotham hardware platforms west scale current highest performing performance platform distributed fas file system includes ieee ghz transactions intel pentium computer cpus file systems server filer february time full journal cpu ncr running corporation raid code journaling including file xor system calculations rdp administrator ran guide performance release benchmarks ncr document implementation rdp data april ontap kondoff set kondoff experiments xortest mpe data management synthetic benchmark system testing exploiting raid xor precision checksum code architecture checksum modified adler generation checksum commercial computer bits wide systems computed ieee input compcon block input proceedings stripe block mckusick deep mckusick blocks wide joy blocks leffler rdp prime fabry fast divide file system block sixteen unix byte acm subblocks transactions rdp computer calculations systems xortest experiment august run cold caches mckusick random data generated mckusick memory karels disk bostic access pageable test memory simply based test filesystem memory ukuug cpu summer processing conference speed pub united ran kingdom sets unix tests systems user group computed parity buntingford input herts blocks july computed checksum mcvoy input mcvoy block output kleiman parity extent-like blocks performance computed unix checksums file system parity winter set usenix tests proceedings computed single january parity raiddouble parity moran rdp moran performed sunos rdp virtual reconstruction memory randomly selected implementation missing euug data blocks conference repeated proceedings experiment spring times ohta ohta tezuka fast tmp file system delay mount option summer usenix proceedings june ousterhout ousterhout results aren eliminate effects operating systems activity operating faster system fast generally hardware results summer repeatable usenix proceedings bad outliers june represent experiments ritchie interfered ritchie activity thompson affecting processor unix cache time-sharing figures system present bell system results technical experiments note journal july graphs august linear small offset ruemmler due fixed ruemmler overhead wilkes algorithm unix disk case access single parity patterns calculation winter raidis usenix fastest proceedings table shows january measured calculation rates scsi small operations note computer system rdp reconstruction rate interfaceansi close draft rdp revision construction rate difference march timings due primarily completion step reconstruction requires series operations byte rdp blocks step required number blocks stripe block computations rdp construction reconstruction basically implementation reconstruction completion step accounted overhead operation determined time hypothetical calculation stripe data blocks overhead rdp reconstruction significantly higher due completion step cases table construction seltzer reconstruction rates seltzer close bostic obtained mckusick staelin implementation raidcon- log-structured number file system disks raidconstruction unix diamondmath winter diamondmath usenix diamondmath proceedings january diamondmath diamondmath diamondmath diamondmath diamondmath rdp construction rdp ston stonebraker reconstruction design figure xortest postgres storage system raidand rdp large performance database conference september checksum computations soft updates block implementation details disk appendix struction raidconstruction low-level reconstruction details identical computations soft updates implementation difference assumes rates information reflects section inability completely read overlap computation basic structure cache storing loads dependency information stores sets main memory previous pointers theoretical memory internal bandwidth indexing processor purposes unique identifier achieving type percent rate types space stalling cache line additional loads type-specific saturating values processor calculation found instruction counts cache organizational line dependency structures consuming inodes processing general budget file blocks cache line pages checksum system cases aggwrite test filer aggregate write performance workload supplied array nfs clients separate performus number actual file disks system metadata raidconstruction diamondmath diamondmath diamondmath file diamondmath blocks diamondmath in-core diamondmath inode diamondmath structures diamondmath rdp re-used construction losing rdp corrupting dependency reconstruction figure information xortest raidand rdp directory performance block checksum inode computations accessed block check disk rate outstanding overhead dependency structure stored raidchecksum rdp hash cons table rdp make recons raidchecksum rdp undone cons rdp recons table xortest derived results algorithm config rate raidrdp rdp rdp table aggwrite results ing write operations tests performed fas dual ghz intel pentium processors filer runs entire data path network nfs protocol file system raid storage compared raidwith configurations rdp data disks case measured achievable write bandwidth table aggwrite results configuration column table presents number separate raid groups connected filer number data disks raid group number parity disks raid group wafl file system uniformly distributes writes data disks table cases rdp performance percent raidwith rdp increase size raid groups realizing increase data protection achieving comparable write performance rdp raid groups disks data parity achieve performance equivalent raidwith total number data parity disks improved data protection conclusions rdp optimally efficient double disk failure protection algorithm combination single whole-disk failure media failures troublesome disks large relative expected bit error rate utilizing rdp significantly reduce data loss due types double failures fact rdp optimal computational complexity proved valuable 
achieving performance close single parity raidimplementation simplicity flexibility rdp allowed implement existing raid framework interesting open problem algorithm extended cover concurrent failures acknowledgements authors loellyn cassell ratnesh gupta sharad gupta sanjay kumar kip macy steve rogridues divyesh shah manpreet singh steve strange rajesh sundaram tom theaker huan significant contributions project salem garcia-molina disk striping proceedings internation conference data engineering pgs feb patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod international conference management data pgs burkhard menon disk array storage system reliability proceedings international symposium fault-tolerant computing pgs qin xin miller schwarz long brandt litwin reliability mechanisms large storage systems ieee nasa boddard conference mass storage systems technologies san diego pgs apr blaum brady bruck menon evenodd efficient scheme tolerating double disk failures raid architectures proc annual international symposium computer architecture pgs macwilliams sloane theory error-corrrecting codes north-holland alvarez burkhard christian tolerating multiple failures raid architectures optimal storage uniform declustering proceedings annual symposium computer architecture pgs park efficient placement parity data tolerate disk updates reflected copy visible users dependency structure types serve purpose type-specific values identify owner pointer virtual file failures system disk vfs array structure systems inode ieee number transactions parallel logical block distributed number systems file nov inode muntz organizational lui structure performance heads analysis lists disk dependency arrays structures failure simply proceedings waiting metadata vldb written conference disk pgs support brisbane undo redo june portions anderson owner dykes block allocation riedel block interface fragment scsi direct ata indirect usenix allocated conference file file storage block technologies pointer san francisco written pgs stable storage march holland block gibson parity initialized deculstering continuous allocation operation redundant initializationdependency disk arrays proceedings introduction international time conference allocation architectural update support metadata programming normal languages fashion operating allocate systems pgs allocsafe dependency structure papoulis probability block random variables initialized stochastic memory processes allocated edition mcgraw-hill alloc dependency york 
structure allocdirect allocindirect metadata block pointer inode indirect block allocsafe-specific pointer companion alloc structure alloc-specific values exact location block pointer metadata structure pointer pointer null fragment extended size newly allocated block fragment extension pointer allocsafe structure state state dependency outstanding in-memory copy up-to-date true allocation dependencies point implementations direct indirect pointers differ describe support pointers located inode initialized block written disk allocdirect state modified allocsafe structure freed time inode written allocdirect structure freed inode written newly allocated block initialized allocation undone accomplished replacing block pointer case fragment extension reducing file length appropriately values changed buffer cache block modifyingthe in-core inode structure redo operations in-core structure holding inode pending allocdirect dependencies re-used file inode number uniquely identifies inode file system simple fast management policy dependency structures needed allocate page kernel memory break list structures freeing structure consists adding compute comm sync barrier switch idle slowdown list allocation simply takes structure compute comm list sync news file switch system copies inode idle contents buffer cached in-core slowdown internal inode structure accessing inode structure manipulated file system separate source block disk writes system inode brought in-core compute values comm replace sync transpose switch inode marked dirty idle happen seconds inode dependency slowdown structure added workitem queue service function consists simply bringing inode in-core pointers indirect blocks implement things differently indirect block block pointers making inefficient traverse list per-pointer structures undo redo updates associate 
indirdep dependency structure indirect block pending allocation dependencies block memory equal size indirect block allocated structure initialized copy safe contents writing indirect block disk safe block source newly allocated disk block initialized allocsafe structure freed allocindirect structure update safe copy freed remaining dependencies indirect block written indirdep structure safe block freed indirect blocks generally represent small fraction cache contents force stay resident dirty pending dependencies avoid compute additional undo comm redo sync embellishments barrier block switch de-allocation idle de-allocated block re-used slowdown previous pointer permanently reset achieve freeing block setting bits free map reset block pointer reaches stable storage compute block comm de-allocation sync required news switch block pointer idle values freeblocks dependency structure slowdown size fragment outstanding alloc allocsafe dependencies de-allocated blocks freed point longer serve purpose block pointers reset compute comm inode sync indirect transpose block switch idle slowdown release blocks modified metadata written disk freeblocks structure added workitem queue special case extending fragment moving data block de-allocating original fragment inode appropriately modified allocdirect dependency clears blocks freed syncer daemon code paths original file system dependency structures owned blocks considered complete point handled applies directory blocks link addition link added directory block written disk pointed-to inode possibly reached stable storage link count incremented undo redo approach allocation initialization provide protection in-memory copies directory block inode modified normal fashion addition addsafe dependency structure allocated inode add structure allocated directory block addsafe-specific pointer add structure add-specific values offset directory entry block pointed-to inode number pointer addsafe structure state state serves purposes allocation initialization inode written addsafe structure freed state modified appropriately directory block accessed add structure freed directory block written inode reaches stable storage link addition undone replacing inode number directory entry indicating entry unused directory block write completes correct inode number replaces directory block contents out-of-date inhibit accesses reads writes disk write mark directory block dirty immediately disk write completes system re-use cache block page directory block accessed make directory entries up-to-date accessed seconds dependency structure added workitem queue service function simply accesses directory block marks dirty link removal link removed link count inode decremented modified directory block reaches disk provide protection deferred approach block de-allocation directory entry removed normal fashion directory entry pending link addition dependency add addsafe structures removed link removal proceeds unhindered add remove serviced disk writes remove dependency structure allocated directory block remove-specific values inode number pointer vfs structure allowing previously pointed-to inode identified directory block written disk remove structure added workitem queue service function consists decrementing link count link count inode freed normal code paths blocks de-allocated link count identifies number directory entries pointing inode 
barrier imbalance imbalanceimbalance latency latency high low medium context-switch computation granularity low low high coarsefine highlowhighlowhighlow high news imbalance imbalanceimbalance latency latency high low medium context-switch computation granularity low low high coarsefine highlowhighlowhighlow high transpose imbalance imbalanceimbalance latency latency high low medium context-switch computation granularity low low high coarsefine highlowhighlowhighlow high ps-adobecreator dvipsk copyright radical eye software title mimdraid dvi pages pageorder ascend boundingbox documentfonts cmr cmti cmbx cmsy cmr cmsy cmr cmsy cmr cmmi cmbx cmti cmmi cmr cmmi cmti cmex cmsy cmmi cmmi cmcsc documentpapersizes letter endcomments dvipscommandline dvips mimdraid mimdraid dvi dvipsparameters dpi compressed comments removed dvipssource tex output beginprocset texc pro texdict dict texdict begin bind exch translate isls false vsize mul hsize mul landplus false rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix dup dup round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding end dup foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop dup definefont setfont ch-width ch-data dup length ch-height ch-data dup length ch-xoff ch-data dup length ch-yoff ch-data dup length ch-dx ch-data dup length ch-image ch-data dup type stringtype ctr ctr ctr add charbuilder save roll dup base index bitmaps ch-data pop ctr ch-dx ch-xoff ch-yoff ch-height ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true ch-xoff ch-yoff ch-image ch-width add idiv string ifelse imagemask restore add dup mod idiv exec loop adv add chg index getinterval putinterval dup add adv exit lsh copy dup pop dup pop dup dup add ifelse ifelse put adv rsh copy dup pop dup pop dup idiv ifelse ifelse put adv clr index string putinterval adv set fillstr index getinterval putinterval adv fillstr string copy put pop adv chg adv chg add chg add chg adv lsh adv lsh adv rsh adv rsh add adv add set add clr adv chg adv chg pop dup bind pop forall dup type stringtype base ctr put bitmaps ctr dup dup length dup index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix dup dup mul exch dup mul add ifelse load pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag array string dup index put cvn put div vsize div hsize show rmat bdot string rulex ruley ruley rulex statusdict begin product pop product dup length getinterval dup display exch getinterval pop false ifelse false ifelse end gsave scale rulex ruley false rmat bdot imagemask grestore gsave rulex ruley scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rulex rlineto ruley neg rlineto rulex neg rlineto fill grestore moveto delta tail dup delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginfont cmr ps-adobefontcmr creationdate feb copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmr readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmr painttype fonttype fontmatrix readonly encoding array index exch notdef put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup dieresis put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup exclam put dup quotedblright put dup numbersign put dup dollar put dup percent put dup ampersand put dup quoteright put dup parenleft put dup parenright put dup asterisk put dup put dup comma put dup hyphen put dup period put dup slash put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup colon put dup semicolon put dup exclamdown put dup equal put dup questiondown put dup question put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup bracketleft put dup quotedblleft put dup bracketright put dup circumflex put dup dotaccent put dup quoteleft put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup endash put dup emdash put dup hungarumlaut put dup tilde put dup dieresis put dup suppress put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec cac daf bab edf bcfbe cda dab fcf fce ffafc bcbbb cdacfbcc ada aff beb fdc eccd ecb afd ddac afa eaefb bfaf fee daa cdf baff ccc cfe bbf fedd acabcdfbcfa eac aef dafe dfaf fdf ecc bdd abfaf ccb dafe aabcabd bee baa dfa cfea afbb dcfaa bec ced eadf ced eaebef bbfc ecdc aee cfb ebde abf ebdd edd baa aba cbf dcf cfec cbb bca 
fce fce bcb bab bec bfbc afaad ecfe fbcbd ecebcb abd ebc eabf fdf cbdad bbdcad defecad fbf dde daaabd adb dfb dfd deddc bdc edc daffe dccd bbb eca dcfae fdddda eadf deedb efdd daa daf ebe ffbea baa fde bedc aefeda cbeac ddbabba edf acd dcc ffb fcee daaadfdaf fea bda fbee ffd fcfa edb dfb eeddc bdd cfd daefed aae eec ddac aad eea ddae badc bae dea dfd faf aafd efd cab dac fcfd bffe aeea dfdebed bcb feb acced becf cbc adea acc fceddc bfb cdf ffc cbbafb bdd dcbd fab ded bffca dfc cfc 
aebf ffe efe cee ede cdb afcfa dbf bcc bda afa cba bfdba bda dde cada ffcd bead ded bbf bfd ffb afeec fffa fce fef cda befcfea ebe dbe caf bbef ace efd eecc dfba adff cdba cac bff fea dfa ddd ccfdc ecb eeb edfd edbd bdfb bcc bcddb ceeb bcc dedb fea bdb cddbe aea bdf ced bda fbd acbeed edc dfa bacefd cdc bdaee aec afab bed bffff bacf daab aeaf ddaf fcafa bfa bde aeb fcea ade acacf bef bab bcda dec bad effef beb ebd ccb bfd eab bcceb dbe cdae ced dac bdc baca feea ddbca efcab dcff bdd efe ddb ffa eddab cea faf bcb bec aeeb dfe fadbf bcacb ebc eaf cbfa bbf aaea eec bac cae afb dcac cec cfd eef edab bba ecc debf ddd abe dcf dfbd aba aedbdb afd aed aecde eef bcd dac eff cae eace eee fed dcaaae cdca eef eaa fcd aee edc aebc fccbabd acc fad eff efaaa dacbe edde adb eda ece fdbf ffecde bde cae cbfa aca ddfab cbf adc cfe efc bdb baf fccff cff fce ead bfc bfa daec cba cce ecb abd caf dcad cbb ddb bae cadf ecb eaf ceb bcdcb cdfd cdb bbf dcd adfeb bfea dfb cfb ceab afbea aee dbafdd aeb edd dbf bdadbc ccae afffaeaf cef ddb ceb afaa baa bfc bde acda aef bfe dfd bef ada dbfd cad bde eba bffb afe ccfaaca addc bea beb cac bfca ebc caa ebb dcb ffd abd eca baba fad acdabfdf eee ace cea bfcb ccc cdea fec dac dcef eaef badc dac cca bedb cad abdf feaab dca ffe dfc fad afd fae abe bdbee fbf acac cfa edb fcde bce bcfaea dcbc abc cfe aea fac eee daeca eeaae dbc acf fbd aedcf bec eccc cceb eedf acdef eace fcbb deda bca abb edb ecde dee dcf cade bcf ffd aab bac bfbb ebc cdafe afbf eaede bdfa fff cdeca ade cfdeff bac bcba cdca fba aea acd bbab dfc ecca ead bbf dda ebb bac fbaace ede baf eabf fbbe fab bfd cac dbcb baa ebf aae cda bea ece cba fed aedbfb dba edf cca ebd bcd caa acc abb ebe dda abbc aae aaf aaea cec bee fea ded ecc eaedd eba eae acbe cffcf cae ffb aaca dee dca fafb feceb cabdaf bbfaf afbd dec caa ffd fab fce cbc bed fed edbdcf abd dbebefa daea bcff fbbc effa ceb badef fcbba cafdf cca dfba ccd ecadd cee eaa fdbcd bdcd ddb dff fbfe abdf cfa ebfb bdf fad fabaf fbcde ade eaab cebdc fefe feb bea abddf decb aef aaff daebcf bfb dff cafd cff fbdc cccd acc edbd dba fcad fef abd bccda cdb bcf ded dddbcc aab fbf cbc eed bdc accdc fcd dfeaef efb eab faccaaf bcd eaae feb ecc efd cee fed edd efa ded fed eaae bcb fae dffc beac bce fbc ecac fac fbf cdb fdb dceb bbcc eea bfeae dde cea fca fcf ecbb ebb feabb edaa fcf ebf dbac ffbefce acc bcc efa eccf cacb bded bfda cdfc ffe bcc faf cfcff cfda fedc edac caa cac dfbd adca bbeaad fef fbc cdc dbe eadee cdcf bde ebaa ebc ebccbd dcd cdf aff deae beaaee affded fbd cda bfca dcdd adb dfed fae cfa bae bbdc bcee ddeeaf ddf aec ccce acbd bee eed ebc dce cfb ece ade efb cae adbc ebe bdd ccfc faa ddbd ada dee ccaab bea eba cdd bea cde ece eebfacbe ddd bbeab fff aaf efdcb bcfefefc fcceaf edd defe ddcc dae fdda accb deb fbc dfe cdf eed eacf aefce aee afdcc aaa daf aed cab aef dde ecdfd bdebbbfa ffb aceb acbd ebd aaa dbfa ecaf cabcb aefa cbf bca dcc cbeb ecea eac dbf ffe fba aac debd fdc eea ebc aae ffd aeaff fcb bff dfb fcb dcb cfa aab abec dcb aea adadfaa afd aebbc dae bff bed aef ffeea dcf dbcfcbb ead daad bccddc fbdf dccd cee cdd dde bce dca dcf fed caa dcb cdd fdac cbe eadb fed ffd edf aaaa edbad cdf bdaa acf faf dbc dda aefcf fba cbb eae bdd cafc aac ceab bccfe adb fca ccd eeda aaf effe acb ecc ddbd afa cdec fef eafcfc adaea cce aff cfa cdf eeaeef fbbfa fcbd bdd bcd ead fee acc cec ffcdd fdeacca cfc cee cfe dfeee fbd bbcba bbf bed cbafa fec afb cdcbece cfc aee cafa dbbd fef afdfbd cbeee bfb abc eaa faa aec bfb bbe acc edbf fed bbf dfd ddbaa edd abadec aafba ffb aab cda fbd ddfb fdf dec dbef fdc bcc acf fcd eaf bcef fed dcbe fbf fdf adeedfff fba bbe cad ddb bdfb feab daa eaca acb adb dbae efbc cae cfcbf acfebb bdd ecd beafe eec aac ecd cdabc fbe abd ecbf eed dab cdea bac dae abf dbbea ede cfa dcb ccde bbc cde bbbed cdf afe adefddb fbef eaebd cfb aebcd fdf fecd ecf acb bcb aebf afe caef cac dccfe aef eafdcb aad fdb acefeed bdd eaf fcaca bcbd cba faae dbec fabb acc dfd bfae abf ebf abcbee ebc afce dea ebe fca dee dcd dec adfb eaf dbf bad ada bbae efd bed aff aae dfdf ccdfc cdb adef cae adf bfff aeed efb aae fdff dcefe afdd bfe fda cffb adf fbfba aff becbe bdac cbb 
dffbc edcf bca ebabd dbdb fcd efebcf bead eaf daa fef dab cae cdf cbf dfd deb cadde aaf aeca edf ddc ffd bff adf afcd cde fbc fbb ffe bdd fcbb ebe fab aac aaee cbc aabde edb aeada abe fbadc eba cea bdac edf cdbb dbc edb dfcf fee efd dbdca ffdef dee fecfa aae fdcd abcbd cfbe ceba efb aef ccf fab cedac debc caf effa bca cdd fafa afea cde fcef eea ddd aefac bdab eccc dbae fcd cfe adc bed ece afc beda bdc aac bab fffa cef fac eef cfc cdf dcdecb dbf fbb efd efbcd dfef ccc cac fdfea dfef bdf adef dbda cba edfe ffe fcbf cee fbecd abe bac bac adb ffc fcddb feb dde feca aafdc addf eabf dce cbecc fdea cec fbdc adb edaad bcaf fcf cacdf efc bec dfc dadcf eff caef feea abeb ebf fdcfe bcc dbfb dcfd adcbeabe dbb cfc acac cbc aafd acde aaf fedc dcb aafdf adeddc bebbc efeafe cdfed ceba ddb cbd fdb faf fdc dcb cbd eecccc bda cee eea ebfa aece cadbc eaefdd abbf fad dba dafc fcec cbd dba ffc faf ecac baa dfd dcd edda acad beb ecdb fda cdf add aad eee fdd fbeae fcf bcaaef ebb cfe eeebc cdfd eda fcfb fcadad fed add daf cce eeeeb bfaf dcb cdfa aaa bcaca bda ffde fec fcc beec efb cfc abdaa aaaeaefb dae ffa afdacd eac efa cbf ebf dec aade dcbc fca cdc fef cbc efbb ccf cac debff bab ffd cef cdf bdb cdf eba fbe fada ebe ade ffa dbe cdec cad dbe bee bff eac bac eab dadadf cdc cfb cdbc bfdca eed beb edf cfdf cafd dcb ecb bfdc ccd bab afc aacc dcf efa bfc afa bef abfe fddbad abf ead cbea bfa ebce acd aaaa cfd bce dfdadcba fab ecd bfea fdcd faf abcddf cfef ceaf fdcae edbb efc ddcd fce fea bac dde bbe aca ffbe cfd bdceb dfaff cac ffd deae dfc bacef cbca eccb cfeb dfc befd decbe fed dcb bbd dec cdee ecb eab bfada dfb eda acb eec efb feb cfe dfd afdd bcdf bec feef bce ccca dea fdd abc eac cff adce cef ace fcf cbd fed dcd dab baf cfd baa ede adf bfc ffa aca bee dafd cefeb add eda cee dde fef ebe afe bef ede bfc ede bed ddb fcfad bba aaa fcc bce bbefdd cac cff aeb ebe bdb fced cfe eca fdba ffe bcfb baa ddf bbfd ffa fffaee dad cae ecb bbb bda ace dbdefbbc bea eee cfa aba eae bcd bdb dfdf dac fbd bfd bad eea aae fbf eba dff aac dac bbdc acbe fdddce defadd bff cfb ebc beb eba dbccc dbb fee befbe eaa eba daa beee efd fef fde bcbfe cdf fbc eef bce afa ecd bcd aaa cebe bded ddb cleartomark endfont beginfont cmti ps-adobefontcmti creationdate feb copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmti readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmti painttype fonttype fontmatrix readonly encoding array index exch notdef put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup dieresis put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup exclam put dup quotedblright put dup numbersign put dup sterling put dup percent put dup ampersand put dup quoteright put dup parenleft put dup parenright put dup asterisk put dup put dup comma put dup hyphen put dup period put dup slash put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup colon put dup semicolon put dup exclamdown put dup equal put dup questiondown put dup question put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup bracketleft put dup quotedblleft put dup bracketright put dup circumflex put dup dotaccent put dup quoteleft put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup endash put dup emdash put dup hungarumlaut put dup tilde put dup dieresis put dup suppress put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec fba cdfdddf bfbbfcb fdc add fbd efe fceb ffda dacfdcd bdd abefd cdab cfc cef afda bce dcd eecc bbebeef fbf fbf ccc bcb aaa ecbbcdcde eee ddf cdd ebd eaffe ceb fca cec dfa efd eab cbed edcd acf badb cbfe ead dddbaa ecccaebdb aeb edb 
deb ddd bfec bfc ffd ddba eefb acb cedb eab eaae cdeb bed dcd eda ecedc caecaf dbc dec bac abdfaaee bad fbcfb dbe fbf bbcf fbfa fdb dfae aedae dea acb feb aded fcc dfbf dde cbaa defae dacfca bdedf ace ceec fefd cca aea aafb aedc acdbabab acaacc cafe bfba aad efca cadabb afb bcc aaf bad eabd bbe dabe aadd fcd dccd cda bfca cbe eab fdee fac cdf ccf bba bcf afe bef aac bed fef aff ecd abba adf cbdf ebbe ddc efa ced eaa ecdd dcb ccdf cbd ffe aca afa fdd cce cbba abcb abbb fed adb cfaea faebd bbd baa dab ecb febe ddb edf dfad cefaf adeafdaba ada bada bcac aed fab ecfa dbc cec feaa caf decea ecaee bca bcd ebbbc bef bde bdc cde cea eeae cdcf bea ffeec cfd dabdf ffbc acf afca eba cee bdc fbc dba dfe cbd ddef ccc aecfa deac eaf efd cdbfd adbf ccf bfe cbf aec caad dda dcea ebe aec cfc bfb facc dee eab bab efffc ecf eed acd caa cef bea ade fcf bdd efd cfada dbe bdab aeb ccdcd dcdb fabab cfe cce dabda bbc fbd cec cffc abb eca fbb aee ccfd fbe cbad acc dbf dab bda fbc dffd bff aee dddbdd acbd aacc edcf fae afe afab fdb ffdd abb bfae fdf dff fda bdfc acc dbe eeef aeeac dfab cee dbcea adace cdb cbccb eceba deb ceb aeee ebc dda edc dfc eaddfebc dab ffa efdced bed fafb defcdf afb adca deb bfaf aeda fefe eab bbb abb bcb fda accad fad baa aca ffa aec ecfaebc cac fedee eda abf ffa acce daacd eefebcfb bcfb bcfbee cdfc cfb baf eac cad cda dde ffd bdffa bee dcbaebead fba ffc ced dbfc cbca bae fae dbdad abe fbcb cfd eaea edd dbf ebe dca dbf eaf bcf ece dff daa acadcfe ddaaf cfd fba fcfb bcd dfdd ace cbeb cba dbf eccdefc ece fcf daba ebf bfe bffccb aba dede edb eee ccb fcf fec ebe bbbd bfd ffac ccc bcbb dee fce ebb cdead ebf efe fec ddc fceef eec ddd ceb cbc faa efe eda cdaa cab cae cbc eae cab fcd eab bbbca cad fcb aedc cdcfdf ead bfa cdc bae dbc daa fcd ecdb eff adca edbaa bcfadfd bfbe cfb ecb faf bebdf dcc eadca aecf defc eca dfaadc cdcccc bce aec fbae ccbdecdb cbd acc daf ffaf efee bab bfec dafdafeeb fec bfda edb eed fcb eadb ceba fcdbb acbad deeec cab ceb dbe ecbd cef aaa aff abdb aea dfd cfc ceb cfa ddd fcc deddf bdf bec ddde cbfa baaba dfa afc bdac cdd fcb aff ccbb bed dbbdf dbd bfb afd ffd ddb bba dbe cdcdcf ecaca bfd cea bde beea cfb dbe dcb bfcbaf fbf dfc edde ebf bcd aaaf bbe ade faca eea cdf bdc bce dea ecbd bbe dfd bec fcfb bbdbd fbf baf cbf dddf cadebd fec fceadc cbe ecff eab dfb bcfc fea fcf cbba aae bdc dba faab eae bea fdd fbbfa ccf bcc fcb dca cdf dabc ddcff eab dbaf ddc cbd bef dcee cfacaf feffa ebc dfcbd cca cffc adccc fdd bebc bad ecf fefb eacc cee fdc efd dceeb bed ffc cee fedce fed ddacde cca bcd eccbc fefd abd ceeaf dfaab dfc fbaa cdaf aae bafcb efa fbc bef fdf eeb semantically-smart disk systems muthian sivathanu vijayan prabhakaran florentina popovici timothy denehy andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison abstract propose evaluate concept semantically-smart disk system sds opposed traditional smart disk sds detailed knowledge system disk system including information on-disk data structures system sds exploits knowledge transparently improve performance enhance functionality beneath standard block read write interface automatically acquire knowledge introduce tool eof discover le-system structure types systems show sds exploit knowledge on-line understand le-system behavior quantify space time overheads common sds showing excessive study issues surrounding sds construction designing implementing number prototypes case studies case study exploits knowledge aspect system implement powerful functionality beneath standard scsi interface surprising amount functionality embedded sds hinting future disk manufacturers compete enhanced functionality simply cost-per-byte performance introduction true knowledge confucius microprocessors memory chips smaller faster cheaper embedding processing memory peripheral devices increasingly attractive proposition placing processing power memory capacity smart disk system functionality migrated system disk raid providing number potential advantages traditional system computation takes place data improve performance reducing traf host processor disk disk system exploit low-level information typically le-system level including exact head position blockmapping information finally unmodi systems leverage optimizations enabling deployment broad range systems smart disk systems great promise realizing full potential proven dif cult causative reason shortfall narrow interface systems disks disk subsystem receives series block read write requests inherent meaning data structures system bitmaps tracking free space inodes data blocks directories indirect blocks exposed research efforts limited applying disk-system intelligence manner oblivious nature meaning system traf improving write performance writing blocks closest free space disk ful potential retain utility smart disk systems smarter interface storage remains system acquire knowledge system exploit understanding order enhance functionality increase performance storage system understands blocks constitute perform intelligent prefetching perle basis storage system blocks unused system utilize space additional copies blocks improved performance reliability storage system detailed knowledge system structures policies semantically-smart disk system sds understands meaning operations enacted important problem solved sds information discovery disk learn details system on-disk data structures straight-forward approach assume disk exact white-box knowledge system structures access relevant header les cases information unavailable cumbersome maintain paper explore gray-box approach attempting proceedings usenix conference file storage technologies fast san francisco california automatically obtain le-system speci knowledge storage system develop present ngerprinting tool eof automatically discovers le-system layout probes observations show eof smart disk system automatically discover layout class systems similar berkeley fast file system ffs show exploit layout information infer higher-level le-system behavior processes classi cation association operation inferencing refer ability categorize disk block data inode bitmaps superblock detect precise type data block directory indirect pointer associate data block inode relevant information identify higher-level operations creation deletion sds techniques implement desired functionality prototype smart disk system software infrastructure in-kernel driver interposes read write requests system disk prototype environment explore challenges adding functionality sds adhering existing interfaces running underneath stock system paper focus linux ext ext systems netbsd ffs understand performance characteristics sds study overheads involved ngerprinting classi cation association operation inferencing microbenchmarks quantify costs terms space time demonstrating common overheads excessive finally illustrate potential semantically-smart storage systems implemented number case studies sds framework aligning les track boundaries increase performance smallle operations information lesystem structures implement effective secondlevel caching schemes volatile non-volatile memory secure-deleting disk system ensures non-recoverability deleted les journaling storage system improve crash recovery time case studies demonstrate broad range functionality implemented semantically-smart disk system cases demonstrate sds tolerate imperfect information system key building robust semantically-smart disk systems rest paper organized section discuss related work discuss lesystem ngerprinting section classi cation association section operation inferencing section evaluate system section present case studies section conclude section related work related work smart disks grouped categories rst group assumes interface storage systems xed changed category sds belongs research group proposes storage interface requiring systems modi leverage interface finally group proposes interface programming model applications fixed interfaces focus paper integration smart disks traditional system environment environment system narrow scsi-like interface storage disk persistent store data structures early smart disk controller loge harnessed processing capabilities improve performance writing blocks current disk-head position wang log-based programmable disk extended approach number ways quick crash-recovery free-space compaction systems assume require knowledge system structures storage system interfaces developed provided local setting opportunities functionality network packet lter slice virtual service slice interpose nfs traf clients implement range optimizations preferential treatment small les interposing nfs traf stream simpler scsi-disk block stream contents nfs packets well-de ned high-end raid products perfect place semantic smartness typical enterprise storage system substantial processing capabilities memory capacity emc symmetrix server eighty mhz motorola microprocessors con gured memory high-end raid systems leverage resources perform bare minimum semanticallysmart behavior storage systems emc recognize oracle data block provide extra checksum assure block write comprised multiple sector writes reaches disk atomically paper explore acquisition exploitation detailed knowledge system behavior expressive interfaces primary factors limits addition functionality smart disk narrow interface systems storage surprising research investigates changing interface brie highlight projects mime investigates enhanced interface context intelligent raid controller speci cally mime adds primitives proceedings usenix conference file storage technologies fast san francisco california clients control updates storage visible traf streams commit order operations logical disks expand interface allowing system express grouping preferences lists systems simpli maintain information raid exposes per-disk information informed system lfs providing performance optimizations control redundancy improved manageability storage finally ganger suggests reevaluation interface needed outlines relevant case studies track-aligned extents explore paper freeblock scheduling recent work storage community suggests evolution storage place disks general-purpose network standard scsi bus suggested network disks export higher-level object-like interface moving responsibilities low-level storage management system drives speci challenges context xed object-based interface systems storage provide interesting avenue research utility semantic awareness programming environments contrast integration underneath traditional system work focused incorporating active storage parallel programming environments recent work active disks includes acharya riedel amiri research focuses partition applications host disk cpus minimize data transferred system busses inferring on-disk structures fingerprinting file system semantically smart disk implement interesting functionality interpret types blocks read written disk speci characteristics blocks sds practical information obtained robust manner require human 
involvement alternatives obtaining information rst approach directly embeds knowledge system sds onus understanding target system developer sds obvious drawbacks sds rmware updated system upgraded sds robust target system approach target system informs sds data structures run-time case responsibilities target system numerous disadvantages approach importantly target system changed system process access information directly communicate sds communication channel existing protocols added target system sds finally dif cult ensure speci cation communicated sds matches actual system implementation approach sds automatically infers system data structures bene approach speci knowledge target system required sds developed assumptions made sds target system checked deployed additional work required con gure sds installed sds deployed environments difculty approach potential semantically-smart storage system explore sds automatically acquire layout information ngerprinting software automatically inferring system structures bears similarity research efforts reverseengineering researchers shown bit-level machine instruction encodings semantic meaning assembly instructions deduced developed techniques identify parameters tcp protocol extract lowlevel characteristics disks determine buffer-cache policies understand behavior real-time cpu scheduler assumptions automatically inferring layout information arbitrary system challenging problem important rst step developed utility called eof extraction filesystems extract layout information ffs-like systems journaling capabilities veri eof identify data structures employed linux ext ext netbsd ffs eof understand future ffs-like system adheres assumptions layout data structures disk general disk blocks statically exclusively assigned categories data inodes bitmaps free allocated data blocks inodes summary information superblock group descriptors log data eof identi block addresses disk allocated category data blocks data block dynamically data directory listings pointers data blocks indirect block data blocks shared les eof identi structure directory data proceedings usenix conference file storage technologies fast san francisco california eof assumes record directory data block length record entry length entry inode number entry eld directory entry assumed multiple bits eof assumes indirect blocks -bit pointers inode blocks inode block inodes inode consumes n-th block eof assumes nition inode eld static time eof identi location absence elds inode size blocks number data blocks allocated inode ctime time inode changed mtime time data changed dtime deletion time links number links inode generation number data pointers number combination direct pointers single double triple indirect pointers dir bits bits change directory inodes exception dir bits elds identify default assumed multiple bits multiple elds identi bits blocks links elds size eld assumed largest multiple bits lead overlapping elds bitmap blocks bitmaps data inodes share single block separate blocks bits data inode bitmap blocks one-to-one linear mapping data blocks inodes bitmap block valid log data log data journaling system managed circular contiguous buffer make assumptions contents log future feasibility inferring on-disk data structures depends assumption production systems change slowly time assumption hold system developers strong motivation on-disk structures legacy systems continue operate examining systems past present corroborates belief on-disk structure ffs system changed years linux ext system layout conception ext journaling system backward compatible ext extensions freebsd ffs designed avoid on-disk algorithm overview eof software system made sds partition eof run partition sds understands context deployed basic structure eof user-level probe process performs operations system generating controlled traf streams disk sds high-level operations performed disk traf result observing blocks written bytes blocks change sds infers blocks type system data structures offsets block type eld sds knowledge con gure simultaneously verifying target system behaves expected sds correlate traf observes system operations performed probe process correlation requires pieces functionality probe process ensure blocks operation ushed system cache written sds ensure probe process unmounts system unmounting re-mounting sparingly increases running time eof probe process occasionally inform sds speci operation ended probe process communicates sds writing distinct pattern fencepost sds pattern resulting traf message probe process general techniques eof identify blocks inode elds identify data blocks sds pattern probe process writes test les classify blocks elds sds attempts isolate unique unclassied block written operation set operations operations algorithm phases eof composed phases eof isolates summary blocks log eof identi data blocks data bitmaps eof inodes inode bitmaps blocks classi eof isolates inode elds finally eof identi elds directory entries bootstrapping phase goal bootstrapping isolate blocks frequently written phases tered blocks interest phase isolates summary blocks log inode data blocks fencepost test directory test les probe process creates fencepost number test les test directory sds identies data blocks searching patterns eof identi blocks belonging log exists step probe process synchronously appends data pattern proceedings usenix conference file storage technologies fast san francisco california test les sds observes blocks meta-data blocks written circular pattern belong log block traf matches pattern eof infers system perform journaling eof identi summary blocks probe process unmounts system written blocks classi log data identi summary blocks isolate inode blocks repeatedly written probe process performs chmod fencepost test directory test les case inode written allowing classied data blocks belonging test directory identi changing test blocks previously unidenti blocks written finally determine separate bitmap blocks data inode blocks linux ext ext single bitmap block shared netbsd ffs eof creates sds observes unclassi blocks determine bitmap blocks shared separate data inodes simplify presentation remainder discussion case data inode bitmaps separate blocks eof correctly handles shared case case eof isolates speci bits shared bitmap block devoted inode data block state data data-bitmap blocks phase eof continues identifying blocks disk data data bitmaps isolate blocks probe process appends blocks data pattern test les blocks match pattern classi assumed data-bitmap blocks indirect-pointer blocks eof differentiates inferring blocks written les data-bitmap blocks care create small les single lls bitmap block bitmap block special case smaller expected completely cleanup phase test les deleted inodes inode-bitmap blocks phase identifying inodes bitmaps requires creating les distinct steps required probe process creates les inodes inode bitmaps modi probe process performs chmod les inodes inode bitmaps written inodes inode bitmaps distinguished phase calculates size inode performed recording number times block identi inode dividing block size observed number inodes block inode fields phase point eof classi blocks disk belonging categories data structures phase identi elds inodes observing elds change operations brevity describe eof infers blocks links generation number elds rst inode elds eof identi size times requires steps probe process creates sds 
stores inode data compare inode data written steps probe process overwrites data inode elds change related time probe process appends small amount data data pointer added point size eld identi data changed step step fourth probe process performs operation change inode changing data adding link changing permissions sds isolate mtime changed step ctime changed finally deleted deletion-time eld observed eof identi location level data pointers inode probe process repeatedly appends sds observes bytes inode change changed previous step eof infers location indirect pointers observing additional data block written additional pointer updated inode improve performance write block probe process seeks progressively larger amount seek distance starts block increases size handled detected indirection level finally eof isolates inode bit elds designate directories probe process alternately creates les directories sds histograms directory inodes histogram eof records count times bit inode type determine directory elds eof isolates bits les directories vice versa bits values considered identify les versus directories soft link bits identi similar manner directory entries phase nal phase eof identi structure entries directory eof infers offsets entry length probe proproceedings usenix conference file storage technologies fast san francisco california cess creates sds searches directory data block eld designating length validation deleted step repeated numerous times lenames lengths eof nds location record length assumption length record remaining space directory data block length reduced record added probe process creates additional les sds simply records offsets change previous entries finally offset inode number found assumption directory entry step probe process creates empty directories sds isolates inode offset recording differences data blocks directories assertion assumptions major challenge automatic inferencing ensure sds correctly identi behavior target system robust system meeting assumptions eof mechanisms detect assumption fails case system identi non-supported sds operates correctly semantic knowledge blocks expected written speci step speci blocks observed eof detects violation veri violations identi appropriately eof run non-ffs systems msdos vfat reiserfs additional bene eof con gure sds system bugs identi running eof ext linux isolated bugs sds observed incomplete traf key steps problem tracked back ext bug data written seconds prior unmount ushed disk probe process noted error inodes allocated case ext incorrectly marks system dirty eof enables checks system easily obtained methods exploiting structural knowledge classi cation association key advantage sds ability identify utilize important properties block disk properties determined direct indirect classi cation association direct classi cation blocks easily identi location disk indirect classi cation blocks identi additional information identify directory data indirect blocks inode examined finally association data block inode connected cases sds requires functionality identify change occurred block functionality implemented block differencing infer data block allocated single-bit change data bitmap observed change detection potentially costly operations sds reasons compare current block version block sds fetch version block disk avoid overhead cache blocks employed comparison expensive location difference byte block compared byte block quantify costs section direct classi cation direct classi cation simplest cient form on-line block identi cation sds sds determines type block performing simple bounds check calculate set block ranges block falls ffs-like system superblock bitmaps inodes data blocks identi technique indirect classi cation indirect classi cation required type block vary dynamically simple direct classi cation precisely determine type block ffs-like systems indirect classi cation determine data block data directory data form indirect pointer block single double triple indirect block illustrate concepts focus directory data differentiated data steps identifying indirect blocks versus pure data similar identifying directory data basic challenge identifying data block belongs directory track inode points data check type directory perform tracking sds snoops inode traf disk directory inode observed data block numbers inserted hash table sds removes data blocks hash table observing blocks freed block differencing bitmaps sds identify block directory block presence table directory data discuss complications approach proceedings usenix conference file storage technologies fast san francisco california sds guarantee correctly identify blocks les directories speci cally data block present hash table sds infers data corresponds cases directory inode sds result hash table situation occur directory created blocks allocated existing directories system guarantee inode blocks written data blocks sds incorrectly classify newly written data blocks problem occur classifying data blocks read case system read inode block data block data block number sds inode rst correctly identify subsequent data blocks transient misclassi cation problem depends functionality provided sds instance sds simply caches directory blocks performance tolerate temporary inaccuracy sds requires accurate information correctness ways ensured rst option guarantee system writes inode blocks data blocks true default ffs soft updates linux ext mounted synchronous mode option buffer writes time classi cation made deferred classi cation occurs inode written disk data block freed inferred monitoring data bitmap traf sds perform excess work obliviously inserts data blocks hash table directory inode read written inode recently passed sds causing hash table updated optimize performance sds infer block added modi deleted time directory inode observed ensure blocks added deleted hash table process operation inferencing detail section identifying indirect blocks process identifying indirect blocks identical identifying directory data blocks case sds tracks indirect block pointers inodes read written maintaining hash table single double triple indirect block addresses sds determine data block indirect block association association connect data blocks inodes size creation date sds association achieved simple space-consuming approach similar indirect classi cation sds snoops inode traf inserts data pointers addressto-inode hash table concern table size accurate association table grows proportion number unique data blocks read written storage system system booted approximate information tolerated sds size table bounded detecting high-level behavior operation inferencing block classi cation association provide sds cient identifying special kinds blocks operation inferencing understand semantic meaning observed blocks outline sds identify system operations observing key challenge operation inferencing sds distinguish blocks valid version instance newly allocated directory block written compared contents block block contained arbitrary data identify versions sds simple insight metadata block written read contents block relevant detect situation sds maintains hash table meta-data block addresses read past meta-data block read added list block freed block bitmap reset removed list block allocated data freed reallocated directory block address present hash table sds contents illustrative purposes section 
examine sds infer create delete operations discussion speci ext similar techniques applied ffs-like systems file creates deletes steps identifying creates deletes rst actual detection create delete determining inode affected describe detection mechanisms logic determining inode rst detection mechanism involves inode block inode block written sds examines determine inode created deleted valid inode non-zero modi cation time proceedings usenix conference file storage technologies fast san francisco california deletion time modi cation time non-zero deletion time non-zero means inode newly made valid created similarly reverse change newly freed inode deleted indication change version number valid inode delete create occurred cases inode number calculated physical position inode disk on-disk inodes inode numbers detection mechanism involves inode bitmap block bit set inode bitmap created inode number represented bit position similarly newly reset bit deleted update directory block indication newly created deleted directory data block written sds examines block previous version directory entry dentry added inode number obtained dentry case removed dentry contents dentry inode number deleted newly created deleted choice mechanism combinations thereof depends functionality implemented sds sds identify deletion immediately creation inode number inode bitmap mechanism sds observe change bitmap operations grouped due delayed write system case modi cation times version numbers similarly newly created deleted directory block-based solution cient file system operations general technique inferring logical operations observing blocks versions detect system operations note cases conclusive inference speci logical operation sds observe correlated multiple meta-data blocks semantically-smart disk system infer renamed observes change directory block entry inode number stays note version number inode stay similarly distinguish creation hard link normal directory entry inode examined evaluation section answer important questions sds framework cost ngerprinting system time overheads classi cation association operation inferencing space overheads proceeding evaluation rst describe experimental environment platform prototype sds employ software-based infrastructure implementation inserts pseudo-device driver kernel interpose traf system disk similar software raid prototype appears systems device system mounted primary advantage prototype observes information traf stream actual sds system current infrastructure differs important ways true sds importantly prototype direct access low-level drive internals information made dif cult sds runs system host interference due competition resources initial case studies prime importance performance characteristics microprocessor memory system actual sds high-end storage arrays signi processing power processing capacity trickle lower-end storage systems experimented prototype sds linux linux netbsd operating systems underneath ext ext ffs systems experiments paper performed processor slow modern standards mhz pentium iii processor k-rpm ibm lzx k-rpm quantum atlas iii disk experiments employ fast system comprised ghz pentium k-rpm seagate cheetah disk gauge effects technology trends off-line layout discovery subsection show time run ngerprinting tool eof reasonable modern disks eof run system runtime eof determine common case performance sds runtime eof prohibitive disks larger potential solution parallelism proceedings usenix conference file storage technologies fast san francisco california time partition size costs fingerprinting eof phase phase slow system fast system figure costs fingerprinting gure presents time breakdown ngerprinting slow system ibm disk fast system running underneath linux ext x-axis vary size partition ngerprinted y-axis shows time phase time-consuming components eof parallelizable reduce run-time disk arrays figure presents graph time run eof single-disk partition size partition increased show performance results slow system ibm disk fast system graph shows phase determines locations data blocks data bitmaps phase determines locations inode blocks inode bitmaps dominate total cost ngerprinting time phases increases linearly size partition requiring approximately seconds slow system seconds fast system comparing performance systems conclude increases sequential disk performance directly improve eof ngerprinting time phases require small amount time partition size on-line time overheads classi cation association operation inferencing potentially costly operations sds subsection employ series microbenchmarks illustrate costs actions results experiments sds underneath linux ext presented table action microbenchmark cases rst case system mounted synchronously ensuring meta-data operations reach sds order allowing sds guarantee correct classi cation additional effort synchronous mounting linux ext similar traditional ffs handling meta-data updates case system mounted asynchronously case guarantee correct classi cation association sds perform operation inferencing microbenchmarks perform basic system operations including directory creates deletes report perle per-directory overhead action test experiments make number observations operations tend cost order tens microseconds directory operations require complete cost due per-block cost operation inferencing synchronous mode create workload takes roughly corresponds base cost create workload cost approximately block costs rise size increases sds incurs small per-block overhead compared actual disk writes number milliseconds complete cases overheads ext system run asynchronous mode lower run synchronous mode asynchronous mode numerous updates meta-data blocks batched costs block differencing amortized synchronous mode meta-data operation ected disk system incurring higher overhead sds observe synchronous mode classi cation expensive association expensive inferencing sds care employ actions needed implement desired functionality on-line space overheads sds require additional memory perform classi cation association operation inferencing speci cally hash tables required track mappings data blocks inodes caches needed implement cient block differencing quantify memory overheads variety workloads table presents number bytes hash table support classi cation association operation inferencing sizes maximum reached run workload netnews postmark modi andrew benchmark netnews postmark vary workload size caption table dominant memory overhead occurs sds performing block-inode association classi cation operation inferencing require table sizes proportional number unique meta-data blocks pass sds association requires information unique data block passes worst case entry required proceedings usenix conference file storage technologies fast san francisco california indirect block-inode operation classi cation association inferencing sync async sync async sync async create create delete delete mkdir rmdir table sds time overheads table breaks costs indirect classi cation block-inode association operation inferencing microbenchmarks row stress aspects action create benchmark creates les size delete benchmark similarly deletes les mkdir rmdir benchmarks create remove directories result presents average overhead operation extra time sds takes perform classi cation association inferencing experiments run slow system ibm lzx disk linux ext mounted synchronously sync asynchronously async data block disk memory disk space space costs tracking association information high prohibitive memory resources scarce sds choose tolerate imperfect information swap portions table disk addition hash tables needed perform classi cation association operation inferencing cache data blocks perform block differencing effectively recall differencing 
observe pointers allocated freed inode indirect block check time elds inode changed detect bitwise bitmap monitor directory data creations deletions performance system sensitive size cache cache small difference calculation rst fetch version block disk avoid extra size cache roughly proportional active meta-data working set postmark workload found sds cache approximately blocks hold working set cache smaller block differencing operations disk retrieve older copy block increasing run-time benchmark roughly case studies section describe case studies implementing functionality sds implement drive raid semantic knowledge case studies indirect block-inode operation classi cation association inferencing netnews netnews netnews postmark postmark postmark andrew table sds space overheads table presents space overheads structures performing classi cation association operation inferencing workloads netnews postmark modi andrew benchmark workloads netnews postmark run amounts input correspond roughly number transactions generates netnews implies transactions run number table represents maximum number bytes stored requisite hash table benchmark run hash entry bytes size experiment run slow system linux ext asynchronous mode ibm lzx disk built system proper implementing le-system functionality storage system advantages semantic intelligence storage-system manufacturers augment products broader range capabilities due space limitations fully describe case studies paper highlight functionality case study implements present performance evaluation conclude analyzing complexity implementing functionality sds performance evaluation included demonstrate interesting functionality implemented effectively sds leave detailed performance studies future work theme explore section usage approximate information scenarios sds wrong understanding system case studies track-aligned extents proposed schindler track-aligned extents traxtents improve disk access times placing medium-sized les tracks avoiding track-switch costs detailed level knowledge traxtents-enabled system requires underlying disk mapping logical block numbers physical tracks traxtents natural candidate implementation sds information readily obtained fundamental challenge implementing traxtents sds system adapting policies system system speci cally traxtent sds uence system allocation prefetching mid-sized les proceedings usenix conference file storage technologies fast san francisco california prefetching prefetching ext traxtent sds table track-aligned extents table shows bandwidth obtained reading les randomized order roughly size track case examine default track-aligned allocation varying track-sized prefetching enabled sds experiment run slow system running linux ext system mounted asynchronously quantum atlas iii disk allocated consecutive data blocks span track boundaries accesses track-sized units components interest traxtent sds implementation bitmap blocks rst read system sds marks bitmap block track allocated similar technique schindler wastes small portion disk fake allocation uences system allocate les span tracks system decides allocate tracks sds dynamically remaps blocks track-aligned locale similar block remapping loge smart disks major difference sds remaps blocks part mid-sized les benet track-alignment non-semantically aware disks make distinction traxtent sds performs additional prefetching ensure accesses smaller track linux ext ffs prefetches blocks initially read traxtent sds observes read rst block track-aligned requests remainder track places data blocks cache traxtent sds relies piece exact information correctness location bitmap blocks marks trick system track-aligned allocation information static obtained reliably eof performance cost runtime indirect classi cation data belonging medium-sized les occasionally incorrect remapping performance correctness table shows traxtent sds prefetching results roughly improvement bandwidth medium-sized les structural caching discuss semantic information caching sds simple lru management disk cache duplicate contents system cache wastes memory storage system waste onerous storage arrays due large amounts memory contrast sds structural undertpc-b tpc-b ffs lru sds file-aware caching sds table file-aware caching table shows time seconds takes execute tpc-b transactions experiments transactions rst run warm system large scan run series transactions timed table compares netbsd ffs standard disk sds lru-managed cache sds le-aware cache experiments run slow system ibm lzx disk standing system cache blocks intelligently avoid wasteful replication explore caching blocks volatile memory dram non-volatile memory nvram presents unique opportunities optimization rst examine simple optimization avoids worst-case lru behavior file-aware caching sds fac sds exploits knowledge size selectively cache blocks les small cache les accessed sequentially strategy avoids caching blocks large les scanned ush cache blocks implement le-aware caching fac sds identi cacheable blocks indirect classi cation association case hash table holds block addresses correspond les meet caching criteria previously sds misclassify blocks cases inode written disk data blocks fac sds small amount state active order detect sequential access patterns table shows performance fac sds database workload scenario run tpc-b transactions periodically intersperse large scans system emulating system running mixed interactive batch transactions large scan ushes contents traditional lru-managed cache degrades performance subsequent transactions le-aware cache cache blocks large scans keeping transactional tables sds memory improving performance examine sds semantic knowledge store important structures non-volatile memory explore possibilities rst exploit semantic knowledge store ext journal nvram implement journal caching sds sds sds recognize traf journal redirect nvram straightforward eof tool determines blocks belong journal classifying caching data reads proceedings usenix conference file storage technologies fast san francisco california create create sync ext lru sds lru sds journal caching sds table journal caching table shows time create -kb les ext sds sds performs lru nvram cache management cache journal caching sds storing journal nvram create benchmark performs single sync les created create sync benchmark performs sync creation inducing journaling-intensive workload experiments run slow system running linux utilizing ibm lzx disk writes journal sds implement desired functionality place meta-data bitmaps inodes indirect blocks directories netbsd ffs nvram inodes bitmaps identi location disk pointer blocks directory data blocks identi indirect classi cation occasionally miss blocks exploit fact approximate information adequate sds writes unclassi blocks disk nvram observes inode track meta-data blocks meta-data caching sds mdc sds additional map record in-core location tables show performance sds mdc sds cases simple nvram caching structures journal system meta-data effective reducing run times dramatically greatly reducing time write blocks stable storage lru-managed cache effective case cache large working set main bene structural caching nvram size cached structures sds guarantees effective cache utilization hybrid combine worlds storing important structures journal meta-data nvram managing rest cache space lru fashion future plan investigate ways semantic information improve storagesystem cache management sds types meta-data updates last-accessedtime updates inode order ascertain les system cache prefetching sds intelligent system awareness make guess block read finally blocks deleted removed cache freeing space live blocks create read delete postmark ffs lru sds lru sds 
mdc sds table meta-data caching left columns table show time seconds complete phase lfs microbenchmark experiment lfs benchmark creates reads deletes -kb les column shows total time seconds postmark benchmark run les transactions directories rows compare performance netbsd ffs slow system ibm disk sds sds performs lru nvram cache management cache mdc sds strategy secure deletion advanced magnetic force scanning tunneling microscopy stm person physical access drive lot time potentially extract sensitive data user deleted case study explore secure-deleting sds disk guarantees data deleted les unrecoverable previous approaches incorrectly functionality system over-writing deleted blocks multiple times patterns guarantee data removed disk copies data blocks exist due bad-block remapping storage system optimizations multiple consecutive le-system writes reach disk media due nvram buffering sds locale secure delete implemented ensure stray copies data exist over-writes performed disk nature case study approximate incorrect information blocks deleted acceptable secure-deleting sds recognizes deleted blocks operation inferencing overwrites blocks data patterns speci number times system reallocate blocks possibly write block fresh contents meantime sds tracks deleted blocks queues writes blocks overwrite nished note mount ext system synchronously secure deletion operate correctly investigating techniques relax requirement part future work table shows overhead incurred sds function number over-writes overwrites performed data recoverable noticeable price paid securedelete functionality loss acceptable highlysensitive applications requiring security performance improved delaying secureproceedings usenix conference file storage technologies fast san francisco california delete postmark ext secure-deleting sds secure-deleting sds secure-deleting sds table secure deletion table shows time seconds complete delete microbenchmark postmark benchmark secure-deleting sds delete benchmark deletes -kb les postmark benchmark performs transactions row secure-deleting sds shows performance number over-writes experiment place slow system running linux ext mounted synchronously ibm lzx disk overwrite disk idle performing immediately freeblock scheduling minimize performance impact journaling nal case study complex sds implements journaling underneath unsuspecting system view journaling sds extreme case helps understand amount information obtain disk level unlike case studies journaling sds requires great deal precise information system due space limitations present summary implementation fundamental dif culty implementing journaling sds arises fact disk transaction boundaries blurred instance system create system inode block parent directory block inode bitmap block updated part single logical create operation block writes grouped single transaction straight-forward fashion sds sees stream meta-data writes potentially interleaved logical system operations challenge lies identifying dependencies blocks handling updates atomic transactions result journaling sds maintains transactions coarser granularity journaling system basic approach buffer meta-data writes memory write disk in-memory state meta-data blocks constitute consistent metadata state logically equivalent performing incremental in-memory fsck current set dirty meta-data blocks writing disk check succeeds current set dirty meta-data blocks form consistent state treated single atomic transaction ensuring on-disk meta-data contents remain previous consistent state fully updated consistent state bene coarse-grained transactions batching commits performance improved traditional journaling systems create read delete ext sync ext async ext ext sync journaling sds table journaling table shows time complete phase lfs microbenchmark seconds -kb les con gurations compared ext linux mounted synchronously mounted asynchronously journaling ext linux journaling sds synchronously mounted ext linux experiment place slow system ibm lzx disk guarantee bounded loss data crash journaling sds limits time elapse successive journal transaction commits journaling daemon wakes periodically con gurable interval takes copy-on-write snapshot dirty blocks cache dependency information point subsequent meta-data operations update copy cache introduce additional dependencies current epoch similar secure-deleting sds current journaling sds implementation assumes system mounted synchronously robust sds requires verify assumption holds turn journaling meta-data state written disk journaling sds consistent synchronous asynchronous mount problem imposed asynchronous mount sds miss operations reversed create delete lead dependencies resolved inde nite delays journal transaction commit process avoid problem journaling sds suspicious sequence meta-data blocks single change expected multiple inode bitmap bits change part single write turns journaling cases fall-back journaling sds monitors elapsed time commit dependencies prolong commit time threshold suspects asynchronous mount aborts evaluate correctness performance journaling sds check correctness crashed system numerous times ran fsck verify inconsistencies reported performance journaling sds summarized table sds requires system mounted synchronously performance similar asynchronous versions semantically-smart disk system delays writing meta-data disk read test sds similar performance base system ext delete test similar performance journalproceedings usenix conference file storage technologies fast san francisco california eof fingerprinting probe process sds sds infrastructure case studies initialization traxtents hash table cache file-aware cache direct classi cation journal cache indirect classi cation meta-data cache association secure delete operation inferencing journaling table code complexity number lines code required implement aspects sds presented sds component eof tool lines code roughly lines shared system types rest le-system speci ing system ext creation sds pays signi cost relative ext overhead block differencing hash table operations noticeable impact purpose case study demonstrate sds implement complex functionality small overhead acceptable complexity analysis brie explore complexity implementing software sds table shows number lines code components system case studies table complexity found eof tool basic cache hash tables operation inferencing code case studies trivial implement top base infrastructure traxtent sds journaling sds require thousand lines code conclude including type functionality sds pragmatic conclusions beware false knowledge dangerous ignorance george bernard shaw recent article wise drives gordon hughes associate director center magnetic recording research writes favor smarter drives stressing great potential improving storage system performance functionality believes interface systems storage required widespread drive input output command requirements interface speci cation short industry consensus task general interest offers market opportunities multiple computer drive companies hughes comments illustrate dif culty interfaces require wide-scale industry agreement eventually limits creativity inventions existing interface framework information system disk low-level knowledge drive internals sds sits ideal location implement powerful pieces functionality disk system implement enabling innovations existing interfaces storage system manufacturers embed optimizations previously relegated domain systems enabling vendors compete axes cost performance paper demonstrated underneath class ffs-like systems le-system information automatically gathered exploited implement functionality drives heretofore implemented system implemented shown costs reverse-engineering system structure behavior reasonable challenges remain including understanding generality robustness semantic inference broader range systems sophisticated systems wider range platforms probed reveal workings approximate information exploited implement interesting functionality techniques tools developed assure correct operation 
semantic technology answer questions research experimentation nal answer elicited acknowledgments members wind research group feedback ideas presented paper keith smith excellent shepherding anonymous reviewers thoughtful suggestions greatly improved content paper finally computer systems lab tireless assistance providing terri environment computer science research work sponsored nsf ccrccr- ccrngs- itran ibm faculty award wisconsin alumni research foundation timothy denehy sponsored ndseg fellowship department defense proceedings usenix conference file storage technologies fast san francisco california acharya uysal saltz active disks proceedings conference architectural support programming languages operating systems asplos viii san jose october amiri petrou ganger gibson dynamic function placement dataintensive cluster computing proceedings usenix annual technical conference pages june anderson chase vahdat interposed request routing scalable network storage transactions computer systems tocs february arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october baker asami deprit ousterhout seltzer non-volatile memory fast reliable file systems proceedings international conference architectural support programming languages operating systems pages boston massachusetts october acm sigarch sigops sigplan bauer priyantha secure data deletion linux file systems tenth usenix security symposium washington august brown yamaguchi oracle hardware assisted resilient data oracle technical bulletin note burnett bent arpaci-dusseau arpaci-dusseau exploiting gray-box knowledge buffer-cache contents proceedings usenix annual technical conference usenix pages monterey june chao english jacobson stepanov wilkes mime high performance parallel storage device strong recovery guarantees technical report hpl-csp- rev laboratories november collberg reverse interpretation mutation analysis automatic retargeting conference programming language design implementation pldi las vegas nevada june jonge kaashoek hsieh logical disk approach improving file systems proceedings acm symposium operating systems principles pages asheville december denehy arpaci-dusseau arpaci-dusseau bridging information gap storage protocol stacks proceedings usenix annual technical conference usenix pages monterey june dowse malone recent filesystem optimisations freebsd proceedings usenix annual technical conference freenix track monterey california june emc corporation symmetrix enterprise information storage systems http emc english stepanov loge selforganizing disk controller proceedings usenix winter technical conference pages san francisco january ganger blurring line oses storage devices technical report cmu-cs- carnegie mellon december gibson nagle amiri butler chang gobioff hardin riedel rochberg zelenka cost-effective high-bandwidth storage architecture proceedings conference architectural support programming languages operating systems asplos viii october gibson nagle amiri chang gobioff riedel rochberg zelenka filesystems network-attached secure disks technical report cmu-cs- carnegie mellon gray storage bricks arrived invited talk usenix conference file storage technologies fast gutmann secure deletion data magnetic solid-state memory sixth usenix security symposium san jose california july hagmann reimplementing cedar file system logging group commit proceedings acm symposium operating systems principles november proceedings usenix conference file storage technologies fast san francisco california hsieh engler back reverseengineering instruction encodings proceedings usenix annual technical conference usenix boston massachusetts june hughes wise drives ieee spectrum august katcher postmark file system benchmark technical report trnetwork appliance october king dirty lesystem bug ext https listman redhat pipermail ext users -april html march lumb schindler ganger freeblock scheduling disk firmware proceedings usenix conference file storage technologies fast monterey january mckusick joy lef fabry fast file system unix acm transactions computer systems august morton data corrupting bug ext http uwsg hypermail linux kernel html dec ousterhout aren operating systems faster fast hardware proceedings usenix summer technical conference anaheim june padhye floyd inferring tcp behavior sigcomm san deigo august regehr inferring scheduling behavior hourglass proceedings usenix annual technical conference freenix track monterey june riedel gibson faloutsos active storage large-scale data mining multimedia vldb york august rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon schindler grif lumb ganger track-aligned extents matching access patterns disk drive characteristics proceedings usenix conference file storage technologies fast monterey january seltzer ganger mckusick smith soules stein journaling versus soft updates asynchronous meta-data protection file systems proceedings usenix annual technical conference pages san diego june swartz brave toaster meets usenet lisa pages chicago illinois october talagala arpaci-dusseau patterson microbenchmark-based extraction local global disk characteristics technical report csd- california berkeley tweedie future directions ext filesystem proceedings usenix annual technical conference freenix track monterey california june wang anderson patterson virtual log-based file systems programmable disk proceedings symposium operating systems design implementation osdi orleans february wong wilkes cache making storage exclusive proceedings usenix annual technical conference usenix monterey june gum chen wang krishnamurthy anderson trading capacity performance disk array proceedings fourth symposium operating systems design implementation osdi san diego october zhou philbin multi-queue replacement algorithm level buffer caches proceedings usenix annual technical conference boston june 
fbaf dec fcc dfc eea cae abd fbd ead abac ffe daf ebabfb bfc dfca fcd bcf afd dbfe accf cbde bea aadcf bfd aacb daee ebf cdf cff fabef bfec faa cef adfc fef dccd edc eede ddf cfd ffc fda cbfe abee fca ada caf cec bbfda adb bea dadef baff ebb fed cbf bdbda cdf dfe bff dca abdd ebfadbe bcf bbe aeec baeadbd ece daae ceb ecc dcf bce cfea efb adc dca fab bbd fbb bfdabca afc cea bfc fcda fbbbac bacb dcc dcf cdd aba ecca fbc dffe bcb baad add fdb aeab fde bdf ded bfe dfe fdb aecbc ffe eeb bdc adce eac ebd dcd eda ecf deaaade ddb fdd dad cffcd eeda dafebf fbda bcccb aee eca bcb bbb abf dcb afd bcd fae bbcfd bfcfdad dea ecbddf eaa aea daf fce aef fdc eea edb dbca ccb daa fac dae dcdf fea cade facb abccc ccd dff dfeb ccda fbfd cab faa ccd faec ddcf abc bdce afd bdd ebcfb eae dbf eec baec bfb bdfb faa abf fde cdb fde cbb edf fdf dce dfe fbc cdc ebce aaa ccd ced fef aafbbf ccc bfae dbd dead feb cada cca babba eab cbe ddc bbbd cccce aca eecd cfc eddd eee cac bbe aad afd add ffe bcb afd cad aee bfcc dce aafd bea dda cbc abc efe beab bafc acbe ada bba efa baeb fcc cfa fbc efeba efbf dcdb dcdff cedc bdc dcf cbfc dcde ecbb fabee dae bdada dcca fee caa ccb cfb accecffdb bbc ddca fcac edf fbb efd bcb bdde fce aabd fcd dbce fcf ecbdc edc eca dfad eed abc cea bbf bde ffc aff ecddf edd bfbc dddb faf eafc faaf ddfbd cfc daa dac cdbb eba deed fbfa bce bbd bbe aca bae ebb acaf cef edbbfd fef cebf bbd ccfd bacc feb ddcdaf accf cbe cbcac eece bcf eea bcdb eec ffd fbe fae cfa dedf eda acf fdc cab bdcfff dfd eca afd ebb dde ecb bdac ced fbfb abe cecbba fbd ccaa efd dbc efa efdf eecc eea edafe bcef aeef cda fae caa fad bcece bdd cdede bae caf ccd baeeebe eebbfefcf efd bbb aad beca bed eec bdb eaab cdb fcd bff ebd ffae abf eeabd bbfd ecba fbc bbbb baf afa ccef dcd aea acdd deb dae fdaaf fcb bccbf ebcca acc adfa ced dfe beac ecb cecc bec fceb fca bdf fba eeeef fcbd cac dff acb cdce eaf acfa ecec bad cca cfcf abf fba abfd dca add dff aeec bdac daa dbd cba addbab bbc dcfd 
fbd ebb fbb dcb dcc accf ebd aebe faef dbe dab bea afbbe cbe cdf afb edcb bbf cbea ffdd fde acc aae dec cbb fde baaeaa adb afa bbbd cfca acc ddae cecb bfdeb ecf feb eedf aebf ebd cefed fbd cafad fcd ceeb ddaa abdbc bbe edba ffda cab ddea dbcf eadc fee ecfa faee ecd cab dda cdd ccca ccec cdd edcdc dea eca eeab dfa cda abdc fea abfa cae aef afd ebc fcf abdf bcb fbb fcbb cda aeea bda afed daaa bca aee aed fbe dfc bfa cfe fcd ddbad eee aac eae fdd fbe ceb aee aeaa aad bbce faa fccd daf bddb cda fda cfceebf fcb cadc dbc edbe cfe adb fbd fbf caed aacb cea bddcb eab afb dfe bac fcfcbf cfa bdd cdf bfeec cbbeedf bbd bcd bfbdb dfcb fbb fdc cee dea fdafcda cda ded edf acb daeefd dee fde baa dcdb dfbad cecda feeb cce aba aab cbfcb fbd dfb efa eecd dfecd accfef eabe dbe dded cdb edfe cae fbb aacdff ebf ccb cac bbf bdedaa eeffb fcb dce adbc fde dcb ada eca dfded fdcd cdb fbc aaa eda ddebdc adbbd ecde cbaa cdb ecd cde cfebea bed bcd bad bdf faa fdf fee eeb bfc aefb dee cbb bbfdce abec ead ade dbbbe afc bbd cfa afe dfe fbd ddcc bbe baae adbaa bfc cbb bfa eefd cbe acb fbd cda fea fff bfa abb eae aefe bda bcda cde bfc abb cde fbc eeea cdeea eae dbc eea ffa bdcc acb bad abb dcd bfa afbd adacf feb fff dff dbd eaeee bfa acec dfae bdaee cbec aae dbfa cfc afeedd aad fbcee fdde adf baa bacc bfee aab faca bec aaf addcf fae eeb cfe ebf bde cbc acef afcc eec ded bdaa ddb fff ecb cbd aaa eeddd efd fba bec ced cab bcb eccef bbfcdc efc efab fffc eaeab cbb cfe fdd addd ebb cfc cddb fee dea edc ced eecce fabb cbcd fdaaca fdf babb baade ebc bcb dcf ace ebc baeabc cec dbbe cff abbe ebf eecba fadba efe afe bece afc cadd fad debf bdfc cfcc aab bbe dfd ace eaf bad cddef dcf ddca fcb cbf ddaf efc cbf eae eee dcdf fed ecfd bbff aacb dcd afe acf acc eacd ffbc dbbdd bdee efcb ffd eaa edf fffa bec dfa ecc fdf ffc ffa edb bebd bff acd ccc fddcb ebb ead fba ccfe fce aed fad efc eff fbc caefc ced cafede ada eacce bace aaadbdb efffe dbb edfd fffd cfad bdb abb fddb bfd cac eff aaa cbc bffdeebd cbbf cbce bccc dbb deb ebab ffac ffb ced effe fbe aeffb bed dcf bdb abafc afff ebd efed cdc cbac dba fbd effcd fbb daee feaec bbe ecdeeed ccd dfe dbad fdd fdfb fbeb add edbd ffa ceba fbf edc eccd acbbbc eaa eaa aeadf cbbac fcffa dfeb fda aad bbd dbead bddfdb fcb fdb faa edaf dfcae dbb ddffd beef bbf dde abf fccead edc acf bae dba bada daac cbe acd cbfeb bbeda fbecb dbb aedb fecac fef bda fae acf aad aba cfed ffc cfd dca cabfd aafcc cdd ead eaaca afaf feddbb cecc facd dcb deda dff ecc bdff acc bebf eff dcbfdc acfd bcbe efed bbb bfd aaf cfa cea eecd efc edffcc deece aeeed ecf efdd adac faf eabb eaaff aae eef ddc cde bbcc dad caa ffe eed aedced aeed eac cdd eeb dbcc cbeca cecec baae bbc cadbc cbd fdfbc dff edb dcbeb cac dff aaa cbf fce bcc ffa bbeecb efc facb dfc aec fee bdfcd fbe fddd baf ebf ddb fee dcd becb aceb efeb dfa eba ceca cce fae dca edf cfaeb edc ebba fbeab caa cbb faf aff ebab cac fcdc bbee faef aeb ccd baf feb adca aedf dba caf ade ddc feaa ead aee cca ecc ddc fcdf bfc cac fef fda afc ebf faa aef afc bfb cabce fed cecf ffa cfd daa adf efa daedb fdd eaaa cfd cca fff bbdd cea afa cbb afe dae bbd aad dca afddfce bce eda bae fcf bca ebdcd dbe ebcb edaa dfa eda eef cad bee cdaf ebf dea bfd faa dcebe deac fbc dbd dfe ced afab eda aebcb bbf edf afed dab aba efaf fcba fded bdb cddefa dec afd dae cadcfaf bba edd ccc acbb bee bff bdb eab ddee aec dee bdbf cacbad bdb bed bac caeec ccd bacd fde eccca caff dae ddec bfc dbf dfe aeadd abb efca accefd eefe bfdc cafb dbcd ecc aeea ffc cleartomark endfont beginfont cmbx ps-adobefontcmbx creationdate feb copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmbx readonly familyname computer modern readonly weight bold readonly italicangle isfixedpitch false end readonly fontname cmbx painttype fonttype fontmatrix readonly encoding array index exch notdef put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup dieresis put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress 
put dup exclam put dup quotedblright put dup numbersign put dup dollar put dup percent put dup ampersand put dup quoteright put dup parenleft put dup parenright put dup asterisk put dup put dup comma put dup hyphen put dup period put dup slash put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup colon put dup semicolon put dup exclamdown put dup equal put dup questiondown put dup question put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup bracketleft put dup quotedblleft put dup bracketright put dup circumflex put dup dotaccent put dup quoteleft put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup endash put dup emdash put dup hungarumlaut put dup tilde put dup dieresis put dup suppress put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec cac daf bab edf bcfbe cda dab fcf fce ffafffbe adee beed efcf bbb acb daf ccfe fdb cab fedb aaac dfaae ffd ade cad bcedfca fcbdb dfb ffe bea fbdbec eebd cab dcec baee dabf beea beed dcb ffe dbc aff fbc aea aefb cde cad dfbab ace bdae aff ccef cff eed fdf eeaf aff bbeb abbf adce bfe bea ccb caecc cfd add fdf adaf fdaaa dfb adaf ccf ccb cff fac dbccaf bfc cbe cacfd aaa eafc fafd baa eadfc bcc faf acc dcd ebc dfc bef deec fbff acc bca dbdb cea efb deda bdaff fae cbc bbf ebd dbb daf afac bbf aab baae ecb efb cca abb ffe eceee babc ceaaebd acb afcf dae eda ead bca fecca bcffe abfbb dbdd feecd aab ceaca ebded fbc ead acc deada bafafd ceb bfd cabf dbee cfac bbb fdb fee dca eaa bbf eeb cccfa acf cbbd ecf beafef adc adafcbe cdbf aca ade edc fabe aaac ceae eadd bfb bbd ccad dfdd fadef fda aaa cdf ccda dcdcf fbaebedad ecd aaa fcca dfbf cbd cede eeaf caa bdc bde adcb cab cfb cfd fbee aff aba bce dca eddea aacb cdcb ecdb adb caba beab bdd bcd dac bfde bdf ccdf ccf ddfc dcf aca bed eeec aac ddf cbe efc bdbe cda fad aac cad ebc aac cca cba aef afe dcf ded ecb aea deec edc fbe dbe afdd edbbe aae efcb caffecf fcdd caa aeb fbdd bfa edae cabd bbc accf dfb ddba cdcbade ede eab afcf ebef defc dfe fba acf dbb ccef bdd fde dca eabb feb fde adcb cdae fce edc adef fbcb fff ddccd ead ccaaf dcea edc dfc fba dbff edd dcd dfe ebf dab fdc cfaebcd dac efdf deb debee cae bad dcd aebc ecd dfda fbf aff bdfbba cddda aec bda adaf dedf ede cccf fcc fafd cfd facec adb aeb efad efc acaddcace fdd ece aafa fcec dcfd dad fac dcdf aeb bcdeb bef ced bfa adec ade bebe bafb fcbfbe bdc edad ccf fab adfe bac bca baa afdea daff deb cac dbe adcbe dffdba dfd baca fee bdb eff cdbdd bdbd bea eff dfcd ceb ecf ebc cea cdf bda eeff feb afe dfb bfef deaa acc deba eba afd dbdef eceed eabebcf ecb eeb aab adee cba efb cfc eda bdf bac addfc bce deb cdb cfd ffcf eee abff aedd dcf ecac ace abeb aef ace dae bbcab cdc dabbee cfb dec bade cfb fec aab fdb dfc afef dbe bcd aba eef cce aaaad caecc fce ceae ceca bcad eda eec afe edf abfbfb fcc bad fba bbee abb eff cde afb faea fcb fefc adde ebed bcd dac eaadb fdfac cdabf abb aaca fcc eabdc cee eaaadf bfe eca ddf adcd aceaa eae afb cbbf ffd bfb dbc edcb bfa dda fef dff fadcec ded faa dfd fdc cbd daee dcee bbde abbb fcb add dbfa afa ebadb eae cef cef cebed edbd dda dffd cdc cbf eab bddbf bdd eff aef abab adeb cbe dcdd bce bde fab eec fdb aef dedc cda eaad feb dcc bad fbbcda daf fddf cbbb dbf aff dcde edfe bcac ddeda cfd aadd ebfcee dac dea afc eabfc efcf cff cebd cbbaa aae ace aff cda baa bafe dfe edd dbb eaf bdedb eed dbf cfdbb dba dfbe fcb bde aed cca decb fac bee eac ccbc cbc dfc ead fdd fbe cbe bdca fbdd aeb eaceee dde ffba afbd dec afae cbfc aafe ecb efa baadbcd feb afb acf fcf dba bed dba fcd ccd ecb ecfaed feb aac dad fbefdffb efce dbfc cfe ffef eac bdaa bfe dbb cba aec cceb aaa adf dbdb ddb abc ffa ffbbbfcfc abdd dbcdd afdc eea bbdd cbfc bce ccc daf effc dad ecc eef dccca acaf dadca cca fac bed dab bbb cbd acf cde dcb bddd dec adf adf eeffc baa ebdf cfd aab cee bdd cbb bdc eadfa eed fdac dabd efdc eed bdf bbdd ecd cbf abe fdf cceeebd aea eab bdc bffcc ecd ecd feeae aee faf cdd cdcaf aefdb ede edff aed ebd ace dfae ada fcc fffb ceae cfab aee cdd fae efdd cfd adf fcce ecbeab bbba effc eee bacfa ceb dde effe acf bcae bdaf ecf add cebb cefde feb fbf ddcb efdc bbb dafb aab fbf dffb fcb ceae baceea ede aeba eccfd faace faa aced beb dabfae cacd acfdf aff bef cade baf bbfe caff fec fff feac fdcd bff bcd edf ffd bda caaa edc edd dba bbb baf dfd abb faf ffa fcca 
aefbb cbab bed acf cfb bfb eeb aadb eac aca feb daff baf abee fcb ecb aadadd ebb ebcaa fca fdc dacd ffa cacecb ccc abde baeeb fec ffa daa abfcc beeaac eac bca ede ebe ebb fed bcc cfa afb aff cef bfa fca eaad bbab bea fec acfdba bed fcc bda dcaeb ebca bbad dea dee facfa fff cef deb ffa eef aaa caf eda aade cdc ffd adaa dcf dcac bee ffc ebcc ffb ddc acb bca ffa fff ebbc abae bbf faa acccb ccb bdcc accddcbd acb edace faf fcddeca dcf dbe cad bcae dbaab bcaaed dcfa dedec ffbc ebf dce cca fabbe fbe defacce ebb dec fef abe aef cde eafd fcbf deff aeb fbe bfc dad accb aae cea ffca bda fdb eca ddddd ada ffc affe fcf cfe cec eda caec becd dafb ada fff bdde fea bba ceb cff bebf aab eee abe afb dcc dca eca caebf afea cca aec eac ddf fdf ebe abce fbdd feb dae bbe fdb ccd dcf aec cabd bcbcb eeb bdc fad bcfcd fce dcfa ccf ddd cfb bfbb adfdf dda ebc dcf fbcd eebc ccc dfabe caf bdbdb adfd ecc afffd fabb cdb aea bffbef bfd dcc fde ddfb daedb eaf ababa cce bda fff bade cee bbcc eaf eedb ffc cce fda cfe deaaee fdc ceeea deb ecda aee ced fae feb add ebaed cfb fed acfef dec ccaac accebdd faa afbeedd eaec acaaffe bbada aadaa bba ebcc bae dad cfb dba eceede afe aaf bca caa ece cab ccb efd caf aff bcfaa cac aea cfe aeb adadd aec dcc dcaa bbcdc bceb aaffa ead abd adc eac fdbb baec ccdb bdc cfc cfa bdfbeb dda abe bce eafb fcfddf efe eca caa ddef affcbf ccfeb dfffe bfe ddb eecb cac dab ceaa effd eec cfee bee fee afc bbfd fabea dcbcd acfe efd cea dac fbb aaf cee cae eddf eaf ecebbf effc cdcf cdc eebf ead feae cebdfae bba ddb eea fffed aef bcb aef fbdae cdfe dfa dcdfc aaf efb deea cbb cff abbbbc eeadcccee dcba aba eab fcefb ccd deb bcaf fee ceb fea cfb eef fefb bfcdff aab fbba ccb eee fccbb ebd debb beb eef aee baf daac abe daac aeb dcb bdc dce dce bae ebbf bcf aacfa bded ffe dcb ada aab cece bbc ffc aacd eeb aafa fdd fca bdc dfe bdc aab dca ffa afe baa cdc faba becc fac aacec adf ced add ccf bfc cdedce dafb dddce aacaa ecb fff baa bdd acf cdb cabcd aba bec cac ded efe acbe abeed aab dee aec efa fbff babb bdb afd ccbea acde eaab bfde caed fff acc daea fbac aafdc bff bee afcc edd bcde fbfeb cead bdde facf fdb ebcd dad cae dac fbaefdf edbf dbce dbab fdff cea aad eadc cfd dae cbf ace dcd bca ddbae fbdf caf abc cca ebe fcb bdf abe dcefdcf cdeecf add feb bbb edbfb abe bfaa fed bab dde ffcd fedea abbff ffb ecddf adc cbbe cbd cfbd fea aeee acafd cceb dedcd ebf bdeecffa afcc cea badd fafdbee cdc bcde acf aeaf aee dbb fcd bdb cac adfa adf ddf fba abbf abca ccb ddf efa ebae fcec cfac eaa eface aba fedfad bce cdbbb ecf fae fdcdeff adf fbf ccd baa aead bae ccc efd dac fad dccc dbaa dbf dfbc cfbca cae bec dde dda bcc ebbbad acb edd cfb abddb dda ddf bdf caa fff bbdee bebd fbaf ebfde bdd ffe bec abf ffdfa feb cdc bdff bea ecb bdc efe afdd bfe ecd dce aed faa cae fdf bddf eced adb bba aea eac abb bfb fcbb aebacb dbc deadf fed cfd fedee bbe ddddfe acad bab dfedeab fda afc fff ddbb edaa efb baca ead ffd aaaa eabbfada dfc cdede bea bdd aec ccdcf ffd ceefaf bef cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate jul copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmsy readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmsy painttype fonttype fontmatrix readonly encoding array index exch notdef put dup minus put dup periodcentered put dup multiply put dup asteriskmath put dup divide put dup diamondmath put dup plusminus put dup minusplus put dup circleplus put dup circleminus put dup circlemultiply put dup circledivide put dup circledot put dup circlecopyrt put dup openbullet put dup bullet put dup equivasymptotic put dup equivalence put dup reflexsubset put dup reflexsuperset put dup lessequal put dup greaterequal put dup precedesequal put dup followsequal put dup similar put dup approxequal put dup propersubset put dup propersuperset put dup lessmuch put dup greatermuch put dup precedes put dup put dup arrowleft put dup spade put dup minus put dup periodcentered put dup multiply put dup asteriskmath put dup divide put dup diamondmath put dup plusminus put dup minusplus put dup circleplus put dup circleminus put dup circlemultiply put dup circledivide put dup circledot put dup circlecopyrt put dup openbullet put dup bullet put dup equivasymptotic put dup equivalence put dup reflexsubset put dup reflexsuperset put dup lessequal put dup greaterequal put dup precedesequal put dup followsequal put dup similar put dup approxequal put dup propersubset put dup propersuperset put dup lessmuch put dup greatermuch put dup precedes put dup put dup arrowleft put dup arrowright put dup arrowup put dup arrowdown put dup arrowboth put dup arrownortheast put dup arrowsoutheast put dup similarequal put dup arrowdblleft put dup arrowdblright put dup arrowdblup put dup arrowdbldown put dup arrowdblboth put dup arrownorthwest put dup arrowsouthwest put dup proportional put dup prime put dup infinity put dup element put dup owner put dup triangle put dup triangleinv put dup negationslash put dup mapsto put dup universal put dup existential put dup logicalnot put dup emptyset put dup rfractur put dup ifractur put dup latticetop put dup perpendicular put dup aleph put dup put dup put dup put dup 
put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup union put dup intersection put dup unionmulti put dup logicaland put dup logicalor put dup turnstileleft put dup turnstileright put dup floorleft put dup floorright put dup ceilingleft put dup ceilingright put dup braceleft put dup braceright put dup angbracketleft put dup angbracketright put dup bar put dup bardbl put dup arrowbothv put dup arrowdblbothv put dup backslash put dup wreathproduct put dup radical put dup coproduct put dup nabla put dup integral put dup unionsq put dup intersectionsq put dup subsetsqequal put dup supersetsqequal put dup section put dup dagger put dup daggerdbl put dup paragraph put dup club put dup diamond put dup heart put dup spade put dup arrowleft put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec fba cdfdddf bfbbfcb fdc add fbd efe fceb ffda dacfdcd bdd abefd dfd becea cfc deb ebe dae dbbed fecc abf cae ebbbf abd cbfd fcfcb eba aeb dbf ebd eef bcd ebafe caf cff eed abfe fcb eec cae aefd dcf beab bcff fbcbc aeb afa deeae aba abad cff fdb bca dcf dfde bfcf cef bba adfe bdf dec acd fce cde bfa caa eac baa acd efeff cffb acd aba cdb fecbafb afdaec fbad fff bcc dfb ddc aea dea ece eeb cfb fbd dcdfce acbba acf beadbd bcda cbb fce acb eef cba dff ded bdc faa eaca eaa aea cbe ddd eaa eae dac fbbb deecbe aebf bbceeaa afc aefac fef cdb dfdc acf ffdb ece acdca aaa dcbe fbf ceff aab ade dec cedd ffc ecdd adb eef bca aef cefd cec fcaa ccf bdbc cda aefa ffcc daff dfeef abc edc fff afc bbabdb daeb cad cdacbe feb bfa ebc ace cbdebfb bcddfea fdb fafe fda ecde cdca bbe dcda cacbb aed bcaeb efd fda dfb edd eecb cdd aaa eede ece dbbe cab bbdef cee fdb bdf ccd fbdae aedabe fced bdb bef fbc bdad ccba abf cdf ced fdc aee dbf cae babe bdefccc ffa efbaa bad ccfb caaef ccdf abe aea faee caf aee eab dbb dcd dbb bea aef eba abd bae adf cae fed efb fdf bab cfd dde aae bed cdf cfcdc fcc dea bda eee fbdb bfc faac dceb eca fcbba abfcbf add aade ffac fec ffa aebc dbdc dbbd aba bedfcf fbc caebf defff ddf edb eed dcb cfc ebbfa daef efd cff cfb dfccd ebdb bbda feaba edea abb aea cdd dba bde fdc ebbb ebe bbebc ecb ccf cbf feaec cde adce feac dfc ebda edcb bfb ffeb abf cccdd cef baf bff adf bdc fdd abe dffa cbe bcf bcf cac bccfb aef dafb bff aab dfc ead adfbc add deeb aeeb aea efd dda eec bee ebebbde ffd bbd dcb dde fef afb dfb ffb daad fcef bae eac edea bdf fefc afc cfc bcc fee eda ddaac bcf bec abf ecf bae cfedb ffb eec dee acb dafa fad abe eac ddf cfeda dfab fcf fdd dbb bae feee caf dca cbfcd bfcfd dbce eac eec abe cdac baccf cfc bdb addc aaaeb fae caa bbd bba ebec ffeead efe edcc dda ddf ccd fead bcd abaf dfc eebdf bfe faa cacfecae dcd cabef bead dca bea dbe ecfce edde aefb ddf fcbeff ebb efdd fded cfcf baefe ddda dbc bfeb bdbc bed ffed cef eec dca efbbd fba adaff edc cbf bdd ddf cef bfb aacb edb eac eda acaaa aaa affafbde ccee caca cfe accc cebfa dcaf cab dbc ffd fbf faeac bac dac adf aaead befb bdeea dcfaec aaf dfaed ddcb ceda cbb bdda dec cffcf fde baf daa dbc ecf caf fce eca eed dbb eef dea ade abdd fca cac bad ddbeb dddbaa cab feb dfadcb cbe dbb abefbf fdc ebc daa edf add dfb dfff fcc cbef acaafc ddc cdb dec fcf dba feecca dfcd dae eef caf ebcbc eaf ffe cbbafd fdffca cda eabebf eebdf efa fcde dcfc bfdf bbac cce cfad bbde cee ade ffffb fdf bfcdaba fcd debb dcdeee dac dbcd efa deacc acf eae afcb ecfa daab eae ffba fadc bfba ebd dff adc cae fac dcf bfa bddb cecb bab eac cbbe ffe eda fcfbe bad debebb ced bdfcf eeeada feb fab fbebf cff dbb ddec edcbd dabbf aae eedb dba ced dda aab bab efed bff bea dfabe dad bfa dcf afe fea bfe bca bfdb bdc ebcb aafd faf addeb efa bdbb bedfc bdbe eabbc ecd fce bfe fabb eba eda aab cdb eac aed abd abc ccbe caaf eae ecc ebfb fce abd abdbe aecda dfc bcab aed daa dba caa fce bddf bfd dbe faab ccb eaad ecaf caa fdbf bdbf ddff cdbf dfbfda dbb dcf edc bbac bad acfced efca bccd eaa bbcee adac fdcf eea afe dae fcaf eda bcb cdb dec ede acf cca ebbe baedf fcc bda debdc eace faaba cde dbd bfd cffe cee fbe baf aef dfb eaa fbcd dcf aeb ece eee cffb bec ecfef fbe ddd cdc cdd eee fdb ccf baa fbf bbb bfdd fcfc bfee bad acbb befc eba ecff eeae aed dcab dbafa cab fda cac dcd dbe afa bbe cad aeb fbd dbd fce dbd ece daa ceaf eccd bdbb ffd cec fdb dfcfebbbf effcf cbf abc fade ade acc cbc aae dcb ade ffe aad ffa dba ecfc dcd ecfeb fec fba aefc faca dedb edc dbedc ecece fffaacb bea ffc cbba fab eba ace fed ada ceb efd efb fbf aef bcda bca ffa cbfb aeac aabe bccf cfe eba daf baa edb bcaf dfff dcf ebf bcb dcb bfe fbffdc ece dcb bef acc fbdeca acd eff dcd dee aaaf cdd cec dca eab ded cbda bff abf dbec cae edc fee abd cac debbea aeeb eae ecec afec fdab 
cfacdcf fbd cba dea adbc cfa ddd cbad cba fdf dde fbae aae eefbc dddc bff efd ccaddb ebc ddab dcf dbe cab cabc dcb efa abe fdce bad cdb dec cec ddd ebe fbbe bde bcbf cbdad faf dadeebd aebb cbe eaa adb abd ccecf bce addb abde feca edf bff fee fca ada eeffdb bcf eab afed dccfc eeedb addc aac eefb bdadd fda eacecc acc aafea bad faf fcf ccce bab dfcd fcd cba edb eae ecd eacd fef efcf dff fbeecc eaad cfc fbd aff fcb bae fed bea eda cfa bced eab dda cdcdd eff aac ebcd adce eec efa bdd ddb adc ade ebc aab eca cffcdbb bfe cef adbe bdfb abf fedac acee acb eebde acdf baa acbbe bfe cab dbb bef aabbb feea adc aeef bcdf fce edba bcfc ece bdc bbc edb cac ede bfa dfa cffe aec cfbba aee bbd aae afe dbdae ffb abf afe afe cba afe fbf dbed bcefe caba adb eaf dcb cfb cbbc edcc fbb dfb fbb dbef bfcafb dee fef fbbfe ebb ecb edc cefc ffaf edf bbdea bab fde ffc cfb ccae baeaa dfed cedd afdee eaee abf dcb acd afa fed dae eed fdec acf dbed efd ccf bbec dbe bbbdb efc aed bebf fffbf dabdd adc eea cbee bdd dfcb cfce cfc bdd fff dfc bfad daa aaba cae bebf abf eeb aabb dcd dcca edb bae dcb daa dfbf fbd cae edf faa eaf acf abba bcd dbd cfa dba abd ddb dbf ceef cecee cefc fdd bbac efd fad bfa cdcc abd aeee dde afa cbe dde cced ccb cdcbe cfeea aefc edc fbaac ddf abcb edbc bea cfa fce dee eebd dfd fbf ded bedd cbf eecc aad afe ffbcef bcae eddaf bafe afcb dfef fbe adf ecc bece febbcc eec edafc aae ddb fbdbce aeb cefd baef dad fcb effd dcb cee acde faeea adc eec accadb fadac cfcd fba ccf bbf bca ecb abafcb deda dba ccc cabbe cccb bdf fbd eae ccc bcca ced aaec ecdc fdf fbd fff ded fabfe beb bdfe ffbcbb fcab cabe ebf aeff fafaa dad ddfe cccbd dee dbaf acc ccaea ddb bfda eda cab dcdcf caa adb ebbb edcc afef bcb bbc dcd dfa bbf acd aace dfc dda adeec dbcd dbd cad ecace efe eddbad dcd ebe afe adfc cbe dcfdad ccaea bfad add bef cbe ebc ecd afb edaedf aded adae bea bfd aee dfda ebe cabf dbf dae babaf cdc fbc abceec dba eeff bbd cfd dea eee cdf bbce ccc daf ffe beede daf ffdfda ffbb dcd bcb eef aaed cbcda cbd eaef edd bae abaf ece cbd dffb ffd dfc edfb bafa daac eec baa fbe eafca dbf abd dcfe adc aafff defca dca fcde eba edb bba fbc edd cad afd bbf eed fafcea adea ebcb cef ace bfcbea afa cdf fcf bdb dfb fbdc abf edb bbffff fde bdeead efc efddd baf dec dec ede baa adae bebaa fade bdfb accb eaf dcb fdd bcd facff bbaa ebf eade afd febfab eca cacf aecc dab adc add ada baa ebb cdb cfc fafa bce dedd bbe acef ebb aad efe dbd cce adfbb aefa facd eabd ddf bff ccc fbd abff feb dcb fce daa fae eca bcb fef beb ffe fadff fcf afa acbdb ede eac dab ebc fed bfadd bcacf dcf acdc dbc dbd aba dcbea cfa ddbf eadda edb dce aaa dad adf efc fcc fbb aed ddf fceae bec baefa aaff dced cdec ecad dab bcc bbf dffbc fbc acb ebb cce ccb aba bcca bcbd dfad ffcb fbf bfbb abb aad ffdcae dbfe aba fbc aedef fff afaa afd beb ced dfa baa cbb cfb cefd add ccd eff abdf bcc fba ffbb aaa cdc ddd cef ecee bbfccb bee cleartomark endfont beginfont cmr ps-adobefontcmr creationdate jun copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmr readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmr painttype fonttype fontmatrix readonly encoding array index exch notdef put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup dieresis put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup exclam put dup quotedblright put dup numbersign put dup dollar put dup percent put dup ampersand put dup quoteright put dup parenleft put dup parenright put dup asterisk put dup put dup comma put dup hyphen put dup period put dup slash put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup colon put dup semicolon put dup exclamdown put dup equal put dup questiondown put dup question put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put 
dup put dup put dup put dup put dup bracketleft put dup quotedblleft put dup bracketright put dup circumflex put dup dotaccent put dup quoteleft put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup endash put dup emdash put dup hungarumlaut put dup tilde put dup dieresis put dup suppress put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec cac daf bab edf bcfbe cda dab fcf fce ffafc eeafc fbe edbfe afc fccc faaafd cea cfa abe cee cdd fbcfda afa cabc aaa aaec abf efd dcdf fad ebb afe ccbc dafb dbd dca fdef adf abfb efbb eda edb bcc ace fbbd fdfd edfbfefdda dfdb acc aee dbeb bea bbe ecf eaed fabcdab ecfe dfadd cee fbc faf cbf dcfe dfd dbcac bff dbfebdb afdf ccf dff abab acaa bfa cfeb edc aec dda bfaef cbd ddc aac deecf dfe ccc affbe eaa fedad fdd eebd eecca ecdb dea bcd bfb faf acd bff ebf aed ccc ffe acc aeb dfd bed baadd cfaed eba fde efbe bad fcedb cca bbbe fed ebc cbcb dbc afd ddb dcd bbccb fae fed adcd fbd bfca fbf feeaf efb cad dbb dfc cea cfaa edb beb acf acb ecbd adfe cbcca cdeb ccd dfed fbc ebf dfe aaa afb ecd dad bebc efd aff abc dfb dfd eecc cffde fca eef adb aae bcdc dbf eaf bae caf efcee aabe efb dfbe eab aada fabc afbb aaca ccc bee abc afd bdc eeba baa fcb fad aeb dcbb aced cfe caaeab feb acfb cceaaabddba dcb dafb cfd afba bea acbbf fbf dcb abfe aca efeccc caa abc bebe cef cfa adc fce cfd dcfb aef ebed bacdf fecc faf fbedbb fde fdd dfc bed ade aae cba fcf fbae bffdcb dbe eabd bed cce beef aaeea efecd fda eff ade ece bbf deafc debfe bae abd cbe ddb fbcf effaeb feb baa fdcd dbefa fea dfa cdda cef ffcd deb abb bcc aeba abae ecc ddfe efe cdb aac dcff fbbd fef bcadddee ded bbef fad edeefba bdfea cbe fba bcad adaa bcdfae cac cabeb debe fddddd afecdf fefc dbd bfd fba ecea faa ebfa bce eeb aaebab acf dbd fdb dbc aae fedbdf aeee adcd fcb fefe dddc aae aefde facf fdfd dfd aea fcaf fabc dba dbffa abe ebb fcd ece cbfa afa aefc cdb dde aaa dcb cbad cda bcabbb faf cfeb eaffc eba eab dfbf ebf dfde faae aeeb eaf ddf fdd afb ffbb eda dbf ebef abf afd aee fbe febacc ced acee bce fdfa dacacd abe aff cafee cdc eadd dbede bcbe fac bafb aee bbec fbbdc bdc acecc dde afe ebcd dcbcfd dfde deb fdaf faf ddb cfe ebd eca aeb aecb cdb bde bbd cad eca ecdf bbb ffe bfeb bee abd eec fedbd aae febd faaacbf dfb edbd bccde fcff dea fcedca bdefade bed bce bec bcb eaccfc deb cbf bef ccc cae afa dddaee baa fac adae aad fce eddf bad fba ede cab ebde dcb fecafb fbfcbcff fbc bbdf bacabf afb cec caa fed ada cbefeda bedf cad bbd ebaecc bed bec ddd bcf fdd cdbcb ade cbbfef fec ffa cfd faaa ddd cac ebfcb fabddb cebefb dcf ccf cabcbcfbe dff dfeb bec fca cec fcb fbe fbda bccc cbdcc eac cdc bfe abec edb dfb aaf cfe cfabe cfdd bbe bcc cac debca aab bbadb eba efffae eff bbfc cdac cfbd caaf aaea ddaf cecdfb ddbaf bbf eadafb dca bdfcffaeebdda acedf ace edb beb fafb cce aac cde fcb cad acb adf bbd beb affdb daebb dee cebf ddcb aff ccb cea efe dded add bba dadd cbc cad afa eeabdf ffdb aca ccc fdd fcdf ded acaf dda cebc ffab dbc faf ffb dafe ccbf dfe ade ccb ebe bfbca faa fbd ecf cacfab deb bfade acc ceb cfe fbe ece ddc ffebbd fcd caf efd cea eda bee bcf cfbe cedd eacbd dfe ceac bfcdc aebdf dfe bcac deae aaf babe dfc fdb ebca bbef bcb dcb acf fea dfb dfaac fba afd fdf adf aca ecbbb fafb aae fda ecc fbae dbef ecc dddb bbcd adf feabb bdbd deee bdbdea aba abfd fdf fadcf acc cccb cbb dcc bdf bfa fcfb dcd acf beddf bce ece eabe afda dcc abb aafd cde acbe fee eec dfd eafb cee dcdb cfdf ffbf bdb dfdef eafbad fdf efd baf bcbb abe adb dce cfc aaecc aebf aca dbd ffe ead baffc ebad efafd dca cdedcd bbf ffe fac bfb adeda eff beca fce ede ffdf ffb cfa fcdef fdce bed baaa dfe aba acb bee cdf fae bed dcafd deb eba cdf eab ebd aaa bed fcc ada cafe bfd bcd ddb ecf dad ddb bdb ede cfdf efba ede dfc ffe ddacb fde ffe ccf fdd dce ddf ebc bfd cffddd ceb bba aaf cee abbf aaad eff add afffa dfae aeec fbe cffe aaeedfa dcb edbc dbfd dcb abf cce edb cda dede afd cbad bdd dcfad aae bae bdd ccd bfe abbd eae befbfe abb cbe eefbf dee faf ada bba caa fcce fae fbc befff dec acc cacb cec fde dbb ccd eff bae afba baa ddb baaa dac dcf bad aacb ecd faf cdc dac dea dad cbfea ead fee cbb eee bfdbb bdbab daa edb add aaad ede bdc bdb fffcfebc fbc bdb fad fed cee ddd aaaf dea dcc fcd ffcd eec ecd dfa dcbb efbee bba cee efcbe bafb fcd abc bbce cdb caf ddba aefa fba baf cfd cfbc fbe dbe dce fdb bad aceda bdf adfbf bdcac efaefbd aeccec fee fae eecea ada dcf abe eab bbaa fbee aff beea beadfb bce aef cacb efb fbe dea dcfea baf dbf efb aec eceddef adc aef fdbea dfcabe efdbc aab 
dcbc fecf adeb afb edb cdd cfd aed eecdd eddfdae edc bef fde faf cdf dec bea dbc eebe ced caaf fafa cbf ede dcceec dee eabc dddf baf dbe cfdb cbef aac ddca cace dabc ffb dfac ddaf aee baa faa ffef bbf fbc edf cadc eed dcfce fab dfa ebcc bbca fcfa ebb efd cae bcb abbe cec ebe dbe bdc bfa dbdb bfb dab bfc faeab adedf aec cde aec edc ffc edbc eced aec eff acaddced fcff dbc dff bfe fec bcd eec eac abfb fcc dcd bcdf ade dba dbcffb dfa ddfa aeeee bdc ced afaab bcae cfb aec fdc cfc dbf faafe bedced deb cded edea ada cfe dea eeefa bfefa fcfdf badd bba bfad aeea dfafa baa eeaf dcc fbd bfde cab fab afa ade bfa fdbb eeb cdf dafc caf ecc bac adf afb eea aedcd dce fee ecf ddd dbae bcf bfb cadc bee aece dbd cfd afe bfef bdf afd dee ade edc cdd bca cfc eaf fcb daa eaf effc acbd fceffd cae cdc aea edbb ddc aced fcd dbf bcb cbfb bcef eead cba bea beceef eeca fbe cdac ffb dfb eda ceaffb faecde cda aeb dce baf cefce ead cae bcfb fef cdc beffb fcbe eed bfde fdd dcd ffe eabf cad dfea aaafc ecfac fbe aef fac aed ceffd ded eafd aeea efcb adac acdbffa cdfcba bfb ccc fba ecf bdcda ceb afdf eed cba dcc adc edba dba abf dccbbf ebae eec fdf befea decd acc ebff fbdffaa bbc ebe edc adf aaff ebd cddc fcb eecf bea cede cdc bbcd cac fce afab aff dfa bbe cfb bffb ebe caba dddbf ecc fadc ebb fca dafa edfca fdb cca bfee fcaba aaad acd fdaffb bedc cfeaf ffccc ecc accc afd add eee fdfa ccbeb aeb acb cfe bbcab cbfa cef dbf acdce dfb caa fcccef adde adc dab cebd cef fce fbe bab fcbc aea daf bea aca efb fed fadb dae baf ead ccc fef bde cdf dffa cec deca fcb fbca aae faa ddf aaccce cad cac aad afce fbe bfdfdb fdb fae fce cefbc fdd daef fcb eab ece bcea caead fefc add cae bbe dcf adfa bba ece dfaee bceb dbd defdbff ebed eafcd bac aec dbfae aae fed dedf edc cbc dadf aeaddaa bdc bcdea cfb fbc cccad afa ebdc cdcb bca acf efdab decda cedcbd dbe fafb edc fba cff fcb aea feaddd eae aef bdadeb cad feb ffc afbc bcb cad bfbb edf dfcb dfd eef abce fbca eae ebed ebd bdb bdfd ccacd cec eda cab aedd bdf abd faa feccdbed bae ccc fcb bcc bdb dff dede ebe ebe fca fce dbc adc aacd fdcd fbf cef bbc cdc ffc fbdcad afcbaaf aeb deb dbb bfad ffe fca dbe dddeb abcc cee cfd dbe dfb bbce beaf ffb edd eade ede dcf fbc fae bbed aadeb ccf ebff fac bdd dcf eaddc cfb ecb bae fbb dbdeb eba afac fdeceb bdf fac bfd dffb eff acad ebbfe feb bbb eefbb cfec bef ecf ceab dfda eae bfdd efeffe dcdd fca afd ffc ddc fed ceb ccf fdb afac aca acf bfb afea bffddb fde cdef fdb feb cfeabfdbaccdf ffe bfb bcd ded aacb bcd aac acc aeb bccf eec dffbda baab feb fca fcf cea cdfe cbaa dba fad ccfc cbd fdf dfd ebd bcd fdb adb ebed dbc fafa ebac aef bdf dca eed eac ebbe ade edea dee eea aef acd febfeab debd bdeea afe cea aee eca fbe fbcba bee bbc aea cfbc efed adc ddc bbc ecee cad fae ccc beecd bebc cebb eef dcde dccd afec adfdd bca fcb bac dfb bee beda acfbe cea faf effd edc eeb edfefde cde cae cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate jul copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmsy readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmsy painttype fonttype fontmatrix readonly encoding array index exch notdef put dup minus put dup periodcentered put dup multiply put dup asteriskmath put dup divide put dup diamondmath put dup plusminus put dup minusplus put dup circleplus put dup circleminus put dup circlemultiply put dup circledivide put dup circledot put dup circlecopyrt put dup openbullet put dup bullet put dup equivasymptotic put dup equivalence put dup reflexsubset put dup reflexsuperset put dup lessequal put dup greaterequal put dup precedesequal put dup followsequal put dup similar put dup approxequal put dup propersubset put dup propersuperset put dup lessmuch put dup greatermuch put dup precedes put dup put dup arrowleft put dup spade put dup minus put dup periodcentered put dup multiply put dup asteriskmath put dup divide put dup diamondmath put dup plusminus put dup minusplus put dup circleplus put dup circleminus put dup circlemultiply put dup circledivide put dup circledot put dup circlecopyrt put dup openbullet put dup bullet put dup equivasymptotic put dup equivalence put dup reflexsubset put dup reflexsuperset put dup lessequal put dup greaterequal put dup precedesequal put dup followsequal put dup similar put dup approxequal put dup propersubset put dup propersuperset put dup lessmuch put dup greatermuch put dup precedes put dup put dup arrowleft put dup arrowright put dup arrowup put dup arrowdown put dup arrowboth put dup arrownortheast put dup arrowsoutheast put dup similarequal put dup arrowdblleft put dup arrowdblright put dup arrowdblup put dup arrowdbldown put dup arrowdblboth put dup arrownorthwest put dup arrowsouthwest put dup proportional put dup prime put dup infinity put dup element put dup owner put dup triangle put dup triangleinv put dup negationslash put dup mapsto put dup universal put dup existential put dup logicalnot put dup emptyset put dup rfractur put dup ifractur put dup latticetop put dup perpendicular put dup aleph put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup 
put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup union put dup intersection put dup unionmulti put dup logicaland put dup logicalor put dup turnstileleft put dup turnstileright put dup floorleft put dup floorright put dup ceilingleft put dup ceilingright put dup braceleft put dup braceright put dup angbracketleft put dup angbracketright put dup bar put dup bardbl put dup arrowbothv put dup arrowdblbothv put dup backslash put dup wreathproduct put dup radical put dup coproduct put dup nabla put dup integral put dup unionsq put dup intersectionsq put dup subsetsqequal put dup supersetsqequal put dup section put dup dagger put dup daggerdbl put dup paragraph put dup club put dup diamond put dup heart put dup spade put dup arrowleft put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec fba cdfdddf bfbbfcb fdc add fbd efe fceb ffda dacfdcd bdd fcf edb bdf fffc caad dcd caf facaff bff eac ffc cea cbf eede abcc efecc bdce baef cdfc ebb acfb bdd fab cce aea daa babf dcc cdc abd acd dfaedb bea ecad cae cfe dff fbc cae cafb faf fed fabadb fdfcab ffbeb ccd deb afcf bacced faf aebd fcbfa efc cad bec aeabf dad eca eff caec dfbc fbf bfad bce eed faa abc ade bfa edd bcc dad ffe dcc edbec dee afc ffdd adfc cbc cabbf beb fcba bcc ddc bbf eda fea cdc bfc bae ede dfa babd dba bbaa aaa bda abfe bfb bed eccb bcd fba bcd ebf bade eba efe fec cda bbfa fefb ebc feed cbdb eff cecfb adb ccd bfd ffbca aee bdbac bed daf ede aeca fde dbbe fde eeaf cbfe bccdc ebe fbc dac cdf deeb aef abd fca cee ffa cde aac ccd ddf ccc bbd ead fdacf beb ddfef eeed abfe bcf bbef bdee faa cffbc eacb cdfb bfbb ffd dff eea fbb aeced dbce fce bea fdf ebf fdcf fcd ffa fbb bac fefd ceacd cee acfadf cdbb bda fba deb bdb bca dfc eac dea aac ebd aef baca ccd fdeb ddea ffb eed dca fefd feb efe ebf ddaf dca cef aed aed abaf eec bdd dda fac fcb cad ccbbf bdbe fbd fad ffd aee ecf ecdc acc fad cbca bfd fbabf bda aea bef fdda ebfaa bbca ede ccfa dcafc dfe dab fed baaf ece ccaeff aab eab dfafa ebb cdbd addb fdf bdaf dab fcd dcd eab aad fafec ffb accf aace ece deb dfde cca dcde fbaedc fffd babe dbd bfbcc cac ccd bba bfce eca adb fac dcec becc ffeacc fbf eac dae fafecbabce cabc dbd cecc ebc dafa ccf eee ecbd adc cbdd fccbcf bcbb cdc dcd adc adf eadf ffdce ede dfc ffd bcae bcf ecabc dfdbb fedc ddc ded dcfbb cee dfadcd adcc ffa cac acfaf bfe edfca aac fcb aaecaf beab abef bbc cab dbb eef eed faa daf ffcc ada cbd bfcbdda ead ced feeb fbe fadc fbb cfe cace cbcbbce dbd bec cda ebcf dec bca acd cff cfc cdc cfddb deb bde eae fcba cecc fde cdb bbeea bdb abb fad efa eaf dba fea ded fed bcbafd cade afbf cccb fbc eaf fbfea bebb ada febcc eead adc bda dbfea abfb ebae eda dfd aec baae acb aaa dbf aec fdaaed acff abf bedf eeb bbbce dcd ebda edff bbdc beb dec baad cfeb bae fcf bde ddee bfe ffbd bab bfc ebc fda fbcf beabfce afac ebdc cfeccb baf aab bba ddb deed fedfdbbdba fea ddcee dfe eee cdd babc fafb fefec eed bcc dcc feb dcfcd abfd aae cbd caa dcbd eabf bdd eef ceaa ecfeb dafa ebdc aaa bae fec caec ccda dfd efd ffae fef fddf ecf fcc fae cfdbf abf bed cdf aea ebb daca cfa abe add bdb ecc aabcf eeb cff aae edae bba ccecae dffd eee aeffe ffd acbce cbb ebb dacf cfbadbc aac facd bca aed dee dcf daa aad cee bdf caf cbdbd eaef fdbd cdad bfe bbe fca ebc ebf fab ccb ded dcd ddb cad fccc ccb add cbdb eefdac cee bbce adcf dadbf ccfdb efe dde ece ded ecb decab aacb eec befcbb ecb cfe eecc aacf feda ebdbbe bbaf aeb aac fde cee bbcb ccd fce bdf bde dea dfb adbb bade abd efe eea aaf aae daba bec afe ceb afd dbd fda ddafd bcbae aebc ecc ecc ceaef cdf edbd baa aada abf beaf cbe aedd aaff dbc adcf acccd dbee bdd afdc ede abad abf dfd aad eab dad afb ecd ffb ffc fbdb cbd aadffba afc bcd ccf eea fbd aaac bce dee dbc bdeb ebb cbb bac cbd daa dbc aba ffbc bac ffbc eabdd acbcc cfcfd dcdd bdf acddc ace aece bad ebf cde aef dad eda fadaa fdc cbf bab ddd cfec bcb ddf ebaa abd fbf cbf bffb fef cdd eac badc dac bcfe ebf bae aea dabc fae bcd dffeb adda bcdb fbdc ddf aeab acd afdba cace cff bbb bad fee cfbd aeae adf effc bdd dff dcc dae feb bef babb bed fbbadf dbe ffec aecd bdb fffb eddec adb ffeafe cdc edf dbdb cba dcd aec fcea baa bdf baf bbcbbce abf dfb dee bca ecb eab cda ffe fbb eea fca dbadf daeaa baac aef cff dec eadbb cea eafaa ecaf ecd fff ebcbd fcf cdacb dfc bbb dee dfa fcbeee ebb abf aadf dbc feb cbf bae abe bca ccb eacc dea cee eca bfc bac aadc daa ccaff eda ebbd cddb baa dae acfb bdfa aac cbf cdeb ffbfd fbdd baf eeaad dbe aebb dec ffb afaba cbb ebf bcbef cba fbfab adce dcabdde efee bfe dfaea fcf ead abcf fad afc beb aeeec adf ddb ecb cba eba eea daa dab efe cac afe afb fbcdbe cfab daba ace ebfd cae dde babdd feda fdd becc eda cdf dff cdf acbf bff aef edeeb eae dac abadc bea 
befdf dfb baa fecafadc acbb bdcf aacec fbe bed dbcf bfc edf bcd bdaaafb ffad cda bbdda fffef ccb fdd cac ecdf bdc bdb eaeaaa bafcd ffc dbd cdcfd fce fcd eeca fca ceee eca caec cbcd efee caf efd ade bdcad bcfc bcc fccc efcdd dffc daf cfbd eca acfcbcfaf bdf add cbf cdf dac cfe efab eae afa fcf fbbb bebc ecd aef dae ace bec fcb dab afc abda efdd acd dcfdc dae dda dec fdf bdfcfd edb dfe cee afe aca bceb bdaa eead fafa cdcde eeb cabcc cfcfda eeaae fdf ebe ebc fbe cbdf dfcbbbc dfe aba fabf acb cce fdd eeb bee bff daec bcb fbe ddb fdd eca eeda eefc eeb bdfc cccf fdbfad eda dad fcd eaeb fdf fca eed eff bdfd cce eee cec ccdeab eebe efa bdc fbce dfd ded aee dbc fcef dacd efdd feb cfecbc ccb bddda fdf bfa dbd acbccd acbc aaa fbe ebe fec cbce afe eca cef fce adc daa afa abf dfba dec afab ded afcc dcd edf fde cad cee fbfcd fadfe dfb efd eab ccedd dff eebcbd dbfb cca aef dbec fbad ebbe dade adb cbf bfe eaf dbb dbda cfa bdce ffdcb ffa eadd dbd ffa dee dda abc cbaab cfd cebf dbdb aadad ddfc defcd faed ebc afe bffd ceb aaa eae fbe ebeaf cbd befe fdf fdb cccf afe ffe cdd fca bcc bfa cecf bed affa acbc bbad bbd edd ade dcebbf ede ddbd dba cab bcf dbef aaba eaf ffd acf fec aede ded fcee baa deb cfae fed ccbc eca adabd bed dcf ecf acbce fef daf cbd fae cad eaee ede fded dac cda adc fbc ddafedf bed bee fee baae cacc eced bead fbcafa bbab ffbb cebadc daa ffc cec aab fed ccf cefd cfb ead faa bec ffd feef faa adc abe aacbb bcb edce eed ceb eea baa adedf dcd cff ada ada ecb ceb dcbc affd dfebfcd cea dba eec afed fff aabb fdb fca adc beec bbcebd ddc caeb eaaf dde ebbc fdebffc aba dace dfe cbad cbbe cce acd bfc ddf ccb acc eadacc fcc eaf eda efba cefc dacd dccb becc adfd beae edae aaf bdf acb fff ecb cdfc cff bee faa ddfa cda aab acb cbbe ada feefceba fce edfdb bfde feaed acb bdac dbdee bbaf cfead afbcafaea eea fcf efd add cfdae fac eecce effb cef dcdb bde dca aeae adda dea fad ffc abcd bdb dced fbc eff dab aaf cefc fcc dcbd eae cdcf ccbbb eff ecfc cbc cce dee bbf adf bbffde aebb dfe bea dbc bdcc bfc aef cba eee beb ccad cbf fbcab abd bbc dbd eea eaec aac eff cdc ede adf cfe eabd abdf afa bdf dccd bfa eaf dfe abff bdafb bbb fecd ace fdd eddf dcd cea bbc caba cbe cec ebf bcdb adf eda dcec dbd dff fac bdb bedcc aae bae efb cde dfe ace abb dbac aab dcb fcee acbf ced afc ebd dfff ecd deb afdebc cbb cbfc dad aae fdad fdd afcf eae dcc bfa aec accaa affd eaa cfe fadcb beae dcca aee cfe ecbcaf edba aef bdc dbcbdfa aae bdd fdfa eede eda aed dbccb abef bbf feafce fdfa cee cdd ceb dff faaa ffde aabdcb fbd fcdbac bbbce fcf beccceb fcfd bcf cea cbdf bafef edcabfd dfe ddaaf dbfe ffa bbee cfa dcfd abeef cec bdb eea bba dcec cde dde bff aedbdb bdd ebf dabbefb fcfd edacd fcfdd ecd baef eae bbdc fbb fae dafe aea dfef cfc bff ced bad dfc bbdc efc baab bab bce dfa afeea ffc dfa ede deb faf adb cefbf edbc cad caf caa aed bea ebbf ccc ebd bcd bab cbfda ddeb edb ebff faacd cfbb ccc bae fff eef dbf aad ffa efdfe afb bdb dfca dca bcd aeed afd eac ccd dff cadb cbf eebfa cdd fde ddc cec ecbd aaec cacadb fce bfe bedc abb eefd dcd dfcbdc cfe bce ffbda eee dcb efeaa bbb bdeebefae ebfd edc adf daf abc bfb edf bdb aefe bcff cfc aeab bfb bfa ded ffa cae cec fad aed aff ebbf dfb ddc edfbdac bcb fbdfb fdbe cfab bcfaebbf cdb bda cleartomark endfont beginfont cmr ps-adobefontcmr creationdate aug copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmr readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmr painttype fonttype fontmatrix readonly encoding array index exch notdef put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup dieresis put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup exclam put dup quotedblright put dup numbersign put dup dollar put dup percent put dup ampersand put dup quoteright put dup parenleft put dup parenright put dup asterisk put dup put dup comma put dup hyphen put dup period put dup slash put dup put dup put dup put dup put dup put dup put dup put dup put 
dup put dup put dup colon put dup semicolon put dup exclamdown put dup equal put dup questiondown put dup question put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup bracketleft put dup quotedblleft put dup bracketright put dup circumflex put dup dotaccent put dup quoteleft put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup endash put dup emdash put dup hungarumlaut put dup tilde put dup dieresis put dup suppress put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec cac daf bab edf bcfbe cda dab fcf fce ffafc bcbbb cdacfbcc ada aff baf bda cfed fcf ecb bde fee adde afed abfd dcb adda cbb cceee ffd dbbfdf cafe ecd adf aca ebed ecdd eea acfb fab fda cbf ada dbad dcb abc cec ffa cbe dba bbec fba dda ffae ffe bef ebb fede fef ddd bee bace efbb eab aee ffc dccd fce dfc add eea fbd fbfa ccc eddc dada bbe baba bed dfb baab bed ccbb afbc bacfe eac cab deb bab bfe bdf bbae cada dbaa aadf cba bcaaa ade aea dfc ddddf efab cfbc fcf fcc efa cfaaa cfd bbc aaef fdbf fcf cefedebcb ada dfe ffa ccd eda acdeb bfa cde dcc dacf ffe efae abda bdb cab cec aedb dec abf cca cdecea faf fdea fad dfe ecc ddf eaf ebdb daf aaa abc cea bea ebf fcec fcc eeddf cee fcbc dac cded aad efeb bfc aee cea dcf eee baf bbf cbcdd badd ecee eaf daab aae cedf adaabf faed ccfcaea adf cfbec faec bfef afc ded baf bdfd fff fdb dab dafb ebc fbfe fbcc dbe bff ccd bbd fccdfa ffff edc bbb ebe bed bdaf eaaae fdd adc ccb dbf ebe aae dfc ced bbd bafcd babfd eed ebb fac ecf afef bdd deea dbe efcceec befa fcd fce faf ddff fbc aeffd eabb decea bbf ccdcfd eaf eae bbc debd fcc bed bff daa deb afecc cef bea dfac ced ecf ecfd adb bff eee bdbc adce dfe adc dee dcc acdacebee ebaad efcc aec ffc cbac eef fce cac abbdb eca ffce acbf addf cee afe dbbedd eeb aac ffafa bab ecc eaca cfabdc fef cbee abe cccfc bfd fdbcae adf cfed ead efd fddbde facbdf faa cbc bdd ece acba baa ecc dff cdce cde ddf ddb aedcbac bdea edd feebb fce ecaa dba ceadc cfafeea fbdba bfb aeadf ccfcc fec bbfda cbfacb cec aea aca bdf bfbc efecd eed eededb dcb abdbaa dafc fdc abef cab dad deb bcc adc cbea cbabf cca fdfd eefdead efb cfeaec fcbde beba fca dae baef ffaa fac adb bcd fdeabcc bde fab fafbdb bccad bfaba fbcf afa bbe dbbc dbe affab aee eded faf dcf ebfafa fae cee aeea dbc dfc dbe bbcd ebd eafb cbff cbc efd babe fddb acc ffddce fdffb fee edbd ffbee abb badfea feb afd aaac fdc addcbb afa ddd aac bfd ccaa bda dede ade daae eedd beb fbf dfa bdf bde fefee cac ddeb cbb fabc dde babea ffcd abc eee cdabc fba ecceb fbc efc dfd bdc fba ece dabf dcbbb ffa bcb cabde fad ebb dbd afbbabc cffb cbdd eaedbe dbb abcf cff fafcc cdfe dac fbd bca aebcf caae bdbebe fcdd eac bff fac ecbf fefc eaed ddeb cebc bcbc bcb ddec ccf dbf cdf bcb fbb dbf ecb dfa ddd aaca aefef fde cea cbd aae dbd feefe afdd dfdbe cbbd bedbb adc beaf deb bebc faf fcba dec cdcb eca debcb bad dda cdf eee fff bbca bae dcdcd cbd bccd fac cab ebb cefc cea ccfa fae dfd edec eab aef bbce abd aefceb cec bbc ecfc eaa fffa cac eed eae ddcbcf aea fce fde aba abd beab fabee ede bfd bbf cfea bcd cfc eda fff bed eab cac dfe ded eaf aee ddbc fedaf afe fbdd cebff affabb fdf ccdff cef ecd ceebb cbc bcaf bba efe ddf fdad bfa cbfff ace aab afcfa cac faac efb dcf aee dde bad cca bcd adbf bce cbf bdc afb eace effc bad bed cfd ccebcd ebbebbb beb efb caec bcd eee ade bff bdf adc acc ecaeba fefbfb cdd cbdfc fac acb addd ecc afd dfae aeeb eacdf fbbfa acf cfe bbeccd afd ead bececa acb edaca eeac fca fbc bbcb cdc afeeddd dcb bfd beb dbbe dbd abbf ffcad bab edd eceb ead dfa afc dba ecb edf eed ecc bee ecadea afbe ffbb fba aeede feb cdd beaf cfba eea ffb bdf ecb cbc efe bfcf bdd fabbddf dde cdc cdf fac fab fcbefd ecedbf aef ceb bfa fac cccb aef bbd abf edb fcf adcc fefc dcc cca cfaf ccefeebd ddc abf bdad ecf cee eeb bffcca cfaa efea cec dab babc eae adaba fbd dddf edd ecbaef aac abfe baa dbdedbd cfde dbeb cdae baad cde ddc bfda fddf dbb cfb bedc cbb cdeeeaabf fbcc aefdbe acc dbadf cba dead ccd becbb bef bffb cbe cdfc cbf cdcad ccae ecaef fde daac dfce dbba adb ebb feb fbea fbf ffb cca bcd dfc bafe bae fff abaaaecad dcf acb efeff bfbb fac adf efe aac dfebfbcb efdc fea ade cec ebc aeb add bfdd aff cdc fba dff bcda fba bab aab fbc dddd caed aadef bdb fccc dcbf add cfc bfdd bea bfb ebfa bfcd eccb dcffb defce ccd cee fdb cfafc deffef cbe abd acab bffd dce cbbb accaf cfae dccfcd decc cea dcfe aac dcc afc ddb aad 
bcd caf dcfb fde dead aacd afa eddc ead fad dcb ccbdb adbf dcb dfa beb ddb cea eae cbd ced feca dad aeceed eecbf dccf cec eeeaf cbeffa edc beca bea dfdbc ecb eceb cebafd bce bbbf deaf bfc bac efd caef eeb bcc dba bde fcd dab aafb bec cbc bec ffa efe faa bce afaf dabb ffbd bbed bca ccd cbedd cbee fdfa baa edb dec edff bba ecc dbe faaab dfd fff adc ebd aaae fedf bcf fba fff dfa abb aed ecda eab bdc aedfa caaab cdc eca febd cee aace baf ead cdf dea abbe eddebe fdad fef efff afd dadf afb eaebc bce eef eec cbeba ffd bebadcee ffb eff ecfc efc dcaff ecda aac dcd edeca cbe fecb cfeea ddd bbcac cba ddb dac eeca fbea ccdeb feeb ecaacbf dac aacea ffc aac fbb baa dbc eeb aabb ccb edc bcd dde aaa aeec adca abb afd aea cae cef aefa aad eaa aafdcc eef aca ecdf dcecb dbdfcd eea fcea fbca ffbca bfd dbca bea dae bcc eab cdb aebcb dba ceeee eab cee cfebdc feb fbbeb aab aeaec fda dbd cdd eec fae edb ccc efa baa bcbe aaa bbcf bdbd bfee cec eca efd edfcb dcf ecf aeb dfd bce fcf fae bbecf ceb acbd adce eeb fdcb dfe cdbaa ceb eddd fbf fcd faa eab abbe dcc daae fbb ebd beef accadb aae ced add fab ade fad fabf edd bfed ede eacce aba facf dee aff fbd fbde ccb ade fde eff ccc dfc abc eaeee bed adf feca edc fac dcd cecb dae ffee ceda fad ccf bdb efccfc cdfbd cbce febde adfad ecab fcae fefa ceaedfda dedec aadcbe baff bef bcdd afadbdaf ede abf afb afc ffba efe fcc fcf fcd acc ace ccb dbba aca ceff bbc ebea acf dfb eeeca cebd fceec eed bec cdb dfe ccdd aba cbf bedffb fca efe efffa dcfd fafbb ccd abea dcc bedd bcee abe cbfbabe cae baddd eabe cdf fce ffcf faacd aab abf ffe edbdaea ebabcc affd bfd cde baf dddadaaa dacf ffe dac bae adeb eba adf abce deb cae dacd cdfc afc dec cdd deeeb fccee eec cbddc cce fde ced bda fed aad acb bdfebf aae cdb ffca ead caa dfa dda abb faf cca aab cfe dcc ebcf aac afb dfcbf eba bbe bae acf bec bbb cfd caf ceb bbe fcb fcfb cab fda ccdaa efbee ddb dafee fccf bbfe debf cdf cdcaf eed ecfd daeffbcfe bff fdb fef bffb aee fae cfc ecce faacc eadb addf dea fdc bbf dcf cee dee defe fda deccf cdd dcd bdce afc dfcb abf acfd ffaf ccd eec ffdd aee dff cea bbe cef cec cbe ecc bfae aef bbe dfd eadcf afddabe cee fafe adf eea dad cdffbfedd ceead aed cfd afabc ade ccecc adc aab bfe adf beba aca cdc fef aac bfe cfddcee dde ddb ccb fbbfd dde fba fcf dfbc eec bcfc cfae acc dab bdc aabe dbb eeee fba cef bef acccc fab ddaab aceedd cbba bbdd aad bfd ecc acd fda dade edbae eee bdcbf fcc cbaf baa cfb bfcb eaab bbbed ffc bee fbe baf edecae acc afe eccd fef bea acb afc dbb caf bfd cee bde dce fff eaf eac cbc eca cff dedc ded aec dba cca ffe bae ccd bbe abe dff ecd bba fbb fce acd dfde afa baba bbdc eab faaa aaa fce eac ecbbfbf fdf bfb fee dcc fdaa acba bad faf bec fab accaff adfe aeef dfeb ede bbf afb eab faf caa febfce cdd dca fdffe aafeceb ebc afc bdd fff cca bcaa aeb adf bdfcded dfcd bbbaeaaf afab afc aae feb bab eec aeec aeeba ada aac aed bff fce debab dace dee efdf ecf fffd adab cca cbb bcc cfaaf eeb faa edef fada aad caf ecaca cfc cebc dcecb acbc efd fcb bba bdf aacdd bba bdfdbd abaae fba cca baf eed faecef daa ceee ffd fcf ace ebd aed dbc eddbada eac beaacaf cae dbe ccab cbe defe efa ded fadfcd bccdd acf dfea cfe dea bfe bbd adc eee eddf caee cabf ace bee eada fbbd eceb cbb cce daf ccb cade fdcefbaeaf baba edcd bde ffeae dab cba bfc dbb becdd cad feb ddf baca dabea cfb beaea afa baea dba bbfac ebbb baf bda eaf baf aec daf cde feb aee adb ecdc adb cfd fdee dbd aea aae bcd adcd dacf ebf fdf dfdfce caf ffd afde ebd aaff bef dbdf dded ffd bcd cbe ebb efd bca bff fce bbcc eadf cdada afafaf bba dfa afb fba bbc edbe bce afd aedc ceb fcb ade fef dfeeeebddaf ebdcedaf bbde addeb dff dda efd fbf ebf aacbeae bea bce dad fefbc bde afcb ead bdd fee cbc fee acd eaddc aecd ceb bfd fcec ada aad dde ccdf bfc fdf adc cdb cad fad afd faaef eaac aeaff bade ddadb ffbb acd aaa dadb cef dbf eefbbb fedc fca fef bba eab dcaeb dcad dcd fca afdccc bab aab abf aee ccad faf fece deeafd cdd cdd abff eebdf dee ecfcbf cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate jul copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmsy readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmsy painttype fonttype fontmatrix readonly encoding array index exch notdef put dup minus put dup periodcentered put dup multiply put dup asteriskmath put dup divide put dup diamondmath put dup plusminus put dup minusplus put dup circleplus put dup circleminus put dup circlemultiply put dup circledivide put dup circledot put dup circlecopyrt put dup openbullet put dup bullet put dup equivasymptotic put dup equivalence put dup reflexsubset put dup reflexsuperset put dup lessequal put dup greaterequal put dup precedesequal put dup followsequal put dup similar put dup approxequal put dup propersubset put dup propersuperset put dup lessmuch put dup greatermuch put dup 
precedes put dup put dup arrowleft put dup spade put dup minus put dup periodcentered put dup multiply put dup asteriskmath put dup divide put dup diamondmath put dup plusminus put dup minusplus put dup circleplus put dup circleminus put dup circlemultiply put dup circledivide put dup circledot put dup circlecopyrt put dup openbullet put dup bullet put dup equivasymptotic put dup equivalence put dup reflexsubset put dup reflexsuperset put dup lessequal put dup greaterequal put dup precedesequal put dup followsequal put dup similar put dup approxequal put dup propersubset put dup propersuperset put dup lessmuch put dup greatermuch put dup precedes put dup put dup arrowleft put dup arrowright put dup arrowup put dup arrowdown put dup arrowboth put dup arrownortheast put dup arrowsoutheast put dup similarequal put dup arrowdblleft put dup arrowdblright put dup arrowdblup put dup arrowdbldown put dup arrowdblboth put dup arrownorthwest put dup arrowsouthwest put dup proportional put dup prime put dup infinity put dup element put dup owner put dup triangle put dup triangleinv put dup negationslash put dup mapsto put dup universal put dup existential put dup logicalnot put dup emptyset put dup rfractur put dup ifractur put dup latticetop put dup perpendicular put dup aleph put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup union put dup intersection put dup unionmulti put dup logicaland put dup logicalor put dup turnstileleft put dup turnstileright put dup floorleft put dup floorright put dup ceilingleft put dup ceilingright put dup braceleft put dup braceright put dup angbracketleft put dup angbracketright put dup bar put dup bardbl put dup arrowbothv put dup arrowdblbothv put dup backslash put dup wreathproduct put dup radical put dup coproduct put dup nabla put dup integral put dup unionsq put dup intersectionsq put dup subsetsqequal put dup supersetsqequal put dup section put dup dagger put dup daggerdbl put dup paragraph put dup club put dup diamond put dup heart put dup spade put dup arrowleft put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec fba cdfdddf bfbbfcb fdc add fbd efe fceb ffda dacfdcd bdd fcf edb bfc cfd cbb eff aeb eeb dcf bae bea dffbfbab bff facde faefca cffb cea ebe dcc acabc fdd bea ebec ddf cfb fafea eeb ace ced daecc cbb bdd aac efa ddb effc ffbce ddb cefa bdb eccead aff eeee bff cfce fdcdfed cabbc badc cbf fdb ccdb fbe bbf aabf cabc ffc feb abaf fda ddbbdc edd eaaa bdb aeba dfb ead cec aaaa cac aeba abb fbac fde adcbbb daba eae aaa abb dac afe cef edc acb ecdafb aba ced efb eefe eeb eff adc edb eabf befbb eddf dfcd cbca fee daacfaa cbd aaf aacd dde eaecd ada dfeac ebf bedafba cdf fae ada efc ded ccf fcce abb fce dcb ccea edbf cdc bdbd aedb dbe caedeec dbf bce afa cab bfccc beaa adf caaa beb dfad fbccd acf abadb bbc ffa ccd aeba cbdc bade beda abbe fdfd dacbe dfbc eefbcac cab bba bfae dfc bacdbacf ddb bfca baeede dccfc ebaecf aff cfb dbf ffa dbd bfa ccc ace cfab ace eee afd bfb cdcf dcbf abef dab dff eec bae cfab baedcd ccc faa edb acc ebf bea dfcfda adc bfabc ddb fbe ffdcc baba ced cefe dac fced eeec ddd fba aea fcaf dfa fce eff ded bdaee ecabf ddf efae eed dab fcdf fca ebb bbda cdc dcba bbefc ddc cff ebf ade bca dbf abf aab defb cdcc affc daece cbce ebe aad bfaf ddbf fcb bbec feab bad fadf bfd ecc eefb ade baf cca eded fcfde dbf fffadc bfb adc efd acb aef bfcb ecd bff eec cfed fbc dcde cfb abb adaacd affa fda ddc cae bfb bcb dfab adefea ccd eedde eff dab abf fda dfb abafe fed eea faa fca aaa eaf abc fed bbf cfc ece cca eedcfe dad edcd afcdd eef edd eada efb fbefac ffc aefaac ddde caee ffc eaf caff aee aba ddd aff edc bce fccf fcfb bac ebcac ebaabf fecc aae fbaa baefee faad baf aacda acd fdab cac fca dda fbb bdcfa afab eccc bcfe bfc ece aae ddad ded cdb eabbb ccfdbc aeaa dadeb cba dce dfb dcd bcd dca abfe eee fdda afb ecb cfd bef aadfc debb afefa cfd feb bcf edf fbec eff bcadf aeea fad fca bfc fec fab acc afb dabd ecbe bdc acfa dbdfb cfe eeb eecb abe ddb fcded baabbd eeeb fea adcb efb efbc bbc eebf edab cce add eee eef fda aff ece dcf fddad abdb dfc baf bfd bacdf efe fedc dba eaf cfed adb acfc cbf aebf cce dde acb bdb bcc cab cef defd dee adb cbe fce fbdebfa efb bddc debcc cdec eda abfa baccb ecc adc eca aaac fcf bfc cdb bfa cff bcb acd beeec bde ecd bea bbf dace caa faf aabd dfbc cbc aaf ced baf fbcf bae cda bdc fcba ffb bce aca acdda abce afb dee bcceb ffd bab fdaf cdc adf faa abf dbdc eed afe cfba bfd ebba abecca bee baf cac efdfd ddb dfd dce eda cde fbd ddf fdbf cbab aca eae eae fdc fcb fbe edd fbfe afa bbc feb bdfc bbdb ffb cbe dcbfe efe aef dfe deccc ade eedc dbb adab afa dbd bdfd aaf ddf fad bce ebd bfadd bbc aadcb bcc cecd cad eef beeec abd fffaa caa dce facf bcfadf cbb bed ddb bcd feb bcd fbfd aeba dbe fdf ace fcda fbc bda bdfec ded edc caec fba aaf fba dda ffb ebadad ccd eefedce cbfbabdcac bfd faa deede ecd caec ebbeb debab bcc bcb cfbc bfa aba cfd faa fbf aec beb edf bfa dae eaf dff ceacd eeb cbce dba 
eafbb cdfe bfd edc acb adb fbb aee fbcc dfa cbd aca fbf efe ccf abff bec ecaa eeb aad ddf eeda ebdc caf bfa fec caea bee cdeee ebeb edb abe dbbd fdac fef cdbb ada edc cabac ade faa cdb ddfdaaf efadb bca bdd dbb dcd dde cef ffec fdcb eff cebd eea adcaba eca aeedda bfa bfc cacc fbe ddb aed fcb fac afa efcc ffc abea abe daafaaa abd cde eef bca bee daa cda cefb eab daa afe fec efebff bba ccfdb bfca fddd ccd bbff ebabedec cbf bfe fcf eee dbbd eabb feca adc caf badadae ebb ecfcb dec cfbe cac fced ecffb dbdc fcee bcc aba aee eee ebe edb ccd bff dee fab ebf bce addc dbef ebfa acf dbf daebb dae adf fede bffcc cbac fac faa aebb dbe ddabc bda edc cdb eca ade eadb bab ebe aafb dca afa ead edc fde bcdea fbad cbeaffa ebc cfb cce ffe afec dfae dbd baec ced ade bbbe eac fceb dce acdcf afdd dbb ffa bee fbf eccd aed fae bae ccef bbff aba aebc deaf dea cbac bcd fab eaa eddffc ddcf cea ffe daf bacc aec ecfa ced eeba bca ffc eeb ace cbb fbebadcbac eea efd bcbc babbad ebd fbd fde dcd aca fea aef fcc dfd adc dbb eea adab ada dccb ebb baf bfee babf cbf ebacb fee baa fad ddc cbf fec ccceaca adfc beb bffbfda fbbc bbde fcd fad acfb bde fac eecf fed daa efbcc eee ccb ceef dae bef fff efc dbe bce aedc fbb afeba dfce cad bdb bbf eed aeeca bba ccf ebd dbb dcb cef bee ace dea edcc ebcf fcf efe bad dce bff dbe eaba cef bda febd adbf bccd fbf dfe fffaa cfe bba faf eba ecff bebc cad aeb dae abcd aad ead bdda aef abb cacd dfd bef baf aceedc fcd dae cac cbb eeb daee aecbb cdb dac ceb cac ccf afd fba bdfe ddc fae bac bbb dcee fdd bedd abe ffdc fac bfbb fced dca cda fbb abff dbdbdfb fbd bdc beb eedef dca adad afacb abb aaf ffcc ecbcde eeade eab aac fdea defc cca fba eca bcca acffbc abfbb cfc efb edd ecbd dab fba cadea eaef bdee eba dcda bde caf ebadab adb dddb ead ded aca ccf baeeabc bfb dfafb bade cad cabad fbe eaa cadfed cbbc eda ffc cac abb cbf abd aad fca bacac adb bbfd faf addd aaa ffa daf dee eed eeadd adbfad ede baadcacade bca dfd acbfd bdff ebc fbb fddfc dbc ded bfedfb efdd fbd cdbdef fde abe ddd dff ddab acf faf decad cfb ced fcef dcab bfad cff eaccb dece bee bcc eda bff aaa cec cba bbee eeda fdc cdb acbe fefe adb fcc daed fcfdbb bbbc fcd dbf fdeb fca daade abf dab aea ebf cda dea dadd fab ddbc bce cdd ccd abbdaf aec dff ccf feb dab ccf cbfb aeded afae abda deea bbe fafd ecb ebf abdb babd dcaf aece bbcc caeabff feaa edc deb bce bbba fef fea cff dbd adddb cfadd caa bfbdeed bdc dafcb cbb beb efb dcdf fba fbfe bfcbce cdc ade efd ecb bfe aab ced fbd cca ccd cbe bbcb bbd bbc acfd fbe badd bbdb babdb ceb bbe fbdd bbe fccbe dbffe fac beed fade badbda bef dae dcac aca fef ddb ffa dbd fadd beb fee bade ded ddcc fcfa ccd cab edf bec dfd bcdf fdffb aabc dcc dad eee fca ffbc fde fdb eab eae dafb ecea eaaeb ffc cbdacdd dad aab abc cda fda fce dbe bafad dbc bcd fefe efa daad adec adeb aac ebc eaabf cab ddfaf dae fce beb ffe cdc acdf fbae eba bbbaa acad faf eae bbc dddbfe eabea afadfbf ddde adf ded dff bcb acdd ebf dbc afb bdb ffcb fbc fdad bcd bbd cbd eee aaf bac eefd ccd accd aecb eaa adee dae abd eaa ffe fecf ddd dac aee bdb fdad eaae fefca fdd bba cdb bda dec acb dbdeb fbff abc ddfa cec bdb bff cbcc aac fbc efc eff bea ccc dbd fddf fba adbc aee bede cccf cfa dee dde cff bfd aeba eeab fbbd ddb caa eef accc fee cff dcbd fadbfb afc aec eec bab edb eeadb fccbfc bad dedc eed bbc effa bce ecb caf cde bfea dbb cca cbf eda ffc dbf ffbf cbe efb babf cfa aed bbc dba adb eba ddb dac ccd fffa bedf eec efd aadc dad cbd dbdc fdc fbecadb cef eba dfe feb aee dbb bab bfbfa bfc dcd bdbd dec dac dde dacecd cfc afbdb acffdfdcf cff bdf bdb aad ddfd aff dcafc aaee fef edb fdb adcfddfe cab dad adf adc ecbef cea eaea deb add eaba dca efa eba cfc caa ace accaf bea bebaff bfebc dea faed dbd fcb cdc bbc ceb eaef ccaed cddd fcba efe cccf afa ecbe ceda fdec cda efd aba abdf dfc caccf debc dfda afb cdaa fcc cda cdce dffb cdc aecdd dbc cce ddfe dcdcbc ddaf cleartomark endfont beginfont cmr ps-adobefontcmr creationdate feb copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmr readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmr painttype fonttype fontmatrix readonly encoding array index exch notdef put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup dieresis put dup gamma put dup delta 
put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup put dup put dup put dup ffi put dup ffl put dup dotlessi put dup dotlessj put dup grave put dup acute put dup caron put dup breve put dup macron put dup ring put dup cedilla put dup germandbls put dup put dup put dup oslash put dup put dup put dup oslash put dup suppress put dup exclam put dup quotedblright put dup numbersign put dup dollar put dup percent put dup ampersand put dup quoteright put dup parenleft put dup parenright put dup asterisk put dup put dup comma put dup hyphen put dup period put dup slash put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup colon put dup semicolon put dup exclamdown put dup equal put dup questiondown put dup question put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup bracketleft put dup quotedblleft put dup bracketright put dup circumflex put dup dotaccent put dup quoteleft put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup endash put dup emdash put dup hungarumlaut put dup tilde put dup dieresis put dup suppress put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec cac daf bab edf bcfbe cda dab fcf fce ffafc eeafc fbe edbfe afc fccc faaafd cea cfa ddbad dae dbee dbc dbd cdae befb dbb aceb ffbb adc eae cdef fec cbec dadbfc daf eda eccc cfe eab fae aec bfdde fefb acc bceaa ebda bbc bbcce ace bfcbf dbede dede baea edbc eca ecdab bafe abaaa bdcbc efcc fdc dff bfb ffeafb adb caf febbf eefebd cfc adb efea bdcc baa eabfedaf eac caa fffd cbf dad bee cddc cceff facf dece abe bba adbdf ccaa aecb bcdb ebea bfaff aae bfad beba dae fda caede bbfbecccbf affadc fec fbf dcd ece ffc eca fea ecedcb caaec ddf fca eddf ebfe ffe afc fdc aff aae adf add cbdd edcfc bfe facace fdb bdd bccc cbe aeb dcd bee dad fbaad fca dccbff effd cbd adba ddf deaf dbe adbdc faa bfad bfe ecbf bef cbb dee dbdb ecd defda ddfe daccc aaa beca badedd fbc bfe dcd dea fea ccace afb afb adf dcb bacdadeb feabf ffabd dced ded afc ffb ecb edf bbf fdff eafce ffd aabc cce cbf add bcda ded bebff dfc dbc dbb bceeb edffd aba bbd efdeaaeae ddbbf cbc fdf dbb eafcdd caf ace fec dce dcdc aac fcbedffe bfd cfd accf acb cdd bcaa cad fae ccbdd fffc beed bcee feeb aab dcdb fef dec aabb efd bbc deb ade fbcc dba ebf ecef ebe bfaec cba ddaaa dff ffb daa fde bdf dbb ada fbca afba eea fcf ebe bebef dbeb aea eea efe fca ace bceacd daf bcc cdb abc cef deddcab cbde afb bfa bdff ece adab dcecd ceb aed adb dcfa bfd cdab fab ffac fba ecd decd cabfa dec afef dfa ffd abd fab cdd cca fad cabaf fea dbc cad eded facb fccd fcb adf dca fdc dac dfbc edc daf aea ade aae edd cbb fda aaf fdf adf eedb deb ddab cbac bac aed ccf cac ccbd edf fbb bdfa dbc dee eda dba bfb ecdcefba dbc eabedccfbe cad dec fbe acfbf dea ddbabfbf ebeb caa dfaa bbd beca dcc ceecb bdbfa ceb aab aff cfadf eba cff dcf fcc aaf eec bbdd cae eca bae cace dee fca daf abbe fec ced dbc efd cffad eda beee ece ecb bcb deb cad fafd ece fcd ceac dba fcaae adb aae beb cbcee aae ccf aed cdc eab bbc aee aafb eff dca ffa acd bdcfbc abd fcdfd fbc bda ddfc cff abdb acff ccdad dcf fde eedf fcdc cadec bdb dde eac cafb eaa aaaddba cffd fbfa abcf bfffcdbb dee fee bcd aff dae eca cfb afce dec bad eac daa fca febc dbbbd dcde bad fdfc cdab baf fcf fccb dfb dad bcfbec cde bcbc afa fbbae efda baaaaff fda aee ccdecb fdb cbd bad fad fcffd dcca fcaa baf eeceea eea aed acfa daba cfe deabead afb eca eeea cab aaf fcb bef bec feab fbb cbd adbe ddd eba bba cef fdcbab fba abd dfa adb dfe fda ecf dacff fba fece bfbbe daab ade aaa bef afecd ffe acfdf ecf adcbc cab bcddd bcbdce aee dee abe ebb cdd dcc eeba abc ecf dfbdc cfbc cad fcba ffb ecd edccb ffc eae ddf eaa ddd fdae dba bfeb fee ffe bdc aeab fbd bef bfbc aaef aac dcdae dbd cdbbbb bfb feff dbc bfe cee dfbfd bdaea bfdbc ccd dcf dda ebd aec fff bcec afeb aec afb fad fbc aff fbd eae bdff dbc eec cfa ffbac ebfd bcbda bbfe ceac accf adf aad cfdf cbc fda cab fbdbd ecacbb cdbc afd adc eaed ddaf edc abc ebfe fcd efd bfe cbba add cbe bcf caa dcab aec bce fde bdd aca fbe abe dbcdbe dcefff ebeab bdc acc fdb fabe acb bff fad fec cec eebc ceaebc add aabb fbba eed ebc eeac efdb faba fff ccdf caa bcf bfccc bdc adb bfcc abe ddead dcb adb dbca cba cdef ffe fefcb cae efb ddbe ecad fbe cce eed cafb ada eafc cdd cdb cfbf dde abf dbc cbe fcf dac adeacaea ddf ffa aee dcea 
aba efcdfb aab cdb ffab dab cfe cbc ccbff fbfba cfa bef abccc bdb aeeae bde dab eedaf bdf dcecccd ace ebe cfcf acd cedf fba dee cdb dfba aecfeb cfb adbb cdb affc dcb eecae fbf bece bdfb fbc cfea fccbcd eac bdd bbd dce dde edba eba dcfc afb efd efa fea bee ddecd addedddc aee cfed ede fee dbf aee dfb bdc caaf fff fcdb bcbd ecf dfd bed fcac bac cbf afad cae fbbb acdb eddd ebcd abed ccac dfd eeb fbd dad fbe ffa bdec dead cfacbbeae dfd dddf bdb aca cec feb aef dad fde afd eee bcf adb dec aadc afa ebb debc add dda edf fbeef cfb ecdb bfb fae ffc fde fcd ead cfbcf ecc fea fac fca efac cbceb ceb bac bdc facbef aabfd eaec ecfcc eafdc aea cba daa fbc dbfb add daf eff fea ceaa bca ddf adb beb bca cec cfd ceacc cbb abf dfeeedef cabc caf fad ccb bebecab bdab aca fee ffa dbcc dbdc faf dad adea ece fbb fea eab ccfe efb adeb ceb ddee dff fab ece eabaed baf eda aebb aac abdf bab acda afc cdd eaa fcdac bcf acda aabe aae ecf eeceeded eca cdc fdffc cbbf cba fed ecb eacc dacf cbe bbf efb cdcd eabaf afb abcf cde faa eaab dad ccfdf caccd afe bbb ffc ded ead fcc afcf eba fda ffaf bef abe fdfc dcdce aaf cae cdfab cfaea dcba cae bad acda feef deebcacc edb dcb bbec bfca ffb baaaf bff eee fbba eab cac cecd fba dcbc bbf dcf bfe fdfdcb eff bac afc cbe dbf fef beac ede aeb ced dad dff beaf dfd ecd effbcdb ebecb fcc ddf aba afd bca ceff ffa eeb fbd faf bbd abeaee cdf dbc cdf cbd ade aaa eeaaca cca aba eede bbf eab aab facce dddfd dde bdb abddf fbc bcfe afbfd fca aad aad fcc bba ccbaf bbe eacdc cbea abbe ffd cfce bca fdd fce ffe dee cba bde bbfcfa fdc cad cac cdeb dbc edd adf bae aad ccba bdb baf bac cbb dfd bae edcb bbb cadf bad cee feb beccfa dffcc fecd faa facda eff cded eace bfbcb fcbfc eec fea dfe fcf cbb fde aafa bed dbf ccf fbc eaa efb ffe eae dcb cdfddef fcda cdcff bfa bee fdcbfa ffdd bde bfb eafc bdcd abc adc bdb acba cbdf eee dce abb bfe cde cba ebc afc dfea eaa eed eacbbf dba bfd ecea bedafae eda bff cabc efa feaf eedcac baf cbb aaeacaad ebb aba eed abc dce bbadd ada fad edfbf bef eeb bce bce adae ece ffd fda ada aff cdfb fce fcc dfb dea ccf fbb bed bfa caa cff cfa ebaaf cef bec ddb fcdb eadf fbcc ecd fcb cee ebc efa ade bda fcfc fcb aeb bbc caf ffe ddd ccd add cdf daaafc dcd cebcb decee ccde fcc fbc eca bbbb accb aab dbd adac ade cceec dace cba fba faec bdef dea ffb dcfd bbb ccc eafa ecd bdcf bec fefe dac dfcdc daebbcb edacbb aeb fcbc fdda fde aeeded adbbdb add daca aac bffd dcea fafb abfa efda bef edf ddad cecf fefa aaae eaf fcd ebcb ffa cdd dab bfd dbbe efbf fad bca abbc eaa afcf eca adaeb edbe bfc eda deaf adee aeb cba bee aaa dda eed dbaf bef ccc bcd feb efd aaecf daac fddf ebc fab ebf afd bbe bfaa bafb febf eaba bdc efe add fdac bef fdb bcf fcb cbfb adab cbb bdaeeb bed fca dcc dab bcbdcebd aca cbe dff aec abbe acc fda ade deca eba abae deffbd ddec aebbc deaaf baa ebed eef afbbf bcb cfbc aae cfeb dbda bdf dec dfc cbffde abce dea dfabe fafeb adaecc baeab eeaaed cbcbd ccc ccecae feac abd cea cdf cef ecda dfa efef ebf ece effc bbac efb afdc caebe aad debb ecc bfc adf cec bea ccf dac dfceee ebb fadac dac ffb eeec caba ded adb fdecc dbd aac edd ecadc abf cca bee bbd efb ebfb fbf fee cba dfcc eeb cffb fadfe eabecbee ffc defc aeda bfdd ffdb eab cdd eeccb fbcecf dae cafe adbc dbca baf dfc aae add caaaaeefadd dfb aec cebbd bfb eed efb babc ddf bbfacfb afa faf adadfd fbffd aada fae bab adf aab faf ccf daa fdd bcf bbd bec eeae dde efdb dee edc baeaa eddc efde abb caa debdd fcf efa cbe fcdfb dece baa fad aaef afb daa dabf baf cea dba faeda fee fea aeb fdd bfca cad abd bcc afead ecc eedc fcad cff daae accdc fccd ddfd eafafeb deb cbc eac efd dbe dbc fae cda dab fdf fda fded dea eac dae abb afdf edb cacf bfe ffecaa fbba fcafbc dde eea fbb ece ceea dccf cfe fbd eee ceec fbaa adbdd eea ddc fdcbcb fae edded cdf bdd edcf dbc cda cfb acc cad bac efd cec bcc efba bcfe cdd cbd aeb ace faee fde dbf aaa ddae cdebe dec caba daa caf bcdf dbe dba afbb cbc edc beec cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright blue sky research rights reserved dict begin fontinfo dict dup begin version readonly notice computer modern fonts designed donald knuth readonly fullname cmmi readonly familyname computer modern readonly weight medium readonly italicangle isfixedpitch false end readonly fontname cmmi painttype fonttype fontmatrix readonly encoding array index exch notdef put dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup alpha put dup beta put dup gamma put dup delta put dup epsilon put dup zeta put dup eta put dup theta put dup iota put dup kappa put dup lambda put dup put dup put dup put dup put dup rho put dup sigma put dup tau put dup upsilon put dup phi put dup chi put dup psi put dup tie put 
dup gamma put dup delta put dup theta put dup lambda put dup put dup put dup sigma put dup upsilon put dup phi put dup psi put dup omega put dup alpha put dup beta put dup gamma put dup delta put dup epsilon put dup zeta put dup eta put dup theta put dup iota put dup kappa put dup lambda put dup put dup put dup put dup put dup rho put dup sigma put dup tau put dup upsilon put dup phi put dup chi put dup psi put dup omega put dup epsilon put dup theta put dup put dup rho put dup sigma put dup phi put dup arrowlefttophalf put dup arrowleftbothalf put dup arrowrighttophalf put dup arrowrightbothalf put dup arrowhookleft put dup arrowhookright put dup triangleright put dup triangleleft put dup zerooldstyle put dup oneoldstyle put dup twooldstyle put dup threeoldstyle put dup fouroldstyle put dup fiveoldstyle put dup sixoldstyle put dup sevenoldstyle put dup eightoldstyle put dup nineoldstyle put dup period put dup comma put dup put dup slash put dup greater put dup star put dup partialdiff put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup flat put dup natural put dup sharp put dup slurbelow put dup slurabove put dup lscript put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup put dup dotlessi put dup dotlessj put dup weierstrass put dup vector put dup tie put dup psi put dup space put readonly fontbbox readonly uniqueid currentdict end currentfile eexec fba cdfdddf bfbbfcb fdc add fbd efe fceb ffda dacfdcd bdd abefd fef aaf fea bde ccc effb dbedc cbbbcb ebf eaf efb aadb dfd decd fed cee abcf aaa ead caee dbfe dcdacb feb bdd aaa bbdd deed baa cceaf debc cde fee ebfaa aba bfa efea fec bbc eeda caa ead cba eeeeb cca acaff fdccdb ddd fcc daaff bfa eadfbf ebabdec adc fcc dcf ccf fbe befa eeb efec dbae fac dab acdecdb cefb eef cdf dca caa bfb bfe deff ebb eff fee dcda abe beb cebba cccd eae aed cfe baca ddcd dab cbb bccaf fbe bfb cabe cda acf ddd bda abe efbe eab cef bebb afa eca afa cfb bdcd efbd eed fbeb aba ffc acd bdc aee eff aaf bdaf fbf bef cee fbfabbcec edfd ebf bbf afabd efaf adad edccfb bdaae bca aaff feb ecfeea dfb fae fee ddbf bbcafea cbefc edec aea dbc aae cde bdc cbb deee adc adfa cef aaae cffd adaff bac dbe aef fdfab cdd dba decc fbf ccb dab cbc abf eaedf abca bbddccae ace eecaa cee fda bddc aaa cbbd cdd dae dada eac bde bbf edc bed cbfafd baa fcd cdff bee cdb dbe becbfaed dbcbb ddb bef dafc aae aee aea ebc dbcaeeeea cad cec add dfe eee ecdba caedde eea bfb cecbc cce dbe cfac bbc fac bedd bdeb cbcb bed ceb bdf bdf ffb bba dac cdce aedd dbbda fcce cae adcad baf cab dde decaff bdf caac bbc acfd cbfc aee dbfa efbe adfac edd cef ccaa ddce fec ebe adae ebea bdf aadd dda daa dbca afc bcb afa cce dfeb dcb afb bbb cfd adbe efcf bcfa cad cfb bdfc aab dce ebabcf dfcc cba eaa eee ecef fafe aef dde cbbc eff dfafc eacd bcb afa ddd cee aad fdb dee dbf ced fce feb edfb ddc ffd aae cfa eed faa ddd abab bcece daf beb fdd bbc abf ced cbbd bab dfccbb abe afa bfaa bdaf acc ffc ffc becc edbb bfeeb acebbbe fbf bfa bcc eecdc edad dfa cfa ffd afce bff fdd eaf bef fbc abb daac ffad dee ebd ccb aee aef ebd cab ecf ada cda edc cbfae eacf fedadf fded eab caad eee effe fdc aae caf cfce ead cac ffe eff dfb bafa aeb fcf dfaac edd bce dec edb bef fcb ccebbbba fbcbcc beb adf cdb dcdfd afc afc bfe adc acaa ade eac dee becff dcf cec ceae febb adcc aacde caecc eab dbd cfbe defa dcb accb dacdcc ffcb ace ecc eeda befb fbf fee adafe bdb bbd febfd ada aabfd dbbb ade abd bec ebd dcc aae bde cdf bea caf daaa afb efb dfb efc ebdf aee eba aceb ddb ecd cfa ecea bab dbd afeeea debd cadba fae bea aab fad efc efb ffefa dbb abedd aaa efb eafec cfa ddea fbd bcbff ecc bfb bdb beffc cfdbdb aff cfe cdd aaa eda ceeeb bdb ebbf ece daf aaf beb acc ffb fcb cdcffe cde cabce ffed aee dbeb fbe eee cfe fdcb bcb afa bdd adbd ccbc cfdb abf bda ecbaac faf dfa dfca fbd daeebe add eaf bbcf cbaee dfa adb ece bae dcbd fdb beed bac ebd bdc ddf add aca facc afd aee cbf acbf afb aae acbe fea cceedec ccb bada bcdd acf bde cdcc cab aac fce bfcfb aeb bfb fec bbf ece eaeedc cedce abdf fda adf fda ccbf fcf cabb beb dceb ddd bcf abe dee ccdd 
petal distributed virtual disks edward lee chandramohan thekkath systems research center digital equipment corporation lytton ave palo alto abstract ideal storage system globally accessible unlimited performance capacity large number clients requires management paper describes design implementation performance petal system attempts approximate ideal practice combination features petal consists collection networkconnected servers cooperatively manage pool physical disks petal client collection appears highly block-level storage system large abstract containers called virtual disks virtual disk globally accessible petal clients network client create virtual disk demand tap entire capacity performance underlying physical resources additional resources servers disks automatically incorporated petal initial petal prototype consisting mhz dec workstations running digital unix connected mbit atm network prototype clients virtual disks tolerate recover disk server network failures latency comparable locally attached disk throughput scales number servers prototype achieve rates requests sec bandwidth mbytes sec introduction managing large storage systems expensive complicated process single component failure halt entire system requires considerable time effort resume operation capacity performance individual components system periodically monitored balanced reduce fragmentation eliminate hot spots requires manually moving partitioning replicating files directories paper describes design implementation performance petal easy-to-manage distributed storage system clients file systems databases view petal collection virtual disks shown figure petal virtual disk permission make digital hard copy part work personal classroom granted fee provided copies made distributed profit commercial advantage copyright notice title date notice copying perm ssion acm copy republish post servers redistribute lists requires prior specific permission fee asplos vii usa acm lfs petal client ntfs petal client petal client scalable network petal --a virtual disk bsd ffs petal client figure client view container sparse -bit byte storage space ordinary magnetic disks data read written petal virtual disks blocks addition combination characteristics reduce complexity managing large storage systems tolerate recover single component failure disk server network geographically distributed tolerate site failures power outages natural disasters transparently reconfigures expand performance capacity servers disks added uniformly balances load capacity servers system fast efficient support backup recovery environments multiple types clients file servers databases petal virtual disks cleanly separate client view storage physical resources implement share physical resources flexibly clients offer important services snapshots incremental expandability efficient manner disk-like interface offered petal lower-level service distributed file system distributed file system efficiently implemented top petal resulting system cost scalable network figure physical view disk storage disk storage disk storage disk storage figure petal server modules effective comparable distributed file system implementation accesses local disks directly separating system cleanly block-level storage system file system handling distributed systems problems block-level storage system system easier model design implement tune simplicity important design expected scale large size provide reliable data storage long period time additional benefit block-level interface supporting heterogeneous clients client applications easily support types file systems databases implemented petal servers alpha workstations running digital unix connected digital atm network petal client interface exists digital unix implemented kernel device driver allowing standard unix applications utilities file systems run unmodified petal implementation exhibits graceful scaling performance comparable local disks providing significant functionality design petal shown figure petal consists pool distributed storage servers cooperatively implement single block-level storage system clients view storage system collection virtual disks access petal services remote procedure call rpc interface basic principle design petal rpc interface maintain state needed ensuring integrity storage system servers maintain hints clients clients maintain small amount high-level mapping information route read write requests server request inappropriate server server returns error code causing client update hints retry request figure illustrates software structure petal ovals represents software module arrows module modules liveness module global state module manage distributed system aspect petal liveness module ensures servers system agree operational status running crashed service modules notably global state manager guarantee continuous consistent operation system face server communication failures operation liveness module based majority tfs consensus periodic exchange alive alive messages servers message exchanges timely manner ensure progress arbitrarily delayed reordered affecting correctness petal maintains information describes current members storage system supported virtual disks information replicated petal servers system global state manager responsible consistently maintaining information megabyte current implementation algorithm maintaining global state based leslie lamport paxos part-time parliament algorithm implementing distributed replicated state machines algorithm assumes servers fail ceasing operate networks reorder lose messages algorithm ensures correctness face arbitrary combinations server communication failures recoveries guarantees progress long majority servers communicate ensures management operations petal creating deleting snapshotting virtual disks adding deleting servers fault tolerant modules deal servicing read write requests issued petal clients data access recovery modules control client data distributed stored petal storage system set data access recovery modules exists type redundancy scheme supported system support simple data striping redundancy replication-based redundancy scheme called chaineddeclustering desired redundancy scheme virtual disk virtual disk created subsequently redundancy scheme attributes transparently changed process called virtual disk reconfiguration virtual-to-physical address translation module common routines data access recovery modules routines translate virtual disk offsets physical disk addresses rest section examine specific aspects system greater detail virtual physical translation section describes petal translates virtual disk addresses clients physical disk addresses basic problem translate virtual addresses form virtualdisk-identifier offset physical addresses form serveridentifier disk-identifier disk-offset translation consistently efficiently distributed system events alter virtual disk address translation server vdiskld offset serverld diskld dlskoffset vdiskld offset diskld diskoffset figure virtual physical mapping failure recovery occur unexpectedly figure illustrates basic data structures steps translation procedure important data structures virtual disk directory vdir global map gmap physical map pmap dotted lines virtual disk directory global map global data structures replicated consistently updated servers global state manager server physical map local server translating client-supplied virtual disk identifier offset disk offset occurs steps shown figure virtual disk directory translates client-supplied virtual disk identifier global map identifier global map determines server responsible translating offset physical map server translates global map identifier offset physical disk offset disk minimize communication cases server performs translation step server performs translation step client initially request server server perform steps translation locally communicating server global map virtual disk specifies tuple servers spanned virtual disk redundancy scheme protect client data stored virtual disk tolerate server failures secondary server assigned responsibility mapping offset primary global 
maps immutable change virtual disk tuple servers redundancy scheme virtual disk assigned global map section describing reconfiguration details process physical map actual data structure translate offset virtual disk physical disk offset disk similar page table virtual memory system physical map entry translates kbyte region physical disk server performs translation perform disk operations needed service original client request separation translation data structures global local physical maps bulk mapping information local minimizes amount information global data structures replicated expensive update support backup petal attempts simplify client backup procedure providing common mechanism applied clients automate backup recovery data stored system mechanism petal fast efficient snapshots virtual disks copy-on-write techniques petal quickly create exact copy virtual disk point time client treats snapshot virtual disk modified supporting snapshots requires slightly complicated virtual-to-physical translation procedure previous section virtual disk directory translate virtual disk identifier global map identifier tuple global-map-identifier epoch-number epoch-number monotonically increasing version number distinguishes data stored virtual disk offset points time tuple global-map-identifier epoch-number physical map step translation system creates snapshot virtual disk tuple epoch number created virtual disk directory accesses original virtual disk made epoch number older epoch number newly created snapshot ensures data written original virtual disk create entries epoch overwriting data previous epoch read requests find data recently written offset recent epoch creating snapshot consistent client application level requires pausing application time takes create petal snapshot alternative approach require pausing application create crash-consistent snapshot snapshot similar disk image left application crashed snapshots made consistent application level running application-dependent recovery program sck case unix file systems implementing crash-consistent snapshots supported snapshots on-line facilitate recovery accidentally deleted files snapshot behaves read-only local disk petal client create consistent archives data utilities ear incremental reconfiguration occasionally desirable change virtual disk redundancy scheme set servers mapped change precipitated addition removal disks servers section describes petal incorporates disks servers existing virtual disks reconfigured advantage resources processes point view adding resources easily generalized removal resources process referred virtual disk reconfiguration primary focus section addition adisk server handled locally server subsequent storage allocation requests automatically disk consideration load balance desirable redistribute previously allocated storage disk redistribution easily accomplished part local background process periodically moves data disks implemented background process petal nonetheless existing data redistributed newly added disks side-effect virtual disk reconfiguration addition petal server global operation composed steps involving global state management module liveness module server added membership petal storage system server participate future global operations sets servers liveness module determining server adjusted incorporate server finally existing virtual disks reconfigured advantage server process virtual-to-physical translation procedure section absence activity system virtual disk reconfiguration trivially implemented create global map desired redundancy scheme server mapping change virtual disk directory entries refer global map refer redistribute data servers translations global map data distribution potentially require substantial amounts network disk traffic challenge perform reconfiguration incrementally concurrently processing normal client requests find acceptable procedure takes hours degrade performance system significantly virtual disk reconfigured server added performance virtual disk gradually increase reconfiguration level reconfiguration level reconfiguration describe reconfiguration algorithm steps describe basic algorithm refinement algorithm refined algorithm implemented system basic algorithm steps executed starting translations recent epoch moved data transferred collection servers global map amount data moved reconfiguration long time complete meantime clients read write data virtual disk reconfigured accommodate requests read write procedures designed function client read request serviced global map translation found global map ensures translations moved found global map client write requests access global map move data starting recent epoch ensure read requests return data older epoch requested client main limitation basic algorithm server mappings entire virtual disk changed data moved means client read request submitted based global map miss global virtual disk arver server server server figure chained-declustering map forwarded require additional communication servers potential degrade performance system refined algorithm solves limitation basic algorithm relocating small portions virtual disk time basic idea break virtual disk address range regions fenced requests regions simply global maps requests fenced region basic algorithm relocated fenced region region fence part region repeat moved data region region keeping relative size fenced region small roughly ten percent entire range minimize forwarding overhead guard fencing heavily subrange virtual disk construct fenced region collecting small non-contiguous ranges distributed virtual disk single contiguous region data access recovery section describes petal chained-declustered data access recovery modules modules give clients highly access data automatically bypassing failed components dynamic load balancing eliminates system bottlenecks ensuring uniform load distribution face component failures start describing basic idea chained-declustering move detailed descriptions read write operation figure illustrates chained-declustered data placement scheme dotted rectangle emphasizes data storage servers single virtual disk clients sequence letters represents block data stored storage system note copies block data stored neighboring servers pair neighboring servers data blocks common arrangement server fails servers automatically share server read load server experience load increase performing dynamic load balancing server copies data servers servers offload normal read load server achieve uniform load balancing chaining data placement server offload read load server immediately preceding server cascading offloading multiple servers uniform load maintained surviving servers contrast simple mirrored redundancy scheme replicates data stored servers failure result load increase opportunities dynamic load balancing system stripes mirrored servers load increase single server reduce system throughput current prototype implements simple dynamic load balancing scheme client track number requests pending server sends read requests server shorter queue length works requests generated clients work requests generated clients occasionally issue requests choice load balancing algorithm active area research petal project additional advantage chained-declustering placing even-numbered servers site oddnumbered servers site tolerate site failures disadvantage chained-declustering relative simple mirroring reliable simple mirroring server failed failure mirror server result data unavailable chained-declustering ifa server falls failure neighboring servers result data unavailable implementation chalned-declustering copies data block denoted primary denoted secondary read requests serviced primary secondary copy servicing write requests start primary server primary case start secondary lock copies data blocks reading writing guarantee consistency ordering guarantee avoid deadlocks read request server receives request attempts read requested data successful server returns requested data returns error code client server request times due network congestion server client alternately retry primary 
secondary servers request succeeds servers return error codes indicating satisfy request disks copies requested data destroyed write request server receives request checks primary data element primary marks data element busy stable storage simultaneously sends write requests local copy secondary copy requests complete busy bit cleared client issued request status code indicating success failure operation primary crashes performing update busy bits crash recovery ensure primary secondary copies consistent write-ahead-logging group commits makes updating busy bits efficient optimization cleating busy bits lazily maintain cache recently set busy bits write requests display locality busy bit set disk require additional server received write request secondary data element service request determine server primary copy lio -iio- digital atm network figure petal prototype case secondary marks data element stale stable storage writing local disk server primary copy eventually bring data elements marked stale up-to-date recovery process similar procedure primary secondary dies implementation performance petal prototype illustrated figure mhz dec running digital unix act server machines runs single petal server user-level process accesses physical disks unix raw disk interface network udp unix sockets server machine configured digital disks inch scsi device gbyte capacity machine disks write-ahead logging remaining store client data disks connected server machine mbyte fast scsi strings digital pmzaa-c host bus adapter additional machines running digital unix configured petal clients generate load servers client kernel loaded petal device driver accessing petal virtual disks clients access petal virtual disks local disks servers clients connected mbit atm links digital atm network entire petal rpc interface calls calls devoted management functions creating deleting virtual disks making snapshots reconfiguring virtual disk adding deleting servers calls typically user-level utilities perform tasks virtual disk creation monitoring physical resource pools system determine additional servers disk added petal rpc calls implement management functions infrequently executed generally complete create snapshot operations milliseconds delete reconfiguration milliseconds initiate total execution time dependent actual amount physical storage virtual disk remainder section report performance accessing petal virtual disk behavior file systems built petal primary performance goals provide latency roughly comparable locally attached disk throughclient request latency local disk petal request byte read log nvram log kbyte read kbyte read byte write kbyte write kbyte write table latency chained-declustered virtual disk put scales number servers performance gracefully degrades servers fail petal performance section examines read write performance petal chain-declustered virtual disk read request client makes rpc petal server simply returns data local disk server receives write request writes small log entry recover consistent state server crash server simultaneously writes data local disk disk mirror server disk writes complete primary server replies client read write procedures petal greater detail section table compares read write latency chaineddeclustered petal virtual disk local disk experiment single client generates requests size random disk offsets show petal performance kinds write-ahead-logging devices disk nvram device simulated ram log device service write requests affect read performance logging nvram improves write latency approximately read requests bytes kbytes petal latency slightly worse kbyte reads latency gap widens increased latency due additional delay transmitting data network includes unix socket udp atm hardware overheads accounts petal server software client interface overheads negligible overlapped reading data disks transfer data network eliminate overhead nvram log device petal write performance worse local disk addition network delay sending data primary server additional delay primary send data mirror server wait acknowledgment returning client latencies due network transmissions approximately byte kbyte kbyte write requests arms spindles primary secondary disks unsynchronized lack synchronization write requests wait slower primary secondary disk writes column table shows peak throughput chained-declustered petal virtual disk log device peak write throughput higher nvram log device small request sizes express throughput number requests larger request sizes shown megabytes measure aggregate throughput log request normal failed normal byte read req req kbyte read mbytes laboratories technical report sufficient processor power disk scheduling based rotational position disk arm position shown provide improved performance taxonomy algorithms based shortest access time satf developed explored simulations access-time based algorithms match outperform seek-time studied aged shortest access time asatf forms continuum fcfs satf equal superior response time variance entire range authors notes writing paper work margo seltzer peter chen john ousterhout seltzer set similar ideas published year wrote report people citing work cited original document physical cut paste graphics electronic version includes scanned images original document marked vertical bar left margin copyright hewlett-packard company rights reserved disk scheduling algorithms based rotational position david jacobson john wilkes concurrent systems project palo alto technical report hpl csp rev february revised march issued electronically introduction widely algorithm scheduling disk requests scan algorithm disk arm alternatively moved edge disk back arm crosses cylinder requests serviced goal disk scheduling algorithms reduce disk arm motion makes sense seek times dominant performance factor impossible rotational position processing power interrupt structure host computer limits amount responsiveness computation disk driver conditions require reconsidering design principle years rotational speed disks increased slightly full stroke seek time shortened significantly table shows sample values late vintage drive modern hewlett-packard smaller diameter date introduction processor speed increased tremendously availability abundant cycles enables scheduling algorithms finally work initially motivated datamesh project hewlettpackard laboratories research effort developing parallel storage server smart storage surface array closely-coupled disk processor modules connected fast reliable mesh module disk mips processor primary ram close coupling cpu disk means processor rotational position disk time request executed channel contention introduce uncertainty conditions make practical design disk scheduling algorithm based rotational position primary consideration begun context datamesh ideas directly applicable systems including device drivers smart disk controllers previous work simplest algorithm service requests order arrive served fcfs algorithm poor performance lightest loads wastes lot time moving areas disk relative time spent transferring data seek time data ibm inferred seek time versus distance graph frank disk diameter rotation speed full-stroke seek time rotations ibm rpm rpm rpm rpm rpm scan request queue request nearest head positioned process traditionally nearest calculated difference cylinder numbers technique shortest seek time sstf periods high load requests arriving area disk arm stick region leaving requests waiting long time starvation problem absence complete starvation phenomenon increases service time variance scan algorithm proposed denning denning sweeps back disk stopping cylinder pending requests variation scan sweep direction end disk reached seek back beginning wong shown bidirectional scan good unidirectional independent arrivals wong bsd version unix one-way algorithm gave behavior readahead leffler scan suffers starvation lesser degree sstf authors proposed adaptations overcome problem approach scan delay recent arrivals sweep gotlieb purported unix system implementations control starvation limiting number requests cylinder serviced moving performance fcfs sstf scan extensively studied literature denning coffman gotlieb oney wilhelm hofri coffman geist daniel proposed continuum algorithms called parameter geist idea pick request sstf add penalty times total number cylinders reversing direction sstf scan suggest good compromise performs scan avoids high variance starvation difficulties sstf time requests arriving disk queue presence large queue lengths surprisingly common figure plots queue lengths experienced ten minute trace time sharing system disk model analysis algorithms presented parameterized performance scsi disk drive drive platters data surfaces physical cylinders sectors bytes track total formatted capacity platters rotate rpm settling time switching tracks cylinder notation algorithms confused two-way algorithm called scan word elevator leffler elevator one-way algorithm unix registered trademark united states countries licensed exclusively open company limited figures presented derived measuring sample drive agree published product specifications long seeks modern disks accelerate disk arm maximum velocity coast constant velocity decelerate back finally settle desired track short seeks arm accelerates halfway point decelerates settles giving seek time form seek distance cylinders long seeks arm reaches terminal velocity seek time form functions form fit measured performance data results seek time milliseconds shown graphically figure rotationally-sensitive scheduling algorithms total access time combines seek rotational latencies traditionally represented rotational delay experienced head arrived correct cylinder modern disks seek time rotational latency natural formula shows combined cost rotational latency basis convenient scale access times time disk rotate sector transfers start stop sector boundaries units equation access time repositioning cost head movement figure frequency queue lengths traverses cylinders sectors number sectors track current head position seek time shown demonstrate graphically significant effect rotation latency behavior access time figure plots access time function cylinder horizontal sector vertical offsets notice large area disk accessible rotational latency suggests strongly rotational delay considered equal footing seek time disk scheduling decision remainder section introduces scheduling policy subsequent sections discuss variations present result simulations performance optimal access time request disk optimal access time oat algorithm considers combinations requests queue performs optimal scheduling decision requests efficient algorithm optimal scheduling result oat theoretical upper bound scheduling performance fortunately greedy algorithms make choice choice remains good approximations fully optimal calculation test experimentally issued clumps random requests greedy scheduler optimal scheduler compared average execution time resulting schedules clumps length greedy algorithm resulted schedules longer optimal problem special case well-known traveling salesman problem decision problem exist schedule completed stated bound np-complete mbytes kbyte read mbytes mbytes byte write req kbyte write mbytes kbyte write mbytes req mbytes mbytes table normal failed throughput chained-declustered virtual disk byte read kbyte read kbyte read byte write kbyte write kbyte write number servers figure scaling increased servers peak throughput petal clients shown figure make random requests single petal virtual disk throughput limited cpu overheads cases server cpu approximately utilized significant fraction time spent copying checksumming data network access petal servers run user-level standard unix socket interface udp protocol stacks techniques streamlining network accesses understood experiment eliminated copying checksums network layer large read requests kbyte read requests optimization reduced cpu utilization increased throughput mbytes mbytes case throughput limited disk controller column table shows performance chaindeclustered petal disk servers crashed read requests performance normal three-quarters servers three-quarters normal performance data placement dynamic load balancing schemes working effectively redistribute load write performance failure normal case servers fail virtual disk addresses managed servers longer mirrored reduces number disk writes system fraction failed servers load surviving server server failure figure shows effect scaling petal servers throughput request type normalized respect maximum throughput request type elapsed time seconds phase petal petal create directories copy files directory status scan files compile table modified andrew benchmark system configurations measured large determine scaling remain linear observed scaling promising file system performance petal clients large virtual disk clients network cluster file systems xfs parallel databases oracle parallel server advantage fact concurrently accessing single virtual disk multiple machines systems widely restrict attention digital unix file system ufs advanced file system advfs table compares performance modified andrew benchmark configurations ufs locally attached disk ufs petal virtual disk advfs collection locally attached disks advfs petal virtual disk petal virtual disk configured chain-declustered data placement disk logging modified andrew benchmark phases phase recursively creates subdirectories phase measures file system data transfer capabilities phase recursively examines status directories files contained fourth phase scans contents data stored file final phase indicative program development phase computationally intensive cases file system level performance petal virtual disk comparable locally attached disks exception phase benchmark ufs generates synchronous writes mentioned earlier writes chalned-declustered petal virtual disk incur logging overheads increase synchronous write latency advfs journals meta-data updates reduce number synchronous writes suffer overheads running petal achieves higher performance ufs phase benchmark local disk measurements ufs single disk 
advfs disks achieve similar performance modified andrew benchmark primarily stresses latency throughput storage system case compilation phase performance primarily limited speed cpu discussion availability cost-effective scalable networks driving force work thinking network primary system-level interconnect build incrementally expandable distributed storage systems availability capacity performance current centralized storage systems distributed storage systems pose difficult management consistency problems petal experiment address problems petal virtual disks hide distributed nature system clients independent applications share performance capacity physical storage resources system transparently incorporate storage components provide convenient management features snapshots provide special support protecting client data clients difficult provide security virtual disk basis petal virtual disk abstraction adds additional level overhead prevent application-specific disk optimizations rely careful placement data problem reasonable tradeoff benefits petal provide view virtualization current trend sophisticated disk array controllers scsi disks obscure physical disk geometry fact petal server approximately complexity raid controller similar hardware resource requirements petal disk-like interface clients read write blocks data chose interface easily integrated existing computer system transparently support existing file systems databases alternative petal design distributed storage richer interface file system cmu nasd project potentially result system efficient simpler petal interface adequate higher level services efficiently built top petal framework sufficiently general incorporate classes redundancyschemes based parity chosen concentrate replication-based redundancy schemes chained-declustering impose higher capacity overhead readily applicable tolerating site failures present opportunities dynamic load balancing easier implement efficiently distributed systems related work section describes work related petal terms primary characteristics type abstraction block-level file-systemlevel degree distribution level fault tolerance support incremental expandability related block-level storage systems include raid-ii tickertaip logical disk loge mime autoraid swift systems support simple algorithmic mappings address space client underlying physical disks mapping completely system configured contrast autoraid logical disk loge mime petal support flexible mappings index data structures autoraid petal systems support creation multiple virtual disks block-level systems including autoraid support distribution multiple nodes geographically distributed sites exceptions tickertaip swift provide support distributing data multiple nodes assume communication interconnect reliable deal full range distributed systems issues addressed petal systems tolerate disk failures tickertaip tolerate node failures contrast petal supports wider distribution tolerate node network failures closely related file systems include xfs zebra echo afs systems xfs single meta-data server partial subtree file system space ultimately limiting scalability xfs distribute management meta-data multiple nodes object-by-object basis file systems suffer problem file disk systems considered incrementally expandable sense data dumped tape restored adding extra components reconfiguring system systems step zebra autoraid disks incorporated system dynamically transparently respect clients afs nodes added volumes partial subtrees file system space moved nodes transparently afs volume span single node contrast petal virtual disk span multiple nodes goal xfs design change management node file dynamically load balancing response node additions deletions functionality implemented petal supports addition deletion nodes system face arbitrary node network failures petal virtual disk span multiple nodes transparently reconfigured advantage additional nodes reconfiguration transparent petal clients knowledge petal distributed block-level storage system supports virtual containers managing physical resources difficult storage system larger distributed found distribution virtual containers powerful combined distribution system scale large sizes virtual containers make easier allocate physical resources efficiently large-scale systems petal storage system supports transparent addition deletion nodes existing storage containers face arbitrary component network failures system-level performance single container scale gracefully additional nodes added summary conclusions petal distributed block-level storage system tolerates recovers single component failure dynamically balances load servers transparently expands performance capacity principal goal design storage system heterogeneous environments easy manage scale gracefully capacity performance significantly increasing cost managing system found combination features achieve goal actual system significant period time conclusively prove assertion designing petal decided distributed software solutions hardware solutions applicable software hardware tradeoff petal strategy fault tolerance distributed mirroring providing redundant hardware paths disk approach makes easier geographically distribute system scale larger system sizes tradeoff distributed algorithms determine servers failed generally achieve consensus reliable communication hardware specialized hardware synchronization petal block-level file-level interface petal handle heterogeneous client file systems gracefully choice block-level interface greatly simplified work adversely limiting functionality provide opens possibility encapsulating petal server software disk array controller raid software encapsulated disk array controllers today petal virtual disks proved invaluable separating client view storage physical resources system virtualization makes easier allocate physical resources heterogeneous clients enabled features snapshots transparent incremental expandability generally satisfied performance prototype read write latencies chain-declustered petal virtual disk larger locally attached disk achieve rates requests sec small read requests bandwidth mbytes sec large read requests throughput write request understand improve performance significantly performance petal degrades gracefully fraction number failed servers throughput system scales number servers measured sufficiently large system determine performance scaling linear feel confident prototype running past months working building larger production system deployment day-to-day laboratory acknowledgments authors roger needham mike schroeder bill weihl anonymous referees comments earlier drafts paper cynthia hibbard provided valuable editorial assistance thomas anderson michael dahlin jeanna neefe david patterson drew roselli randolph wang serverless network file systems acm transactions computer systems february thomas anderson susan owicki james saxe charles thacker high-speed switch scheduling localarea networks acm transactions computer systems november andrew birrell bruce jay nelson implementing remote procedure calls acm transactions computer systems february luis-felipe cabrera darrel long swift distributed disk striping provide high data rates acm computing systems fall pei cao swee boon lim shivakumar venkataraman john wilkes tickertaip parallel raid architecture acm transactions computer systems august chao english jacobson stepanov wilkes mime high performance parallel storage device strong recovery guarantees technical report hpl-csp- hewlett-packard laboratories november peter chen edward lee ann drapeau ken lutz ethan miller srinivasan seshan ken shirriff david patterson randy katz performance design evaluation raid-ii storage server journal distributed parallel databases july wiebren special jonge cases frans kaashoek found wilson np-complete hsieh garey logical disk conjecture approach improving file figure systems seek time proceedings versus seek distance acm symposium cylinders operating systems principles pages extended simple december experiment peter druschel larry short-sighted oat peterson algorithm bruce davie optimally experiences scheduled high-speed batches network requests adaptor software head queue compared full greedy algorithm remaining requests queue short-sighted greedy algorithm looked requests queue sliding window oat algorithm pulled request queue scheduled dispatched table shows results relative full greedy algorithm examining entire queue perspective enormous proceedings win compared sigcomm symposium optimal scheduling communications mid-sized architectures batches protocols requests applications reason pages oat august pick distant english request order stepanov gain loge time self-organizing servicing disk requests controller proceedings occur isolation winter usenix requests conference arriving pages service january batching garth algorithm gibson david taking nagle advantage khalil amiri fay produce chang eugene feinberg schedule howard gobioff chen results lee berend pursue ozceri erik oat riedel algorithms david rochberg shortest access case time network-attached 
shortest secure access disks time technical report satf algorithm cmu-cs- department approximation electrical oat computer greedy engineering scheduler carnegie-mellon access time june scheduling john parameter hartman john seek distance ousterhout zebra direct striped analogue network sstf file algorithm system relative acm performance transactions short-sighted computer oat sliding systems window oat august short-sighted hui-i greedy hsiao full david greedy dewitt figure chained access time declustering availability strategy function multiprocessor database cylinder machines sector technical sector report left cylinder wisconsin madison middle june cylinder leslie times lamport uniform part-time horizontally parliament technical region report implementation digital equipment satf corporation closely sstf queue systems pending research center lytton ave palo alto september timothy mann andrew birrell andy hisgen chuck jerian garret swart coherent distributed file cache directory write-behind transactions computer systems satyanarayanan scalable secure highly distributed file access ieee computer daniel stodolsky mark holland william courtright garth gibson parity-logging disk arrays acm transactions computer systems august chandramohan thekkath henry levy limits low-latency communication high-speed networks acm transactions computer systems john wilkes richard golding carl staelin tim sullivan autoraid hierarchical storage system proceedings acm symposium operating systems principles pages december 
requests scanned access time calculated request head position disk idle calculated head position end current request 
easily implemented assistance small static array holding seek times seek distance reduce number requests scanned dividing disk number bins figure encompasses connected region access-time graph shown figure request arrives put bin target portion disk time calculate schedule bins searched order depends current head position order pre-computed stored small array indexed head position figure shows bin search order head sector middle cylinder cells lie sides head trajectory requests accessed revolution cope threshold worst cell calculated cell worst time good request cell request split cell met limit search continues split cells numbered good requests bad avoid scan keeping track request bad side split cell request replaces search terminates cell encountered worst cell assume simplicity disk command queueing worse reordering ignore effects spared sectors tracks figure disk divided cells ordering happen cell scan list bin orderings worst values small held -element grid algorithm figure illustrates detail taccess time access request head position reducing starvation starvation requests continue arrive chosen servicing queue avoid refuse temporarily admit requests queue accumulated side future time considered scheduling pool requests scheduled decreases size likelihood disk optimally utilized declines population candidates small selection requests fit neatly holes schedule maintaining high disk efficiency requires pool candidates scheduling large avoiding starvation requires requests allowed indefinitely delay reduces efficient disk result compromise required sstf satf subject starvation conditions engender complex nearness dynamic function rotational position effect section introduces number variations satf address starvation problem limiting time request remain unserved reduce variance service time eliminate starvation expense maximum throughput approach presented responds starvation forcibly scheduling oldest request variations theme mollify tendency approach degenerate fcfs highload conditions starvation approach avoids starvation batching requests preventing considered batch processed variations theme requests scheduled long delay execution current batch bestsofar nil current head position cell order current head position request cell taccess taccess bestsofar bestsofar endfor taccess bestsofar tworst cell exit returning bestsofar endfor exit returning bestsofar figure efficient satf algorithm finally approach avoids starvation modifying criteria select deserving request processed adding age-related amount calculated access time selecting selected forcibly scheduling oldest request shortest access time urgent forcing satfuf algorithm shown figure forcibly schedules oldest request executed immediately aged minimize effect disk throughput requests scheduled front scheduled doesn delay oldest request symbols addition length length request sectors simulations showed satfuf good algorithm requests spliced front oldest request starvation behavior triggered performance approximates fcfs typically arrival rate exceeded capacity fcfs clear backlog response time recovers result dropped pure satfuf set simulated algorithms modification satfuf forcibly select oldest requests schedule slotting additional requests accommodated delaying schedule called shortest access time urgent forcing satfuf satfuf family batch algorithms discussed section approach improving satfuf starts selecting oldest request aged inserts whole-rotations worth slack executed requests scheduled intervening time gap requiredreq nil current head position oldest oldest request nil bestsofar cell order current head position request cell nil taccess length taccess taccess make reach losing revolution taccess taccess bestsofar bestsofar endfor bestsofar worsttime cell exit returning bestsofar endfor exit returning bestsofar figure satfuf algorithm number requests swallowed parameterized algorithm called shortest access time delayed forcing satfdf variations schedule inserted requests aren forcibly scheduled perfect optimization rotation times delay entire request queue eligible consideration factorial behavior renders approach computationally intractable approximate optimal assignment greedy algorithm greedy algorithm deadline forced request begin determine cutoff point knowledge end ideal head positioned close access time start forcible request practice uniformlydistributed random repositioning delay introduced greedy algorithms working forward current head position backwards end point computed portion forward algorithm spliced portion backwards point minimizes resulting dead time coax head forced request heuristic guide greedy algorithm selection algorithm called shortest access time guided delayed forcing satfgdf note variation require examining entire queue scheduling step pseudocode figure satfgdf static variable deadline survives request number revolutions oldest scheduled future typically hueristic function larger returns desirable choice static deadline initially nil oldest request current time sectors current head position deadline nil deadline taccess bestsofar request taccess length taccess deadline make reach oldest deadline deadline-t bestsofar deadline-t bestsofar endfor bestsofar deadline nil exit returning bestsofar figure satfgdf algorithm possibilities heuristic function function maximized yield good schedule number additional requests reached end request reaching remaining time make complexity selection request quadratic number remaining requests linear complex simply returning taccess virtually identical satfdf coax head oldest request heuristic appealing area disk reached remaining time figure illustrates idea plot area heuristic curves distance deadline plotted starting cylinder number family parabolas area metric directly moderately expensive compute store approximation developed effect edge disk quadratic function distance area heuristic computed quadratic function fit figure coefficients stored arrays indexed remaining time sectors linear term quadratics centered batch algorithms batch algorithms prevent starvation temporarily preventing requests joining queue delaying indefinitely batch algorithms continuously two-mode fashion invoked starvation observed bring check prevent occurrences two-mode behavior attempts benefit high throughput satf limiting damage caused starvation batch technique figure area accessible disk space simplest algorithm batched shortest access time bsatf operates processing requests queue completion admitting greedy algorithm optimization variant relaxes requests rule called leaky batched shortest access time lbsatf bsatf batch acquired scheduled greedy algorithm projected end time remembered deadline request arrives added batch schedule found complete existing requests existing deadline request put batch bsatf forward progress guaranteed requests accommodated satfuf variety two-moded batch algorithm modified selection criteria avoid starvation needed oldest requests removed strictly positive rate queue choice rate influences long request sit queue higher rate shorter time request stuck weight scheduling algorithm choice deserving request account age aged shortest access time asatf algorithm calculates merit request queue age calculated access time modified proportional time age request waiting queue units sectors weighting factor varied pure satf infinity pure fcfs sense similar algorithms geist covers spectrum sstf scan figure approximations area heuristic times deadline performance simulator constructed model behavior disk including seek time rotational latency transfer time run warmup requests generated real requests indefinite number warm requests real requests tracked measured simulation terminated real requests completed data point response time curves corresponds results twenty experiments requests uniformly distributed disk exponentially distributed interarrival times requests uniform size transfer size common unix file 
systems simulation carried range arrival rates low capacity scheduling algorithm handle arrival rate service time percentile service time distribution collected -bin histogram response times collected percentile arrived interpolation histogram simulations fcfs scan sstf satf satfuf satfdf satfgdf quadratic heuristic asatf conducted results shown figure method replications pawlikowski estimate confidence intervals cases narrow figure shows graphically plotting error bars representing confidence intervals response time arrival rate curve asatf algorithm results algorithms perform equally low arrival rates queue lengths short fcfs good algorithm algorithms seek time basis distinctly fcfs ranked metrics performances figure service time distributions asatf range arrival rates showing confidence intervals throughput scan sstf starvation resistance scan sstf rotational-sensitive algorithms performed seek-time based algorithms increasing order goodness metrics shown algorithms performed throughput satfdf satfgdf asatf satf starvation resistance satfdf satfgdf satf asatf asatf shows performance chose exploring performance asatf algorithm function high-load case arrival rate requests figure plots standard deviation percentile rankings obtained comparing request rates sustainable fixed high response times means percentiles figure upper percentile lower service times scheduling algorithms range arrival rates response time range values performance measures good values range conservatively choose conclusion disk scheduling algorithms based access time proposed promising studied well-known algorithms simulation algorithms perform low arrival rates higher arrival rates access-time algorithms match outperform seek-time studied algorithm asatf sustain higher throughput sstf response time terms request rates percentile response times asatf outperforms sstf request rate asatf worse satf response time percentile response time finally asatf sustain higher throughput rate scan maintaining percentile response time seconds percentile response time seconds asatf sustain throughput higher scan heretofore goal disk scheduling algorithms minimize disk arm motion work shows goal minimizing access time taking account rotational position improve maximum disk throughput modern disks simulation results reported based load exponential interarrival times uniform distribution requests disk couple months plan test algorithms traces real system activity coffman coffman klimko ryan analysis scanning policies reducing disk seek times siam journal computing september coffman coffman hofri expected performance scanning disks siam journal computing february denning denning effects scheduling file memory operations proceedings afips spring joint computer conference atlantic city jersey april pages april frank frank analysis optimization disk storage devices time-sharing systems journal acm october garey garey johnson computers intractability guide theory npcompleteness freeman geist geist daniel continuum disk scheduling algorithms acm transactions computer systems february gotlieb gotlieb macewen performance movable-head disk storage systems journal acm october hofri hofri disk scheduling fcfs sstf revisited communications acm november figure standard deviation percentile response time versus asatf arrivals leffler leffler mckusick karels quarterman design implementation bsd unix operating system addison-wesley oney oney queueing analysis scan policy moving-head disks journal acm july pawlikowski pawlikowski steady-state simulation queueing processes survey problems solutions computing surveys june seltzer margo seltzer peter chen john ousterhout disk scheduling revisited proceedings winter usenix technical conference washington january pages wilhelm wilhelm anomaly disk scheduling comparison fcfs sstf seek scheduling empirical model disk accesses communications acm january wong wong algorithmic studies mass storage systems computer science press taft court rockville 
technical report rev file system design nfs file server appliance dave hitz james lau michael malcolm networkappliance presented january usenix winter san francisco california copyright usenix association reproduced permission file system design nfs file server appliance rev network appliance corporation-printed usa north bemardo avenue mountain view rights reserved part covered copyright reproduced form means-graphic electronic mechanical including photocopying recording taping storage electronic retrieval system-without prior written permission copyright owner network appliance reserves change products time notice network appliance assumes responsibility liability arising products expressly agreed writing network appliance purchase product convey license user patent rights trademark rights intellectual property network appliance product protected patents foreign patents pending applications restricted rights legend duplication disclosure government subject restrictions set subparagraph rights technical data computer software clause dfars october june trademark acknowledgment faserver wafl snapshot trademarks network appliance sunos nfs pc-nfs registered trademarks sun microsystems unix registered trademark united states countries licensed exclusively open company limited ethernet registered trademark xerox corporation intel registered trademark intel corporation products services mentioned document identified trademarks service marks product names designated companies market products inquiries trademarks made directly companies file system design nfs file server appliance rev table contents abstract introduction introduction snapshots user access snapshots snapshot administration wafl implementation overview meta-data lives files tree blocks snapshots file system consistency non-volatile ram write allocation snapshot data structures algorithms block-map file creating snapshot performance conclusion bibliography biographies file system design nfs file server appliance rev abstract network appliance recently began shipping kind network server called nfs file server appliance dedicated server sole function provide nfs file service file system requirements nfs appliance general-purpose unix system nfs appliance optimized network file access appliance easy paper describes wafl write file layout file system designed specifically work nfs appliance primary focus algorithms data structures wafl implement snapshots read-only clones active file system wafl copy-on-write technique minimize disk space snapshots consume paper describes wafl snapshots eliminate file system consistency checking unclean shutdown file system design nfs file server appliance rev introduction appliance device designed perform function recent trend networking provide common services appliances generalpurpose computers instance special-purpose routers companies cisco bay networks replaced general-purpose computers packet routing general purpose computers originally handled routing examples network appliances include network terminal concentrators network servers network printers type network appliance nfs file server appliance requirements file system operating nfs appliance general purpose file system nfs access patterns local access patterns special-purpose nature appliance affects design wafl write file layout file system network appliance corporation faserver nfs appliance wafl designed meet primary requirements provide fast nfs service support large file systems tens grow dynamically disks added provide high performance supporting raid redundant array independent disks restart quickly unclean shutdown due power failure system crash requirement fast nfs service obvious wafl intended nfs appliance support large file systems simplifies system administration allowing disk space belong single large partition large file systems make raid desirable probability disk failure increases number disks large file systems require special techniques fast restart file system consistency checks normal unix file systems unacceptably slow file systems grow nfs raid strain write performance nfs servers store data safely replying nfs requests raid read-modify-write sequence maintain parity patterson led non-volatile ram reduce nfs response time write-anywhere design wafl write disk locations minimize raid write performance penalty write-anywhere design enables snapshots turn eliminate requirement time-consuming consistency checks power loss system failure file system design nfs file server appliance rev introduction snapshots wafl primary distinguishing characteristic snapshots read-only copies entire file system wafl creates deletes snapshots automatically prescheduled times snapshots on-line provide easy access versions files snapshots copy-on-write technique avoid duplicating disk blocks snapshot active file system blocks active file system modified removed snapshots blocks begin consume disk space users access snapshots nfs recover files accidentally changed removed system administrators snapshots create backups safely running system addition wafl snapshots internally restart quickly unclean system shutdown user access snapshots directory file system hidden sub-directory named snapshot users access contents snapshots nfs suppose user accidentally removed file named todo recover shows list versions todo saved snapshots spike -lut snapshot todo -rw-r--r-hitz oct snapshot nightly todo -rw-r--r-hitz oct snapshot hourly todo -rw-r--r-hitz oct snapshot hourly todo -rw-r--r-hitz oct snapshot nightly todo -rw-r--r-hitz oct snapshot nightly todo option shows todo access time set time snapshot created user recover recent version todo copying back current directory spike snapshot hourly todo file system design nfs file server appliance rev snapshot directories hidden sense show directory listings snapshot visible commands find report files expected commands -rf fail files snapshots read-only removed snapshot administration faserver commands system administrators create delete snapshots creates deletes snapshots automatically default faserver creates hourly snapshots times day nightly snapshot night midnight hourly snapshots days nightly snapshots week creates weekly snapshot midnight sunday weeks file systems change quickly schedule consume disk space snapshots deleted sooner snapshots hours users notice immediately removed important file file systems change slowly make sense snapshots on-line longer typical environments keeping snapshots week consumes percent disk space file system design nfs file server appliance rev wafl implementation overview wafl unix compatible file system optimized network file access ways wafl similar unix file systems berkeley fast file system ffs mckusick transarc episode file system chutani wafl block-based file system inodes describe files blocks fragments wafl inode block pointers blocks belong file unlike ffs block pointers wafl inode refer blocks level inodes files smaller block pointers point data blocks inodes files smaller point indirect blocks point actual file data inodes larger files point doubly indirect blocks small files data stored inode place block pointers meta-data lives files episode wafl stores meta-data files wafl meta-data files inode file inodes file system block-map file identifies free blocks inode-map file identifies free inodes term map bit map files bit entry block-map file format detail root inode inode file files block map file inode map file files file system figure wafl file system tree blocks root inode describes inode file top meta-data files regular files underneath file system design nfs file server appliance rev keeping meta-data files wafl write meta-data blocks disk origin 
wafl stands write file layout write-anywhere design wafl operate efficiently raid scheduling multiple writes raid stripe avoid -towrite penalty raid incurs updates block stripe keeping meta-data files makes easy increase size file system fly disk added faserver automatically increases sizes meta-data files system administrator increase number inodes file system manually default small finally write-anywhere design enables copy-on-write technique snapshots snapshots work wafl write data including meta-data locations disk overwriting data wafl stored meta-data fixed locations disk tree blocks wafl file system thought tree blocks root tree root inode shown figure root inode special inode describes inode file inode file inodes describe rest files file system including block-map inode-map files leaves tree data blocks files figure detailed version figure shows files made individual blocks large files additional layers indirection inode actual data blocks order wafl boot find root tree exception wafl write-anywhere rule block root inode live fixed location disk wafl find file system design nfs file server appliance rev root inode inode file indirect blocks inode file data blocks regular file indirect blocks regular file data blocks block map file inode map file random small file random large file figure detailed view wafl tree blocks snapshots understanding wafl file system tree blocks rooted root inode key understanding snapshots create virtual copy tree blocks wafl simply duplicates root inode figure shows works figure simplified diagram file system figure leaves internal nodes tree inodes indirect blocks figure shows wafl creates snapshot making duplicate copy root inode duplicate inode root tree blocks representing snapshot root inode represents active file system snapshot inode created points disk blocks root inode brand snapshot consumes disk space snapshot inode figure shows user modifies data block wafl writes data block disk active file system point block snapshot original block unmodified disk time files active file system modified deleted snapshot blocks longer active file system rate files change determines long snapshots line consume unacceptable amount disk space file system design nfs file server appliance rev snapshot root inode abcde snapshot root inode abcde snapshot block update root inode abcde snapshot figure wafl creates snapshot duplicating root inode describes inode file wafl avoids changing blocks snapshot writing data locations disk interesting compare wafl snapshots episode fileset clones duplicating root inode episode creates clone copying entire inode file indirect blocks file system generates considerable disk consumes lot disk space instance file system inode disk space inodes file system creating snapshot duplicating inodes generate disk consume disk space creating snapshots consume one-third file system space data blocks modified duplicating root inode wafl creates snapshots quickly disk snapshot performance important wafl creates snapshot seconds quick recovery unclean system shutdowns figure shows transition figure detail disk block modified contents written location block parent modified reflect location parent parent turn written location root tree inode file indirect block inode file block regular file indirect block regular file data block block update block update snapshot inode root inode snapshot inode root inode ddd figure write block location pointers block ancestors updated requires written locations file system design nfs file server appliance rev wafl inefficient wrote blocks nfs write request wafl gathers hundreds nfs requests scheduling write episode write episode wafl allocates disk space dirty data cache schedules required disk result commonly modified blocks indirect blocks blocks inode file written write episode nfs request file system consistency non-volatile ram wafl avoids file system consistency checking unclean shutdown creating special snapshot called consistency point seconds unlike snapshots consistency point accessible nfs snapshots consistency point completely consistent image entire file system wafl restarts simply reverts recent consistency point faserver reboot minute data single partition consistency points wafl write data disk writes blocks tree blocks representing recent consistency point remains completely unchanged wafl processes hundreds thousands nfs requests consistency points on-disk image file system remains seconds wafl writes consistency point time on-disk image advances atomically state reflects made requests technique unusual unix file system databases instance astrahan describes shadow paging technique system databases unusual write operations time wafl consistency points wafl non-volatile ram nvram log nfs requests processed consistency point nvram special memory batteries store data system power unclean shutdown wafl replays requests log prevent lost faserver shuts creates consistency point suspending nfs service clean shutdown nvram doesn unprocessed nfs requests turned increase battery life wafl divides nvram separate logs log full wafl switches log starts writing consistency point store log safely disk wafl schedules file system design nfs file server appliance rev consistency point seconds log full prevent on-disk image file system date logging nfs requests nvram advantages common technique nvram cache writes disk driver layer lyon sandberg describe nvram write cache technique legato prestoserve nfs accelerator lyon processing nfs request caching resulting disk writes generally takes nvram simply logging information required replay request instance move file directory file system update contents inodes source target directories ffs blocks cache space wafl bytes log information needed replay rename operation rename factor difference nvram usage extreme case simple write caching disk blocks consume data inode update large files indirect block wafl logs data bytes header information typical mix nfs operations wafl store operations megabyte nvram nvram cache unwritten disk blocks turns integral part disk subsystem nvram failure corrupt file system ways fsck detect repair wrong wafl nvram wafl lose nfs requests on-disk image file system remains completely consistent important nvram reliable reliable raid disk array final advantage logging nfs requests improves nfs response times reply nfs request file system nvram update in-memory data structures allocate disk space data wait modified data reach disk file system nvram write cache steps copies modified data nvram waiting data reach disk wafl reply nfs request quickly update in-memory data structures log request allocate disk space data copy modified data nvram write allocation write performance important network file servers ousterhout observed read caches larger client server writes file system design nfs file server appliance rev begin dominate subsystem ousterhout effect pronounced nfs client-side write caching result disks nfs server times write operations reads wafl design motivated largely desire maximize flexibility write allocation policies flexibility takes forms 
wafl write file system block root inode location disk ffs meta-data inodes bit maps fixed locations disk prevents ffs optimizing writes putting data newly updated file inode disk wafl write meta-data disk optimize writes creatively wafl write blocks disk order ffs writes blocks disk carefully determined order fsck restore file system consistency unclean shutdown wafl write blocks order on-disk image file system wafl writes consistency point constraint wafl write blocks consistency point writes root inode consistency point file system design nfs file server appliance rev wafl allocate disk space nfs operations single write episode ffs allocates disk space processes nfs request wafl gathers hundreds nfs requests scheduling consistency point time allocates blocks requests consistency point deferring write allocation improves latency nfs operations removing disk allocation processing path reply avoids wasting time allocating space blocks removed reach disk features give wafl extraordinary flexibility write allocation policies ability schedule writes requests enables intelligent allocation policies fact blocks written location order wide variety strategies easy block allocation strategies change wafl on-disk data structures details wafl write allocation policies scope paper short wafl improves raid performance writing multiple blocks stripe wafl reduces seek time writing blocks locations disk wafl reduces headcontention reading large files placing sequential blocks file single disk raid array optimizing write allocation difficult goals conflict file system design nfs file server appliance rev snapshot data structures algorithms block-map file file systems track free blocks bit map bit disk block bit set block technique work wafl snapshots block time wafl block-map file -bit entry disk block bit set active file system block bit set snapshot block block bits block-map entry set figure shows life cycle typical block-map entry time block-map entry completely clear indicating block time wafl allocates block stores file data snapshots created times wafl copies active file system bit bit indicating membership snapshot block deleted active file system time occur file block removed contents block updated contents written location disk block reused snapshot figure occurs time snapshots block removed time block-map entry description block unused block allocated active snapshot created snapshot created block deleted active snapshot created snapshot deleted snapshot deleted block unused bit set active file system bit set snapshot bit set snapshot bit set snapshot figure life cycle block-map file entry creating snapshot challenge writing snapshot disk avoid locking incoming nfs requests problem nfs requests change cached data part snapshot remain unchanged reaches disk easy create snapshot suspend nfs processing write snapshot resume nfs processing writing snapshot long file system design nfs file server appliance rev nfs server stop responding remember wafl creates consistency point snapshot seconds performance critical wafl technique keeping snapshot data consistent mark dirty data cache snapshot rule snapshot creation data marked snapshot modified data marked snapshot flushed disk nfs requests read file system data modify data isn snapshot processing requests modify snapshot data deferred avoid locking nfs requests wafl flush snapshot data quickly wafl performs steps allocate disk space files snapshot blocks wafl caches inode data places special cache in-core inodes disk buffers belonging inode file finishes write allocating file wafl copies newly updated inode information inode cache inode file disk buffer clears snapshot bit in-core inode step complete inodes regular files marked snapshot nfs operations continue blocking fortunately step quickly requires disk update block-map file block-map entry wafl copies bit active file system bit snapshot write snapshot disk buffers cache newly-allocated locations disk buffer flushed wafl restarts nfs requests waiting modify duplicate root inode create inode represents snapshot turn root inode snapshot bit snapshot inode reach disk blocks snapshot written rule unexpected system shutdown leave snapshot inconsistent state snapshot inode written snapshot data exists cache nfs requests suspended processed normal loads wafl performs steps step generally hundredths wafl completes nfs operations delayed deleting snapshot trivial wafl simply zeros root inode representing snapshot clears bit representing snapshot block-map entry file system design nfs file server appliance rev performance difficult compare wafl performance file systems directly wafl runs nfs appliance benchmarked file systems context nfs nfs benchmark today spec sfs system file server benchmark laddis laddis stands group companies originally developed benchmark legato auspex digital data general interphase sun laddis tests nfs performance measuring server response time throughput levels servers typically handle requests quickly low load levels load increases response time figure compares faserver laddis performance well-known nfs servers system level benchmark laddis compare file system performance misleading argue instance figure underestimates wafl performance faserver cluster file systems servers dozens file system basis wafl outperforms file systems faserver raid typically degrades file system performance substantially small request sizes characteristic nfs servers raid hand argue benchmark overestimates wafl performance entire faserver designed specifically nfs performance nfs-specific tuning system wafl wafl special purpose nature fair compare performance general purpose file systems satisfies design goal performing nfs raid file system design nfs file server appliance rev conclusion wafl developed stable surprisingly quickly file system production file system year case lost user data attribute stability part wafl consistency points processing file system requests simple wafl updates in-memory data structures nvram log consistency points eliminate ordering constraints disk writes significant source bugs file systems code writes consistency points concentrated single file interacts rest wafl executes infrequently nfs operations average response time msec faserver cluster auspex sun sparcenter sun sparccluster sun sparcserver figure graph specnfs operations clusters graph shows specnfs cluster operations importantly easier develop high quality high performance system software appliance general purpose operating system compared general purpose file system wafl handles regular simple set requests general purpose file system receives requests thousands applications wide variety access patterns applications added frequently contrast wafl receives requests nfs client code systems nfs client implementations implementations rare applications ultimate source nfs requests nfs client code converts file system requests regular pattern network requests filters error cases reach server small number operations wafl supports makes define test entire range inputs expected handle file system design nfs file server appliance rev advantages apply appliance file server appliances network appliance makes sense protocols defined widely protocols appliance provide important advantages general purpose computer file system design 
nfs file server appliance rev bibliography astrahan astrahan blasgen chamberlain eswaran gravy griffiths king traiger wade watson system relational approach database management acm transactions database systems chutani sailesh chutani episode file system proceedings winter usenix conference san francisco january hitz dave hitz nfs file server appliance network appliance corporation tasman drive suite santa clara lyon bob lyon russel sandberg breaking nfs performance barrier suntech journal autumn mckusick marshall mckusick fast file system unix acm transactions computer systems august ousterhout john ousterhout fred douglis beating bottleneck case log-structured file systems acm sigops january patterson patterson gibson katz case redundant arrays inexpensive disks raid acm sigmod chicago june sandberg russel sandberg david goldberg steve kleiman dan walsh bob lyon design implementation sun network file system proceedings summer usenix conference portland june file system design nfs file server appliance rev biographies dave hitz dave hitz co-founder system architect network appliance builds nfs file server appliances network appliance dave focused designing implementing network appliance file system design network appliance file server worked auspex systems file system group mips system kernel group jobs hobbies included herding castrating slaughtering cattle pen-based computer programming typing names blue shield insurance cards dropping high school attended george washington swarthmore college deep springs college finally princeton received computer science bse author reached mail hitz netapp james lau james lau co-founder director engineering network appliance james spent years auspex systems recently director software engineering instrumental defining product requirements high level architecture auspex high performance nfs file server joining auspex james spent years bridge communications implemented variety protocols xns tcp ethernet hdlc spent year bridge group manager products james received masters degree computer engineering stanford bachelors degrees computer science applied mathematics berkeley author reached e-mail jlau netapp michael malcolm michael malcolm co-founder senior vice president strategic development network appliance previously ran successful management consulting practice clients focused distributed computing networking file storage technology founder ceo waterloo microsystems canadian developer network operating system software past associate professor computer science waterloo taught hundreds students program real-time systems control electric model trains research spanned areas network operating systems portable operating systems interprocess communication compiler design numerical mathematics led development major operating systems thoth waterloo port received mechanical engineering denver computer file system design nfs file server appliance rev science stanford author reached e-mail malcolm netapp 
frangipani scalable distributed file system chandramohan thekkath timothy mann edward lee systems research center digital equipment corporation lytton ave palo alto abstract ideal distributed file system provide users coherent shared access set files arbitrarily scalable provide storage space higher performance growing user community highly spite component failures require minimal human administration administration complex components added frangipani file system approximates ideal easy build two-layer structure lower layer petal earlier paper distributed storage service incrementally scalable highly automatically managed virtual disks upper layer multiple machines run frangipani file system code top shared petal virtual disk distributed lock service ensure coherence frangipaniis meant run cluster machines common administration communicate securely machines trust shared virtual disk approach practical frangipani file system exported untrusted machines ordinary network file access protocols implemented frangipani collection alphas running digital unix initial measurements frangipani excellent single-server performance scales servers added introduction file system administration large growing computer installation built today technology laborious task hold files serve users add disks attached machines components requires human administration groups files manually assigned disks manually moved replicated components fill fail performance hot spots joining multiple disk drives unit raid technology partial solution administration problems arise system grows large require multiple raids multiple server machines permission make digital hard copy part work personal classroom granted fee provided copies made distributed profit commercial advantage copyright notice title date notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee frangipani scalable distributed file system manages collection disks multiple machines single shared pool storage machines assumed common administration communicate securely earlier attempts building distributed file systems scale throughput capacity distinguishing feature frangipani simple internal structure set cooperating machines common store synchronize access store locks simple structure enables handle system recovery reconfiguration load balancing machinery key aspect frangipani combines set features makes easier administer frangipani existing file systems users consistent view set files servers easily added existing frangipani installation increase storage capacity throughput changing configuration existing servers interrupting operation servers viewed bricks stacked incrementally build large file system needed system administrator add users concern machines manage data disks store systemadministrator make full consistentbackup entire file system bringing backups optionally online allowing users quick access accidentally deleted files file system tolerates recovers machine network disk failures operator intervention frangipani layered top petal easy-to-administer distributed storage system virtual disks clients physical disk petal virtual disk storage read written blocks unlike physical disk virtual disk sparse byte address space physical storage allocated demand petal optionally replicates data high availability petal efficient snapshots support consistent backup frangipani inherits scalability fault tolerance easy administration underlying storage system careful design required extend properties file system level section describes structure frangipani relationship petal greater detail user program user program user program frangipani file server frangipani file server distributed lock service petal distributed virtual disk service physical disks figure frangipani layering interchangeable frangipani servers provide access set files petal virtual disk figure illustrates layering frangipani system multiple interchangeable frangipani servers provide access files running top shared petal virtual disk coordinating actions locks ensure coherence file system layer scaled adding frangipani servers achieves fault tolerance recovering automatically server failures continuing operate servers survive improved load balancing centralized network file server splitting file system load shifting machines files petal lock service distributed scalability fault tolerance load balancing frangipani servers trust petal servers lock service frangipani designed run cluster workstations single administrative domain frangipani file system exported domains frangipani viewed cluster file system implemented frangipani digital unix due frangipani clean layering atop existing petal service implement working system months frangipani targeted environments program development engineering workloads tests workloads frangipani excellent performance scales limits imposed network system structure figure depicts typical assignment functions machines machines shown top run user programs frangipani file server module diskless shown bottom run petal distributed lock service components frangipani assigned machines shown figure petal frangipani servers separate machines make sense petal machine run frangipani installation petal machines heavily loaded distributed lock service independent rest system show lock server running petal server machine run frangipani hosts machines components shown figure user programs access frangipani standard operating system call interface programs running machines files views coherent changesmade file directory machine petal server lock server petal server lock server petal server lock server petal virtual disk network user programs file system switch frangipani file server module petal device driver user programs file system switch frangipani file server module petal device driver figure frangipani structure typical frangipani configuration machines run user programs frangipani file server module run petal distributed lock service configurations machines play roles immediately visible programs essentially semantic guarantees local unix file system file contents staged local kernel buffer pool guaranteed reach nonvolatile storage applicable fsync sync system call metadata logged optionally guaranteed non-volatile time system call returns small departure local file system semantics frangipani maintains file last-accessed time approximately avoid metadata write data read frangipani file server module machine runs operating system kernel registers kernel file system switch file system implementations file server module kernel buffer pool cache data recently files reads writes petal virtual disks local petal device driver file servers read write file system data structures shared petal disk server redo log pending distinct section petal disk logs petal frangipani server crashes server access log run recovery frangipani servers communicate directly communicate petal lock service server addition deletion recovery simple petal device driver hides distributed nature petal making petal ordinary local disk higher layers operating system driver responsible contacting define metadata on-disk data structure contents ordinary file correct petal server failing digital unix file system run top petal frangipani coherent accessto files multiple machines petal servers run cooperatively provide frangipani large scalable fault-tolerant virtual disks implemented top ordinary physical disks connected server petal tolerate disk server failures long majority petal servers remain communication copy data block remains physically accessible additional details petal separate paper lock service general-purpose service multiple-reader single-writer locks clients network implementation distributed fault tolerance scalable performance frangipani lock service coordinate access virtual disk buffer caches coherent multiple servers security client server configuration configuration shown figure machine 
hosts user programs hosts frangipani file server module configuration potential good load balancing scaling poses security concerns frangipani machine read write block shared petal virtual disk frangipani run machines trusted operating systems sufficient frangipani machine authenticate petal acting behalf user remote file access protocols nfs full security requires petal servers lock servers run trusted operating systems types components authenticate finally ensure file data private users prevented eavesdropping network interconnecting petal frangipani machines fully solve problems placing machines environment prevents users booting modified operating system kernels interconnecting private network user processes granted access necessarily machines locked room private physical network cryptographic techniques secure booting authentication encrypted links applications partial solutions acceptable typical existing nfs installations secure network eavesdropping data modification user boots modified kernel workstation implemented security measures date reach roughly nfs level security petal servers accept requests list network addresses belonging trusted frangipani server machines frangipani file systems exported untrusted machines administrative domain configuration illustrated figure distinguish frangipani client server machines trusted frangipani servers communicate petal lock service located restricted environment interconnected private network discussed remote untrusted clients talk frangipani servers separate network direct access petal servers clients talk frangipani server file access protocol supported host operating system dce dfs nfs smb becausefrangipani local file system machine running frangipani server prouser programs file system switch nfs dfs client file system switch frangipani file server module nfs dfs server petal device driver network lock service petal frangipani client machine frangipani server machine figure client server configuration frangipani server provide file access local machine remote client machines connect standard network file system protocols tocol supports coherent access dce dfs frangipani coherence multiple servers thrown level ideally protocol support failover frangipani server protocols mentioned support failover directly technique machine address failed machine systems applied security reason client server configuration frangipani runs kernel quickly portable operating systems versions unix clients frangipani unsupported system accessing supported remotely discussion idea building file system layers lower level providing storage repository higher level providing names directories files unique frangipani earliest universal file server storage facility provided petal substantially earlier systems leading higher level structure section detailed comparisons previous systems frangipani designed work storage abstraction provided petal fully considered design needed exploit alternative storage abstractions nasd petal highly storage scale throughput capacity resources added petal provision coordination sharing storage multiple clients applications directly petal client interface disk-like file-like frangipani file system layer makes petal applications retaining extending good properties strength frangipani transparent server addition deletion failure recovery easily combining write-ahead logging locks uniformly accessible highly store strength frangipani ability create consistent backups system running frangipani backup param eters logs allocation bitmaps inodes small blocks large blocks figure disk layout frangipani takes advantage petal large sparse disk address space simplify data structures server log blocks allocation bitmap space mechanism discussed section aspects frangipani design problematic frangipani replicated petal virtual disk implies logging occurs frangipani log petal frangipanidoes disk location information placing data petal virtualizes disks finally frangipani locks entire files directories individual blocks usage experience evaluate aspects design general setting frangipani measured performance engineering workloads tested good disk layout frangipani large sparse disk address space petal simplify data structures general idea reminiscent past work programming computers large memory address spaces address space parcelled generously petal virtual disk bytes address space petal commits physical disk space virtual addresses written petal decommit primitive frees physical space backing range virtual disk addresses internal data structures small petal commits decommits space fairly large chunks range addresses data written decommitted physical disk space allocated petal clients afford make data structures sparse physical disk space wasted fragmentation figure shows frangipani divides virtual disk space region stores shared configuration parameters housekeeping information terabyte virtual space region fact kilobytes region stores logs frangipani server obtains portion space hold private log reserved bytes region partitioned logs choice limits current implementation servers easily adjusted region allocation bitmaps describe blocks remaining regions free frangipani server locks portion bitmap space exclusive server bitmap space fills finds locks unused portion bitmap region long fourth region holds inodes file inode hold metadata timestamps pointers location data symbolic links store data directly inode made inodes bytes long size disk block avoiding unnecessary contention false sharing servers occur servers needed access inodes block allocate inode space allowing room inodes mapping bits allocation bitmap inodes fixed frangipani server allocates inodes files portions inode space corresponds portions allocation bitmap frangipani server read write free existing file inode region holds small data blocks bytes size blocks file stored small blocks file grows rest stored large block allocate bytes small blocks allowing times maximum number inodes remainder petal address spaceholds large data blocks address space reserved large block disk layout policy blocks suffer fragmentation policy carefully husbands disk space allocating bytes inode wasteful space alleviate problems storing small files inode gain design simplicity reasonable tradeoff cost extra physical disk space current scheme limits frangipani slightly million large files large file file bigger file larger small blocks large block limits prove small easily reduce size large blocks making larger number permit large files span large block raising maximum file size byte address space limit prove inadequate single frangipani server support multiple frangipani file systems multiple virtual disks chosen file system parameters based usage experience earlier file systems choices serve time usage confirm design frangipani flexible experiment layouts cost backup restore file system logging recovery frangipani write-ahead redo logging metadata simplify failure recovery improve performance user data logged section word file includes directories symbolic links frangipani server private log petal frangipani file server make metadata update creates record describing update appends log memory log records periodically written petal order updates describe requested optionally log records written synchronously offers slightly failure semantics cost increased latency metadata operations log record written petal server modify actual metadata permanent locations permanent locations updated periodically roughly seconds unix update demon logs bounded size current implementation petal allocation policy log composed fragments distinct physical disks space allocated log managed circular buffer log fills frangipani reclaims oldest log space log entries ordinarily entries reclaimed area refer metadata blocks written 
petal previous sync operation case additional petal writes metadata blocks written work completed log reclaimed size log typical sizes frangipani log records bytes log fill periodic sync operations operations modify metadata interval frangipani server crashes system eventually detects failure runs recovery server log failure detected client failed server lock service asks failed server return lock holding reply recovery demon implicitly ownership failed server log locks demon finds log start end examines record order carrying update complete log processing finished recovery demon releases locks frees log frangipani servers proceed unobstructed failed server failed server optionally restarted empty log long underlying petal volume remains system tolerates unlimited number frangipani server failures ensure recovery find end log disk controllers write data order attach monotonically increasing log sequence number -byte block log end log reliably detected finding sequence number lower preceding frangipani ensures mapreduce simpli data processing large clusters jeffrey dean sanjay ghemawat jeff google sanjay google google abstract mapreduce programming model implementation processing generating large data sets users map function processes key pair generate set intermediate key pairs reduce function merges intermediate values intermediate key real world tasks expressible model shown paper programs written functional style automatically parallelized executed large cluster commodity machines run-time system takes care details partitioning input data scheduling program execution set machines handling machine failures managing required inter-machine communication programmers experience parallel distributed systems easily utilize resources large distributed system implementation mapreduce runs large cluster commodity machines highly scalable typical mapreduce computation processes terabytes data thousands machines programmers system easy hundreds mapreduce programs implemented upwards thousand mapreduce jobs executed google clusters day introduction past years authors google implemented hundreds special-purpose computations process large amounts raw data crawled documents web request logs compute kinds derived data inverted indices representations graph structure web documents summaries number pages crawled host set frequent queries day computations conceptually straightforward input data large computations distributed hundreds thousands machines order nish reasonable amount time issues parallelize computation distribute data handle failures conspire obscure original simple computation large amounts complex code deal issues reaction complexity designed abstraction express simple computations perform hides messy details parallelization fault-tolerance data distribution load balancing library abstraction inspired map reduce primitives present lisp functional languages realized computations involved applying map operation logical record input order compute set intermediate key pairs applying reduce operation values shared key order combine derived data appropriately functional model userspeci map reduce operations parallelize large computations easily re-execution primary mechanism fault tolerance major contributions work simple powerful interface enables automatic parallelization distribution large-scale computations combined implementation interface achieves high performance large clusters commodity pcs section describes basic programming model examples section describes implementation mapreduce interface tailored cluster-based computing environment section describes nements programming model found section performance measurements implementation variety tasks section explores mapreduce google including experiences basis osdi rewrite production indexing system section discusses related future work programming model computation takes set input key pairs produces set output key pairs user mapreduce library expresses computation functions map reduce map written user takes input pair produces set intermediate key pairs mapreduce library groups intermediate values intermediate key passes reduce function reduce function written user accepts intermediate key set values key merges values form possibly smaller set values typically output produced reduce invocation intermediate values supplied user reduce function iterator handle lists values large memory problem counting number occurrences word large collection documents user write code similar pseudo-code map string key string key document document contents word emitintermediate reduce string key iterator values key word values list counts int result values result parseint emit asstring result map function emits word count occurrences simple reduce function sums counts emitted word addition user writes code mapreduce speci cation object names input output les optional tuning parameters user invokes mapreduce function passing speci cation object user code linked mapreduce library implemented appendix full program text types previous pseudo-code written terms string inputs outputs conceptually map reduce functions supplied user types map list reduce list list input keys values drawn domain output keys values intermediate keys values domain output keys values implementation passes strings user-de ned functions leaves user code convert strings types examples simple examples interesting programs easily expressed mapreduce computations distributed grep map function emits line matches supplied pattern reduce function identity function copies supplied intermediate data output count url access frequency map function processes logs web page requests outputs hurl reduce function adds values url emits hurl total counti pair reverse web-link graph map function outputs htarget sourcei pairs link target url found page named source reduce function concatenates list source urls target url emits pair htarget list source term-vector host term vector summarizes important words occur document set documents list hword frequencyi pairs map function emits hhostname term vectori pair input document hostname extracted url document reduce function passed per-document term vectors host adds term vectors throwing infrequent terms emits nal hhostname term vectori pair osdi user program master fork worker fork worker fork assign map assign reduce split split split split split output file write worker read worker local write map phase intermediate files local disks worker outputfile input files remote read reduce phase output files figure execution overview inverted index map function parses document emits sequence hword document idi pairs reduce function accepts pairs word sorts document ids emits hword list document pair set output pairs forms simple inverted index easy augment computation track word positions distributed sort map function extracts key record emits hkey recordi pair reduce function emits pairs unchanged computation depends partitioning facilities section ordering properties section implementation implementations mapreduce interface choice depends environment implementation suitable small shared-memory machine large numa multi-processor larger collection networked machines section describes implementation targeted computing environment wide google large clusters commodity pcs connected switched ethernet environment machines typically dual-processor processors running linux memory machine commodity networking hardware typically megabits gigabit machine level averaging considerably bisection bandwidth cluster consists hundreds thousands machines machine failures common storage provided inexpensive ide disks attached directly individual machines distributed system developed in-house manage data stored disks system replication provide availability reliability top unreliable hardware users submit jobs scheduling system job consists set tasks mapped scheduler set machines cluster execution overview map invocations distributed multiple machines automatically partitioning input data osdi set splits input splits processed parallel machines reduce invocations distributed partitioning intermediate key space pieces partitioning function hash key mod number partitions partitioning function speci user figure shows mapreduce operation implementation user program calls mapreduce function sequence actions occurs numbered labels figure correspond numbers list mapreduce library user program rst splits input les pieces typically megabytes megabytes piece controllable user optional parameter starts copies program cluster machines copies program special master rest workers assigned work master map tasks reduce tasks assign master picks idle workers assigns map task reduce task worker assigned map task reads contents input split parses key pairs input data passes pair user-de ned map function intermediate key pairs 
produced map function buffered memory periodically buffered pairs written local disk partitioned regions partitioning function locations buffered pairs local disk passed back master responsible forwarding locations reduce workers reduce worker noti master locations remote procedure calls read buffered data local disks map workers reduce worker read intermediate data sorts intermediate keys occurrences key grouped sorting needed typically keys map reduce task amount intermediate data large memory external sort reduce worker iterates sorted intermediate data unique intermediate key encountered passes key set intermediate values user reduce function output reduce function appended nal output reduce partition map tasks reduce tasks completed master wakes user program point mapreduce call user program returns back user code successful completion output mapreduce execution output les reduce task names speci user typically users combine output les pass les input mapreduce call distributed application deal input partitioned multiple les master data structures master data structures map task reduce task stores state idle in-progress completed identity worker machine non-idle tasks master conduit location intermediate regions propagated map tasks reduce tasks completed map task master stores locations sizes intermediate regions produced map task updates location size information received map tasks completed information pushed incrementally workers in-progress reduce tasks fault tolerance mapreduce library designed process large amounts data hundreds thousands machines library tolerate machine failures gracefully worker failure master pings worker periodically response received worker amount time master marks worker failed map tasks completed worker reset back initial idle state eligible scheduling workers similarly map task reduce task progress failed worker reset idle eligible rescheduling completed map tasks re-executed failure output stored local disk failed machine inaccessible completed reduce tasks re-executed output stored global system map task executed rst worker executed worker failed osdi workers executing reduce tasks noti reexecution reduce task read data worker read data worker mapreduce resilient large-scale worker failures mapreduce operation network maintenance running cluster causing groups machines time unreachable minutes mapreduce master simply re-executed work unreachable worker machines continued make forward progress eventually completing mapreduce operation master failure easy make master write periodic checkpoints master data structures master task dies copy started checkpointed state single master failure current implementation aborts mapreduce computation master fails clients check condition retry mapreduce operation desire semantics presence failures user-supplied map reduce operators deterministic functions input values distributed implementation produces output produced non-faulting sequential execution entire program rely atomic commits map reduce task outputs achieve property in-progress task writes output private temporary les reduce task produces map task produces les reduce task map task completes worker sends message master includes names temporary les message master receives completion message completed map task ignores message records names les master data structure reduce task completes reduce worker atomically renames temporary output nal output reduce task executed multiple machines multiple rename calls executed nal output rely atomic rename operation provided underlying system guarantee nal system state data produced execution reduce task vast majority map reduce operators deterministic fact semantics equivalent sequential execution case makes easy programmers reason program behavior map reduce operators nondeterministic provide weaker reasonable semantics presence non-deterministic operators output reduce task equivalent output produced sequential execution non-deterministic program output reduce task correspond output produced sequential execution non-deterministic program map task reduce tasks execution committed execution weaker semantics arise read output produced execution read output produced execution locality network bandwidth scarce resource computing environment conserve network bandwidth taking advantage fact input data managed gfs stored local disks machines make cluster gfs divides blocks stores copies block typically copies machines mapreduce master takes location information input les account attempts schedule map task machine replica input data failing attempts schedule map task replica task input data worker machine network switch machine data running large mapreduce operations signi fraction workers cluster input data read locally consumes network bandwidth task granularity subdivide map phase pieces reduce phase pieces ideally larger number worker machines worker perform tasks improves dynamic load balancing speeds recovery worker fails map tasks completed spread worker machines practical bounds large implementation master make scheduling decisions state memory constant factors memory usage small piece state consists approximately byte data map task reduce task pair osdi constrained users output reduce task ends separate output practice tend choose individual task roughly input data locality optimization effective make small multiple number worker machines expect perform mapreduce computations worker machines backup tasks common lengthens total time mapreduce operation straggler machine takes unusually long time complete map reduce tasks computation stragglers arise host reasons machine bad disk experience frequent correctable errors slow read performance cluster scheduling system scheduled tasks machine causing execute mapreduce code slowly due competition cpu memory local disk network bandwidth recent problem experienced bug machine initialization code caused processor caches disabled computations affected machines slowed factor hundred general mechanism alleviate problem stragglers mapreduce operation close completion master schedules backup executions remaining in-progress tasks task marked completed primary backup execution completes tuned mechanism typically increases computational resources operation percent found signi cantly reduces time complete large mapreduce operations sort program section takes longer complete backup task mechanism disabled nements basic functionality provided simply writing map reduce functions suf cient found extensions section partitioning function users mapreduce number reduce tasks output les desire data partitioned tasks partitioning function intermediate key default partitioning function provided hashing hash key mod result fairly well-balanced partitions cases partition data function key output keys urls entries single host end output support situations user mapreduce library provide special partitioning function hash hostname urlkey mod partitioning function urls host end output ordering guarantees guarantee partition intermediate key pairs processed increasing key order ordering guarantee makes easy generate sorted output partition output format support cient random access lookups key users output convenient data sorted combiner function cases signi repetition intermediate keys produced map task userspeci reduce function commutative associative good word counting section word frequencies tend follow zipf distribution map task produce hundreds thousands records form counts network single reduce task added reduce function produce number user optional combiner function partial merging data network combiner function executed machine performs map task typically code implement combiner reduce functions difference 
reduce function combiner function mapreduce library handles output function output reduce function written nal output output combiner function written intermediate reduce task partial combining signi cantly speeds classes mapreduce operations appendix combiner input output types mapreduce library support reading input data formats text osdi mode input treats line key pair key offset contents line common supported format stores sequence key pairs sorted key input type implementation split meaningful ranges processing separate map tasks text mode range splitting ensures range splits occur line boundaries users add support input type providing implementation simple reader interface users small number prede ned input types reader necessarily provide data read easy reader reads records database data structures mapped memory similar fashion support set output types producing data formats easy user code add support output types side-effects cases users mapreduce found convenient produce auxiliary les additional outputs map reduce operators rely application writer make side-effects atomic idempotent typically application writes temporary atomically renames fully generated provide support atomic two-phase commits multiple output les produced single task tasks produce multiple output les crossle consistency requirements deterministic restriction issue practice skipping bad records bugs user code map reduce functions crash deterministically records bugs prevent mapreduce operation completing usual action bug feasible bug third-party library source code unavailable acceptable ignore records statistical analysis large data set provide optional mode execution mapreduce library detects records deterministic crashes skips records order make forward progress worker process installs signal handler catches segmentation violations bus errors invoking user map reduce operation mapreduce library stores sequence number argument global variable user code generates signal signal handler sends gasp udp packet sequence number mapreduce master master failure record record skipped issues re-execution map reduce task local execution debugging problems map reduce functions tricky actual computation distributed system thousand machines work assignment decisions made dynamically master facilitate debugging pro ling small-scale testing developed alternative implementation mapreduce library sequentially executes work mapreduce operation local machine controls provided user computation limited map tasks users invoke program special easily debugging testing tools gdb status information master runs internal http server exports set status pages human consumption status pages show progress computation tasks completed progress bytes input bytes intermediate data bytes output processing rates pages links standard error standard output les generated task user data predict long computation resources added computation pages gure computation slower expected addition top-level status page shows workers failed map reduce tasks processing failed information attempting diagnose bugs user code counters mapreduce library counter facility count occurrences events user code count total number words processed number german documents indexed facility user code creates named counter object increments counter appropriately map reduce function osdi counter uppercase uppercase getcounter uppercase map string string contents word contents iscapitalized uppercaseincrement emitintermediate counter values individual worker machines periodically propagated master piggybacked ping response master aggregates counter values successful map reduce tasks returns user code mapreduce operation completed current counter values displayed master status page human watch progress live computation aggregating counter values master eliminates effects duplicate executions map reduce task avoid double counting duplicate executions arise backup tasks re-execution tasks due failures counter values automatically maintained mapreduce library number input key pairs processed number output key pairs produced users found counter facility sanity checking behavior mapreduce operations mapreduce operations user code ensure number output pairs produced equals number input pairs processed fraction german documents processed tolerable fraction total number documents processed performance section measure performance mapreduce computations running large cluster machines computation searches approximately terabyte data pattern computation sorts approximately terabyte data programs representative large subset real programs written users mapreduce class programs shuf data representation class extracts small amount interesting data large data set cluster con guration programs executed cluster consisted approximately machines machine ghz intel xeon processors hyperthreading enabled memory ide seconds input figure data transfer rate time disks gigabit ethernet link machines arranged two-level tree-shaped switched network approximately gbps aggregate bandwidth root machines hosting facility round-trip time pair machines millisecond memory approximately reserved tasks running cluster programs executed weekend afternoon cpus disks network idle grep grep program scans -byte records searching rare three-character pattern pattern occurs records input split approximately pieces entire output figure shows progress computation time y-axis shows rate input data scanned rate gradually picks machines assigned mapreduce computation peaks workers assigned map tasks nish rate starts dropping hits seconds computation entire computation takes approximately seconds start nish includes minute startup overhead overhead due propagation program worker machines delays interacting gfs open set input les information needed locality optimization sort sort program sorts -byte records approximately terabyte data program modeled terasort benchmark sorting program consists lines user code three-line map function extracts -byte sorting key text line emits key osdi input shuffle seconds output normal execution input shuffle seconds output backup tasks input shuffle seconds output tasks killed figure data transfer rates time executions sort program original text line intermediate key pair built-in identity function reduce operator functions passes intermediate key pair unchanged output key pair nal sorted output written set -way replicated gfs les terabytes written output program input data split pieces partition sorted output les partitioning function initial bytes key segregate pieces partitioning function benchmark builtin knowledge distribution keys general sorting program add pre-pass mapreduce operation collect sample keys distribution sampled keys compute splitpoints nal sorting pass figure shows progress normal execution sort program top-left graph shows rate input read rate peaks dies fairly quickly map tasks nish seconds elapsed note input rate grep sort map tasks spend half time bandwidth writing intermediate output local disks intermediate output grep negligible size middle-left graph shows rate data network map tasks reduce tasks shuf ing starts rst map task completes rst hump graph rst batch approximately reduce tasks entire mapreduce assigned machines machine executes reduce task time roughly seconds computation rst batch reduce tasks nish start shuf ing data remaining reduce tasks shuf ing seconds computation bottom-left graph shows rate sorted data written nal output les reduce tasks delay end rst shuf ing period start writing period machines busy sorting intermediate data writes continue rate writes 
nish seconds computation including startup overhead entire computation takes seconds similar current reported result seconds terasort benchmark things note input rate higher shuf rate output rate locality optimization data read local disk bypasses bandwidth logging recovery work correctly presence multiple logs requires attention details frangipani locking protocol section ensures updates requested data servers serialized write lock covers dirty data change owners dirty data written petal original lock holder recovery demon running behalf implies log hold uncompleted update block frangipani ensures recovery applies updates logged server acquired locks cover holds locks needed ensure serialization imposed locking protocol violated make guarantee enforcing stronger condition recovery replays log record describing update completed accomplish version number -byte metadata block metadata directories span multiple blocks multiple version numbers block log record updates record description version number recovery block applied block version number record version number user data updates logged metadata blocks space reserved version numbers creates complication block metadata freed reused user data log records referring block skipped properly version number overwritten arbitrary user data frangipani avoids problem reusing freed metadata blocks hold metadata finally frangipani ensures time recovery lock service guarantees granting active recovery demon exclusive lock log frangipani logging recovery schemes assume disk write failure leaves contents single sector state state combination sector damaged reading returns crc error petal built-in replication ordinarily recover copies sector lost frangipani data structures corrupted software bug metadata consistency check repair tool unix fsck needed implemented tool date frangipani logging intended provide high-level semantic guarantees users purpose improve performance metadata updates speed failure recovery avoiding run programs fsck time server fails metadata logged user data user guarantee file system state consistent point view failure claim semantics ideal standard local unix file systems provide local unix file systems frangipani user consistency semantics calling fsync suitable checkpoints frangipani logging application techniques developed databases log-based file systems frangipani log-structured file system data log maintaining conventional on-disk data structures small log adjunct provide improved performance failure atomicity unlike log-based file systems cited log-structured file systems zebra xfs frangipani multiple logs synchronization cache coherence multiple frangipani servers modifying shared on-disk data structures careful synchronization needed give server consistent view data concurrency scale performance load increased servers added frangipani multiple-reader single-writer locks implement synchronization lock service detects conflicting lock requests current holder lock asked release downgrade remove conflict read lock server read data disk cache server asked release read lock invalidate cache entry complying write lock server read write data cache server cached copy disk block on-disk version holds relevant write lock server asked release write lock downgrade read lock write dirty data disk complying retain cache entry downgrading lock invalidate releasing lock flushing dirty data disk write lock released downgraded chosen bypass disk forward dirty data directly requester reasons simplicity design frangipani servers communicate communicate petal lock server design ensures server crashes process log server dirty buffers directly forwarded destination server dirty buffer crashed log entries referring dirty buffer spread machines pose problem recovery reclaiming log space fills divided on-disk structures logical segments locks segment avoid false sharing ensure single disk sector hold data structure shared division on-disk data structures lockable segments designed number locks small avoid lock contention common case lock service bottleneck system log single lockable segment logs private bitmap space divided segments locked exclusively contention files allocated data block inode allocated file protected lock segment allocation bitmap holds bit marking free finally file directory symbolic link segment lock protects inode file data points per-file lock granularity engineering workloads files rarely undergo concurrent write-sharing workloads require finer granularity locking operations require atomically updating on-disk data structures covered locks avoid deadlock globally ordering locks acquiring phases server determines locks involve acquiring releasing locks names directory sorts locks inode address acquires lock turn server checks objects examined phase modified locks released releases locks loops back repeat phase performs operation dirtying blocks cache writing log record retains lock dirty blocks covers written back disk cache coherence protocol similar protocols client file caches echo andrew file system dce dfs sprite deadlock avoidance technique similar echo frangipani oracle data base oracle parallel server writes dirty data disk cache-to-cache transfers successive owners write lock lock service frangipani requires small generic set functions lock service expect service performance bottleneck normal operation implementations fill requirements lock service implementations frangipani project existing lock services provide functionality thin layer additional code top lock service multiple-reader single-writer locks locks sticky client generally retain lock client conflicting recall clients lock service frangipani servers lock service deals client failure leases client contacts lock service obtains lease locks client acquires lease lease expiration time set seconds creation renewal client renew lease expiration time service failed network failures prevent frangipani server renewing lease crashed server discards locks data cache cache dirty frangipani turns internal flag subsequent requests user programs return error file system unmounted clear error condition chosen drastic reporting error make difficult ignore inadvertently initial lock service implementation single centralized server lock state volatile memory server adequate frangipani becausethe frangipaniservers logs hold state information permit recovery lock service loses state crash lock service failure large performance glitch implementation stored lock state petal virtual disk writing lock state change petal returning client primary lock server crashed backup server read current state petal provide continued service scheme failure recovery transparent performance common case poorer centralized in-memory approach fully implement automatic recovery failure modes implementation final lock service implementation fully distributed fault tolerance 
scalable performance consists set mutually cooperating lock servers clerk module linked frangipani server lock service organizes locks tables namedbyascii strings individual locks tables named -bit integers recall single frangipani file system petal virtual disk multiple frangipani file systems mounted machine file system table frangipani file system mounted frangipani server calls clerk opens lock table file system lock server clerk lease identifier successful open subsequent communication file system unmounted clerk closes lock table clerks lock servers communicatevia asynchronousmessages rpc minimize amount memory achieve good flexibility performance basic message types operate locks request grant revoke release requestand release message types clerk lock server grant revoke message types lock server clerk lock upgrade downgrade operations handled message types lock service fault-tolerant distributed failure detection mechanism detect crash lock servers mechanism petal based timely exchange heartbeat messages sets servers majority consensus tolerate network partitions locks consume memory server clerk current implementation server allocates block bytes lock addition bytes clerk outstanding granted lock request client bytes lock avoid consuming memory sticky locks clerks discard locks long time hour small amount global state information change consistently replicated lock servers lamport paxos algorithm lock service reuses implementation paxos originally written petal global state information consists list lock servers list locks responsible serving list clerks opened closed lock table information achieve consensus reassign locks lock servers recover lock state clerks lock server crash facilitate recovery frangipani servers efficiency locks partitioned hundred distinct lock groups assigned servers group individually locks occasionally reassigned lock servers compensate crashed lock server advantage newly recovered lock server similar reassignment occurs lock server permanently added removed system cases locks reassigned number locks served server balanced number reassignments minimized lock served lock server reassignment occurs phases phase lock servers lose locks discard internal state phase lock servers gain locks contact clerks relevant lock tables open servers recover state locks clerks clerks informed servers locks frangipani server crashes locks owns released recovery actions performed specifically crashed frangipani server log processed pending updates written petal frangipani server lease expires lock service clerk frangipani machine perform recovery release locks belonging crashed frangipani server clerk granted lock ensure exclusive access log lock covered lease lock service start recovery process fail general frangipani system tolerates network partitions continuing operate shutting cleanly specifically petal continue operation face network partitions long majority petal servers remain communication parts petal virtual disk inaccessible replica majority partition lock service continues operation long majority lock servers communication frangipani server partitioned lock service unable renew lease lock service declare frangipani server dead initiate recovery log petal frangipani server partitioned petal unable read write virtual disk cases server disallow user access affected file system partition heals file system remounted small hazard frangipaniserver lease expires server crash contact lock service due network problems access petal lease expired frangipani server checks lease valid valid margin seconds attempting write petal petal checking write requestarrives sufficienttime delay frangipani lease check arrival subsequent write request petal problem lease expired lock server large error margin margin seconds normal circumstances problem occur rule absolutely future eliminate hazard method work add expiration timestamp write request petal timestamp set current lease expiration time moment write request generated minus margin petal ignore write request timestamp current time method reliably rejects writes expired leases provided clocks petal frangipani servers synchronized margin method required synchronized clocks integrate lock server petal include lease identifier obtained lock server write request petal petal reject write request expired lease identifier adding removing servers frangipani installation grows system administrator occasionally add remove server machines frangipani designed make task easy adding frangipani server running system requires minimal amount administrative work server told petal virtual disk find lock service server contacts lock service obtain lease determines portion log space lease identifier operation administrator touch servers adapt presence automatically removing frangipani server easier adequate simply shut server preferable server flush dirty data release locks halting strictly needed server halts abruptly recovery run log time locks needed bringing shared disk consistent state administrator touch servers petal servers added removed transparently petal paper lock servers added removedinasimilarmanner backup petal snapshotfeature convenientway make consistent full dumps frangipani file system petal client create exact copy virtual disk point time snapshot copy appears identical ordinary virtual disk modified implementation copy-on-write techniques efficiency snapshots crashconsistent snapshot reflects coherent state petal virtual disk left frangipani servers crash backup frangipani file system simply taking petal snapshot copying tape snapshot include logs restored copying back petal virtual disk running recovery log due crash-consistency restoring snapshot reduces problem recovering system-wide power failure improve scheme minor change frangipani creating snapshots consistent file system level require recovery accomplish backup program force frangipani servers barrier implemented ordinary global lock supplied lock service frangipani servers acquire lock shared mode modification operation backup process requests exclusive mode frangipani server receives request release barrier lock enters barrier blocking file systemcalls modify data cleaning dirty data cache releasing lock frangipani servers entered barrier backup program acquire exclusive lock makes petal snapshot releases lock point servers reacquire lock shared mode normal operation resumes scheme snapshot mounted frangipani volume recovery volume accessed on-line retrieve individual files dumped tape conventional backup format require frangipani restoration volume mounted read-only petal snapshots readonly future extend petal support writable snapshots implement thin layer top petal simulate performance frangipani layered structure made easier build monolithic system expect layering exact cost performance section show frangipani performance good spite layering file systems latency problems frangipani solved straightforwardly adding non-volatile memory nvram buffer front disks effective place put nvram system directly physical disks petal server software ordinary prestoserve cards drivers suffice purpose petal frangipani needed failure nvram petal server treated petal equivalent server failure severalaspects frangipaniand petal combine provide good scaling throughput parallelism layers system multiple frangipani servers multiple petal servers multiple disk arms working parallel clients system parallelism increases aggregate throughput compared centralized network file server frangipani difficulty dealing hot spots file system processing split shifted machines files frangipani petal logs commit updates clients log write group commit providing improved log throughput load individual clients large writes benefit parallelism due petal striping data multiple 
disks servers experimental setup planning build large storage testbed petal nodes attached hundred disks frangipani servers petal nodes small array controllers attached off-the-shelf disks network frangipani servers typical workstations testbed study performance frangipani large configuration ready report numbers smaller configuration measurements reported mhz dec alpha machines petal servers machine stores data digital disks inch fast scsi drives storing average seek time sustained transfer rate machine connected port atm switch mbit point-to-point link prestoserve cards nvram servers petal servers supply data aggregate rate replicated virtual disks petal servers sink data aggregate rate single machine performance subsection compares frangipani code path compares unix vnode file system digital advanced file system advfs advfs comparison familiar bsd-derived ufs file system advfs significantly faster ufs advfs stripe files multiple disks achieving double throughput ufs test machines unlike ufs synchronouslyupdates metadata advfs write-ahead log frangipani significantly reduces latency operations file creation advfs ufs similar performance reading small files directories ran advfs frangipani file systems identical machines storage subsystems comparable performance machine mhz dec alpha cpu ram managed unified buffer cache ubc connected atm switch point-to-point link frangipani file system local disks accesses replicated petal virtual disk petal device driver accessed raw device interface block sizes petal driver read write data saturating atm link petal server cpu utilization read latency petal disk advfs file system storage subsystem performance roughly equivalent petal configuration consists digital disks connected fast scsi strings backplane controllers accessedthrough raw device interface controllers disks supply data cpu utilization read latency connected advfs file system petal virtual disk ensure file systems identical storage subsystems previous experiments shown advfs slower run petal present advfs light chose intention compare petal cost performance locally attached disks hardware resources required provide storage subsystemsfor frangipani advfs vastly goal demonstrate frangipani code path efficient compared existing well-tuned commercial file system hardware resources petal non-trivial resources amortized multiple frangipani servers tables compare performance systems standard benchmarks table columns advfs raw column benchmark run advfs directly accessing local disks advfs nvr column benchmark rerun nvram interposed front local disks frangipani raw column benchmark run frangipani accessing petal device interface frangipani nvr column frangipani configuration retested addition nvram buffer petal disks numbers averaged ten runs benchmarks standard deviation cases advfs frangipani phase description raw nvr raw nvr create directories copy files directory status scan files compile table modified andrew benchmark unmount operations compare performance file system configurations local access nvram digital unix advanced file system advfs frangipani frangipani nvram buffer added petal disks unmount file system end phase table entry average elapsed time seconds smaller numbers table results modified andrew benchmark widely file system benchmark phase benchmark creates tree directories phase copies collection source files tree phase traverses tree examines status file directory fourth phase reads file tree phase compiles links files difficult make comparative measurements modified andrew benchmark standard form becausethe benchmarkdoes accountfor work deferred file system implementation work deferred phase benchmark performed phase inappropriately charged phase work deferred past end benchmark accounted traditional unix file systems advfs frangipani defer cost writing dirty file data sync operation explicitly requested user triggered background periodic update demon unlike traditional unix file systems advfs frangipani log-based write metadata updates synchronously disk metadata updates deferred sync log wraps order account properly sources deferred work changed benchmark unmount file system phase choseto unmount async call digital unix sync queues dirty data writing guarantee reached disk returning results shown table frangipani comparable advfs phases table shows results running connectathon benchmark connectathon benchmark tests individual operations small groups related operations providing insight sources differences visible andrew benchmark andrew benchmark benchmark account deferred work unmounted file system end phase frangipani latencies nvram roughly comparable advfs frangipani test description raw nvr raw nvr file directory creation creates files directories file directory removal removes files directories lookup mount point getwd stat calls setattr getattr lookup chmods stats files write writes byte file times read reads byte file times readdir reads directory entries files link rename renames links files symlink readlink symlinks readlinks files statfs statfs calls table connectathon benchmark unmount operations run connectathon benchmark unmount operation included end test table entry average elapsed time seconds smaller numbers test anomalous due bug advfs advfs notable exceptions tests creating files setting attributes reading directories significantly longer frangipani practice latencies small users hard optimize file creation takes longer frangipani partly log fills times test double log size times reduce seconds frangipani slower file read test advfs file read test peculiar artifact implementation iteration read test benchmark makes system call invalidate file buffer cache reading current advfs implementation appears ignore invalidation directive read test measures performance advfs reading cache disk redid test cold advfs file cache performance similar frangipani seconds nvram report throughput achieved single frangipani server reading writing large files file reader sits loop reading set files iteration loop flushes contents files buffer cache file writer sits loop repeatedly writing large private file file large steady stream write traffic disk read write tests run minutes observed significant variation throughput time-averaged steady state results summarized table presence absence nvram effect timing single frangipani machine write data throughput cpu utilization frangipani advfs frangipani advfs write read table frangipani throughput cpu utilization show performance frangipani reading writing large files limit imposed atm link udp software machine frangipani achieves good performance clustering writes petal naturally aligned blocks difficult make frangipani occasionally sync write part data smaller blocks smaller block sizes reduces maximum throughput udp stack frangipani server cpu utilization petal server cpus bottleneck single frangipani machine read data cpu utilization performance improved changing read-ahead algorithm frangipani frangipani read-ahead algorithm borrowed bsd-derived file system ufs effective advfs comparison advfs write data accessing large files striped disks connected controllers cpu utilization advfs read performance cpu utilization cpu controllers bottlenecked advfs performance improved bit tuning interesting note frangipani simple policy lay data latency write throughput comparable conventional file systems elaborate policies frangipani good write latency latency-critical metadata updates logged asynchronously performed synchronously place file systems ufs synchronously update metadata careful data placement separate experiments found frangipani updates logs synchronously performance good log allocated 
large physically contiguous blocks nvram absorbs write latency frangipani achieves good write throughput large files physically striped contiguous units disks machines frangipani exploit parallelism inherent structure frangipani good read throughput large files reason recall section individual blocks files smaller allocated contiguously disk frangipani read-ahead small files hide disk seek access times frangipani bad read performance small files quantify small read performance ran experiment processes single frangipani machine read separate files invalidating buffer cache frangipani throughput cpu bottleneck petal accessed raw device interface blocks deliver frangipani maximum throughput achievable case scaling section studies scaling characteristics frangipani ideally operational latencies unchanged throughput scales linearly servers added compile scan files directory status copy files create directories frangipani machines elapsed time secs figure frangipani scaling modified andrew benchmark frangipani servers simultaneously run modified andrew benchmark independent data sets y-axis averageelapsed time frangipani machine complete benchmark figure shows effect scaling frangipani running modified andrew benchmark experiment measure average time frangipani machine complete benchmark number machines increased experiment simulates behavior users program development shared data pool notice minimal negative impact latency frangipani machines added fact single machine machine experiment average latency increased surprising benchmark exhibits write sharing expectlatencies remain unaffected increasedservers read file uncached linear scaling frangipani machines throughput figure frangipani scaling uncached read frangipani servers simultaneously read set files dotted line shows linear speedup curve comparison figure illustrates frangipani read throughput uncached data test replicate reader single-server experiment multiple servers test runs minutes observe negligible variation steady-state throughput figure frangipani shows excellent scaling test process installing frangipani machines expect aggregate read performance increase saturates petal servers capacity figure illustrates frangipani write throughput writer single-server experiment replicated multiple servers server distinct large file experiment write file linear scaling frangipani machines throughput figure frangipani scaling write frangipani server writes large private file dotted line shows linear speedup curve comparison performance tapers early atm links petal servers saturated runs minutes observe variation steady-state throughput interval lock contention experiment performance scale atm links petal servers saturated virtual disk replicated write frangipani server turns writes petal servers effects lock contention frangipani coarse-grained locking entire files important study effect lock contention performance report experiments experiment measures effect read write sharing files readers compete single writer large file initially file cached readers writer readers read file sequentially writer rewrites entire file result writer repeatedly acquires write lock callback downgrade readers read lock callback writer flush data disk time reader repeatedly acquires read lock callback release writer write lock callback reader invalidate cache read reacquiring lock fetch data disk read-ahead read-ahead number readers read throughput figure frangipani reader writer contention frangipani servers read shared file single frangipani server writes file show effect read-ahead performance results observed experiment unexpected distributed lock manager designed fair granting locks simulations show true implementation single writer readers make lock requests uniform rate serviced round-robin fashion successive grants write lock writer separated grants read lock readers interval downgrade callbacks expect number read requests aggregate read throughput increase readers added limit large scaling linear observe behavior experiment read throughput flattens readers running shown dashed line figure earlier figure frangipani servers achieve lock constrained network shuf rate higher output rate output phase writes copies sorted data make replicas output reliability availability reasons write replicas mechanism reliability availability provided underlying system network bandwidth requirements writing data reduced underlying system erasure coding replication osdi effect backup tasks figure show execution sort program backup tasks disabled execution similar shown figure long tail write activity occurs seconds reduce tasks completed stragglers don ish seconds entire computation takes seconds increase elapsed time machine failures figure show execution sort program intentionally killed worker processes minutes computation underlying cluster scheduler immediately restarted worker processes machines processes killed machines functioning properly worker deaths show negative input rate previously completed map work disappears map workers killed redone re-execution map work quickly entire computation ishes seconds including startup overhead increase normal execution time experience wrote rst version mapreduce library february made signi enhancements august including locality optimization dynamic load balancing task execution worker machines time pleasantly surprised broadly applicable mapreduce library kinds problems work wide range domains google including large-scale machine learning problems clustering problems google news froogle products extraction data produce reports popular queries google zeitgeist extraction properties web pages experiments products extraction geographical locations large corpus web pages localized search large-scale graph computations number instances source tree figure mapreduce instances time number jobs average job completion time secs machine days days input data read intermediate data produced output data written average worker machines job average worker deaths job average map tasks job average reduce tasks job unique map implementations unique reduce implementations unique map reduce combinations table mapreduce jobs run august figure shows signi growth number separate mapreduce programs checked primary source code management system time early separate instances late september mapreduce successful makes write simple program run ciently thousand machines half hour greatly speeding development prototyping cycle programmers experience distributed parallel systems exploit large amounts resources easily end job mapreduce library logs statistics computational resources job table show statistics subset mapreduce jobs run google august large-scale indexing signi mapreduce date complete rewrite production indexto osdi ing system produces data structures google web search service indexing system takes input large set documents retrieved crawling system stored set gfs les raw contents documents terabytes data indexing process runs sequence ten mapreduce operations mapreduce ad-hoc distributed passes prior version indexing system provided benets indexing code simpler smaller easier understand code deals fault tolerance distribution parallelization hidden mapreduce library size phase computation dropped approximately lines code approximately lines expressed mapreduce performance mapreduce library good conceptually unrelated computations separate mixing avoid extra passes data makes easy change indexing process change months make indexing system days implement system indexing process easier operate problems caused machine failures slow machines networking hiccups dealt automatically mapreduce library operator intervention easy improve performance indexing process adding machines indexing cluster related work systems provided restricted programming models restrictions parallelize computation automatically associative function computed pre xes element array log time processors parallel pre computations mapreduce considered simpli cation distillation models based experience large real-world computations signi cantly provide fault-tolerant implementation scales thousands processors contrast parallel processing systems implemented smaller scales leave details handling machine failures programmer bulk synchronous programming mpi primitives provide higher-level abstractions make easier programmers write parallel programs key difference systems mapreduce mapreduce exploits restricted programming model parallelize user program automatically provide transparent fault-tolerance locality optimization draws inspiration techniques active disks computation pushed processing elements close local disks reduce amount data subsystems network run commodity processors small number disks directly connected running directly disk controller processors general approach similar backup task mechanism similar eager scheduling mechanism employed charlotte system shortcomings simple eager scheduling task repeated failures entire computation fails complete instances problem mechanism skipping bad records mapreduce implementation relies in-house cluster management system responsible distributing running user tasks large collection shared machines focus paper cluster management system similar spirit systems condor sorting facility part mapreduce library similar operation now-sort source machines map workers partition data sorted send reduce workers reduce worker sorts data locally memory now-sort user-de nable map reduce functions make library widely applicable river programming model processes communicate sending data distributed queues mapreduce river system provide good average case performance presence non-uniformities introduced heterogeneous hardware system perturbations river achieves careful scheduling disk network transfers achieve balanced completion times mapreduce approach restricting programming model mapreduce framework partition problem large number negrained tasks tasks dynamically scheduled workers faster workers process tasks restricted programming model schedule redundant executions tasks end job greatly reduces completion time presence non-uniformities slow stuck workers bad-fs programming model mapreduce unlike mapreduce targeted osdi execution jobs wide-area network fundamental similarities systems redundant execution recover data loss caused failures locality-aware scheduling reduce amount data congested network links tacc system designed simplify construction highly-available networked services mapreduce relies re-execution mechanism implementing fault-tolerance conclusions mapreduce programming model successfully google purposes attribute success reasons model easy programmers experience parallel distributed systems hides details parallelization fault-tolerance locality optimization load balancing large variety problems easily expressible mapreduce computations mapreduce generation data google production web search service sorting data mining machine learning systems developed implementation mapreduce scales large clusters machines comprising thousands machines implementation makes cient machine resources suitable large computational problems encountered google learned things work restricting programming model makes easy parallelize distribute computations make computations fault-tolerant network bandwidth scarce resource number optimizations system targeted reducing amount data network locality optimization read data local disks writing single copy intermediate data local disk saves network bandwidth redundant execution reduce impact slow machines handle machine failures data loss acknowledgements josh levenberg instrumental revising extending user-level mapreduce api number features based experience mapreduce people suggestions enhancements mapreduce reads input writes output google file system mohit aron howard gobioff markus gutschke david kramer shun-tak leung josh redstone work developing gfs percy liang olcan sercinoglu work developing cluster management system mapreduce mike burrows wilson hsieh josh levenberg sharon perl rob pike debby wallach 
provided helpful comments earlier drafts paper anonymous osdi reviewers shepherd eric brewer provided suggestions areas paper improved finally users mapreduce google engineering organization providing helpful feedback suggestions bug reports andrea arpaci-dusseau remzi arpaci-dusseau david culler joseph hellerstein david patterson high-performance sorting networks workstations proceedings acm sigmod international conference management data tucson arizona remzi arpaci-dusseau eric anderson noah treuhaft david culler joseph hellerstein david patterson kathy yelick cluster river making fast case common proceedings sixth workshop input output parallel distributed systems iopads pages atlanta georgia arash baratloo mehmet karaul zvi kedem peter wyckoff charlotte metacomputing web proceedings international conference parallel distributed computing systems luiz barroso jeffrey dean urs hcurrency olzle web search planet google cluster architecture ieee micro april john bent douglas thain andrea arpaci-dusseau remzi arpaci-dusseau miron livny explicit control batch-aware distributed system proceedings usenix symposium networked systems design implementation nsdi march guy blelloch scans primitive parallel operations ieee transactions computers november armando fox steven gribble yatin chawathe eric brewer paul gauthier cluster-based scalable network services proceedings acm symposium operating system principles pages saint-malo france sanjay ghemawat howard gobioff shun-tak leung google system symposium operating systems principles pages lake george york osdi gorlatch systematic cient parallelization scan list homomorphisms bouge fraigniaud mignotte robert editors euro-par parallel processing lecture notes computer science pages springer-verlag jim gray sort benchmark home page http research microsoft barc sortbenchmark william gropp ewing lusk anthony skjellum mpi portable parallel programming message-passing interface mit press cambridge huston sukthankar wickremesinghe satyanarayanan ganger riedel ailamaki diamond storage architecture early discard interactive search proceedings usenix file storage technologies fast conference april richard ladner michael fischer parallel pre computation journal acm michael rabin cient dispersal information security load balancing fault tolerance journal acm erik riedel christos faloutsos garth gibson david nagle active disks large-scale data processing ieee computer pages june douglas thain todd tannenbaum miron livny distributed computing practice condor experience concurrency computation practice experience valiant bridging model parallel computation communications acm jim wyllie spsort sort terabyte quickly http alme almaden ibm spsort pdf word frequency section program counts number occurrences unique word set input les speci command line include mapreduce mapreduce user map function class wordcounter public mapper public virtual void map const mapinput input const string text input const int text size int skip past leading whitespace isspace text find word end int start isspace text start emit text substr start i-start register mapper wordcounter user reduce function class adder public reducer virtual void reduce reduceinput input iterate entries key add values int inputdone stringtoint inputvalue inputnextvalue emit sum inputkey emit inttostring register reducer adder int main int argc char argv parsecommandlineflags argc argv mapreducespecification spec store list input files spec int argc mapreduceinput input spec add input inputset format text inputset filepattern argv inputset mapper class wordcounter output files gfs test freq-of- gfs test freq-of- mapreduceoutput spec output outset filebase gfs test freq outset num tasks outset format text outset reducer class adder optional partial sums map tasks save network bandwidth outset combiner class adder tuning parameters machines memory task spec set machines spec set map megabytes spec set reduce megabytes run mapreduceresult result mapreduce spec result abort result structure info counters time number machines return osdi 
contention conjectured anomalous behavior caused read-ahead repeated experiment read-ahead check read-ahead disadvantageous presence heavy read write contention reader called back release lock invalidate cache read-ahead data cache delivered client discarded work read turns wasted readers extra work make lock requests rate writer redoing experiment read-ahead disabled yielded expected scaling result shown solid line figure make performance improvement users letting explicitly disable read-ahead specific files devising heuristic recognize case disable read-ahead automatically trivial implement affect parts operating system kernel frangipani making inconvenient support future releases kernel approach devised tested heuristics triangle diamond number readers read throughput triangle triangle triangle triangle triangle diamond diamond diamond diamond diamond figure effect data size reader writer contention frangipani readers share varying amounts data frangipani writer readahead disabled experiment experiment variation readers run writer modifies amounts file data frangipani locks entire files readers invalidate entire cache irrespective writer behavior readers acquire lock faster writer updating fewer blocks data writer flush smaller amounts data disk figure shows performance frangipani read-ahead disabled readers writer concurrently share differing amounts data expected shared data smaller performance experiment measures effects write write sharing files base case frangipani server writes file isolation added frangipani servers wrote file measured degradation performance writers modify file data blocks frangipani whole-file locking offsets writers irrelevant test found aggregate bandwidth writers dropped single-writer case writers surprising multiple writers modify file write system call lock revocation request revocation request lock holder flush dirty data petal locks revoked write system call call dirties data throughput limited smaller block sizes throughput smaller experience workloads exhibit concurrent write sharing straightforward extend frangipani implement byte-range locking block locking improve performance workloads read write parts file making similar performance writing files current system workloads multiple machines concurrently read write blocks file filesystem interprocess communication channel perform frangipani simply targeted workloads related work frangipani cambridge universal file server takes two-layered approach building file system split layers cfs lower layer clients abstractions files indices file systems built cfs abstractions implement files directories major difference cfs petal cfs single machine manages storage nfs file system simply remote file access protocol nfs protocol weak notion cache coherence stateless design requires clients access servers frequently maintain level coherence frangipani strongly coherent single system view protocol maintains state eliminates unnecessary accesses servers andrew file system afs offshoot dce dfs provide cache performance coherence nfs afs designed kind scalability frangipani frangipani unified cluster file system draws single pool storage scaled span disk drives machines common administration contrast afs global space security architecture plug separate file servers clients wide area afs frangipani approaches scaling complementary make good sense frangipani servers export file system wide-area clients afs dce dfs space access protocol frangipani echo file system logbased replicates data reliability access paths availability permits volumes span multiple disks coherent caching echo share frangipani scalability echo volume managed server time failover designated backup volume span disks connected single machine internal layering file service atop disk service echo implementation requires layers run 
address space machine experience echo showed server cpu bottleneck vms cluster file system offloads file system processing individual machines members cluster frangipani cluster member runs instance file systemcode top shared physical disk synchronization provided distributed lock service shared physical disk accessed special-purpose cluster interconnect disk controller directly connected ordinary network ethernet machine acting disk server frangipani improves design ways shared physical disk replaced shared scalable virtual disk provided petal frangipani file system log-based quick failure recovery frangipani extensive caching data metadata performance spiralog file system offloads file system processing individual cluster members run shared storage system layer interface layers spiralog differs original vms cluster file system petal lower layer file-like simply disk-like array stably-stored bytes permits atomic actions update arbitrarily scattered sets bytes array spiralog split layers simplifies file system complicates storage system considerably time spiralog storage system share petal scalability fault tolerance spiralog volume span disks connected machine unavailable machine crashes designed cluster file system calypso similar echo vms clusters frangipani echo calypso stores files multiported disks machines directly connected disk acts file server data stored disk machine fails takes members calypso cluster access current server file system clients frangipani echo clients caches coherent multiple-reader single-writer locking protocol comparison purposes authors calypso built file system shared-disk style called pjfs calypso performed pjfs leading abandon shareddisk approach pjfs differs frangipani main respects lower layer centralized disk server distributed virtual disk petal file server machines pjfs share common log shared log proved performance bottleneck frangipani pjfs locks shared disk wholefile granularity granularity caused performance problems workloads large files concurrently write-shared multiple nodes expect present frangipani implementation similar problems workloads noted section adopt byte-range locking shillner felten built distributed file system top shared logical disk layering system similar lower layer multiple machines cooperate implement single logical disk upper layer multiple independent machines run file system code top logical disk providing access files unlike petal logical disk layer provide redundancy system recover node fails restarts dynamically configure failed nodes configure additional nodes file system careful ordering metadata writes logging frangipani logging technique avoids full metadata scan fsck restore consistency server crash unlike logging lose track free blocks crash necessitating occasional garbage collection scan find unable compare performance system present performance numbers file system layer xfs file system closest spirit frangipani fact goals systems essentially distribute management responsibility files multiple machines provide good availability performance frangipani effectively serverless sense xfs service distributed machines configured frangipani server petal server machine frangipani locking coarser-grained xfs supports block-level locking work differs xfs principal ways internal organization file system interface storage system significantly xfs unlike frangipani xfs predesignated manager file storage server log-structured contrast frangipani organized set cooperating machines petal shared store separate lock service concurrency control simpler model reminiscent multithreaded shared memory programs communicate common store locks synchronization model deal file system recovery server addition deletion machinery xfs requires made system easier implement test addressed file system recovery reconfiguration issues left open problems xfs work date compare frangipani performance xfs considerable performance work remains completed current xfs prototype comparison systems time premature unfair xfs conclusions frangipani file system users coherent shared access set files scalable provide storage space higher performance load balancing user community grows remains spite component failures requires human administration administration complex components added growing installation frangipani feasible build two-layer structure consisting multiple file servers running simple file system code top shared petal virtual disk petal lower layer provided benefits petal implements data replication high availability obviating frangipani petal virtual disk uniformly accessible frangipani servers server serve file machine run recovery server fails petal large sparse address space allowed simplify frangipani on-disk data structures frangipani simple data layout allocation policy coarse-grained locking happy performance initial performance measurements frangipani comparable production digital unix file system expect improvement tuning frangipani shown good scaling properties size testbed configuration petal nodes frangipani nodes results leave optimistic system continue scale nodes future plans include deploying frangipani dayto-day hope gain experience prototype load validate scalability testing larger configurations experiment finer-grained locking complete work backup finally ideas frangipani make commercial products acknowledgments mike burrows mike schroeder puneet kumar helpful advice frangipani design comments paper fay chang implemented early prototype frangipani summer project anonymous referees shepherd john wilkes suggested improvements paper cynthia hibbard provided editorial assistance thomas anderson michael dahlin jeanna neefe david patterson drew roselli randolph wang serverless network file systems acm transactions computer systems february philip bernstein vassos hadzilacos nathan goodman concurrency control recovery database systems addison-wesley anupam bhide elmootazbellah elnozahy stephen morgan highly network file server proceedings winter usenix conference pages january birrell needham universal file server ieee transactions software engineering seseptember andrew birrell andy hisgen charles jerian timothy mann garret swart echo distributed file system research report systems research center digital equipment corporation september michael burrows efficient data sharing phd thesis cambridge september chao english jacobson stepanov wilkes mime high performance parallel storage device strong recovery guarantees technical report hpl-csp- hewlett-packard laboratories november jeffrey chase henry levy michael feeley edward lazowska sharing protection singleaddress-spaceoperating system acm transactions computer systems november sailesh chutani owen anderson michael kazar bruce leverett anthony mason robert sidebotham episode file system proceedings winter usenix conference pages january wiebren jonge frans kaashoek wilson hsieh logical disk approach improving file systems proc symp operating systems principles pages december murthy devarakonda bill kish ajay mohindra recovery calypso file system acm transactions computer systems august murthy devarakonda ajay mohindra jill simoneaux william tetzlaff evaluation design alternatives cluster file system proceedings winter usenix conference pages january garth gibson david nagle khalil amiri fay chang eugene feinberg howard gobioff chen lee berend ozceri erik riedel david rochberg jim zelenka file server scaling network-attached secure disks proceedings acm international conference measurements modeling computer systems sigmetrics pages june andrew goldstein design implementation distributed file system digital technical journal september digital equipment corporation nagog park acton cary gray david cheriton leases efficient faulttolerant mechanism distributed file cache consistency proc symp operating systems principles pages december robert hagmann reimplementing cedar file system logging group commit proc symp operating systems principles pages november john hartman john 
ousterhout zebra striped network file system acm transactions computer systems august andy hisgen andrew birrell charles jerian timothy mann garret swart new-value logging echo replicated file system research report systems research center digital equipment corporation june john howard michael kazar sherri menees david nichols satyanarayanan robert sidebotham michael west scale performance distributed file system acm transactions computer systems february james johnson william laing overview spiralog file system digital technical journal digital equipment corporation nagog park acton michael kazar bruce leverett owen anderson vasilis apostolides ben bottos sailesh chutani craig everhart antony mason shu-tsui edward zayas decorum file system architectural overview proceedings summer usenix conference pages june nancy kronenberg henry levy william strecker vaxclusters closely-coupled distributed system acm transactions computer systems leslie lamport part-time parliament research report systems research center digital equipment corporation september edward lee chandramohan thekkath petal distributed virtual disks proc intl conf architectural support programming languages operating systems pages october barbara liskov sanjay ghemawat robert gruber paul johnson liuba shrira michael williams replication harp file system proc symp operating systems principles pages october timothy mann andrew birrell andy hisgen charles jerian garret swart coherent distributed file cache directory write-behind acm transactions computer systems marshal kirk mckusick william joy samuel leffler robert fabry fast file system unix acm transactions computer systems august james mitchell jeremy dion comparison network-based file servers communications acm april sape mullender andrew tanenbaum files software practice experience april michael nelson brent welch john ousterhout caching sprite network file system acm transactions computer systems february brian pawlowski chet juszczak peter staubach carl smith diane lebel david hitz nfs version design implementation proceedings summer usenix conference pages june mendel rosenblum john ousterhout design implementation log-structured file system acm transactions computer systems february russel sandberg david goldberg steve kleiman dan walsh bob lyon design implemention sun network filesystem proceedings summer usenix conference pages june robert shillner edward felten simplifying distributed file systems shared logical disk technical report tr- dept computer science princeton garret swart andrew birrell andy hisgen charles jerian timothy mann availability echo file system research report systems research center digital equipment corporation september randy wang tom anderson mike dahlin experience distributed file system implementation technical report california berkeley computer science division june edward wobber martin abadi michael burrows butler lampson authentication taos operating system acm transactions computer systems february 
analysis evolution journaling file systems vijayan prabhakaran andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison vijayan dusseau remzi wisc abstract develop apply methods analyzing file system behavior evaluating file system semantic block-level analysis sba combines knowledge on-disk data structures trace disk traffic infer file system behavior contrast standard benchmarking approaches sba enables users understand file system behaves semantic trace playback stp enables traces disk traffic easily modified represent file system implementation contrast directly modifying file system stp enables users rapidly gauge benefits policies sba analyze linux ext reiserfs jfs windows ntfs process uncover strengths weaknesses journaling file systems apply stp evaluate modifications ext demonstrating benefits optimizations incurring costs real implementation introduction modern file systems journaling file systems writing information pending updates write-ahead log committing updates disk journaling enables fast file system recovery crash basic techniques existed years cedar episode journaling increased popularity importance recent years due ever-increasing disk capacities scan-based recovery fsck prohibitively slow modern drives raid volumes popularity importance journaling file systems ext reiserfs jfs ntfs internal policies understanding file systems behave important developers administrators application writers time perform detailed analysis journaling file systems previous work analyzed file systems writing userlevel programs measuring time file system operations elicit salient aspects file system performance difficult discover underlying reasons observed performance approach paper employ benchmarking methodology called semantic block-level analysis sba trace analyze file systems sba induce controlled workload patterns file system focus analysis time operations resulting stream read write requests file system analysis semantic leverage information block type block request journal inode analysis block-level interposes block interface storage analyzing low-level block stream semantically meaningful understand file system behaves analysis hints file system improved reveal change worth implementing traditionally potential improvement file system implement change measure performance workloads change improvement implementation effort wasted paper introduce apply complementary technique sba called semantic trace playback stp stp enables rapidly suggest evaluate file system modifications large implementation simulation effort real workloads traces show stp effectively applied detailed analysis linux ext reiserfs preliminary analysis linux jfs windows ntfs case focus journaling aspects file system determine events data metadata written journal fixed locations examine characteristics workload configuration parameters size journal values commit timers impact behavior analysis uncovered design flaws performance problems correctness bugs file systems ext reiserfs make design decision group unrelated traffic compound transaction result tangled synchrony single disk-intensive process forces write traffic disk affecting performance asynchronous writers find ext reiserfs artificially limit parallelism preventing overlap pre-commit journal writes fixed-place updates analysis reveals ordered data journaling modes ext exhibits eager writing forcing data blocks disk sooner typical -second delay addition find jfs proceedings usenix annual technical conference april anaheim infinite write delay utilize commit timers indefinitely postpones journal writes trigger forces writes occur memory pressure finally identify previously unknown bugs reiserfs fixed subsequent releases main contributions paper methodology semantic block analysis sba understanding internal behavior file systems methodology semantic trace playback stp rapidly gauging benefits file system modifications heavy implementation effort detailed analysis sba important journaling file systems ext reiserfs preliminary analysis jfs ntfs evaluation stp design implementation alternatives ext rest paper organized describe techniques sba stp apply techniques ext reiserfs jfs ntfs discuss related work conclude methodology introduce techniques evaluating file systems semantic block analysis sba enables users understand internal behavior policies file system semantic trace playback stp users quantify changing file system impact performance real workloads semantic block-level analysis file systems traditionally evaluated approaches applies synthetic real workloads measures resulting file system performance collects traces understand file systems performing isolation misses interesting opportunity correlating observed disk traffic running workload performance answer workload behaves block-level tracing disk traffic analyze number interesting properties file system workload coarsest granularity record quantity disk traffic divided reads writes information understanding file system caching write buffering affect performance detailed level track block number block read written analyzing block numbers extent traffic sequential random finally analyze timing block timing information understand file system initiates burst traffic combining block-level analysis semantic information blocks infer ext reiserfs jfs ntfs sba generic sba specific sba total table code size sba drivers number statements counted number semicolons needed implement sba ext reiserfs preliminary sba jfs ntfs behavior file system main difference semantic block analysis sba standard block-level tracing sba analysis understands on-disk format file system test sba enables understand properties file system sba distinguish traffic journal versus in-place data track individual transactions journal implementation infrastructure performing sba straightforward places pseudo-device driver kernel associates underlying disk mounts file system interest ext pseudo device refer sba driver runs controlled microbenchmarks generate disk traffic sba driver passes traffic disk efficiently tracks request response storing small record fixed-sized circular buffer note tracking ordering requests responses pseudo-device driver infer order requests scheduled lower levels system sba requires interpret contents disk block traffic interpret contents journal infer type journal block descriptor commit block interpret journal descriptor block data blocks journaled result efficient semantically interpret block-level traces on-line performing analysis off-line require exporting contents blocks greatly inflating size trace sba driver customized file system test concern amount information embedded sba driver file system focus paper understanding journaling file systems sba drivers embedded information interpret placement contents journal blocks metadata data blocks analyze complexity sba driver journaling file systems ext reiserfs jfs ntfs journaling file systems journal transactions temporarily recorded fixed-location data structures data permanently reside sba driver distinguishes traffic journal fixed-location data structures traffic simple distinguish reiserfs jfs ntfs journal set contiguous blocks separate rest file system backward proceedings usenix annual technical conference april anaheim compatible ext ext treat journal regular file determine blocks belong journal sba knowledge inodes indirect blocks journal change location created classification remains efficient run-time sba classify types journal blocks descriptor block journal data block commit block perform analysis journaling file systems sba driver understand details file system driver understand directory blocks superblock ext tree structure reiserfs jfs wishes infer additional file system properties embed sba driver knowledge sba driver policies parameters file system fact sba infer policies parameters table reports number statements required implement sba driver numbers show code sba driver statements general infrastructure approximately 
statements needed support journaling file systems ext specific code file systems ext journal created file span multiple block groups order find blocks belonging journal file parse journal inode journal indirect blocks reiserfs jfs ntfs journal contiguous finding blocks trivial journal file ntfs small journals contiguously allocated workloads sba analysis gather information workload focus paper understanding internal policies behavior file system result construct synthetic workloads uncover decisions made file system realistic workloads considered apply semantic trace playback constructing synthetic workloads stress file system previous research revealed range parameters impact performance created synthetic workloads varying parameters amount data written sequential versus random accesses interval calls fsync amount concurrency focus exclusively write-based workloads reads directed fixed-place location impact journal analyze file system report results workloads revealed file system policies parameters overhead sba processing memory overheads sba minimal workloads ran generate high rates request sba driver performs operations collect detailed traces gettimeofday call start end block number comparison block journal fixed-location block check magic number journal blocks distinguish journal metadata journal data sba stores trace records details read write block number block type time issue completion internal circular buffer operations performed detailed traces analyses sufficient cumulative statistics total number journal writes fixedlocation writes numbers easy collect require processing sba driver alternative approaches directly instrumenting file system obtain timing information disk traces equivalent superior performing sba analysis case reasons directly instrument file system source code file system re-instrument versions released contrast sba analysis require file system source sba driver code reused file systems versions directly instrumenting file system accidentally miss conditions disk blocks written sba driver guaranteed disk traffic finally instrumenting existing code accidentally change behavior code efficient sba driver impact file system behavior semantic trace playback section describe semantic trace playback stp stp rapidly evaluate kinds file system designs heavy implementation investment detailed file system simulator describe stp functions stp built user-level process takes input trace parses issues requests disk raw disk interface multiple threads employed concurrency ideally stp function taking blocklevel trace input generated sba driver sufficient types file system modifications straightforward model layout schemes simply mapping blocks on-disk locations desire enable powerful emulations stp issue explore effect byte differences journal storing entire blocks complication arises changing contents journal proceedings usenix annual technical conference april anaheim timing block thresholds initiate triggered time handle emulations alter timing disk information needed readily low-level block trace specifically stp observe high-level activities stp observe file-system level operations create dirty buffers memory reason requirement found number uncommitted buffers reaches threshold ext journal size commit enacted similarly interval timers expires blocks flushed disk stp observe application-level calls fsync stp understand operation sba trace due fsync call due normal file system behavior thresholds crossed timers differentiation stp emulate behaviors timing sensitive requirements met giving filesystem level trace input stp addition sbagenerated block-level trace library-level interpositioning trace application interest qualitatively compare stp standard approaches file system evolution approach idea improving file system simply implements idea file system measures performance real system approach attractive reliable answer idea real improvement assuming workload applied relevant time consuming modification file system non-trivial approach builds accurate simulation file system evaluates idea domain file system migrating real system approach attractive avoid details building real implementation quickly understand idea good requires detailed accurate simulator construction maintenance challenging endeavor stp avoids difficulties approaches low-level traces truth file system behaves modifying file system output block stream based simple internal models file system behavior models based empirical analysis found advantages traditional implementation simulation stp limited important ways stp suited evaluating design alternatives simpler benchmarks workload exhibits complex virtual memory behavior interactions file system modeled results meaningful stp limited evaluating file system radical basic operation file system remain intact finally stp provide means evaluate implement change understand modification improves performance environment measurements machine running linux mhz pentium iii processor main memory file system test created single ibm lzx disk separate root disk data point reports average trials cases variance low ext file system section analyze popular linux filesystem ext begin giving overview ext apply semantic block-level analysis semantic trace playback understand internal behavior background linux ext journaling file system built extension ext file system ext data metadata eventually standard ext structures fixed-location structures organization loosely based ffs disk split number block groups block group bitmaps inode blocks data blocks ext journal log commonly stored file file system stored separate device partition figure depicts ext on-disk layout information pending file system updates written journal forcing journal updates disk updating complex file system structures writeahead logging technique enables efficient crash recovery simple scan journal redo incomplete committed operations bring file system consistent state normal operation journal treated circular buffer information propagated fixed location ext structures journal space reclaimed journaling modes linux ext includes flavors journaling writeback mode ordered mode data journaling mode figure illustrates differences modes choice mode made mount time changed remount writeback mode file system metadata journaled data blocks written directly fixed location mode enforce ordering journal fixed-location data writes writeback mode weakest consistency semantics modes guarantees consistent file system metadata provide guarantee consistency data blocks ordered journaling mode metadata writes journaled data writes fixed location ordered journal writes metadata proceedings usenix annual technical conference april anaheim jcib inode groupscylinder group journal descriptor block inode bitmap journal commit blockdb data bitmap journal superblock figure ext on-disk layout picture shows layout ext file system disk address space broken series block groups akin ffs cylinder groups bitmaps track allocations regions inodes data blocks ext journal depicted file block group file system superblock descriptor blocks describe contents commit blocks denote ends transactions journal commit journal inode sync fixed data fixed data fixed inode fixed data journal inode sync journal commit fixed data sync fixed inode sync writeback mode data write happen time writeback ordered journal inode data fixed inode data journal commit data journal write journal commit checkpoint write figure ext journaling modes diagram depicts journaling modes ext writeback ordered data diagram time flows downward boxes represent updates file system journal inode implies write inode journal destination writes labeled fixed write fixed in-place ext structures 
arrow labeled sync implies blocks written succession synchronously guaranteeing completes curved arrow ordering succession write happen time finally writeback mode dashed box fixed data block happen time sequence data block write inode updates propagated file system diagrams show data flow ext journaling modes contrast writeback mode mode consistency semantics data metadata guaranteed consistent recovery full data journaling mode ext logs metadata data journal decision implies process writes data block typically written disk journal fixed ext location data journaling mode strong consistency guarantees ordered journaling mode performance characteristics cases worse surprisingly cases explore topic transactions file system update separate transaction ext groups updates single compound transaction periodically committed disk approach simple implement compound transactions performance fine-grained transactions structure frequently updated short period time free space bitmap inode file constantly extended journal structure ext additional metadata structures track list journaled blocks journal superblock tracks summary information journal block size head tail pointers journal descriptor block marks beginning transaction describes subsequent journaled blocks including final fixed on-disk location data journaling mode descriptor block data metadata blocks ordered writeback mode descriptor block metadata blocks modes ext logs full blocks opposed differences versions single bit change bitmap results entire bitmap block logged depending size transaction multiple descriptor blocks data metadata blocks logged finally journal commit block written journal end transaction commit block written journaled data recovered loss checkpointing process writing journaled metadata data fixed-locations checkpointing checkpointing triggered thresholds crossed file system buffer space low free space left journal timer expires crash recovery crash recovery straightforward ext journaling file systems basic form redo logging updates data metadata written log process restoring in-place file system structures easy recovery file system scans log committed complete transactions incomplete transactions discarded update completed transaction simply replayed fixed-place ext structures analysis ext sba perform detailed analysis ext sba framework analysis divided categories analyze basic behavior ext function workload journaling modes isolate factors control data committed journal isolate factors control data checkpointed fixed-place location proceedings usenix annual technical conference april anaheim bandwidth amount data written bandwidth data ordered writeback ext journal data amount data written amount journal writes data ordered writeback ext fixed-location data amount data written amount fixed-location writes data ordered writeback ext figure basic behavior sequential workloads ext graph evaluate ext ext journaling modes increase size written file x-axis workload writes single file sequentially performs fsync graph examines metric top graph shows achieved bandwidth middle graph sba report amount journal traffic bottom graph sba report amount fixed-location traffic journal size set basic behavior modes workload begin analyzing basic behavior ext function workload journaling mode writeback ordered full data journaling goal understand workload conditions trigger ext write data metadata journal fixed locations explored range workloads varying amount data written sequentiality writes synchronization interval writes number concurrent writers sequential random workloads begin showing results basic workloads workload writes single file sequentially performs fsync flush data disk figure workload issues writes random locations single file calls fsync writes figure workload issues random writes calls fsync write figure workload increase total amount data bandwidth amount data written random write bandwidth data ordered writeback ext journal data amount data written amount journal writes data ordered writeback ext fixed-location data amount data written amount fixed-location writes data ordered writeback ext figure basic behavior random workloads ext figure similar figure workload issues writes random locations single file calls fsynconce writes top graph shows bandwidth middle graph shows journal traffic bottom graph reports fixed-location traffic journal size set writes observe behavior ext top graphs figures plot achieved bandwidth workloads graph compare journaling modes ext bandwidth graphs make observations achieved bandwidth extremely sensitive workload expected sequential workload achieves higher throughput random workload calling fsync frequently reduces throughput random workloads sequential traffic ext performs slightly highest performing ext mode small noticeable cost journaling sequential streams workloads ordered mode writeback mode achieve bandwidths similar ext finally performance data journaling irregular varying sawtooth pattern amount data written graphs file system throughput compare performance workloads journaling modes enable infer differences infer internal behavior file system apply semantic analysis underlying block stream proceedings usenix annual technical conference april anaheim bandwidth amount data written random write bandwidth data ordered writeback ext journal data amount data written amount journal writes data ordered writeback ext fixed-location data amount data written amount fixed-location writes data ordered writeback ext figure basic behavior random workloads ext figure similar figure workload issues random writes calls fsync write bandwidth shown graph journal writes fixed-location writes reported graph sba journal size set record amount journal fixedlocation traffic accounting shown bottom graphs figures row graphs figures quantify amount traffic flushed journal infer events traffic data journaling mode total amount data written journal high proportional amount data written application expected data metadata journaled modes metadata journaled amount traffic journal small row figures shows traffic fixed location writeback ordered mode amount traffic written fixed location equal amount data written application data journaling mode observe stair-stepped pattern amount data written fixed location file size process called fsync force data disk data written fixed location time application terminates data logged expected consistency semantics preserved consistency application writes data checkpointing occur regular intervals extra traffic leads sawtooth bandwidth measured graph experiment sequential traffic journal size checkpoint occurs data written explore relationship checkpoints journal size carefully sba graphs reveal data journaling mode performs modes asynchronous random writes data journaling mode data written log random writes logically sequential achieve sequential bandwidth journal filled checkpointing extra disk traffic reduces bandwidth experiment checkpointing occurs finally sba analysis reveals synchronous writes perform data journaling mode forcing small write log logical sequence incurs delay sequential writes shown write incurs disk rotation concurrency report results running workloads multiple processes construct workload diverse classes traffic asynchronous foreground process competition background process foreground process writes file calling fsync background process repeatedly writes block random location optionally calls fsync sleeps period time sync interval focus data journaling mode effect holds ordered journaling mode shown figure show impact varying sync interval background process performance foreground process graph plots bandwidth achieved foreground asynchronous process depending competes asynchronous synchronous background process expected 
foreground process runs asynchronous background process bandwidth uniformly high matches in-memory speeds foreground process competes synchronous background process bandwidth drops disk speeds sba analysis graph reports amount journal data revealing frequently background process calls fsync traffic journal fact amount journal traffic equal sum foreground background process traffic written interval background process effect due implementation compound transactions ext file system updates add global transaction eventually committed disk workload reveals potentially disastrous consequences grouping unrelated updates comproceedings usenix annual technical conference april anaheim bandwidth sync interval milliseconds bandwidth background process call fsync background process calling fsync journal data sync interval milliseconds amount journal writes background process call fsync background process calls fsync figure basic behavior concurrent writes ext processes compete workload foreground process writing sequential file size background process writing optionally calling fsync sleeping sync interval repeating x-axis increase sync interval top graph plot bandwidth achieved foreground process scenarios background process calling calling fsync write bottom graph amount data written disk sets experiments shown pound transaction traffic committed disk rate asynchronous traffic wait synchronous updates complete refer negative effect tangled synchrony explore benefits untangling transactions stp journal commit policy explore conditions ext commits transactions on-disk journal factors influence event size journal settings commit timers experiments focus data journaling mode mode writes metadata data journal traffic journal easily mode writeback ordered modes commit transactions policies exercise log commits examine workloads data explicitly forced disk application process call fsync minimize amount metadata overhead write single file impact journal size size journal configurable parameter ext contributes updates committed varying size journal amount data written workload infer amount data triggers log commit figure shows resulting bandwidth amount journal traffic function file size journal size graph shows amount data writbandwidth amount data written bandwidth journal size journal size journal size journal size journal data amount data written amount journal writes journal size journal size figure impact journal size commit policy ext topmost figure plots bandwidth data journaling mode different-sized file writes lines plotted representing journal sizes graph shows amount log traffic generated experiments clarity journal sizes shown ten application precise number dirty uncommitted buffers includes data metadata reaches size journal bandwidth drops considerably fact performance regime observed bandwidth equal in-memory speeds semantic analysis shown graph reports amount traffic journal graph reveals metadata data forced journal equal journal size inspection linux ext code confirms threshold note threshold ordered writeback modes shown triggered frequently metadata logged impact timers linux ext timers control data written metadata commit timer data commit timer managed kupdate daemon commit timer managed kjournal daemon system-wide kupdate daemon responsible flushing dirty buffers disk kjournal daemon specialized ext responsible committing ext transactions strategy ext flush metadata frequently seconds delaying data writes longer time seconds flushing metadata frequently advantage file system approach ffs-like consistency severe performance penalty delaying data writes advantage files deleted quickly tax disk mapping ext goals ext timers leads default values seconds kupdate metadata timer seconds kjournal timer proceedings usenix annual technical conference april anaheim journal write time seconds kupdated metadata timer seconds sensitivity kupdated metadata timer journal write time seconds kupdated data timer seconds sensitivity kupdated data timer journal write time seconds kjournald timer seconds sensitivity kjournald timer figure impact timers commit policy ext graph timer varied x-axis time write journal recorded y-axis measuring impact timer set timers seconds journal size affect measurements seconds kupdate data timer measure timers affect transactions committed journal ensure specific timer influences journal commits set journal size sufficiently large set timers large analysis observe write appears journal figure plots results varying timers x-axis plotting time log write occurs y-axis graph graph show kupdate daemon metadata commit timer kjournal daemon commit timer control timing log writes data points log write occurred precisely timer expired traffic log minimum timers graph shows kupdate daemon data timer influence timing log writes data points correlated x-axis timer influences data written fixed location interaction journal fixed-location traffic timing writes journal fixedrequest queue blocks time seconds write ordering ext fixed location journal figure interaction journal fixed-location traffic ext figure plots number outstanding writes journal fixed-location disks experiment run processes issues random synchronous writes file system journal running ordered mode journal configured run separate disk location data managed carefully consistency fact difference writeback ordered mode timing writeback mode enforce ordering ordered mode ensures data written fixed location commit block transaction written journal performed sba analysis found performance deficiency ordered mode implemented workload synchronously writes large number random blocks sba driver separate journal fixed-location data figure plots number concurrent writes data type time figure shows writes journal fixed-place data overlap specifically ext issues data writes fixed location waits completion issues journal writes journal waits completion finally issues final commit block waits completion observe behavior irrespective journal separate device device file system inspection ext code confirms observation wait needed correctness cases journal configured separate device extra wait severely limit concurrency performance ext falsely limited parallelism stp fix timing problem checkpoint policy turn attention checkpointing process writing data fixed location ext structures show checkpointing ext function journal size commit timers synchronization interval workload focus data journaling mode sensitive journal size understand checkpointing occurs construct workloads periodically force data journal call fsync observe data subsequently written fixed location impact journal size figure shows sba results proceedings usenix annual technical conference april anaheim fixed location data amount data written amount fixed location writes sync size sync size sync size free space amount data written checkpointing sync size sync size sync size journal size journal size figure impact journal size checkpoint policy ext workload amount data x-axis written sequentially fsync issued graph sba plot amount fixed-location traffic graph sba plot amount free space journal function file size synchronization interval single journal size graph shows amount data written fixed ext location end experiment point checkpointing occurs varies sync intervals sync interval data forced disk worth writes checkpoints occur approximately committed log sync interval checkpoints occur illustrate triggers checkpoint graph plot amount journal free space immediately preceding checkpoint correlating graphs checkpointing occurs amount free space -th -th journal size precise fractiondepends synchronization interval smaller sync 
amounts checkpointing postponed free space journal confirmed relationship journal sizes shown impact timers examine system timers impact timing checkpoint writes fixed locathe exact amount free space triggers checkpoint straightforward derive reasons ext reserves amount journal space overhead descriptor commit blocks ext reserves space journal committing transaction synchronization interval derived free space function precisely feel detailed information enlightening simply checkpointing occurs free space -th -th journal size write time seconds kupdated data timer seconds sensitivity kupdated data timer log writes fixed-location writes figure impact timers checkpoint policy ext figure plots relationship time data written log checkpointed dependent kupdate data timer scatter plot shows results multiple runs process running writes data fsync data journaling mode timers set seconds journal size tions workload vary kupdate data timer setting timers seconds figure shows kupdate data timer impacts data written fixed location previously figure log updated timers expire checkpoint write occurs amount kupdate data timer granularity experiments shown reveal granularity controlled kupdate metadata timer analysis reveals ext timers lead timing data metadata traffic ext ordered data journaling modes force data disk time metadata writes data metadata flushed disk frequently timing behavior largest potential performance differentiator ordered writeback modes interestingly frequent flushing potential advantage forcing data disk timely manner large disk queues avoided performance improved disadvantage early flushing temporary files written disk subsequent deletion increasing load system summary ext sba isolated number features ext strong impact performance journaling mode delivers performance depends strongly workload random workloads perform logging relationship size journal amount data written application larger impact performance ext implements compound transactions unrelated concurrent updates transaction result tangled synchrony traffic transaction committed disk rate results disastrous performance asynchronous traffic combined synchronous traffic proceedings usenix annual technical conference april anaheim bandwidth file number bandwidth ordered journaling mode default ext journal beginning modified ext journal middle stp journal middle figure improved journal placement stp compare placements journal beginning partition ext default modeled middle file system stp middle file system files created file system file chosen number x-axis workload issues synchronous writes file ordered mode ext overlap writes journal fixed-place data specifically ext issues data writes fixed location waits completion issues journal writes journal waits completion finally issues final commit block waits completion wait needed correctness journal separate device falsely limited parallelism harm performance ordered data journaling modes timer flushes meta-data disk data flushed disadvantage eager writing temporary files written disk increasing load evolving ext stp section apply stp wider range workloads traces evaluate modifications ext demonstrate accuracy stp approach begin simple modification varies placement journal sba analysis pointed number improvements ext quantify stp journaling modes depending workload separate transactions update overlapping pre-commit journal writes data updates ordered mode finally stp evaluate differential journaling block differences written journal journal location experiment stp quantifies impact changing simple policy placement journal default ext creates journal regular file beginning partition start policy validate stp results obtain stp similar implement change ext construct workload stresses placement journal partition filled files benchmark process issues random synchronous bandwidth sync interval milliseconds bandwidth untangled standard figure untangling transaction groups stp experiment identical figure addition show performance foreground process untangled transactions emulated stp writes chosen file figure vary file chosen x-axis line graph shows performance ordered mode default ext bandwidth drops file located journal sba analysis shown confirms performance drop occurs seek distance increases writes file journal evaluate benefit placing journal middle disk stp remap blocks validation coerce ext allocate journal middle disk compare results figure shows stp predicted performance identical version ext worst-case behavior avoided placing journal middle file system beginning longest seeks entire volume avoided synchronous workloads workloads frequently seek journal ext structures journaling mode shown workloads perform journaling modes random writes perform data journaling mode random writes written sequentially journal large sequential writes perform ordered mode avoids extra traffic generated data journaling mode journaling mode ext set mount time remains fixed mount stp evaluate adaptive journaling mode chooses journaling mode transaction writes transaction transaction sequential ordered journaling data journaling demonstrate potential performance benefits adaptive journaling run portion trace labs removing inter-arrival times calls compare ordered mode data journaling mode adaptive approach trace completes seconds seconds ordered data journaling modes stp adaptive journaling trace completes seconds trace sequential random write proceedings usenix annual technical conference april anaheim request queue blocks time seconds modified write ordering fixed location journal figure changing interaction journal fixedlocation traffic stp experiment run figure run stp issue precommit journal writes data writes concurrently plot stp emulated performance made change ext directly obtaining resultant performance phases adaptive journaling performs single-mode approach transaction grouping linux ext groups updates system-wide compound transactions commits disk periodically shown single update stream synchronous dramatic impact performance asynchronous streams transforming in-memory updates disk-bound stp show performance file system untangles traffic streams forcing process issues fsync commit data disk figure plots performance asynchronous sequential stream presence random synchronous stream vary interval updates synchronous process graph segregated transaction grouping effective asynchronous stream unaffected synchronous traffic timing show stp quantify cost falsely limited parallelism discovered pre-commit journal writes overlapped data updates ordered mode stp modify timing journal fixed-location writes initiated simultaneously commit transaction written previous writes complete workload processes issuing random synchronous writes journal separate disk figure shows stp model implementation change modifying timing requests workload stp predicts improvement prediction matches achieve ext changed directly expected increasing amount concurrency improves performance journal separate device journal contents ext physical logging writes blocks entirety log blocks journaled irrespective bytes changed block journal space fills quickly increasing commit checkpoint frequency stp investigate differential journaling file system writes block differences journal blocks entirety approach potentially reduce disk traffic noticeably dirty blocks substantially previous versions focus data journaling mode generates journal traffic differential journaling modes evaluate differential journaling matters real workloads analyze sba traces underneath database workloads modeled tpc-b tpcc simple application-level implementation debit-credit benchmark realistic implementation order-entry built top postgres data journaling mode amount data written journal reduced factor tpc-b factor tpc-c contrast ordered writeback modes difference minimal modes metadata written log applying differential journaling metadata blocks makes difference total volume reiserfs focus linux journaling 
filesystem reiserfs section focus chief differences ext reiserfs due time constraints stp explore reiserfs background general behavior reiserfs similar ext file systems journaling modes compound transactions reiserfs differs ext primary ways file systems on-disk structures track fixed-location data ext structures ext improved scalability reiserfs tree data stored leaves tree metadata stored internal nodes impact fixed-location data structures focus paper difference largely irrelevant format journal slightly ext journal file partition contiguous reiserfs journal file contiguous sequence blocks beginning file system ext reiserfs journal put device reiserfs limits journal maximum ext reiserfs differ slightly journal contents reiserfs fixed locations blocks transaction stored descriptor block commit block unlike ext reiserfs descriptor block compound proceedings usenix annual technical conference april anaheim bandwidth amount data written bandwidth data ordered writeback journal data amount data written amount journal writes data ordered writeback fixed-location data amount data written amount fixed-location writes data ordered writeback figure basic behavior sequential workloads reiserfs graph evaluate reiserfs journaling modes single workload size sequentially written file increased x-axis graph examines metric hows achieved bandwidth sba report amount journal traffic sba report amount fixed-location traffic journal size set transaction limits number blocks grouped transaction semantic analysis reiserfs performed identical experiments reiserfs ext due space constraints present results reveal significantly behavior file systems basic behavior modes workload qualitatively performance journaling modes reiserfs similar ext random workloads infrequent synchronization perform data journaling sequential workloads generally perform random writeback ordered modes generally perform data journaling reiserfs groups concurrent transactions single compound transaction ext primary difference file systems occurs sequential workloads data journaling shown graph figure fixed-location data amount data written amount fixed-location writes sync size sync size sync size sync size fixed location data number transactions amount fixed-location writes sync size sync size sync size figure impact journal size transactions checkpoint policy reiserfs workloads data sequentially written anfsyncis issued amount data sba report amount fixedlocation traffic graph vary amount data written graph vary number transactions defined number calls fsync throughput data journaling mode reiserfs follow sawtooth pattern initial reason found sba analysis graphs figure data written journal checkpointed inplace location reiserfs appears checkpoint data aggressively ext explore journal commit policy explore factors impact reiserfs commits transactions log focus data journaling sensitive postpone exploring impact timers previously ext commits data log approximately log filled timer expires running workload force data disk call fsync reiserfs performing sba analysis find reiserfs threshold depending journal size reiserfs commits data blocks blocks written reiserfs limits journal size fixed thresholds sufficient finally note reiserfs falsely limited parallelism ordered mode ext reiserfs forces data flushed fixed location issues writes journal proceedings usenix annual technical conference april anaheim write time seconds kreiserfsd timer seconds sensitivity kreiserfsd journal timer log writes fixed-location writes figure impact timers reiserfs figure plots relationship time data written kreiserfs timer scatter plot shows results multiple runs process running writes data fsync data journaling mode timers set seconds journal size checkpoint policy investigate conditions trigger reiserfs checkpoint data fixed-place location policy complex reiserfs ext found data checkpointed journal full reiserfs point data checkpointed depends free space journal number concurrent transactions workloads periodically force data journal calling fsync intervals results shown figure graph shows amount data checkpointed function amount data written cases data checkpointed journal filled graph shows amount data checkpointed function number transactions graph shows data checkpointed intervals transactions running similar workload ext reveals relationship number transactions checkpointing reiserfs checkpoints data journal free space drops transactions journal ext timers control data written journal fixed locations differences ext kjournal daemon responsible committing transactions reiserfs kreiserfs daemon role figure shows time data written journal fixed location kreiserfs timer increased make conclusions log writes occur seconds data write application timer fixed-location writes occur elapsed time greater seconds multiple kreiserfs timer reiserfs timer policy simpler ext finding bugs sba analysis inferring policies filesystems finding cases implemented correctly sba analysis found number problems reiserfs implementation reported case identified problem sba driver observe disk traffic expected verify problems examined code find suggested fixes reiserfs developers transaction mount fsync call returns data written tracked aberrant behavior incorrect initialization file block overwritten writeback mode stat information updated error occurs due failure update inode transaction information committing transactions dirty data flushed tracked erroneously applying condition prevent data flushing journal replay irrespective changing journal thread wake interval dirty data flushed problem occurs due simple coding error ibm journaled file system section describe experience performing preliminary sba analysis journaled file system jfs began rudimentary understanding jfs obtain documentation knew journal located default end partition treated contiguous sequence blocks journaling mode due fact knew file system began found needed apply analysis technique cases filtered traffic rebooted system infer filtered traffic consistency technique understand journaling mode jfs basic starting point examining jfs code learn number interesting properties jfs inferred jfs ordered journaling mode due small amount traffic journal obvious employing data journaling differentiate writeback ordered modes observed ordering writes matched ordered mode data block written application jfs orders write data block written successfully metadata writes issued determined jfs logging record level inode index tree directory tree structure structure logged entire block structure result jfs writes fewer journal blocks ext reiserfs operations jfs default group concurrent updates single compound transaction running experiment performed figure proceedings usenix annual technical conference april anaheim bandwidth asynchronous traffic high irrespective synchronous traffic background circumstances transactions grouped write commit records log page finally commit timers jfs fixedlocation writes happen kupdate daemon timer expires journal writes triggered timer journal writes indefinitely postponed trigger memory pressure unmount operation infinite write delay limits reliability crash result data loss data written minutes hours windows ntfs section explain analysis ntfs ntfs journaling file system default file system windows operating systems source code documentation ntfs publicly tools finding ntfs file layout exist ran windows operating system top vmware linux machine pseudo device driver exported scsi disk windows ntfs file system constructed top pseudo device ran simple workloads ntfs observed traffic sba driver analysis object ntfs file metadata stored terms files journal file located center file system ntfsprogs tools discover journal file boundaries journal boundaries distinguish journal 
traffic fixed-location traffic analysis found ntfs data journaling easily verified amount data traffic observed sba driver found ntfs similar jfs block-level journaling journals metadata terms records verified blocks journaled ntfs matching contents fixed-location traffic contents journal traffic inferred ntfs performs ordered journaling data writes ntfs waits data block writes fixed-location complete writing metadata blocks journal confirmed ordering sba driver delay data block writes upto seconds found metadata writes journal delayed amount related work journaling studies journaling file systems studied detail notably seltzer compare variants journaling ffs soft updates technique managing metadata consistency file systems authors present direct observation low-level traffic familiar systems implementors explain behavior make semantic inferences explain journaling performance drops delete benchmark authors report file system forced read indirect block order reclaim disk blocks section tool sba makes expert observations readily recent study compares range linux file systems including ext ext reiserfs xfs jfs work evaluates file systems fastest benchmarks explanation workload file system benchmarks popular file system benchmarks iozone bonnie lmbench modified andrew benchmark postmark iozone bonnie lmbench perform synthetic read write tests determine throughput andrew postmark intended model realistic application workloads uniformly measure throughput runtime draw high-level conclusions file system contrast sba intended yield low-level insights internal policies file system related work chen patterson self-scaling benchmark work benchmarking framework conducts search space workload parameters sequentiality request size total workload size concurrency hones interesting parts workload space interestingly conclusions file system behavior drawn resultant output size file cache approach automated construct benchmarks exercise file system behaviors controlled manner file system tracing previous studies traced file system activity zhou ousterhout baker roselli record file system operations deduce file-level access patterns vogels performs similar study inside file system driver framework information mapped missed studies recent tracing infrastructure tracefs traces file systems vfs layer tracefs enable low-level tracing sba finally blaze ellard show low-level packet tracing nfs environment recording network-level protocol activity network file system behavior carefully analyzed type packet analysis analogous sba positioned low level reconstruct higher-level behaviors obtain complete view proceedings usenix annual technical conference april anaheim conclusions systems grow complexity techniques approaches enable users system architects understand detail systems operate presented semantic block-level analysis sba methodology file system benchmarking block-level tracing provide insight internal behavior file system block stream annotated semantic information block belongs journal data structure excellent source information paper focused behavior journaling file systems understood sba case sba straightforward user journal allocated disk sba analyzed detail linux journaling file systems ext reiserfs performed preliminary analysis linux jfs windows ntfs cases uncovered behaviors difficult discover conventional approaches developed presented semantic trace playback stp enables rapid evaluation ideas file systems stp demonstrated potential benefits numerous modifications current ext implementation real workloads traces modifications transaction grouping mechanism ext reevaluated untangled approach enables asynchronous processes obtain in-memory bandwidth presence synchronous streams system acknowledgments theodore jiri schindler members adsl research group insightful comments mustafa uysal excellent shepherding anonymous reviewers thoughtful suggestions work sponsored nsf ccrccr- ccrngs- itritr- ibm emc aranya wright zadok tracefs file system trace fast san francisco april baker hartman kupfer shirriff ousterhout measurements distributed file system sosp pages pacific grove october jfs log journaled file system performs logging proceedings annual linux showcase conference pages atlanta jfs overview ibm developerworks library l-jfs html blaze nfs tracing passive network monitoring usenix winter pages san francisco january bray bonnie file system benchmark http textuality bonnie bryant forester hawkes filesystem performance scalability linux freenix monterey june chen patterson approach performance evaluation self-scaling benchmarks predicted performance sigmetrics pages santa clara chutani anderson kazar leverett mason sidebotham episode file system usenix winter pages san francisco january ellard seltzer nfs tracing tools techniques system analysis lisa pages san diego california october ganger patt metadata update performance file systems osdi pages monterey november gray reuter transaction processing concepts techniques morgan kaufmann hagmann reimplementing cedar file system logging group commit sosp austin texas november katcher postmark file system benchmark technical report trnetwork appliance october mckusick joy leffler fabry fast file system unix acm transactions computer systems august mckusick joy leffler fabry fsck unix file system check program unix system manager manual bsd virtual vaxversion april mcvoy staelin lmbench portable tools performance analysis usenix san diego january mogul update policy usenix summer boston june norcutt iozone filesystem benchmark http iozone ousterhout aren operating systems faster fast hardware proceedings usenix summer technical conference anaheim june ousterhout costa harrison kunze kupfer thompson trace-driven analysis unix bsd file system sosp pages orcas island december reiser reiserfs namesys riedel kallahalla swaminathan framework evaluating storage system security fast pages monterey january roselli lorch anderson comparison file system workloads usenix pages san diego california june rosenblum ousterhout design implementation logstructured file system acm transactions computer systems february seltzer ganger mckusick smith soules stein journaling versus soft updates asynchronous meta-data protection file systems usenix pages san diego california june solomon inside windows microsoft programming series microsoft press sourceforge linux ntfs project http linux-ntfs net sweeney doucette anderson nishimoto peck scalability xfs file system usenix san diego january transaction processing council tpc benchmark standard specification revision technical report transaction processing council tpc benchmark standard specification revision technical report tweedie future directions ext filesystem freenix monterey june tweedie journaling linux ext file system fourth annual linux expo durham north carolina tweedie ext journaling file system olstrans sourceforge net release ols -ext ols -ext html july vogels file system usage windows sosp pages kiawah island resort december yang twohey engler musuvathi model checking find file system errors osdi san francisco december zhou costa smith file system tracing package berkeley unix usenix summer pages salt lake city june 
cmc pragmatic approach model checking real code madanlal musuvathi david parky andy chou dawson engler david dill fmadan parkit acc engler dillg stanford computer systems laboratory stanford stanford abstract system errors emerge intricate sequence events occurs practice means systems errors trigger days weeks execution model checking ective subtle errors takes simpli description code exhaustively tests inputs techniques explore vast state spaces ciently model checking systems code wonderful practice building models hard signi cantly time write model write code checking abstraction code code easy miss errors paper rst contribution model checker cmc checks implementations directly eliminating separate abstract description system behavior major advantages reduces ort model checking reduces missed errors time-wasting false error reports resulting inconsistencies abstract description actual implementation addition implementation checked immediately updating high-level description paper contribution demonstrating cmc works real code applying implementations ad-hoc on-demand distance vector aodv networking protocol found distinct errors roughly bug lines code including bug aodv speci cation experience building supported gsrc marco grant ysupported national science foundation graduate research fellowship systems appears approach work contexts networking protocols introduction complex systems complex errors real systems variety mishandled corner cases triggered intricate sequences events practice leaves residue errors system crashes days weeks continuous execution detected problems cult diagnose errors reproducible sequence events leading reconstructed formal veri cation methods diagnose deep errors option explicit model checking systematically enumerates states system basic model checker starts initial state recursively generates successive system states executing nondeterministic events system states stored hash table ensure state explored process continues state space explored model checker runs resources works style state graph exploration achieve ect impractically massive testing avoiding redundancy occur conventional testing conventional model checkers assume design high level abstracts details actual implementation verifying actual code tool requires reconstructing abstract description code process requires great deal manual ort hampering model checking actual system design human errors manual abstraction process result missing bugs false alarms veri cation increasing cost reducing usefulness model checking errors introduced constructing model result drift actual system evolves reasons notable curiosity software model checked everyday occurrence introduce cmc model checker address issues cmc works unmodi implementations explores large state spaces ciently storing states traditional model checkers cmc achieves equivalent executing astronomical numbers tests reasonable time cmc require writing separate high-level model code extracting model implementation importantly nds bugs implementation miss implementation bugs omitted model waste user time bugs model implementation idea model checking actual implementation code advocated small number tools verisoft instance systematically executes implementation code store states software model checking tools specialized work classes java programs cmc designed combine ective techniques research orts veri cation community apply software written predominant programming languages industry ultimate goal work check systems code general initial focus networking code code naturally eventdriven execution model makes good model checkers correctness networking protocol implementations important core services rst target external security attacks network protocols cult design implement test involve complex interactions multiple machines network deal network failures packet losses link failures cult control test environment model checkers excel checking interactions cmc works real code demonstrated results applying implementations aodv networking protocol rst implementation mad-hoc released years ago active development implementation kernel aodv derives mad-hoc implementation released year ago implementation aodv-uu released year ago aodv speci cation active development rst version subsequently undergone ten revisions cult measure quality absolutely measure formal group devoted testing aodv implementations testbed check mad-hoc aodv-uu implementations cmc found unique errors total date rate roughly bug lines code bugs non-trivial cult method ironic twist model checking implementation found bug speci cation aodv error con rmed authors aodv speci cation protocol implementations similar aodv cmc enhancements broaden applicability concurrent systems good reason cmc systems cult debug means model checking overview fundamentally explicit state model checking systematic search error states state graph represents behavior system generate graph search report errors state graph large search completely important state graphs systems errors larger correct systems search algorithms newly discovered states stored queue policy depthrst breadthrst bestrst states removed queue successors generated expanded enqueued multiple successors nondeterminism system states searched stored hash table successors expanded model checking prove system satis speci property practical bugnding method model checking applicable ective conventional testing discovering bugs thoroughness exploring state space system including corner cases overlooked model checking cient random testing searches state code model check model environment relevant aspects network operating system calls environment model avoid false error reports resulting illegal inputs state occur actual system execution parts environment model unit testing system checked put model checker apparent problems model checking small system description result huge state graph called state explosion problem addressed ways including methods suppressing details input description abstraction optimizations save time importantly space state explosion problem remains culty applications model checking note state pruning randomized testing typically fare signi cantly worse situations addressing issues paper presents approach pragmatically apply model checking actual implementation code bugs end implemented tool called cmc bugs network protocol implementations sections design cmc cmc model checker generates state space system directly executing implementation section describes design cmc beginning description tool infrastructure steps required set system checking illustrated actual model checking algorithm finally techniques cope state explosion problem discussed cmc infrastructure cmc models system collection interacting concurrent agents called processes process runs unmodi code implementation cmc model checker responsible scheduling executing processes system checked cmc processes system run single operating system process unlike operating system cmc search system states reached alternative scheduling decisions nondeterministic events search erent possibilities cmc save restore complete state modelled system process system executes heap stack instant state process consists copy global static variables heap stack context registers processes communicate shared memory accessible context processes state system ned union states processes contents shared memory scheduled process allowed execute deterministic non-blocking set instructions ned transition transition atomic step system determines degree interleaving processes protocols cmc applied follow eventdriven execution model set event handler routines process incoming events packet arrivals timeouts event-driven protocol event handler mapped transition cmc event handler preserves state stack registers global variables heap saved restored protocols written event-driven style event-driven model restrictive feasible save restore full states including 
stack modelled processes feature implemented evaluated results reported paper creating cmc model implementation figure shows skeleton event-driven implementation routing protocol similar aodv protocol checked section implementation running discussion main function implementation calls initialization function line enters event dispatch loop line depending input event calls event handlers ned lines handler processes event user request route destination request node response node previous requests timer event requiring protocol invalidate routes subsection describes steps user perform apply cmc protocol steps essentially provide unit test sca required test environments running implementation simulator step additional requirement cmc step correctness properties system tested user correctness properties properties domain independent program access illegal memory leak memory domain-speci properties speci assertions points implementation protocol return invalid route line cases careful implementer assertions code long cmc applied properties inherently global requirement loops routing table properties speci boolean functions written access datastructures process contexts step environment user build test environment adequately represents behavior actual environment protocol executed networking protocols environment model fakes operating system protocol function decision part system checked environment decided user environment model collection substitute api functions data structures emulate state environment modelled detail super uous states generated model environmental behavior irrelevant checking protocol functions replaced simple stubs gettimeofday return constant counter model requires network exchanging routing packets simple network modelled unordered queue bounded length model include versions interface functions broadcast request function sends packets network environment processes exevent handlers user request dest route table route dest return route dest broadcast request dest recv request dest route table route dest send response route dest broadcast request dest recv response route install route route table route forwarded send response route timeout route route table route remove route route table init route table null insert route main init event dispatch loop depending event call user request recv request recv response timeout figure simple routing protocol implementation void malloc size cmcchoose return nondeterministic failure alloc bytes heap return figure implementation malloc cmc malloc nondeterministically fails allocate memory ample process nondeterministically removes packet network model lossy network represent nondeterminism environment cmc cmcchoose function similar toss verisoft cmcchoose takes integer argument returns integer range cmcchoose arbitrarily selects possibilities environment shown figure malloc implementation allocate requested memory cmc heap fail returning null cmcchoose make choices cmc attempt return values call cmcchoose calls cmcchoose environment code implementations standard system functions malloc select generally modify actual implementation providing environment model time consuming important reduce modelling ort required apply cmc previously unchecked protocol rst obvious step engineer models re-usable reducing incremental ort checking protocol bene cial related protocols checked large part reason paper checks erent implementations protocol finding ways reduce cost environmental modelling interesting area future work step identifying initialization functions event handlers event driven system user provide initialization functions event handlers process system user provide guard function event handler boolean function determines event handler enabled state instance guard function recv request handler returns true request pending process network cmc model checking algorithm model system built cmc explores state space system executing traces interleaving transitions pseudocode algorithm shown figure algorithm maintains data structures hash table states search queue states successors generated hash table guarantees algorithm explores subgraph rooted state generating initial state cmc computes initial state starting copy global variables initialized linker cmc calls initialization function process initial state consists states processes immediately initialization functions called values initialized shared memory generating successor states generate state graph on-they cmc compute set successors state state state space system successors nondeterminism arises sources choice process execute choice enabled transition process execute nondeterministic values returned calls cmcchoose state cmc chooses process enabled event handlers schedule cmc restores context process copying contents heap global variables process state event handler called function eventually returns guaranteed atomic point context process state saved yielding system state cmc generates successors state repeating process nondeterministic choices checking correctness properties model checking cmc checks range correctness properties simple pointer access void modelcheck systemstate sharedmem network procstate processes initial current successor queue stateq hash visitedstates build initial state forall processes pid call pid initfn initial procstate pid savectxt call sharedmem initfn initial sharedmem getsharedmem stateq insert initial current stateq pop visitedstates add current repeat forall nondeterministic choices forall processes pid forall event handlers pid forall return values cmcchoose calls set proc context sharedmem restorectxt current procstate pid setsharedmem current sharedmem enabled continue call event handler construct state successor sharedmem getsharedmem successor procstate pid savectxt forall processes pid pid state change successor procstate pid current procstate pid successor visitedstates continue successor fails assertions generate error stateq insert successor figure pseudocode cmc model checking algorithm violation errors complex protocol bugs execution event handler cmc runs implementation code directly automatically catching errors pointer access violations program assertion failures present code addition cmc detects use-after-free bugs overwriting freed memory random state generated cmc checks violations user-provided system invariants absence global routing loops cmc detects memory leaks generated state achieved standard mark-and-sweep algorithm reachable memory algorithm implemented cmc case study cmc detects memory leaks starting copy current state cmc calls cleanup functions present implementation heap memory left allocated reported leaked approach requiring additional manual ort potentially bugs cleanup code future cmc approach easily coupled dynamic debugging tools purify stackguard tools catch run-time errors uninitialized memory stack ows tools ective cmc ordinary testing cmc achieve greater ective test coverage level user ort conventional software testing methods handling state space explosion problems model checking practice so-called state explosion problem state space system large nite outset impossible explore entire state space limited resources time memory cmc techniques search state space ciently running resources unable formally prove correctness implementation cmc catch wide range errors including errors involving intricate interactions multiple processes model checkers memory critical resource time model checking memory consumed hash table states visited queue states successors generated cmc hash compaction reduce memory requirements hash table orders magnitude state cmc computes small signature bytes storing entire state order kilobytes signature stored hash table compacting states lead con icts hash table erent states compute signature state spaces order hundred million states practical hash table sizes hundred megabytes probability missing 
single state due signature con ict reduced lower states queue compacted information needed compute successor states queue good locality swapped disk model checking successive states queue lot commonality compressed instance transition cmc process state cient store erence generating successor state standardizing data structures cmc default interprets states streams bits equivalent data structures memory erent representations states order objects allocated heap considered ectively cmc automatically transform states deterministically traversing pointer data structures arranging objects heap order visited signature transformed state saved state table process performed simultaneously mark-and-sweep algorithm detect memory leaks automatic tool traversal development framework case study discussed section traversal code written manually additional equivalences states depend data structures program implementation linked list store unordered collection objects behavior implementation independent order objects list case user provide function sort list automatic standardization transformations applied finally ective reductions state space achieved methods risk missing errors bene catching remaining ciently down-scaling obvious approach reduce scale system ure instance model restrict number routing nodes network hard-tond bugs involve complex interactions small number processes preserved downscaling miss bugs occur larger instances system abstraction states addition standardizing distinct equivalent states eliminate information user judges unimportant properties checked abstraction process ignoring memory locations computing hash signature state abstracting states miss errors abstraction hash computation actual concrete state produce false positives heuristics exhaustive checking entire state space infeasible fails cmc act automated testing framework large number scenarios checked intelligently mere fact cmc cache states prevents redundant simulations goal exercise interesting scenarios memory exhausted end preliminary work heuristics prioritize state space search rst class heuristics involves dropping states altogether deemed uninteresting class heuristics involves exploring interesting states rst bestrst search cmc module monitor state variables history state bits changed checking basic idea number bit positions changed initial state suddenly increases variables frequented values state considered interesting explored earlier heuristic bias search cases outliers occur states diverge norm idea adapted diduce tool ags divergent cases reports user program testing preliminary results errors discovered heuristics discovered simple depthrst search heuristics accelerated discovery errors produced shorter examples executions leading error experimentation heuristics needed wider range protocols arrive reliable conclusions sections describe application results cmc check aodv protocol implementations description aodv protocol aodv ad-hoc on-demand distance vector loop-free routing protocol ad-hoc networks designed self-starting environment mobile nodes withstanding variety network behaviors node mobility link failures packet losses section describes aodv protocol reader referred complete details protocol node aodv maintains routing table routing table entry destination essential elds hop node sequence number hop count packets destined destination hop node sequence number acts form time-stamping measure freshness route hop count represents current distance destination node suppose nodes hop destination suppose sequence number hop count routes seqa hcnta seqb hcntb aodv protocol maintains property times seqa seqb seqa seqb hcnta hcntb words newer route shorter route equally recent partial order constraint protocol guaranteed free routing loops aodv nodes discover routes request-response cycles node requests route destination broadcasting rreq message neighbors node receives rreq message route requested destination turn broadcasts rreq message remembers reverse-route requesting node forward subsequent responses rreq process repeats rreq reaches node valid route destination node destination responds rrep message rrep unicast reverse-routes intermediate nodes reaches original requesting node end request-response cycle bidirectional route established requesting node destination node loses connectivity hop node invalidates route sending rerr nodes potentially received rrep receipt aodv messages rreq rrep rerr nodes update hop sequence number hop counts routes satisfy partial order constraint mentioned aodv model section describes aodv model implementations aodv protocol mad-hoc version kernel aodv version aodv-uu version mad-hoc implementation runs user space daemon approximately lines code kernel aodv implementation built nist based mad-hoc implementation lines code runs loadable kernel module linux arm based pdas aodvuu implementation runs user space daemon linux ported nssimula- tor roughly lines code aodv model reused minor modi cations implementations model built correctness properties table lists correctness properties checked aodv model generic assertions checked cmc model global invariant checks routing loops model performs sanity checks routing table entries network messages range violations elds environment environment model consists network modelled bounded-length unordered message queue model simulates message loss nondeterministically dequeuing message message queue shared nodes models completely connected topology implementations wrapper function send network packets model alternate nition wrapper function copy packets network model additionally kernel aodv implementation model implementations twenty-two kernel functions types checks examples generic assertions segmentation violations memory leaks dangling pointers routing loop invariant routing tables nodes form routing loop assertions routing table entries routing table entry destination route aodv-uu implementation hop count route present hop count nity number nodes network assertions message fields reserved elds set hop count packet nity table properties checked aodv enabling condition event invalid route destination initiation route request pending message network receipt aodv message pending message network message loss valid route routing table timeout route enabled detection link failure enabled node reboot table set event handlers aodv model checking kmalloc printk user space version socket library initialization functions event handlers implementations event dispatch loop calls event handlers initialization functions model obtained executing code event dispatch loop model maps event handler called dispatch loop transition model simulates node reboot calling initialization function implicitly resets contents routing table list transitions respective enabling conditions shown table table shows lines code implementations executed framework lines code model correctness speci cations shared implementations aodv-uu erent representation routing table required additional correctness speci cations network model environment shared implementations dealing state space explosion state space aodv protocol essentially nite protocol arbitrary number nodes network node types unbounded counters sequence number measure freshness route broadcast incremented node broadcast ective search nite state space bound search experiments downscaled aodv model run processes model discarded state sequence numbers broadcast ids exceeded prede ned limit size message queue network bounded sizes processes cmc miss errors applying bounds remaining state space contained interesting behavior uncover numerous bugs section time values stored state source state space explosion instance route response rrep lifetime eld determines freshness route receipt packet node adds lifetime current clock determine time route stale absolute stored routing table increase state space size 
aodv model problem modelling route timeouts nondeterministic events setting time variables prede ned constants environment model nition gettimeofday function returns constant handling time model miss timing related errors protocol checked correctness environment state code speci cation network stubs skbu canonicalization mad-hoc kernel aodv aodv-uu table lines implementation code cmc modelling code potentially lead false positives error reported caused sequence timeouts impossible real protocol aodv model hand-written code traverse routing table implemented linked list mad-hoc kernel aodv implementations hash table aodv-uu implementation traversal code created canonicalized representation routing table global variables formed state aodv node model amount lines required traversal code shown column table results table summarizes set bugs found cmc aodv implementations bugs range simple memory errors protocol invariant violations found total bugs unique kernel aodv implementation bugs shown parenthesis table instances bug madhoc aodv speci cation bug routing loop implementations cmc stops nding rst bug model prints failed assertion trace events starting initial state error state bug xed cmc run bugs iteratively bugs found minutes model checking time longest roughly minutes describe bugs high level give feel breadth coverage focus interesting bugs give feel depth memory errors rst error classes illustrate mishandling dynamically allocated memory checking allocation failure errors freeing allocated memory errors memory freeing errors implementations checked pointer reaodv deamon aodv recv message rerri rerri rerrhdr msg dst cnt rerri malloc sizeof break skip packet tpnext rerrhdr msg unr dst rerrhdr msg unr dst bug assumes rerrhdr msg dst cnt buffers allocated rec rerr info msg rerrhdr msg free list structs rec rerr rerri rerri rerrhdr msg dst cnt rerri bug null malloc failed rerrhdr msg unr dst rerrhdr msg unr dst rerrhdr msg unr dstnext free figure mishandled malloc failure malloc fails loop exit allocating rerrhdr msg dst cnt ers errors code assumes rerrhdr msg dst cnt ers allocated lead segmentation faults turned malloc null functions call malloc indirectly return null pointers allocations fail code erratically checked cases cmc directly executes implementation errors manifested segmentation faults memory-related bugs straightforward interesting errors code correctly check allocation failure recovery code broken figure representative error code attempts allocate rerrhdr msg dst cnt temporary message ers correctly checks malloc failure breaks loop code loop assumes rerrhdr msg dst cnt list entries allocated assumption leads bugs rst intraprocedural error mad-hoc kernel aodv aodv-uu mishandling malloc failures memory leaks free invalid routing table entry unexpected message generating invalid packets program assertion failures routing loops total table number bugs type implementations aodv gures parenthesis show number bugs instances bug mad-hoc implementation attempts dequeue rerrhdr msg dst cnt ers rerrhdr msg unr dst list order free list fewer entries expected code attempt null pointer segmentation fault interprocedural error rec rerr similarly walk rerrhdr msg dst cnt list entries seg faults list short memory leaks similarly caused mishandled allocation failures commonly code attempt memory allocations rst allocation succeeded failed return error leaking rst pointer unexpected messages cmc detected places unexpected messages mad-hoc crash segmentation violation figure shows errors error aodv encodes state messages error current node receives route request rreq message node req requesting route node dst node inserts reverse route req routing table route dst routing table route re-broadcasts rreq message rreq message address destination node dst requesting node req response request route response rrep message includes route dst address req node inserts route dst routing table attempts relay route req route req normal case lookup return reverse route inserted step step error code assumes normal case result routing table lookup req checking null lookup fail reasons machine rebooted implementation start empty routing table rrep message arrives reboot lookup req return null pointer attacker send bogus rrep node address exist crashing router invalid messages cases invalid packets created cases uninitialized variables detected gcc -wall cases invalid routes send routing updates violating aodv speci cation figure representative cmc detected instances integer resulted program assertion failures implementations bit integer store hop counts represent hopcount ity error cases nite hopcount erroneously incremented routing loops cmc found routing loops bugs caused implementation errors routing loop due error aodv protocol speci cation rst routing loop caused implementation fails increment sequence number processing speci rerr messages loop caused implementation performs sequence number comparison subsequent increment aodv speci cation requires comparison increment madhoc rrep rec rrep destination rrep forward rrepsrc infoip pkt entry google file source system sanjay ghemawat src howard getentry gobioff rrepsrc shun-tak leung bug google src abstract exist designed add implemented precursor google src file rtnxt system hop scalable distributed send gratuitous system rrep large distributed destination bug src providesfault tolerance invalid anditdelivers srchop high aggregate cnt performance check large number getentry clients rrep hop sharing cnt srchop goals cnt previous send distributed datagram systems info design rrep sizeof driven rrep observations figure application workloads bugs technological unexpected environment message thatre invalid route ectamarked response departure unexpected earlier routeresponse system rrep assumptions message led getentry reexamine return traditional null choices crashing explore machine radically route erent design returned getentry points invalidated system hopcount successfully met storage widely deployed google storage platform generation processing data service research development orts require large data sets largest cluster date code hundreds check terabytes sends storage message thousands disks speci cation bug thousand bug machines involved handling concurrently rerr accessed route error hundreds messages clients node receives paper rerr present system hop interface sets extensions sequence designed number support route distributed sequence applications number discuss rerr aspects message design normal report conditions measurements thing micro-benchmarks real world underlying categories link subject layer descriptors reorder messages distributed systems rerr general message terms design reliability outdated performance sequence measurement number keywords fault resulting tolerance scalability node data setting storage clustered sequence storage number authors older reached version addresses ultimately sanjay result hgobio shuntak google routing loop permission bug mentioned authors protocol suggested make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee sosp october bolton landing york usa copyright acm introduction designed implemented google file system gfs tomeet therapidlygrowing demandsofgoogle data processing gfs shares bug goals previous accepted distributed systems protocol authors figure error speci cation bug found running aodv nodes depthrst search state space cmc error trace length bestrst performance search scalability reliability traces availability short performing design hasbeen breadthrst search drivenbykeyobservations ofourapplication state space workloads give technological shortest trace environment current breadthrst search aodv anticipated ran ect resources marked nding departure bug carefully earlier hand-crafted system simulation design bug assumptions required reexamined transitions traditional choices complex explored error radically erent points cult design catch space component conventional means testing madhoc rerr rec rerr pointer route table destination tmp rtentry getentry tmp unr dstunr dst tmp rtentry null bug sequence number incoming message tmp unr dst validation check tmp rtentrydst seq failures norm exception system consists hundreds thousands storage machines built inexpensive commodity tmp parts unr accessed dstunr comparable dst number seq client return tmp rtentrydst seq tmp unr dstunr dst seq figure speci cation bug sequence number incoming message validation causing time backwards messages reordered machines fortunately quantity quality error components obvious virtually guarantee surviving rounds speci functional cation time revisions recover trivial related current work failures paper problems proposes caused initial application approach bugs operating system systematically bugs human errors ciently verify failures large disks class memory connectors networking software power supplies create abstract constant models monitoring error erent detection language fault tolerance compares automatic recovery work integral cmc system orts les traditional huge model checking traditional software standards model multi-gb checking les static common analysis typically traditional model checking application objects basic idea web documents state graph search regularly verify workingwithfast network growing communication billions protocols objects unwieldy dating manage back billions approximately kb-sized recent les decades model system checking support made signi result progress design assumptions tackling parameters veri cation operation complex concurrent blocksizes systems tools revisited smv les 
mutated spin appending murphi data verify hardware randomwriteswithin software protocols practically exhaustively non-existent searching written state space les caching states read employing sound sequentially state variety reduction data techniques share tools characteristics detect non-trivial constitute bugs large drawback traditional model data checkers streams continuously generated system running veri applications modeled archival data description language intermediate requiring results signi produced amount machine manual processed ort easily simultaneously error prone time cmc speci access cally pattern designed huge les goal appending reducing focus amount performance work optimization required atomicity guarantees software caching development data blocks systematic veri client cation loses software model appeal checking fourth co-designing recent formal applications veri cation tools system api bene idea system executing increasing checking systems exibility implementation relaxed level gfs verisoft consistency model instance vastly systematically simplify executes system veri imposing actual code onerous burden applications successfully introduced atomicappendoperation concurrently toa lewithout extrasynchronization discussed details paper multiple gfs clusters deployed check erent communication purposes protocols written largest verisoft storage nodes store states diskstorage potentially heavily explore accessed state hundreds clients distinct machines problem alleviated continuous basis degree design partial overview order assumptions reduction designing sound state system space reduction technique implemented verisoft eliminates exploration redundant interleavings transitions created commutative operations technique requires hints provided user static analysis code determine dependencies transitions set transitions system high degree interdependence guided assumptions case challenges handlers opportunities protocol alluded code key veri observations earlier partial order lay methods assumptions ective details thesystem finally isbuilt interesting systems manyinexpensivecommodity componentsthatoftenfail state itmustconstantlymonitor spaces detect cycles tolerate recover promptly cases component verisoft failures limited routine basis checking system stores modest xed number depth large java pathfinder les model expect checking million les verify concurrent typically java larger programs size deadlock multi-gb les assertion common failures case relies specialized managed virtual ciently machine small les tailored supported automatically extract optimize current state workloads java primarily program consist kinds cmc java reads large pathfinder streaming compresses reads stores small random states reads table large prevent streaming reads redundant individual searches operations typically relies read hundreds abstraction kbs techniques commonly curb state successive space operations explosion problem client infrastructure read jpf contiguous relies region small applied random read software typically written reads kbs arbitrary set predominant languages performance-conscious applications system batch software sort development small slam reads tool advance steadily converts code abstracted skeletons boolean types slam model checks abstracted program error state reachable culty tool slam giving backand speci cation workloads correct behavior large sequential system writes append slam data static les tool typical writing operation sizes speci cation similar routing reads loops written les cult seldom modi depends small writes interleaved event arbitrary behavior positions multiple nodes supported slam deal cient concurrent systemmust environments ciently implement well-de multiple ned processes semantics queues multiple clients static analysis concurrently static append analysis gained les ground recent years producerconsumer detecting queues bugs software many-way tools merging hundreds esc producers running lclint esp machine concurrently checker append atomicity check minimal source code synchronization overhead errors essential statically detected read minimal consumer manual ort reading static techniques simultaneously high good sustained nding bandwidth speci important set errors low latency cmc approach target deep applications conceptual place errors premium code processing emergent data routing loops bulkat high cult rate statically addition stringent cmc response time requirements false individual positives read write scenario interface checked gfs valid execution familiar path system conclusion interface future work filesare paper cmc edbypathnames model support checker usual targetting operations subtle bugs create systems delete code open close experimental results read andwrite cmc les check gfs snapshot implementations record aodv append routing operations protocol snapshot creates key copy features cmc directory tree checks low cost implementation record code append directly multiple stores clients states append avoid data redundant state concurrently explorations initial guaranteeing experiences atomicity cmc individual client encouraging append cmc powerful discover non-trivial bugs implementation speci cation protocols cmc verify larger complex protocols wider essential automate process converting implementing implementation multi-way merge system results cmc producerconsumer model queues clients simultaneously results append reported additional require considerable manual locking ort found future types improvements les cmc invaluable signi building large cantly distributed reduce applications discussedfurther exploring sections heuristics architecture ciently search gfs cluster state consists space single initial master ndings multiple suggest chunkservers simple accessed heuristics provide multiple huge clients asshown improvements figure state space typically search commodity instance linux implemented itiseasy torun monitor detects aslong counters machine resources rogue permit variables lower reliability uninitialized caused variables running possibly statistics aky variables application monitor code abstracts acceptable files variables divided system xed-size state chunks automatically pruning chunkis identi immutable globally unique bitchunk handleassigned themaster thetime chunkcreation chunkservers store chunks local disks linux les read write chunkdata speci chunkhandle byterange forreliability eachchunkisreplicated onmultiplechunkservers bydefault westorethreereplicas users designate erent replication levels erent regions namespace master maintains system metadata includes namespace access control information mappingfrom lestochunks controls system-wide activities chunklease management garbage collection orphaned chunks chunkmigration chunkservers master periodically communicates chunkserver heartbeat messages give instructions collect state gfs client code linked application implements system api communicates master chunkservers read write data behalf application clients interact master metadata operations data-bearing communication directly chunkservers provide posix api hookinto linux vnode layer client chunkserver caches data client caches bene applications stream huge les working sets large cached simpli client system eliminating cache coherence issues clients cache metadata chunkservers cache data chunks stored local les andsolinux sbu data memory single master single master vastly simpli design enables master make sophisticated chunk placement legend data messages control messages application file chunk index chunk handle chunk locations gfs master file namespace foo bar instructions chunkserver chunkserver state gfs chunkservergfs chunkserver chunk handle byte range chunk data chunk linux file system linux file system gfs client figure gfs architecture replication decisions global knowledge minimize involvement reads writes bottleneck clients read andwrite ledatathroughthemaster aclientasks master chunkservers contact caches information limited time interacts chunkservers directly subsequent operations ence figure xed chunksize client translates byte set speci application chunkindex sends master request chunk index master replies chunk handle locations replicas client caches information chunkindex key client sends request replicas closest request speci chunk handle byte range chunk reads chunkrequire client-master interaction cached information expires reopened fact client typically asks multiple chunks request master include information chunks immediately requested extra information sidesteps future client-master interactions practically extra cost chunk size chunksize key design parameters chosen larger typical system blocksizes chunkreplica stored plain linux chunkserver extended needed lazy space allocation avoids wasting space due internal fragmentation greatest objection large chunksize large chunksize ers important advantages reduces clients interact master 
reads writes chunkrequire initial request master chunklocation information reduction signi workloads applications read write large les sequentially small random reads client comfortably cache chunklocation information multi-tb working set large chunk client perform operations chunk reduce network overhead keeping persistent tcp connection chunkserver extended period time reduces size metadata stored master metadata memory turn brings advantages discuss section ontheotherhand alargechunksize evenwithlazyspace allocation disadvantages small consists small numberofchunks perhapsjustone thechunkservers storing chunks hot spots clients accessing practice hot spots major issue applications read large multi-chunk les sequentially hot spots develop gfs rst bya batch-queuesystem executable written gfs single-chunk started hundreds machines time chunkservers storing executable overloaded hundreds simultaneous requests xed problem storing executables higher replication factor making batchqueue system stagger application start times potential long-term solution toallow clients read data clients situations metadata master stores major types metadata chunknamespaces mapping les chunks locations chunk replicas metadata master memory rst types namespaces le-to-chunkmapping persistent logging mutations operation log stored master local diskand replicated remote machines log update master state simply reliably risking inconsistencies event master crash master store chunklocation information persistently asks chunkserver chunks master startup chunkserver joins cluster in-memory data structures masteroperationsare fast easy cient master periodically scan entire state background periodic scanning implement chunkgarbage collection re-replication presence chunkserver failures chunkmigration balance load diskspace usage chunkservers sections discuss activities potential concern memory-only approach number chunks capacity system limited memory master limitation practice master maintains bytesof metadata chunk lescontainmany chunks partially lled similarly namespace data typically requires bytes stores names compactly pre compression support larger systems cost adding extramemory tothemaster small price topay simplicity reliability performance exibility gain storing metadata memory chunk locations master persistent record chunkservers replica chunk simply polls chunkservers information startup master up-to-date controls chunkplacement monitors chunkserver status regular heartbeat messages weinitially information persistently master decided simpler request data chunkservers startup periodically eliminated problem join leave cluster change names fail restart cluster hundreds servers events happen understand design decision realize chunkserver nal word chunks disks point maintain consistent view information master errors chunkserver chunks vanish spontaneously disk bad disabled operator rename chunkserver operation log operation log historical record critical metadata central gfs persistent record metadata serves logical time line nes order concurrent operations files chunks versions section uniquely eternally identi logical times created operation log critical store reliably make visible clients metadata made persistent ectively lose system recent client operations chunks survive replicate multiple remote machines respond client operation ushing log record disk locally remotely master batches log recordstogetherbefore ushing replication system throughput master recovers system state replaying operation log minimize startup time log small themaster checkpointsitsstate wheneverthelog grows size recover loading latest checkpoint local disk replaying write record append serial defined defined success interspersed concurrent consistent inconsistent successes undefined failure inconsistent table file region state mutation limited number log records checkpoint compact b-tree form directly mapped memory namespace lookup extra parsing speeds recovery improves availability building checkpoint master internal state structured checkpoint created delaying incoming mutations master switches log creates checkpoint separate thread checkpoint includes mutations switch created minute cluster million les completed written diskboth locally remotely recovery latest complete checkpoint subsequent log les older checkpoints log les freely deleted guard catastrophes failure checkpointing ect correctness recovery code detects skips incomplete checkpoints consistency model gfs relaxed consistency model supports highly distributed applications remains simple cient implement discuss gfs guarantees applications highlight gfs maintains guarantees butleave details parts paper guarantees gfs file namespace mutations creation atomic handled exclusively master namespace locking guarantees atomicity correctness section master operation log nes global total order operations section state region data mutation depends type mutation succeeds fails concurrent mutations table summarizes result region consistent clients data replicas read region ned data mutation consistent clients mutation writes entirety mutation succeeds interference concurrent writers ected region ned implication consistent clients mutation written concurrent successful mutations leave region unde ned consistent clients data ect mutation haswritten typically consistsof mingledfragments multiple mutations failed mutation makes region inconsistent unde ned erent clients erent data erent times describe applications distinguish ned regions unde ned regions applications distinguish erent kinds unde ned regions data mutations writes record appends awrite data written application-speci set record append data record appended atomically presence concurrent mutations set gfs choosing section contrast regular append write set client believes current end set returned client marks beginning ned region record addition gfs insert padding record duplicates occupy regions considered inconsistent typically dwarfed amount user data sequence successful mutations mutated region isguaranteedtobede nedandcontain thedatawritten mutation gfs achieves applying mutations chunkin order replicas section replica stale missed mutations chunkserver section stale replicas involved mutation clients master chunk locations garbage collected earliest opportunity clients cache chunklocations read stale replica information refreshed window limited cache entry timeout open purges cache chunkinformation les append-only stale replica returns premature end chunkrather outdated data reader retries contacts master immediately current chunklocations long successful mutation component failures corrupt destroy data gfs identi failed chunkservers regular handshakes master chunkservers detects data corruption checksumming section problem surfaces data restored section achunk lost irreversibly replicas lost gfs react typically minutes case unavailable corrupted applications receive clear errors corrupt data implications applications gfs applications accommodate relaxed consistencymodelwith afew simpletechniquesalready neededfor purposes relying appends overwrites checkpointing writing self-validating self-identifying records practically applications mutate les appending overwriting typical writer generates beginning end atomically renames permanent writing data periodically checkpoints successfully written checkpoints include application-level checksums readers verify process region checkpoint ned state ofconsistency concurrencyissues approach served appending cient resilient application failures random writes checkpointing writers restart incrementally readers processing successfully written data incomplete application perspective typical writers concurrently append merged results producer-consumer queue recordappend serves writer output readers deal occasional padding duplicates record prepared writer extra information checksums validity veri reader identify discard extra padding record fragments checksums tolerate occasional duplicates trigger non-idempotent operations lter unique identi ers records needed application entities webdocuments functionalities record duplicate removal library code shared applications applicable interface implementations google sequence records rare duplicates delivered record reader system interactions designed system minimize master involvement operations background describe client master chunkservers interact implementdatamutations atomicrecordappend andsnapshot leases mutation order 
mutation operation contents metadata chunksuch write append operation mutation performed chunk sreplicas weuseleases tomaintain aconsistent mutation orderacross replicas themaster grantsachunklease tooneof thereplicas call primary primary picks serial order mutations chunk replicas follow order applying mutations global mutation order ned rst lease grant order chosen master lease serial numbers assigned primary lease mechanism designed minimize management overhead master lease initial timeout seconds long chunkis mutated primary request typically receive extensions master inde nitely extension requests grants piggybacked heartbeat messages regularly exchanged master chunkservers master revoke lease expires master disable mutations renamed nite state space interesting avenue research simple facts discovered static analysis code direct search interesting parts state space acknowledgments satyaki das thoughtful discussions paper miguel castro anonymous reviewers providing valuable comments suggesting improvements previous versions paper thomas ball rupak majumdar todd millstein sriram rajamani automatic predicate abstraction programs proceedings sigplan conference programming language design implementation bhargavan obradovic gunter formal veri cation standards distance vector routing protocols brat havelund park visser model checking programs ieee international conference automated software engineering ase clarke grumberg peled model checking mit press corbett dwyer hatcli laubach pasareanu robby zheng bandera extracting nite-state models java source code icse crispan cowan calton dave maier jonathan walpole peat bakke steve beattie aaron grier perry wagle qian zhang heather hinton stackguard automatic adaptive detection prevention erover attacks proc usenix security conference pages san antonio texas jan perkins royer das hoc demand distance vector aodv routing ietf draft http ietf internet-drafts draftietf-manet-aodv- txt january manuvir das sorin lerner mark seigle esp pathsensitive program veri cation polynomial time conference programming language design implementation david detlefs rustan leino greg nelson james saxe extended static checking david dill andreas drexler alan han yang protocol veri cation hardware design aid ieee international conference computer design vlsi computers processors pages engler chelf chou hallem checking system rules system-speci programmerwritten compiler extensions proceedings fourth symposium operating systems design implementation october erik nordstrom hoc protocol evaluation testbed http apetestbed sourceforge net erik nordstrom aodv-uu implementation http user henrikl aodv david evans john guttag james horning yang meng tan lclint tool speci cations check code proceedings acm sigsoft symposium foundations software engineering pages godefroid model checking programming languages verisoft proceedings acm symposium principles programming languages hajek automatically veri data transfer protocols proceedings iccc pages sudheendra hangal monica lam tracking software bugs automatic anomaly detection proceedings international conference software engineering gerard holzmann model checker spin software engineering mcmillan symbolic model checking kluwer academic publishers luke klein-berndt kernel aodv implementation http antd nist gov wctg aodv kernel lilieblad mad-hoc aodv implementation http mad-hoc yinglinux net mccanne floyd ucb lbnl vint network simulator version april http isi nsnam mcmillan schwalbe formal veri cation gigamax cache consistency protocol proceedings international symposium shared memory multiprocessing pages tokyo japan inf process soc nelson techniques program veri cation xerox parc research report csl- june stanford park stern skakkebaek dill java model checking ieee international conference automated software engineering ase charles perkins elizabeth royer samir das private communication rational software purify advanced runtime error checking developers http rational products purify unix stern dill scheme memory-e cient probabilistic veri cation ifip joint international conference formal description techniques distributed systems communication protocols protocol speci cation testing veri cation stern dill automatic veri cation sci cache coherence protocol correct hardware design veri cation methods ifip advanced research working conference proceedings west general technique communications protocol validation ibm journal research development 
master loses communication primary safely grant lease replica lease expires figure illustrate process control write numbered steps client asks master chunkserver holds current lease chunkand locations replicas lease master grants replica chooses shown locations secondary replicas client caches data future mutations contact master primary primary replica secondary replica secondary replica master legend control data client step figure write control data flow unreachable replies longer holds alease client pushes data replicas client order chunkserver store data internal lru cache data aged decoupling data control improve performance scheduling expensive data based networktopology chunkserver primary section discusses replicas acknowledged receiving data client sends write request primary request identi data pushed earlier replicas primary assigns consecutive serial numbers mutations receives possibly multiple clients serialization applies mutation local state serial number order primary forwards write request secondary replicas secondary replica applies mutations serial number order assigned primary secondaries reply primary indicating completed operation primary replies client errors encountered replicas reported client case errors write succeeded cas failed primary assigned serial number forwarded client request considered failed modi region left inconsistent state client code handles errors retrying failed mutation make attempts steps falling backto retry beginning write write application large straddles chunk boundary gfs client code breaks multiple write operations follow control interleaved overwritten concurrent operations clients shared region end fragments erent clients althoughthereplicaswill beidenticalbecausetheindividual operations completed successfully order replicas leaves region consistent unde ned state noted section data flow decouple data control networke ciently control ows client primary secondaries data pipelined fashion goals fully utilize machine networkbandwidth avoid networkbottlenecks high-latency links minimize latency push data fully utilize machine networkbandwidth data pushed linearly chain chunkservers distributed topology tree machine full outbound bandwidth transfer data fast divided multiple recipients avoid network bottlenecks high-latency links inter-switch links machine forwards data closest machine networktopology received suppose client pushing data chunkservers sends data closest chunkserver forwards closest chunkserver closest similarly forwards whichever closer networktopology simple distances accurately estimated addresses finally minimize latency pipelining data transferovertcpconnections data starts forwarding immediately pipelining helpful switched networkwith full-duplex links sending data immediately reduce receive rate networkcongestion ideal elapsed time transferring bytes replicas networkthroughput latency transfer bytes machines network links typically mbps ideally distributed atomic record appends gfs atomic append operation called record append traditional write client speci set data written concurrent writes region serializable region end data fragments multiple clients record append client speci data gfs appends atomically continuous sequence bytes set gfs choosing returns set client similar writing opened append mode unix race conditions multiple writers concurrently record append heavily distributed applications clients erent machines append concurrently clients additional complicated expensive synchronization distributed lockmanager traditional writes workloads les serve multiple-producer single-consumer queues merged results erent clients record append kind mutation control section extra logic primary client pushes data replicas chunkof sends request primary primary checks appending record current chunkwould chunkto exceed maximum size pads chunkto maximum size tells secondaries replies client indicating operation retried chunk record append restricted one-fourth maximum chunksize worstcase fragmentation acceptable level record maximum size common case primary appends data replica tells secondaries write data exact set nally replies success client theclientretriesthe operation result replicas chunkmay erent data possibly including duplicates record part gfs guarantee replicas bytewise identical guarantees data written atomic unit property readily simple observation operation toreportsuccess set replicas chunk replicas long end record future record assigned higher set erent chunkeven erent replica laterbecomestheprimary intermsofourconsistency guarantees regions successful record append operations written data ned consistent intervening regions inconsistent undened applications deal inconsistent regions discussed section snapshot snapshot operation makes copy directory tree source instantaneously minimizing interruptions ongoing mutations users quickly create branch copies huge data sets copies copies recursively checkpoint current state experimenting committed rolled backeasily likeafs implement snapshots master receives snapshot request onthechunks les snapshot ensures subsequentwrites tothesechunkswill requireaninteraction master lease holder give master opportunity create copy chunk rst leases revoked expired master logs operation disk applies log record in-memory state duplicating metadata thesource directory tree newly created snapshot les point chunks source les rst time client write chunkc snapshot operation sends request master current lease holder master notices count chunkc greater defers replying client request picks chunk handle asks chunkserver current replica create chunkcalled creating chunkon chunkservers original ensure data copied locally network disks times fast ethernet links point request handling chunk master grants replicas aleaseon thenewchunkc andrepliestotheclient canwrite thechunknormally notknowing thatithas created existing chunk master operation master executes namespace operations addition manages chunkreplicas system makes placement decisions creates chunks replicas coordinates system-wide activities chunks fully replicated balance load chunkservers reclaim unused storage discuss topics namespace management locking master operations long time wedonotwanttodelay master operations running multiple operations active locks regions namespace ensure proper serialization unlike traditional systems gfs per-directory data structure lists les directory support aliases directory hard symbolic links unix terms gfs logically full pathnames metadata pre compression table ciently represented memory node namespace tree absolute absolute directory read-write lock master operation acquires set locks runs typically involves leaf acquire read-locks directory names read lockor write lockon fullpathname leaf notethatleaf directory depending operation home user foo created home user snapshotted save user snapshot operationacquiresreadlockson home save andwrite locks home user save user creation acquires read locks home home user andawrite lockon home user foo operations serialized properly obtain con icting locks home user file creation require write lock parent directory directory inode-like data structureto beprotected modi cation read lockon cient protect parent directory deletion nice property locking scheme concurrent mutations directory multiple creations executed concurrently directory acquires read lockon directory write lockon read lockon 
directory ces prevent directory deleted renamed snapshotted write locks names serialize attempts create read-writelock objects allocated lazily deleted locks acquired consistent total order prevent deadlock rst ordered level namespace tree lexicographically level replica placement gfs cluster highly distributed levels typically hundreds chunkserversspread machine racks chunkservers turn accessed hundreds clients erent racks communication machines erent racks cross network switches additionally bandwidth rackmay aggregate bandwidth machines rack multi-level distribution presents unique challenge distribute data scalability reliability availability chunkreplica placement policy serves purposes andmaximizenetworkbandwidth utilization spread replicas machines guards snetworkbandwidth spread chunkreplicas racks ensures replicas chunk survive remain entire rackis damaged ine due failure shared resource network switch power circuit means tra reads chunkcan exploit aggregate bandwidth multiple racks hand write tra chasto owthroughmultipleracks atradeo wemake willingly creation re-replication rebalancing chunkreplicas created reasons chunkcreation re-replication rebalancing master creates chunk chooses place initially empty replicas considers factors below-average diskspace utilization time equalizediskutilization acrosschunkservers wewant limit number recent creations chunkserver creation cheap reliably predicts imminentheavywritetra mandedbywrites load typically practically read-only completely written discussed spread replicas chunkacross racks master re-replicates chunkas number replicas falls user-speci goal happen reasons chunkserver unavailable itreports thatitsreplica becorrupted disks disabled errors replication goal increased chunkthat re-replicated prioritized based factors replication goal give higher prioritytoachunkthat haslost tworeplicas thantoachunkthat lost addition prefer rst re-replicate chunks live les opposed chunks belong recently deleted les section finally minimize impact failures running applications boost priority chunkthat blocking client progress master picks highest priority chunk clones instructing chunkserver copy chunk data directly existing valid replica replica goals similar creation equalizing diskspace utilization limiting active clone operations single chunkserver spreading replicas racks cloning tra overwhelming client tra master limits numbers active clone operations cluster chunkserver additionally chunkserver limits amount bandwidth spends clone operation throttling read requests source chunkserver finally master rebalances replicas periodically examines current replica distribution moves replicas diskspace load balancing process master gradually lls chunkserver instantly swamps chunks heavy write tra placement criteria replica similar discussed addition master choose existing replica remove general prefers remove chunkservers below-average free space equalize diskspace usage garbage collection deleted gfs immediately reclaim physical storage lazily regular garbage collection chunklevels approach makes system simpler reliable mechanism deleted application master logs deletion immediately reclaiming resources immediately renamed hidden includes deletion timestamp master regular scan system namespace removes hidden les existed days interval con gurable read special undeleted renaming backto normal hidden removed namespace inmemory metadata erased ectively severs links chunks similar regular scan chunknamespace master identi orphaned chunks reachable erases metadata chunks heartbeat message regularly exchanged master chunkserver reports subset chunks master replies identity chunksthat longer present master metadata chunkserver free delete replicas chunks discussion distributed garbage collection hard problem demands complicated solutions context programming languages simple case easily identify chunks leto-chunkmappings maintained exclusively master easily identify chunkreplicas linux oneachchunkserver replica master garbage garbage collection approach storage reclamation ers advantages eager deletion simple reliable large-scale distributed system component failures common chunkcreation succeed chunkservers leaving replicas master exist replica deletion messages maybelost failures chunkserver garbage collection uniform dependable clean replicas merges storage reclamation regular background activities master regular scans namespaces handshakes chunkservers batches cost amortized master free master respond promptly client requests demand timely attention delay reclaiming storage safety net accidental irreversible deletion experience themain disadvantage thedelay hinders user ort tune usage storage tight applications repeatedly create delete temporary les reuse storage address issues expediting storage reclamation deleted explicitly deleted users apply erent replication reclamation policies erent parts namespace users chunks les directory tree stored replication deleted les immediately irrevocably removed system state stale replica detection chunkreplicas stale chunkserver fails misses mutations chunkwhile chunk master maintains chunk version number distinguish up-to-date stale replicas master grants lease chunk increases chunkversion number informs up-todate replicas master replicas record version number persistent state occurs client noti start writing chunk replica unavailable chunkversion number advanced master detect chunkserver stale replica chunkserver restarts reports set chunks version numbers master sees version number greater records master assumes failed granting lease takes higher version up-to-date master removes stale replicas regular garbage collection ectively considers astale replica exist replies client requests chunk information safeguard master includes chunkversion number informs clients chunkserver holds lease chunk instructs chunkserver read chunk chunkserver cloning operation client thechunkserververi version number performs operation accessing up-to-date data fault tolerance diagnosis greatest challenges designing system dealing frequent component failures quality quantity components make problems norm exception completely trust machines completely trust disks componentfailures worse corrupted data discuss meet challenges lems inevitably occur high availability hundreds servers gfs cluster bound unavailable time system highly simple ective strategies fast recovery replication fast recovery master chunkserver designed restore state start seconds matter terminated fact distinguish normal abnormal termination servers routinely shut killing process clients servers experience minor hiccup time outstanding requests reconnect restarted server retry section reports observed startup times chunk replication discussed earlier chunkis replicated multiple chunkservers erent racks users erent replication levels erent parts namespace default master clones existing replicas needed chunk fully replicated chunkservers goo throughchecksumveri cation section replication served exploring forms cross-server redundancysuchasparityorerasurecodesforourincreasingread- storage requirements expect challenging manageable implement complicated redundancy schemes loosely coupled system tra dominated appends reads small random writes master replication master state replicated reliability operation log checkpoints replicated multiple machines mutation state considered committed log record ushed disklocally master replicas simplicity master process remains charge mutations background activities asgarbage collection thatchange thesystem internally fails restart instantly machine diskfails monitoring infrastructure gfs starts master process replicated operation log clients canonical master gfs-test dns alias changed master relocated machine shadow masters provide read-only access lesystemevenwhen theprimary master isdown shadows mirrors lag primary slightly typically fractions enhance read availability les actively mutated applications mind slightly stale results fact content read chunkservers applications observe stale content stale short windows metadata directory contents access control information tokeepitself informed growing operation log applies sequence data structures primary theprimary polls chunkserversat startup infrequently locate chunkreplicas exchanges frequent handshake messages monitor status depends primary master replica location updates resulting primary decisions create delete replicas data integrity ofstoreddata disks hundreds machines regularly experiences diskfailures data corruption loss read write paths section recover corruption 
chunkreplicas impractical detect corruption comparing replicas chunkservers divergent replicas legal semantics gfs mutations atomic record append discussed earlier guarantee identical replicas chunkserver independently verify integrity copy maintaining checksums achunkisbrokenupinto kbblocks eachhasacorresponding bit checksum metadata checksums memory stored persistently logging separate user data reads chunkserver veri checksum data blocks thatoverlap theread range returningany data requester client chunkserver chunkservers propagate corruptions machines blockdoes match recorded checksum chunkserver returns error requestor reports mismatch master response requestor read replicas master clone chunkfrom replica valid replica place master instructs chunkserverthat reported mismatch delete replica checksumming ect read performance reasons reads span blocks read checksum small amount extra data veri cation gfs client code reduces overhead align reads checksum block boundaries checksum lookups comparison chunkserver checksum calculation overlapped checksum computation heavily optimized writes append end chunk opposed writes overwrite existing data dominant workloads incrementally update checksum partial checksum block compute checksums brand checksum blocks lled append partial checksum block corrupted fail detect checksum valuewill match thestored data thecorruption detected usual blockis read contrast write overwrites existing range chunk read verify rst blocks range overwritten perform write nally compute record checksums verify rst blocks overwriting partially regions overwritten idle periods chunkservers scan verify contents inactive chunks detect corruption chunks rarely read corruption detected master create uncorrupted replica delete corrupted replica prevents inactive corrupted chunkreplica fooling master thinking valid replicas chunk diagnostic tools extensive detailed diagnostic logging helped immeasurably problem isolation debugging performance analysis incurring minimal cost logs hard understand transient non-repeatable interactions machines gfs servers generate diagnostic logs record signi events chunkservers rpc requests replies diagnostic logs freely deleted ecting correctness system logs space permits rpc logs include exact requests responses wire data read written matching requests replies collating rpc records erent machines reconstruct entire interaction history diagnose problem logs serve traces load testing performance analysis performance impact logging minimal outweighed bene logs written sequentially asynchronously recent events memory continuous online monitoring measurements trate bottlenecks inherent gfs architecture implementation numbers real clusters google micro-benchmarks measured performance gfs cluster consisting master master replicas chunkservers clients note con guration set ease testing typical clusters hundreds chunkservers hundreds clients machines con gured dual ghz piii processors gbofmemory rpmdisks mbps full-duplex ethernet connection switch gfs server machines connected switch client machines switches connected gbps link reads clients read simultaneously system client reads randomly selected region set repeated times client ends reading data chunkservers memory expect hit rate linux cache results close cold cache results figure shows aggregate read rate clients theoretical limit limit peaks aggregate gbps linkbetween switches saturated client mbps networkinterface saturated whichever applies observed read rate per-client limit client reading aggregate read ratereaches ofthe linklimit readers client ciency drops probability multiple readers simultaneously read chunkserver writes clients write simultaneously distinct les client writes data series writes aggregate write rate theoretical limit shown figure limit plateaus becauseweneedtowriteeachbyteto ofthe chunkservers input connection thewrite rate client halfof limit main culprit thisis networkstack interact pipelining scheme pushing data chunkreplicas delays propagating data replica reduce write rate aggregate write rate reaches clients client half theoretical limit thecaseofreads write concurrently chunkserver number clients increases collision writers readers write involves erent replicas writes slower practice major problem increases latencies individual clients signi cantly ect aggregate write bandwidth delivered system large number clients record appends figure shows record append performance clients append simultaneously single performance limited networkbandwidth chunkservers store chunkof independent number clients starts client drops clients due congestion variances networktransfer rates erent clients applications tend produce multiple les concurrently words clients append shared les simultaneously dozens hundreds experiment signi issue practice client make progress writing chunkservers busy real world clusters examine clusters google representative cluster regularly research development hundred engineers typical taskis initiated human user runs hours reads mbs tbs data transforms analyzes data writes results backto cluster cluster primarily production data processing tasks cluster chunkservers disk space disk space number files number dead files number chunks metadata chunkservers metadata master table characteristics gfs clusters longer setswith onlyoccasional humanintervention bothcases asingle task consistsofmanyprocesses onmanymachines reading writing les simultaneously storage asshownbythe rst veentriesinthetable bothclusters hundreds chunkservers support tbs disk space fairly completely full space includes chunkreplicas virtually les replicated times clusters store data clusters similar numbers les larger proportion dead les les deleted replaced bya version storage reclaimed chunks les tend larger metadata chunkservers aggregate store tens gbs metadata checksums blocks user data metadata chunkservers chunkversion number discussed section metadata master smaller tens mbs bytes average agrees assumption size master memory limit system capacity practice perle metadata names stored pre x-compressed form metadata includes ownership permissions mapping les chunks chunk scurrentversion inaddition chunkwe store current replica locations count implementing copy-on-write eachindividualserver metadata recovery fast takes seconds read metadata master hobbled period typically seconds fetched chunklocation information chunkservers read write rates table shows read write rates time periods clusters weekwhen measurements clusters restarted recently upgrade version gfs average write rate restart tookthese measurements data produced networkload writes propagated replicas number clients read rate network limit aggregate read rate reads number clients write rate network limit aggregate write rate writes number clients append rate network limit aggregate append rate record appends figure aggregate throughputs top curves show theoretical limits imposed networktopology bottom curves show measured throughputs error bars show con dence intervals illegible cases low variance measurements cluster read rate minute read rate hour read rate restart write rate minute write rate hour writerate sincerestart master ops minute ops ops master ops hour ops ops master ops restart ops ops table performance metrics gfs clusters read rates higher write rates total workload consists reads writes assumed clusters middle heavy read activity sustaining read rate preceding week network conguration support resources ciently cluster support peakread rates applications master load table shows rate operations master operations master easily rate bottleneckfor workloads earlier version gfs master occasionally bottleneckfor workloads spent time sequentially scanning large directories contained hundreds thousands les les changed master data structures cient binary searches namespace easily support thousands accesses speed upfurther placing lookup caches front namespace data structures recovery time chunkserverfails chunkswill underreplicated cloned restore replication levels time takes 
restore chunks depends amount resources experiment killed single chunkserver cluster chunkserver chunks data limit impactonrunningapplicationsandprovideleewayforschedul- ing decisions default parameters limit cluster concurrent clonings number chunkservers clone operation allowed consume mbps allchunkswere restored minutes ective replication rate experiment killed chunkservers withroughly chunksand gbofdata thisdouble failure reduced chunks single replica chunks cloned higher priority restored replication minutes putting cluster state tolerate chunkserver failure data loss workload breakdown section present detailed breakdown workloads gfs clusters comparable identical section cluster research development cluster production data processing methodology caveats results include client originated requests ect workload generated applications system include interserver requests carry client requests internal background activities forwarded writes rebalancing statistics operations based information heuristically reconstructed actual rpcrequestslogged gfs servers gfs client code breaka read multiple rpcs increase parallelism infer original read access patterns highly stylized expect error noise explicit logging applications provided slightly accurate data logistically impossible recompile restart thousands running clients cumbersome collect results machines careful overly generalize workload google completely controls gfs applications applications tend tuned gfs conversely gfs designed applications mutualin operation read write record append cluster inf table operations breakdown size reads andtransferred amount requested systems ect pronounced case chunkserver workload table shows thedistributionof operations bysize read sizes exhibit bimodal distribution small reads seek-intensive clients small pieces data huge les large reads long sequential reads entire les asigni numberof reads returnnodata atall incluster applications production systems les producer-consumer queues producers append concurrently consumer reads end occasionally data returned consumer outpaces producers cluster shows short-lived data analysis tasks long-lived distributed applications write sizes exhibit bimodal distribution large writes typically result signi ering writers writers data checkpointorsynchronizemoreoften orsimplygeneratelessdata account smaller writes record appends cluster sees higher percentage large record appends cluster production systems cluster aggressively tuned gfs table shows total amount data transferred operations sizes kinds operations larger operations generally account bytes transferred small reads transfer small signi portion read data random seekworkload appends versus writes record appends heavily production systems cluster ratio writes record appends bytes transferred operation counts cluster production systems ratios ratios suggest clusters record appends tend larger writes cluster usage record append measured period fairly low results skewed applications size choices expected data mutation workload dominated appending overwriting measured amount data overwritten primary replicas apoperation read write record append cluster inf table bytes transferred breakdown operation size reads size amount data read transferred amount requested read attempts read end design uncommon workloads cluster open delete findlocation findleaseholder findmatchingfiles combined table master requests breakdown type proximates case client deliberately overwrites previous written data appends data cluster overwriting accounts bytes mutated mutation operations clustery theratiosareboth althoughthisisminute higher expected turns overwrites client retries due errors timeouts part workload consequence retry mechanism master workload table shows breakdown type requests master requests askfor chunklocations findlocation reads lease holder information findleaselocker data mutations clusters signi cantly erent numbers delete requests cluster stores production data sets regularly regenerated replaced newer versions erence hidden erence open requests version implicitly deleted opened write scratch mode unix open terminology ports similar system operations unlike requests master process large part namespace expensive cluster sees automated dataprocessing taskstendto examine parts system understand global application state contrast cluster applications explicit user control names needed les advance experiences process building deploying gfs experienced variety issues operational technical initially gfs conceived backend system production systems time usage evolved include research development tasks started support thingslike permissions quotasbutnow includes rudimentary forms production systems disciplined controlled users infrastructure required users interfering someofourbiggest disks claimed linux driver supported range ide protocol versions fact respondedreliablyonlytothemorerecentones sincetheprotocol versions similar drives worked occasionally mismatches drive kernel disagree drive state corrupt data silently due problems kernel problem motivated checksums detect data corruption whileconcurrentlywemodi edthekerneltohandle protocol mismatches earlier problems linux kernels due cost fsync cost proportional size size modi portion problem large operation logs implemented checkpointing worked time synchronous writes eventually migrated linux linux problem single reader-writer lock thread address space hold pages disk reader lock modi address space mmap call writer lock transient timeouts system light load looked hard resource bottlenecks sporadic hardware failures eventually found single lockblocked primary networkthread mapping data memory diskthreads paging previously mapped data limited networkinterface memory copy bandwidth worked replacing mmap pread cost extra copy helped time explore understand system behavior improve kernel share open source community related work large distributed systems afs gfs location independent namespace enables data moved transparently load balance fault tolerance unlikeafs gfsspreadsa sdataacross storage serversin moreakin toxfs swift order deliver aggregate performance increased fault tolerance disks cheap replication simpler sophisticated raid approaches gfs replication redundancyand consumes raw storage xfs swift contrast systemslike afs xfs frangipani intermezzo gfs provide caching system interface target workloads reuse single application run stream large data set randomly seekwithin read small amounts data time distributed systems frangipani xfs minnesota sgfs andgpfs rely distributed algorithms consistency management opt centralized approach order simplify design increase reliability gain exibility centralized master makes easier toimplement sophisticated chunkplacement andreplication policies master relevant information controls address fault tolerance keeping master state small fully replicated machines scalability high availability reads provided shadow master mechanism updates master state made persistent appending write-ahead log adapt primary-copyscheme liketheone harp provide high availability stronger consistency guarantees current scheme weare addressing aproblem similar tolustre interms delivering aggregate performance large number clients simpli problem signi cantly focusing applications building posix-compliant system additionally gfs assumes large number unreliable components fault tolerance central design gfs closely resembles nasd architecture nasd architecture based network-attached diskdrives gfs commodity machines chunkservers nasd prototype unlike nasd work xed-sizechunksrather variable-length objects additionally gfs implements features rebalancing replication recovery required production environment unlike minnesota gfs nasd seek alter model storage device focus addressing day-to-day data processing complicated distributed systems existing commodity components producer-consumer queues enabled atomic record appendsaddress similar problemas thedistributedqueues river river memory-based queues distributed machines careful data control gfs persistent appended concurrently producers river model supports m-to-n distributedqueuesbutlacksthefaulttolerancethatcomeswith persistent storage gfs supports m-toqueues ciently multiple consumers read coordinate partition incoming load conclusions google file system demonstrates qualities essential supporting large-scale data processing workloads commodity hardware design decisions speci unique setting apply data processing tasks 
similar magnitude cost consciousness lesystemassumptions light current anticipated application workloads technological environment observations led radically erent points design space treat component failures norm exception optimize huge les appended concurrently read sequentially extend relax standard system interface improve system system fault tolerance constant monitoring replicating crucial data fast automatic recovery chunkreplication tolerate chunkserver failures frequency failures motivated pairs damage compensates lost replicas additionally checksumming detect data corruption diskor ide subsystem level common number disks system design delivers high aggregate throughput achieve separating system control passes master data transfer passes directly chunkservers clients master involvement common operations minimized large chunk size chunkleases delegates authority primary replicas data mutations makes simple centralized master bottleneck improvements networking stack lift current limitation write throughput individual client gfs successfully met storage widely google storage platform research development production data processing important tool enables continue innovate attackproblems scale entire web acknowledgments system paper brain bershad shepherd anonymous reviewers gave valuable comments andsuggestions anuragacharya dean anddaviddesjardins contributed early design fay chang worked comparison replicas chunkservers guy edjlali worked storage quota markus gutschke worked testing frameworkand security enhancements david kramer worked performance enhancements fay chang urs hoelzle max ibel sharon perl rob pike debby wallach commented earlier drafts paper colleagues google bravely trusted data system gave feedback yoshka helped early testing thomas anderson michael dahlin jeanna neefe david patterson drew roselli randolph wang serverless network systems proceedings acm symposium operating system principles pages copper mountain resort colorado december remzi arpaci-dusseau eric anderson noah treuhaft david culler joseph hellerstein david patterson kathy yelick cluster river making fast case common proceedings sixth workshop input output parallel distributed systems iopads pages atlanta georgia luis-felipe cabrera darrell long swift distributed diskstriping provide high data rates computer systems garth gibson david nagle khalil amiri butler fay chang howard gobio charles hardin erikriedel david rochberg jim zelenka cost-e ective high-bandwidth storage architecture proceedings architectural support programming languages operating systems pages san jose california october john howard michael kazar sherri menees david nichols mahadev satyanarayanan robert sidebotham michael west scale performance distributed system acm transactions computer systems february intermezzo http inter-mezzo barbara liskov sanjay ghemawat robert gruber paul johnson liuba shrira michael williams replication harp system symposium operating system principles pages paci grove october lustre http lustreorg david patterson garth gibson randy katz case redundant arrays inexpensive disks raid proceedings acm sigmod international conference management data pages chicago illinois september frankschmuckand roger haskin gpfs shared-disk system large computing clusters proceedings usenix conference file storage technologies pages monterey california january steven soltis thomas ruwart matthew keefe gobal file system proceedings nasa goddard space flight center conference mass storage systems technologies college park maryland september chandramohan thekkath timothy mann edward lee frangipani scalable distributed system proceedings acm symposium operating system principles pages saint-malo france october 
tiger tiger william blake tiger tiger burning bright forests night immortal hand eye frame thy fearful symmetry distant deeps skies burnt fire thine eyes wings dare aspire hand dare seize fire shoulder art twist sinews thy heart thy heart began beat dread hand dread feet hammer chain furnace thy brain anvil dread grasp dare deadly terrors clasp stars threw spears water heaven tears smile work made lamb make thee tiger tiger burning bright forests night immortal hand eye dare frame thy fearful symmetry 
cummings righter books plan stupidest teacher guess run skip hasn buds books don grow everyanything world leaf tree bough birds sing sweeter books fly forever till love love books shuter books deep high fall shout calling brighter sun greater books everyanything spin leap alive alive wonderful times 
pqm fsv ojpd hmh iak veb diee fkp efu qqq ifu giui gcu pjja itde ghi wcp twv q-w utmh bjun blr dtx fwz ekic pqc gvj tkk fqg oen kiwg lra mtd jpk ewx w-g jds gfd nwus ttsr znj acd bnr sfenq hqjx kvj ruh bmlsh dna r-v wnt byyf xzp zce nmm cxy mvn bjk skl juk wlt mnn hty ogz yjj cuo fze uwe jla bqcd dkauu agop zmww jlm pdm ihu x-x lzw kvw ycf kwrs btv dlfh zgkk jet orvt izf ylu msw nqj evi yje -ky kpl frk spz dlt ckc zelt poroav aub kxjf uaw ima asmq uel tvbwvd zcg dma deen hoe xjj njz kxh-q ozp bmai jxu gss cvq tqv zwm ppp yqw fhd dub crxw tuxk yjk frk tteo ebp cgr ztz dma hea bme ktq euj sqn i-or ood zfb tjb xta boq bby ejs nsr izc szm geyi uul lrq wou yju cwn nddlt llj mbsy aeoqb zls mft sqv dviy dma rix qhu fvk hzlb qyvzy obh ajo uhw ymf zmnrj zzv tnv dwsg wug afa ggq fvt hna muo fuf vxy iupr iwn zvy tju hzx dzd fwvb wed uhr bhdi opn ujur kew bnm xpg rfu luj lqmnkv olq aim vvc npr osvc gvq mja ecj rbv nql gxj znl pxj qfo bbd dthl jdd vmkf g-zt mkb tfo ymf vxx ycb iek jssu yhx gzzzu edx aix hvf jbn zsmw hlf czfh wlh -xd iteh ktp uti opi kzjpkw gyi jkis pqz qhx jja ytu ajm qhk agoqh gpp pus fal ofl xvt dbys v-n ovq mfip jmoyc jaboq ycn rfz rgtu hhz zen bbm occn qif nxi ifz hsg wbh sya vcg azw icn ewe smc ktw w-m nblc rex zfv dog sfn yvk fxd ayd dcpic jtb qwl zgd rnt xyq zgsu rrx jtnq avjb tekm eoo aut ltbe sru mfv bma fjy umr jgr ord zrf eis sop zkl ebyw ogy drq geo fjw nce xfd vva dhm awo mokx acbbr koa mps nwz uvq yvuok jmbk nff opf rht ydl yvs agop qqm pud dkuk r-jr t-t ufd uui dme mcb ery ljl myf wbp woeb tau fos mak xkf anp lkt pwulrlf zyl bdv cth pnn dsxs kvoowfw ejrd mht zsc ciw qaxc oqq -kx cpv vzi roh mak oenb zkj svd gnr qte lzqz dtvk ojn dgv tsq hvs yihl yxl uov mmo ozsa hxm svm bom hkyw oyj -un bvo oue zwe snq wfs khh yfv jsb jpg nuw hsr akfg png kvmm olk fyzu ioem rkqt evif smf xlk ggq zeg jja lsvh ymi bzy lie atkv fay qemx mbp xjllx dyl fai m-st icg phf mth zys jof zym nbs opz bpo wvnj nqr ste omd hdz wmwo tbnt kbf wwel zna tjs qem -ao zrk towk sjme s-d exm d-a oqr mgjk vto vwl yoew vla drl jcl crv-f pzga nvy hbb fjm qmda rcs yfc fmo rfq whp wwdn bma b-l tsd gztu qia lof oqd woit abg bnm w-t bcb nqb inn sewu igt ubt vpw vtg icl gjv fbm ljx jdw ylq wll bqi hkz yji kmj essj zio ylx zvo agop dcq tkv unm zsj yhl rzk nqn hlom qjr pfa fieh zse jmo uuuo afc osz cfh kma osu tzsh aaup bhr jdx mda vae xcxk kgt hwu ggv qoz kzu rvn jwt akn pbq zup puk rkv phsa ruk qls aeq ujk utr nly lqu les npe hfa nzz wmu a-ddz mat nwn fzo -yrkd -bx ifb qgw vvu olmnb wwb rfg gtf ywo lfr wmr avu pma -gj -lq mas wpe bme trw rgs yhf aal syx uec zcg mmjd zce ecn cawl wnf spj bkt ffg dey ths teh gqh jfu mkl vrx ohjs sjy wbg gmtb -vu jfka ofg kxl obn hdd -zx stz wsh wgq opa mek ywxl dfc rbyh fma bmg euy zge qnu gjmh sqd svo yzp ymnuj rlf letn gte eau pas oqa d-ak x-s aig wdzpa xzp afr evu ylc ldun dxdvp wug czo hro kth dks ujvf zzq cya wxd cyx fmww xv-b ycb hli ydb-m jfj uwj nec ddrq -xsy hsu tuc knq tvn fia rzyn bul nqh wvd bme quvl wvr qte zja cbb dks m-s bjh eutb ien vgo wttew k-o c-o qed kek frmk qqup -en vwt ldjq xmx qoe kyw xun tqz mnz ggu ikz xvdb qid ajoqr oiz fvl ovs ext gyi fhc ago iccb qvq uja rfy bpsb iaff aeo yef dhm sbtua eob vrh ksh fhy nmc pdg cdd evacg oapph tty dchl -xv bep k-l dsd xah krj mnac oqk jlx nim kub xbci ntt ijc skm fjl efn dsx ssg dtb etu nvop kse hjjbl rhw fqi ina wgv bhc szl pkxvb hzb mzg enfol ago lud kqa mai vfbm peh tgjh mut xbe gsr njp fxq yob ywmk skg yml qgl qlc tyqx xdg pue tmjt gec zpe cgr cwhrza fvlf ojo kpj bnr ths yuc vcpkw phfp mzy crb nyt fza vjmiod qca djm gdv lgb tts iaz nre esk gppd im-ey ljy dlf yoa oiq lzd yyvb phsd uig uju pvi qvtb shjo oum kfe ism opb gno eojl qwp ibom frj lfm wmy yuea ice otj ucak cgf szm yzp den oen lbg kfm dwy -cq ljsefc autoraid hierarchical storage system john wilkes richard golding carl staelin tim sullivan hewlett-packard laboratories con uring redundant disk arrays black art configure array properly system administrator understand details array workload support incorrect understanding workload time lead poor performance present solution problem two-level storage hierarchy implemented inside single disk-array controller upper level hierarchy copies active data stored provide full redundancy excellent performance lower level raid parity protection provide excellent storage cost inactive data lower performance technology describe article autoraid automatically transparently manages migration data blocks levels access patterns change result fully redundant storage system extremely easy suitable wide variety workloads largely insensitive dynamic workload performs disk arrays comparable numbers spindles larger amounts front-end ram cache implementation autoraid technology software additional hardware cost benefits small describe autoraid technology detail provide performance data embodiment storage array summarize results simulation studies choose algorithms implemented array categories subject descriptors input output data communication input output devices-channels controllers input output data communications reliability testing fault-tolerance redundant design operating systems storage management secondary storage general terms algorithms design performance reliability additional key words phrases disk array raid storage hierarchy introduction modern businesses increasing number individuals depend information stared computer systems modern disk drives mean-time-to-failure mitf values measured hundreds years storage increased enormous rate sufficiently large collection devices experience inconveniently frequent authors address hewlett-packard laboratories page mill road palo alto wilkes gelding staelin sullivan hpl corn permission make digital hard copy part work personal classroom granted fee provided copies made distnbu profit commercial advantage copyright notice title date notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee acm acm transactions computer systems vol february psges autoraid failures worse completely reloading large storage system backup tapes hours days resulting costly downtime small numbers disks preferred method providing fault protection duplicate mirror data disks independent failure modes solution simple performs total number disks large cost effective employ array controller form partial redundancy parity protect data stores raids redundant arrays independent disks early lawlor park balasubramanian popularized work group berkeley patterson storing partial redundancy data incremental cost desired high availability reduced total storage-capacity cost number disks array cost array controller berkeley raid terminology number raid levels representing amount redundancy placement rule redundant data disk array products implement raid level raid level host data blocks bitor byte-interleaved set data disks parity stored dedicated data disk figure raid level host data blocks block-interleaved disks disk parity block stored rotates round-robin fashion stripes figure hardware software raid products vendors current disk arrays difficult chen lee raid levels performance characteristics perform narrow range workloads accommodate raid systems typically offer great configuration parameters dataand parity-layout choice stripe depth stripe width cache sizes write-back policies setting correctly difficult requires knowledge workload characteristics people unable unwilling acquire result setting raid array daunting task requires skilled expensive people cases painful process trial error making wrong choice costs resulting system perform poorly changing layout inevitably requires copying data device reformatting array reloading step process hours opportunity inadvertent data loss operator error-one commonest sources problems modern computer systems gray adding capacity existing array essentially problem taking full advantage disk requires reformat data reload raid arrays suffer reduced performance degraded mode drives failed include provision spare disks pressed service active disk fails redundancy reconstruction commence immediately reducacm transactions computer systems vol february john wilkes data parity data atity raid raid fig data parity layout raid levels ing window vulnerability data loss device failure minimizing duration performance degradation normal case spare disks contribute performance system secondary problem assuming spare disk working spare idle array controller find failed late solution managed storage hierarchy fortunately solution problems great applications disk arrays redundancy-level storage hierarchy basic idea combine performance advantages mirroring cost-capacity benefits raid mirroring active data storing inactive read-only data raid make solution work part data active part inactive cost performance reduce mirrored data active subset change slowly time array work move data levels fortunately studies access patterns disk shuffling file system restructuring shown conditions met practice akyurek salem deshpandee bunt floyd schlattir ellis geist majumdar mcdonald bunt mcnutt ruemmler wilkes smith storage hierarchy implemented number ways manually system administrator large mainframes run decades gelb discusses slightly refined version basic idea advantage approach human intelligence brought bear problem knowledge lower levels operating systems error prone wrong choices made mistakes made moving data level adapt rapidly changing access patterns requires highly skilled people resources disk drives added system easily file system per-file basis place terms good balance knowledge file system track access patterns per-file basis implementation freedom acm lyansaetions computer systems vol february autoraid file system implementations customers hands deployment major problem smart array controller block-level device interface small systems computer interface scsi standard scsi level disadvantage knowledge files lost enormous compensating advantage easily deployable strict adherence standard means array approach regular disk array set plain disk drives surprisingly describing array-controller-based solution auto refer collection technology developed make embodiment array controller summary features autoraid summarize features autoraid mapping host block addresses internally mapped physical locations transparent migration individual blocks mirroring write-active data mirrored performance provide single-disk failure redundancy raid write-inactive data stored raid cost capacity retaining good read performance single-disk failure redundancy addition large sequential writes directly raid advantage high bandwidth access pattern adaptation amount data stored initially array starts empty data added internal space allocated mirrored storage data stored storage space automatically reallocated raid storage class data migrated mirrored storage class raid layout compact data representation data stored array reapportionment allowed proceed capacity mirrored storage shrunk total usable space exact number policy choice made implementors autoraid firmware maintain good performance space apportioned coarse-granularity lmb units adaptation workload active set data newly active data promoted mirrored storage data active demoted raid order amount mirrored data roughly constant data movements background affect performance array promotions demotions occur completely automatically fine-granularity units hot-pluggable disks fans power supplies controllers failed component removed inserted system continues operate commonplace features acm transactions computer systems vol february john wilkes higher-end disk arrays important enabling features on-line storage capacity expansion disk added array time maximum allowed physical 
packaging-currently disks system automatically takes advantage additional space allocating mirrored storage time workload permit active data rebalanced drives workload newcomer previous disks maximum performance system easy disk upgrades unlike conventional arrays disks capacity advantages drive purchased optimal capacity cost performance point regard prior selections entire array upgraded disk type capacity interrupting operation removing disk time inserting replacement disk waiting automatic data reconstruction rebalancing complete eliminate reconstruction data drained disk replaced advantage retaining continuous protection disk failures process require spare capacity system controller fail-over single array controllers capable running entire subsystem failure primary operations rolled failed controller replaced system active concurrently active controllers supported active hot spare spare space needed perform reconstruction spread disks increase amount space mirrored data array performance-rather simply left idle disk fails mirrored data demoted raid provide space reconstruct desired redundancy process complete disk failure tolerated-and physical capacity filled data raid storage class simple administration setup system administrator divide storage space array logical units luns scsi terminology correspond logical groupings data stored creating lun changing size existing lun trivial takes seconds front-panel menus select size confirm request array formatted traditional sense creation lun require pass newly allocated space initialize parity operation hours regular array needed controller data structures updated log-structured raid writes well-known problem raid disk arrays so-called small-write problem update-in-place part stripe takes data parity read parity calculated data parity written back autoraid acm transactions computer systems vol february autoraid avoids overhead cases writing raid storage log-structured fashion empty areas disk written old-data old-parity reads required related work papers published raid reliability performance design variations parity placement recovery schemes chen annotated bibliography autoraid work builds studies concentrate architectural issues multiple raid levels specifically single array controller storage technology corporation iceberg ewing stk similar indirection scheme map logical ibm mainframe disks count-keydata format array -inch scsi disk drives art rudeseal private communication nov iceberg handle variable-sized records autoraid scsi interface handle indirection fixed-size blocks emphasis iceberg project achieving extraordinarily high levels availability emphasis autoraid performance single-component failure model regular raid arrays achieved iceberg include multiple raid storage levels simply single-level modified raid storage class dunphy ewing team ibm almaden extensive work improving raid array controller performance reliability ideas application ibm mainframe storage controllers floating-parity scheme menon kasson indirection table parity data written nearby slot necessarily original location reduce small-write penalty raid arrays distributed sparing concept menon mattson spreads spare space disks array allowing spindles hold data autor aid data parity relocated distributed spare capacity increase fraction data held mirrored form improving performance schemes menon courtney dual-controller version autoraid array handle controller failures loge disk drive controller english stepanov followons mime chao logical disk jonge scheme keeping indirection table fixed-sized blocks held secondary storage supported multiple storage levels targeted raid arrays work extended function controller disk divisions looked issues progress awaited development suitable controller technologies make approach adopted autoraid cost effective log-structured writing scheme autoraid owes intellectual debt body work log-structured file systems lfs carson setia ousterhout douglis rosenblum ousterhout acmtransactions computer systems vol february john wilkes seltzer cleaning garbage collection policies blackwell mcnutt mogi kiteuregawa large body literature hierarchical storage systems commercial products domain chen cohen dec deshpandee bunt epoch systems gelb henderson poston katz miller misra sienknecht smith proceedings ieee symposia mass storage systems work concerned wider performance disparities levels exist autoraid systems disk robotic tertiary storage tape magneto-optical disk levels hierarchical storage systems front-end dieks act cache data tertiary storage autoraid mirrored storage cache data moved storage classes residing precisely class time method maximizes storage capacity number disks highlight system kohl extended lfs two-level storage hierarchies disk tape fixed-size segments highlight segments lmb size suited tertiary-storage mappings secondary-etorage levels schemes inactive data compressed burrows cate taunton exhibit similarities storage-hierarchy component autoraid operate file system level block-based device interface finally modern array controllers autoraid takes advantage kind optimization noted baker ruemmler wilkes nonvolatile memory roadmap remainder article remainder article organized begin overview technology autoraid array controller works sets performance studies set measurements product prototype set simulation studies evaluate algorithm choices autoraid finally conclude article summary benefits technology technology section introduces basic technologies autoraid etarts overview hardware discusses layout data disks array including structures ueed mapping data blocks locations disk overview normal read write operations illustrate flow data system descriptions series operations performed background eneure performance system remaine high long periods time acm transactions computer systems vol february autoraid sscsl scsln host processor fig overview autoraid hardware autoraid array controller hardware autor array fundamentally similar regular raid array set disks intelligent controller incorporates microprocessor mechanisms calculating parity caches staging data nonvolatile connection host computers speed-matching buffers figure overview hardware hardware prototype provide performance data back-end scsi buses connect disks fast-wide scsi buses front-end host connection alternatives exist packaging technology scope article array presents scsi logical units luns hosts treated virtual device inside array controller storage freely intermingled lun size increased time subject capacity constraints block lun valid data stored address array controller allocate physical space data layout intelligence autoraid controller devoted managing data placement disks two-level allocation scheme physical data layout pegs pexes segments data space disks broken large-granularity objects called physical extents pexes shown figure pexes typically lmb size acm transactions computer systems vol february john wilkes disk waddreties egs --------dk ka--------fig mapping pegs pexes disks adapted burkes table summary autqraid data layout terminology term meaning size pex physical extent unit sicaiapaceallocation lmb peg physical extent group group pexss assigned storage class stripe row parity dats segments raid storage class segment stripe unit raid half mirroring unit relocation block unit data migration lun logical unit host-visible virtual disk user settable depends number disks pexes combined make physical extent group peg order provide redundancy make usable mirrored raid storage class peg includes pexes disks time peg assigned mirrored storage class raid storage class unassigned speak mirrored raid free pegs terminology summarized table pexes allocated pegs manner balances amount data disks hopefhlly load disks retaining redundancy guarantees pexes disk stripe beeause diska autoraid array acm transactions computsr syatema vol february autoraid disko disk diak diak diek mirrored peg 
mirroradz pair segme strip raid peg fig layout pegs mirrored raid peg spread disks raid peg segments disks assemble strip-es mirrored peg segments disks form mirrored pairs sizes allocation process leave uneven amounts free space disks segments units contiguous space disk included stripe mirrored pair pex divided set segments figure shows mirrored raid pegs divided segments segments logically grouped storage classes ways raid segment stripe unit mirrored storage class segment unit duplication logical data layout rbs logical space provided array visible clients divided small units called relocation blocks rbs basic units migration system lun created increased size address space mapped set rbs assigned space peg host issues write lun address maps size compromise data layout data migration data access costs smaller rbs require mapping information record put increase time spent disk seek rotational delays larger rbs increase migration costs small amounts data updated report exploration relationship size performance section acm transactions compuix systems vol february john wilkes vktld vico tabtes tie owlun rss tinters tothepme wmchthey reside peg mbles peg holdsfistof rss pegand listof xesused store pex mbles physicaldiskdrive fig structure tables map addresses virtual volumes pegs pexes physical disk addresses simplified peg hold rbs exact number fimction peg size storage class unused slots peg marked free data allocated mapping structures subset mapping structures shown figure data structures optimized physical disk address logical lun-relative address common operation addition data held access times history amount free space peg cleaning garbage collection purposes statistics shown back pointers additional scans normal operations start host-initiated read write operation host sends scsi command descriptor block cdb autoraid array parsed controller cdbs active time additional cdbs held fifo queue waiting serviced limit requesta queued host long requests broken pieces handled sequentially method limits amount controller resources single consume minimal performance cost request read data completely controller cache memories data transferred host speed-matching btier command completes statistics acm transactionson computer systems vol february autoraid updated space allocated front-end buffer cache read requests dispatched back-end storage classes writes handled slightly differently nonvolatile front-end write buffer nvram host request complete copy data made memory check made cached data invalidating space allocated nvram allocation wait space trigger flush existing dirty data back-end storage class data transferred nvram host host told request complete depending nvram cache-flushing policy back-end write initiated point hope subsequent write coalesced increase efllciency flushing data back-end storage class simply back-end write data mirrored storage class flush trigger promotion raid mirrored exceptions describe promotion calling migration code allocates space mirrored storage class copies raid space mirrored storage class background daemons chance run turn provoke qmr dbm mmf wkh ktv sbl jhf vqk dhh opf xbk iph hyj kos dgv boq wwob wwob nar wqkv usj qulm jad caww ubjqg jyv -xi alr nmvs oid yki mdp jwtv -et ojm dtw rkah qny gyl lst bsr pzge rkl bcd urkxn uex ocdvw xit bak nwk fqr oqd zpy iwrt kgmevw wel kii ioy jgzc stz frovpp ukz igo skq clik eni jza woa ppn kns ehb ahf qam fjng eql demotion kaja mirrored data raid uqr tricky details involved ensuring turn fail mak free-space management policies yde anticipate tnq worst-case sequence dff events arise practice mirrored reads writes reads writes mirrored storage class zlu straightforward read call picks copies ivu issues request disk ijz write call writes disks returns copies saeoq updated note back-end write call issued flush data nvram synchronous host write uhg raid reads writes back-end reads raid storage class simple mirrored storage class normal case read issued ccl disk holds data recovery case data lml reconstructed blocks agop stripe lmh usual raid recovery algorithms case discuss failure nlb case article implemented current system techniques parity declustering holland gibson improve recovery-mode performance back-end raid writes fdwz complicated raid storage laid bem log freshly demoted rbs appended end current dxxb raid write peg overwriting virgin storage writes ways per-rb writes batched writes simpler efficient per-rb writes ready written flushed disk copy contents flow past parityacm transactions computer systems vol february john wilkes calculation logic xors previous contents-the parity stripe data written parity written prior contents parity block stored nonvolatile memory process protect power failure scheme data-rb write ckns disk writes data parity scheme advantage simplicity cost slightly worse performance batched writes parity written data rbs stripe written end batch beginning batched write valid data peg wvzf written prior edbt contents parity rqf block copied nonvolatile memory sxo index highest-numbered peg valid data panty calculated xoring rbs indices equal rbs written pxe data portion fuq stripe eqx end stripe reached batch completes point parity gzx written parity ilp computed on-the-fly fmefel parity-calculation logic data written ypj batched write fails complete reason system returned prebatch state restoring parity index write retried ihq per-rb method batched writes require bit coordination per-rb writes require additional parity write full stripe data written raid writes batched writes kvmi addition logging write methods method typically azo nonlogging raid implementations lhq read-modify-write caees k-e method reads data parity modifies lae rewrites disk forward progress rare cases peg logging write processes update data holes section place raid migrate mirrored storage background migrations array idle background operations bho addition foreground activities autoraid array controller executes background activities garbage collection layout balancing background algorithms nkdg attempt provide slack resources needed foreground operations foreground trigger synchronous version background tasks dramatically reduce performance background operations vxeyc triggered array idle period time idleness defined algorithm current past device activity-the array completely devoid activity idle period detected array performs set background operations subsequent idle period continuation current triggers set operations acmtransactions computer systems vol february autoraid long period array activity current algorithm moderate amount time detect array idle hope apply results nqi gelding improve idle-period detection prediction accuracy bql turn aggressive executing dgf background algorithms compaction cleaning hole-plugging mirrored storage class gdc acquires holes empty slots qmv rbs demoted raid storage ayh class updates mirrored rbs written place generate holes holes added free list mirrored storage class yfl subsequently promoted newly created rbs peg needed raid rebf storage class free pexes mirrored peg chosen cleaning data migrated fill holes mirrored pegs peg reclaimed reallocated raid storage class similarly raid storage class acquires holes rbs promoted mirrored storage class rbs updated normal raid write process logging holes reused directly call garbage array perform periodic garbage collection eliminate raid peg holes full array performs hole-plugging garbage izz collection rbs copied peg small number rbs mxs fill holes full peg minimizes data movement spread fullness pegs hhx case peg holes empty qql 
holes plugged array peg cleaning appends remaining valid rbs current end raid write log reclaims complete peg unit migration moving rbs levels background migration policy run move rbs mirrored storage raid primarily provide empty slots mirrored storage class handle future write burst ruemmler phu wilkes showed xgx bursts common rbs selected migration approximate 
recently written algorithm migrations performed background number free slots mirrored storage class kfuyx free pegs exceeds high-water mark chosen system handle burst incoming data threshold set provide burst-handling cost slightly lower out-of-burst performance current autoraid firmware fixed determined dynamically balancing adjusting data layout drives drives added array data contribute system performance hvblry balancing process migrating pexes disks equalize amount data stored disk request load imposed disk access histories acm transactions tkvf computer systems vol february john wilkes balance disk load pvl precisely balancing background wgeb activity performed system type imbalance results ggj drive added array newly created raid byp pegs bii drives system provide maximum performance previously created -kr raid pegs continue original disks mooe imbalance corrected bxr pojr low-priority background process copies valid data pegs full-width pegs workload logging uncertainties gnh faced tnw developing autoraid design lack broad range real system workloads disk level measured accurately evaluating performance remedy future fme aut aid array incorporates workload logging tool system presented specially formatted disk tool records start stop times externally issued request events recorded desired overhead small qpb event logs buffered controller ram written large blocks result anp faithfid record unit asked drive simulation design studies kind describe article management tool aut dlaid controller maintains opr set internal statistics cache utilization times disk utilizations statistics cheap acquire store euc provide zry significant insight operation system product team developed off-line inference-based management tool statistics suggest configuration choices aeoqbma tool determine period high load performance improved adding cache memory array controller gph short read cache information dwy administrators maximize array performance environment autoraid performance results combination prototyping event-driven simulation development autoraid technology autoraid embedded algorithms policies manage storage hierarchy result hardware firmware prototypes developed concurrently event-driven simulations studied design choices algorithms policies parameters algorithms primary rje development team based product division designed -isym built tested prototype hardware firmware supported group laboratories built detailed simulator ixz acm lhmactions computer systems vol february autoraid hardware firmware model alternative algorithm policy choices depth organization allowed teams uvdk incorporate technology products time fully wop investigating alternative kby design choices section present measured results laboratory eob prototype disk array product embodies autoraid technology flu section present set comparative -jed performance analyses algorithm policy choices gly guide implementation real thing experimental setup baseline autoraid configuration report -disk system controller controller data cache connected fast-wide differential scsi adapters system oqn processor main memory running release hp- operating system qeo clegg drives txi ogb rpm seagate barracudas write reporting turned calibrate autoraid results external systems measurements disk subsystems measurements host hardware days host configurations number disks type disks data general clariion series disk-array storage atj system deskside yvh model rvz front-end cache efb refer system raid array array chosen recommended third-party raid array solution primary customers autoraid product clariion supports connection host fast-wide differential scsi channels single channel bottleneck system array configured raid results raid qowj raid set directly connected individual disk drives solution data redundancy hp-ux logical volume manager jnak lvm stripe data disks chunks unlike autoraid qqq raid array disks central controller controller-level cache refer naj configuration jbod-lvm bunch disks performance results begin presenting database macrobenchmarks order demonstrate autoraid ffzg excellent performance real-world workloads workloads exhibit behaviors burstiness present simple rate tests relying provide misleading impression system behave kol real acm transactions computer systsms vol krg february john wilkes macrobenchmarks oltp database workload made medium-weight transactions run autoraid array regular raid array jbod-lvm jdx database test syi allowed fit mgz mirrored storage autoraid working-set sizes larger mirrored space discussed benchmark raid array disks spread evenly scsi qfubv channels cache enabled cache page size set optimal workload hmo default stripe-unit cqzb size ekvw nyk figure shows result autoraid significantly outperforms raid array performance yak threefourths jbod-lvm results suggest autoraid performing expected keeping data mirrored storage means writes faster raid array fast jbod-lvm reads handled equally cases figure sdf shows autoraid performance data migrated mirrored storage lmt raid working set large contained mirrored storage class type oltp database workload azc database size set lgb fit -drive autoraid system started -drive system baseline mirrored storage accommodate one-third database case two-thirds -drive system -drive system larger systems differences performance -drive systems due primarily differences number migrations performed differences larger systems result spindles spread amount mirrored data -drive configuration limited host cpu speed performed n-drive system data database workload fairly random access pattern large data set autoraid performs factor optimum one-third data held mirrored storage threefourths optimum two-thirds data mirrored microbenchmarks addition database macrobenchmark ran microbenchmarks synthetic workload generation program drive arrays saturation working-set size random tests measurements slightly conditions reported section autoraid contained controller data cache host tests single fast-wide differential scsi channel autoraid raid array tests jbod case lvm striping nature workload immaterial addition jbod disks match amount space data configurations finally jbod test acm transactions computer systems vol february autoraid raid array autofiaid jbod-lvm fig oltp macrobenchmark results comparison autoraid non-raid drives regular raid array system drives entire database tit mirrored storage autqraid performance autoraid numbers drives fraction lgb database held mirrored storage -drive system -drive system -drive system larger systems numberof drives fast-wide single-ended scsi card required host cpu cycles affect microbenchmarks cpu limited raid array cache pages cache noted data microbenchmarks provided figure shows relative performance arrays jbod random sequential reads writes random read-throughput testis primarily measure controller overheads autoraid performance roughly midway raid array cache disabled jbod cachesearching algorithm raid array significantly limiting performance cache hit rate close tests random write-throughput test primarily test low-level storage system systems driven disk-limited acmtransactionson computersystems vol february john wilkes l-l autoraid raid raid jbod cache random reads autoraid raid fiaid jbod nocache sequential reads aijioraid raid raid jbod nocache random writes autoraid raid raid jbod nocache sequential writes fig microbenchmark companions autoraid aregular raid array non-raid drives behavior benchmark expected ratio raid small update autoraid mirrored storage jbod write place sequential read-bandwidth test shows mirrored storage autoraid largely compensate controller overhead deliver performance comparable jbod finally sequential write-bandwidth test illustrates autor aid ability stream data disk nvram cache performance pure jbod solution good explanation poor performance raid array cases results shown obtained acmtransactions computer systems vol february autoraid number array configurations results demonstrated difficulties involved properly conf ring raid array parameters adjusted caching cache granularity stripe depth data layout single combination performed range workloads examined thrashing noted section performance autoraid depends working-set size applied workload working set size mirrored 
space performance good shown figure figure figure shows good performance obtained entire working set fit mirrored storage active write working set exceeds size mirrored storage long periods time drive autoraid array thrashing mode update target promoted mirrored storage class demoted raid autoraid array configured avoid adding disks write-active data mirrored storage ail data write active cost-performance advantages technology reduced fortunately fairly easy predict detect environments large write working set avoid thrashing occur autoraid detects reverts mode writes directly raid automatically adjusts behavior performance worse raid simulation studies section illustrate design choices made inside autoraid implementation trace-driven simulation study simulator built pantheon cao gelding simulation framework detailed trace-driven simulation environment written individual simulations configured set simulation objects scripts written tcl language ousterhout configuration techniques gelding disk models simulation improved versions detailed calibrated models ruemmler wilkes traces drive simulations variety systems including cello time-sharing series hp-ux system snake series hp-ux cluster file server oltp series hp-ux system running database benchmark made medium-weight transactions system section hplajw personal workstation netware server subsets traces usr disk cello subset database disks oltp oltp log disk long time periods months lthe simulator called tickertaip changed avoid confusion parallel raid array project cao acm transactions computer systems vol february john wilkes simulation runs two-day subsets traces netware trace contained detailed timing information resolution considerable detail ruemmler wilkes modeled hardware autoraid pantheon components caches buses disks wrote detailed models basic firmware alternative algorithms policies design experiments pantheon simulation core comprises lines lines tel hp-autoraid-specific portions simulator added lines lines tel complexity model number parameters algorithms policies examining impossible explore combinations experimental variables reasonable amount time chose organize experiments baseline runs runs related baseline allowed observe performance effects individual closely related changee perform wide range experiments quickly cluster high-performance workstations run simulations executing experiments week elapsed time performed additional experiments combine individual suspected strongly interact positively negatively test aggregate effect set algorithms proposing product development team hardware implementation aut aid early simulation study initially unable calibrate simulator disk models high level detail simulation confident relative performance differences predicted simulator valid absolute performance numbers calibrated relative performance differences observed simulation experiments suggest improvements team implementing product firmware present turn updated baseline model correspond made implementation individual results report chosen describe highlight behaviors autor aid system disk speed experiments measured sensitivity design size performance components wanted understand faster disks cost effective baseline disks held spun rpm evaluated variations disk spinning rpm rpm keeping data density bite inch transfer rate bits constant expected increasing back-end disk performance generally improves performance shown figure results suggest improving transfer rate important improving rotational latency acm transactions computer systems vol february autoraid snake const density const bit rate const density const bit rate oltpdb const density corrstbit rate crest density mnst bit rate onp-log const density const bit rate const density const bit rate cello-usr const density const bit rate const density const bit rate percent improvement versus rpm disks disk spin speed snake -db oltp-log cello-usr percent fmprovemenf versus size fig effects disk spin speed size performance acm transactions computer systems vol february john wilkes size standard autoraid system rbs basic storage unit looked effect smaller larger sizes workloads figure size balance seek rotational overheads versus data movement costs surprising disks track sizes transfer sizes range tend benefit fewer mechanical delays data layout system blocks remapped blocks host system lay sequentially physically discontinuous bad problem compared performance system host lun address spaces initially laid completely linearly disk case completely randomly worst case figure shows difference layouts modest improvement performance linear case compared random suggests size large limit impact seek delays sequential accesses mirrored storage class read selection algorithm front-end read cache misses stored mirrored storage class array choose read stored copies baseline system selects copy random attempt avoid making disk bottleneck possibilities strictly alternating disks alternate attempting heads disks outer edge keeping inside outer disk shortest queue shortest queue disk reach block determined shortestpositioning-time algorithm jacobson wilkes seltzer shortest seek policies stacked aggressive policy falling back break tie experiments random final fallback policy figure shows results investigations possibilities shortest queue simple load-balancing heuristic performance improved average random workloads shortest seek performed random average complex implement requires detailed knowledge disk head position seek timing static algorithms alternate innertouter perform random interact unfavorably patterns workload decrease system performance acm kanaactions computer systems vol february autoraid snake oltp-db oltp-log cello-usr percent improvement sequerttjal ayout snake altarnate innerlouter shortest queue shortast seek shortest queue alternate innarloutar shortastqueue shorlest seek shorleat seek queue lemaite innerlwter shcftast queue shortest seek shortestw rqueue alternate outer shortest quaue shortest seek shortest seek queue versus random layout data layout percent improvement vecsusrandom read disk selection policy fig effects data layout mirrored storage clasa read diek selection policy performance acm transactions computer systems vol february john wilkes snake fig effect ofallowing writ ecache overwrites performance note passing differences show microbenchmarks type reported figure disks typically driven saturation effects show write cache overwrites investigated policy choices managing nvram write cache baseline system instance write operation overwrite dirty data cache write block previous dirty data cache flushed disk figure shows allowing overwrites noticeable impact workloads huge impact oltp-log workload improving performance factor omitted workload graph scaling reasons hole-plugging demotion rbs typically written raid reasons demotion mirrored storage garbage collection normal operation system creates holes raid promoting rbs mirrored storage class order space consumption constant system demotes rbs raid default configuration autdtaid logging writes demote rbs raid quickly demotion idle time demotions fill holes left promoted rbs reduce work raid cleaner allowed rbs demoted idle periods written raid hole-plugging optimization reduced number rbs moved raid cleaner acmtransactionson computer systems vol february autoraid cello-usr workload snake improved time user summary autoraid technology works extremely providing performance close nonredundant disk array workloads time full data redundancy tolerate failures single array component easy authors article delivered system manuals day demonstration running trial benchmark minutes afl connected completely unmodified workstation product team experiences demonstrating system potential customers autoraid technology panacea storage problems workloads suit algorithms environments variability response time unacceptable nonetheless adapt 
great environments encountered real life outstanding general-purpose storage solution availability matters product based technology xlr advanced disk array acknowledgments colleagues hps storage systems division developed autoraid system architecture product version controller customers performance algorithm studies people put enormous amounts effort making pro success possibly acknowledge directly chris ruemmler wrote benchmark results section article dedicated memory late colleague kondoff helped establish collaboration produced body work akyurek salem adaptive block rearrangement tech rep cs-trdept computer science univ maryland college park bakkr asami deprit ousterhout andseltzer non-volatile memory fast reliable file systems proceedings international conference architectural support programming languages operating systems cornput arch news oct blackwell harris andseltzer heuristic cleaning algorithms log-structured tile systems proceedings usenix technical conference unix aduanced computing systems usenix assoc berkeley calif burkes dlamond andvoigt adaptive hierarchical raid solution raid write problem part hewlett-packard storage systems division boise idaho acm transactions computer systems vol february john wilkes burrows jerjan lampson iklwni on-line data compression log-structured file syetem proceedings zntemationnl conference architectuml support progmmming languages opemting systems comput arch news oct cao lim veiwwtaraman andwilkes tickertaip parallel raid architecture acm tmns comput syst aug carson seiy optimal write batch size log-structured file systems usenzx workshop file systems usendc assoc berkeley calif cate levels file system hierarchy disk tech rep cmu-cs- dept computer science carnegie-mellon univ pittsburgh chao english jacobson stepanov wilkes mime high performance storage device strong recovery guarantees tech rep hpl- hewlettpackard laboratories palo alto calif chen optimal file allocation multi-level storage hierarchies proceedings national computer conference exposition afips conference promedings vol afips press montvale chen andlee striping raid leveldisk array tech rep cse-tr- univ michigan ann arbor mich chen lee gibson katz pattrrson raid high-performance reliable secondary storage acm comput surv june clegg kusmer andsontag hp-ux operating system precision architecture computers hewlett-packard dec cohen king andbrady storage hierarchies ibm syst dec polycenter storage management openvms vax systems digital equipment corp maynard mass jonge kaashoek andhsieh logical disk approach improving file systems proceedings tlw acm symposium opemting systems principles acm york deshpande andbunt dynamic file management techniques proceedings ieee phoenix conference computers communication ieee york dunphy wmsh bowers andrudeseal disk drive memory patent patent office washington english andstepanov loge self-organizing storage device proceedingsof lysl lnfxwinter technical conference usenik assoc berkeley calif epochsystems mass storage server puts optical discs line workstations electronics nov ewing raid overview part storage technology corp louisville colo vzi http stortek storagetek raid htrnl floyd andschlatterellis directory patterns hierarchical file systems ieee trms knqwl data eng june geist reynolds andsuggs minimizing seek distance mirrored disk systems cylinder remapping perf eual gels system managed storage ibm syst gcmnng staelin sullivan andwilkes tel cures simulation configuration problems claims astonished researcher proceedings tcl workshop tech rep hpl-ccd- concurrent computing dept hewlettpackard laboratories palo alto calif golding bosch staelin sullivan andwilkss idleness sloth proceedings usenix technical conference unix advanced computing systems usenix assoc berkeley calif gray census tandem system availability tech rep tandem computers cupertino calif acm transactions computer systems vol february autoraid hen erson powon mssand rash mainframe unix based mass storage system rapid access storage hierarchy tile management system proceedings usenix winter conference usenix assoc berkeley calif holmnd andgibson parity declustering continuous operation redundant disk arrays proceedings international conference architectural support programming atgua ges operating systems comput arch news oct jacobson andwilkes disk scheduling algorithms based rotational position tech rep hpl-csp- hewiett-packard laboratories palo alto calif katz andeiwdn ousterhout patterson robo-line storage low-latency high capacity storage systems geographically distributed networks csd computer science div dept electrical engineering computer science univ california berkeley berkeley calif kohl staelin anrrstonebraicsr highlight log-structured file system tertiary storage management proceedings winter usenly usenfx assoc berkeley calif lawlor efficient mass storage panty recovery mechanism ibm tech discl bull july majumdar locality file referencing behaviour principles applications thesis tech rep dept computer science univ saskatchewan saskatmn saskatchewan canada mcdonald bunt improving tile system performance dynamically restructuring disk space proceedings phoenix conference computers communica tion ieee york mcnu background data movement log-structured disk subsystem ibm res devel menon courtney architecture fault-tolerant cached raid controller proceedings international symposium computer architecture acm york menon kassori methods improved update performance disk arrays tech rep ibm almaden research center san jose calif declassified nov menon andkasson methods improved update performance disk arrays proceedings international conference system sciences vol ieee york menon mattson comparison sparing alternatives disk arrays proceedings international symposium computer architecture acm york mill file migration cray y-mp national center atmospheric research ucb csd computer science div dept electrical engineering computer science univ california berkeley berkeley calif mwra capacity analysis mass storage system ibm syst kitsuregawa dynamic parity stripe reorganizations raid disk arrays proceedings parallel distributed information systems international conference ieee york ousterhout doum beating bottleneck case log-structured tile systems oper syst reu jan ousterhol tcl toolkit addison-wesley reading mass park balasumi anmnmn providing fault tolerance parallel seconda storage systems tech rep cs-tr- dept computer science princeton univ princeton pati rson chen gibson katz introduction redundant arrays inexpensive disks raid xnaq spring compcon ieee york pattkrson ykt gibson katz case aid redundant arrays inexpensive disks raid proceedings acm sigmod international conference qogv managemen data acm york acm transactions computer systems vol february john wilkes rosenblum andousterhout design uxr implementation log-stmctured file system acm trans opt comput syst feb ruemmler andwilkes disk shuffling tech rep hpl- nst hewlett-packard laboratories palo alto calif ruemmler andwilkes unix disk access patterns lio proceedings winter usenix conference usenix assoc berkeley calif ruemmler andwilkes vxl introduction disk rlw drive modeling ieee comput mar scsi draft proposed american national standard information systems-small computer system interfacescsi- lhft ansi standard revision secretariat computer business equipment manufacturers association seltzer bostic mckusick staelin implementation iog-stnctured tile system unix proceedings winter usenix conference usentx assoc berkeley calif seltzer chen andousterhout disk scheduling revisited proceedings winter usenix conference usenix asscw berkeley calif seltzer smith balakrishnan chang mcmains andpadmanarhan file system logging versus clustering performance comparison conference proceedings usenix technical conference unix advanced computing systems usenix assoc berkeley calif sienknecht friedrich martinka qpr friedenrach implications ildso distributed data commercial environment design hierarchical storage management per-f eual smith cpsy optimization systems cache hbh disks file migration summary perf eval 
stk iceberg rgj disk array subsystem storage technology corp misville colo xzfl http stortek storagetek iceberg html taunton compressed executable ufuz exercise thinking small proceedings summer usenzx usenix assoc berkeley calif received september revised october accepted october acm transactions jlhr computer systems vol february 
vzw opb fmt pje kbd dhg agv izx qvw uci jiyk gpu tpocw zca umf ogf ago llh yps x-mj euj iyqo yca bae vmk wvl xai k-e rre fhv gtksf xlg xum loi empb ifj bkj gpy ztrvb gqqzp ovp znz nqg mhoi jojthzh uvb cje uli hyf mbh kuf fyd omm wwg aboq wqn wwugey i-p tbj emd obi ede qzm qaf prp overview singularity project galen hunt james larus mart abadi mark aiken paul barham manuel hndrich chris hawblitzel orion hodson steven levi nick murphy bjarne steensgaard david tarditi ted wobber brian zill microsoft research microsoft redmond http research microsoft singularity microsoft research technical report msr-tr- abstract singularity research project microsoft research started question software platform designed scratch primary goal dependability singularity working answer question building advances programming languages tools develop system architecture operating system named singularity aim producing robust dependable software platform singularity demonstrates practicality technologies architectural decisions lead construction robust dependable systems report snapshot project motion performance measurements preliminary subject improvement contact galen hunt galenh microsoft jim larus larus microsoft check http research microsoft singularity latest results citation information mart abadi affiliated computer science department california santa cruz paul barham microsoft research cambridge mart abadi nick murphy ted wobber microsoft research silicon valley fortunate great group interns made contributions project past couple years michael carbin fernando castor adam chlipala jeremy condit daniel frampton chip killian prince mahajan bill mccloskey martin murray martin pohlack tom roeder avi shinnar mike spear yaron weinsberg aydan yumerefendi introduction software runs platform evolved past years increasingly showing age platform vast collection code operating systems programming languages compilers libraries run-time systems middleware hardware enables program execute hand platform enormous success financial practical terms platform forms foundation billion dollar packaged software industry enabled revolutionary innovations internet hand platform software running robust reliable secure users developers part problem current platform evolved computer architectures operating systems programming languages computing environment period today milieu computers extremely limited speed memory capacity small group technically literate non-malicious users rarely networked connected physical devices characteristics remains true modern computer architectures operating systems programming languages evolved accommodate fundamental shift computers singularity research project microsoft research started question software platform designed scratch primary goal dependability common goal performance singularity working answer question building advances programming languages programming tools develop build system architecture operating system named singularity aim producing robust dependable software platform dependability difficult measure research prototype singularity shows practicality technologies architectural decisions lead robust dependable systems future exponential rate progress hardware evolution commonly appears drive fundamental systems applications software glacial progress rarely creates opportunities fundamental improvements software evolve change makes rethink assumptions practices advances programming languages run-time systems program analysis tools provide building blocks construct architectures systems ctzh dependable robust existing systems expressive safe programming languages java type safety ensures object correctly interpreted manipulated memory safety ensures program memory bounds valid live objects optimizing compilers high performance run-time kcn systems generate safe code runs speeds comparable unsafe code compilers jkf unlike common just-in-time jit compilers perform global optimizations mitigate safetyrelated overhead garbage collectors systems reclaim memory overhead comparable loh explicit bjc deallocation scl term aef dependability reliability ifip dependable computing fault tolerance qar defines terms bbhz notion dependability defined trustworthiness computing system reliance justifiably service delivers enables concerns subsumed single conceptual framework dependability includes special cases attributes reliability availability safety security validation techniques ensure end-to-end type safety compiler compiled code run-time system typed intermediate assembly language validate proper operations bzu system components ensure language safety guarantees underlie system correctness sound specification-driven defect detection tools ensure correctness aspects ddck olm oyi npa system sound tool finds occurrences error false positives reliably defect eliminated specification-driven tools hardwired collection defects extensible adapted check program library-specific abstractions correctly languages tools based advances detecting preventing programming errors explored mechanisms enable deep system architecture turn szq advance ultimate goal preventing ajh mitigating software defects rest paper describes singularity system detail section overview system aspects section describes singularity system architecture focusing kernel processes hxr language run-time system section describes programming language support system section describes security system section performance benchmarks section surveys related work appendix list kernel abi calls singularity singularity operating system developed basis dependable system application software singularity exploits advances programming languages tools create environment software built correctly program behavior easier fky verify run-time failures contained key aspect singularity extension model based uqo software-isolated processes sips encapsulate pieces application -be gls qryj system provide information hiding failure isolation strong interfaces sips operating system application software building system abstraction lead dependable software sips processes singularity izv code kernel executes sip sips differ conventional operating system processes number ways sips closed object spaces address spaces singularity processes simultaneously access object communications processes transfers exclusive ownership data sips closed code spaces process dynamically load generate code sips rely memory management hardware isolation lng multiple sips reside physical virtual address space communications sips -oo bidirectional strongly typed higher-order channels channel specifies communications protocol values transferred aspects verified sips inexpensive create communication sips incurs low overhead low cost makes practical sips fine-grain isolation extension mechanism sips created terminated operating system termination sip resources efficiently fiod bme ztv reclaimed sips executed independently extent data layouts run-time systems garbage ktx collectors sips encapsulate application extensions hqt singularity single mechanism protection extensibility conventional dual mechanisms processes mme dynamic code loading consequence singularity error recovery model communication mechanism security nfr policy ldd programming ozu model layers partially redundant mechanisms policies current jfr systems key experiment singularity construct entire operating opu fbu system sips demonstrate resulting system dependable conventional system singularity kernel consists safe code rest system executes sips consists verifiably safe code including device drivers system processes applications untrusted code verifiably safe parts singularity kernel run-time system called trusted base verifiably jtq safe language safety protects trusted base untrusted code integrity sips yciy depends language safety system-wide invariant process hold process object space ensuring code safety essential short term singularity relies compiler verification source intermediate code vfx future typed assembly language tal singularity verify fbv safety compiled code tal requires adp program zme executable supply proof type safety produced automatically kdsm compiler safe language yjsd verifying proof correct applicable instructions executable straightforward task simple verifier wfw r-b thousand lines code end-to-end verification strategy eliminates compiler large complex program singularity trusted base verifier carefully designed implemented checked tasks feasible size simplicity memory independence invariant prohibits cross-object space pointers serves purposes enhances data abstraction failure isolation process hiding implementation details preventing dangling pointers terminated processes relaxes implementation constraints allowing processes run-time systems garbage collectors run coordination clarifies resource accounting reclamation making unambiguous process ownership piece memory finally simplifies kernel interface eliminating manipulate multiple types pointers address spaces major objection architecture difficulty communicating message passing compared flexibility directly 
sharing data singularity addressing problem efficient messaging system programming language extensions concisely communication channels verification tools extensibility software creators rarely anticipate full functionality demanded users system application satisfy monolithic system non-trivial software mechanisms load additional code microsoft windows supports party device drivers enable control hardware device similarly countless browser add-ons extensions augment browser interface components web pages open source projects theoretically modifiable provide plug-in mechanisms extensions easier develop distribute combine versions software extension consists code dynamically loaded parent address space direct access parent internal interfaces data structures extensions provide rich functionality flexibility high cost extensions major software reliability security backward compatibility problems extension code untrusted unverified faulty malicious loaded directly program address space hard interface boundary distinction host extension outcome unpleasant swift reports faulty device drivers diagnosed windows system crashes extension lacks hard interface unexposed aspects parent implementation constrain evolution program require extensive testing avoid incompatibilities dynamic code loading imposes obvious tax performance correctness software load code open environment impossible make sound assumptions system states invariants valid transitions java virtual machine jvm interrupt exception thread switch invoke code loads file overwrites class method bodies modifies global state general feasible analyze program running conditions start unsound assumption environment change arbitrarily operations alternative prohibit code loading isolate dynamically created code environment previous attempts lines widely popular isolation mechanisms performance programmability problems made appealing risks running isolation common mechanism traditional process high costs limit usability memory management hardware hard boundaries protects processor state makes inter-process control data transfers expensive processor switching processes cost hundreds thousands cycles including tlb cache refill misses recent systems java virtual machine microsoft common language runtime clr designed extensibility language safety hardware mechanism isolate computations running address space safe languages guarantee isolation shared data provide navigable path computations object spaces point reflection mechanisms subvert data abstraction information hiding consequence systems incorporate complex security mechanisms policies java fine grain access control clr code access security limit access system mechanisms interfaces mechanisms difficult properly impose considerable overhead equally important computations share run-time system execute process isolated failure computation running jvm fails entire jvm process typically restarted difficult isolate discard corrupted data find clean point restart failed computation singularity sips encapsulate device driver system process application extension runs sip communicates channels provide limited functionality code sip fails terminates system reclaim resources notify communication partners partners share state extension error recovery local facilitated explicit protocols channels run-time source code dynamic code generation commonly encapsulated reflection interface feature running program examine existing code data produce install methods reflection commonly produce marshalling code objects parsers xml schemas singularity closed sips run-time code generation singularity compile-time reflection ctr similar functionality executes file compiled normal reflection access runtime values general ctr cases class marshaled schemas parsed ahead execution cases ctr produces code compilation cases singularity support mechanism generating code running separate sip application abstraction operating systems treat programs applications first-class abstraction modern application collection files code data metadata untrusted agent installs copying pieces file system registering namespaces system largely unaware relationships pieces control installation process well-known consequence adding removing application break unrelated software singularity application consists manifest collection resources manifest describes application terms resources dependencies existing setup descriptions combine declarative imperative aspects singularity manifests declarative statements describe desired state application installation update process realizing state singularity responsibility manifest provide information singularity installer deduce installation steps detect conflicts existing applications decide installation succeeded singularity prevent installations impair system aspects singularity utilize information manifest singularity security model introduces applications security principal enables application entered file access control lists acl treating application principal requires knowledge application constituent pieces dependencies strong identity manifest discussion key contributions singularity construction system application model called software-isolated processes verified safe code implement strong boundary processes hardware mechanisms sips cost create schedule system applications support finer isolation boundaries stronger isolation model consistent extension model system applications simplifies security model improves dependability failure recovery increases code optimization makes programming testing tools effective fast verifiable communication mechanism processes system preserves process independence isolation enables process communicate correctly low cost language compiler support build entire system safe code verify interprocess communications explicit resource management elimination distinction operating system safe language run-time system java jvm microsoft clr pervasive specifications system describe configure verify components rest paper organized section describes implementation singularity system detail section discusses programming language compiler support singularity section describes singularity system services section performance measurements section discusses related work section concludes singularity architecture figure depicts architecture singularity built key abstractions kernel software-isolated processes channels kernel core functionality system including memory management process creation termination channel operations scheduling microkernels system functionality extensibility exist processes kernel trusted base code singularity verified trusted verified code type memory safety checked compiler unverifiable code trusted system limited hardware abstraction layer hal kernel parts run-time system kernel verifiably safe portions written assembler unsafe code written safe language translated safe microsoft intermediate language msil compiled bartok compiler trust bartok correctly verifies generates safe code unsatisfactory long run plan typed assembly language verify output compiler reduce part trusted computing base small verifier msil cpu-independent instruction set accepted microsoft clr singularity standard msil format features specific singularity expressed metadata extensions msil microkernel runtime kernel class library page mgr mgr scheduler channel mgr figure singularity architecture application runtime clr class library file sys runtime file sys library disk driver runtime driver class library extension runtime clr class librar dividing line types code blurred run-time system trusted unverifiable code effectively isolated computation verified safety prevents interacting run-time system data structures safe interfaces singularity compiler in-line routines safely moving operations traditionally run kernel user process kernel singularity kernel privileged system component controls access hardware resources allocates reclaims memory creates schedules threads intraprocess thread synchronization manages written mixture safe unsafe code runs garbage collected object space addition usual mechanism message-passing channels processes communicate kernel strongly versioned application binary interface abi invokes static methods kernel code interface design rest system isolates kernel process object spaces parameters abi values pointers kernel process garbage collectors coordinate exception location abi methods garbage collectors relocate code maintain invariant methods remain addresses abi maintains system-wide state 
isolation invariant process alter state process abi exceptions abi call affects state calling process exceptions alter state child process executes execution call create child process specifies code loaded child begins execution call stop child process reclaims resources threads cease execution state isolation ensures singularity process sole control state handle table kernel exports synchronization constructs mutexes auto manual reset events coordinate threads process thread manipulates constructs strongly typed opaque handle points kernel handle table strong typing prevents process changing forging handles addition slots handle table reclaimed process terminates prevent process freeing mutex retaining handle manipulate process object singularity reuse table entries process case retaining handle benign painful error process exchange heap figure exchange heap abi versioning kernel abi strongly versioned explicitly identifying abi version information program singularity clear path system evolution backward compatibility code process compiled compiled abi interface assembly namespace explicitly specifies version microsoft singularity threads namespace thread-related functionality version abi process source code names specific namespace desired version abi process binary code explicit metadata specific version abi install time program installed version abi supported target machine abi interface assembly replaced implementation assembly process-side implementation version abi system version kernel simplest implementation turns run-time calls kernel abi direct invocations static kernel method newer singularity system populate namespace earlier version library compatibility functions alternatively compatibility code run kernel kernel easily support multiple abi implementations distinct namespaces version kernel abi entry points appendix lists methods abi scheduler singularity supports compile-time replaceable scheduler implemented scheduler rialto scheduler multi-resource laxity-based scheduler round-robin scheduler implemented degenerate case rialto scheduler minimum latency round-robin scheduler minimum latency round-robin scheduler optimized large number threads communicate frequently scheduler maintains lists runable threads called unblocked list threads recently runable called preempted list runable threads pre-empted choosing thread run scheduler removes threads unblocked list fifo order unblocked list empty scheduler removes thread preempted list scheduling timer interrupt occurs threads unblocked list moved end preempted list thread running timer fired thread unblocked list scheduled scheduling timer reset net effect list scheduling policy favor threads awoken message small amount work send messages processes block waiting message common behavior threads running message handling loops avoid costly reset scheduling timer threads unblocked list inherit scheduling quantum thread unblocked combined two-list policy quantum inheritance effective singularity switch thread cycles processes singularity system lives single virtual address space virtual memory hardware protect pages mapping address space trap null pointer singularity system address space logically partitioned kernel object space object space process exchange heap channel data pervasive design decision memory independence invariant cross-object space pointers point exchange heap kernel pointers process object space process pointer process objects invariant ensures process garbage collected terminated cooperation processes kernel creates process allocating memory sufficient load executable image file stored microsoft portable executable format singularity performs relocations fixups including linking kernel abi functions kernel starts process creating thread running image entry point trusted thread startup code calls stack page manager initialize process process obtains additional address space calling kernel page manager returns unshared pages pages adjacent process existing address space garbage collectors require address space contiguous contiguous regions large objects arrays addition memory holds process code heap data process stack thread access exchange heap stack management singularity linked stacks reduce memory overhead thread stacks grow demand adding non-contiguous segments singularity compiler performs static interprocedural analysis optimize placement overflow tests compiler-inserted checks trusted code accesses system data structures residing process object space determine amount space remaining current stack segment running thread pushes stack frame potentially overflow current stack segment trusted code calls kernel method disable interrupts invokes page manager allocate stack segment code initializes stack frame segment running procedure callee call segment unlink routine deallocate segment stack popped processes run ring current stack segment leave room processor save interrupt exception frame handler switches dedicated interrupt stack exchange heap exchange heap underlies efficient communication singularity holds data passed processes figure exchange heap garbage collected counts track usage blocks memory called regions process accesses region structure called allocation allocations reside exchange heap enables passed processes owned accessible single process time allocation share read-only access underlying region allocations base bounds provide distinct views underlying data protocol processing code network stack strip encapsulated protocol headers packet copying region tracks number allocations point deallocated count falls singularity compiler hides extra level indirection allocation record strongly typing region automatically generating code dereference record threads process create additional threads untrusted verified code running process creates thread object initializes supplied function stores object unused slot run-time system thread table code invokes threadhandle create passing thread table index kernel method creates thread context hold registers allocates initial stack frame updates data structures returns process runtime calls threadhandle start schedule thread thread starts executing kernel running code calls process entry point passing thread index run-time thread table process startup code invokes function thread object starts thread execution process thread creation kernel aware address process thread startup code process entry point kernel abi methods relocated garbage collection garbage collection essential component safe languages prevents memory deallocation errors subvert safety guarantees singularity kernel processes object spaces garbage collected large number garbage collection algorithms experience strongly suggest garbage collector system application code singularity architecture decouples algorithm data structures execution process garbage collector selected accommodate behavior code process run global coordination aspects singularity make process closed environment run-time support pointers cross process kernel boundaries collectors cross-space pointers messages channels objects agreement memory layout messages data exchange heap kernel controls memory page allocation nexus coordinating resource allocation singularity run-time systems support types collectors generational semi-space generational sliding compacting adaptive combination previous collectors mark-sweep concurrent mark-sweep system code short pause times collection collector thread segregated free list eliminates thread synchronization normal case garbage collection triggered allocation threshold executes independent collection thread marks reachable objects collection collector stops thread scan stack introduces pause time microseconds typical stacks overhead collector higher non-concurrent collectors simpler non-concurrent marksweep collector applications sip collector solely responsible collection objects object space garbage collector perspective thread control enters leaves application kernel treated similarly call call-back native code conventional garbage collected environments garbage collection object spaces scheduled run 
completely independently application employs stop-theworld collector thread considered stopped respect application object space run kernel object space due kernel call thread stopped return application process space duration collection stack management garbage collected environment thread stack object potential roots collector calls kernel executed user thread stack store kernel pointers stack sight appears violate memory independence invariant creating cross-process pointers entangles user kernel garbage collections avoid problems singularity delimits boundary space stack frames garbage collector space cross-domain process kernel kernel process call singularity saves callee-saved registers special structure stack demarks crossdomain call structures mark boundary stack regions belong object space calls kernel abi pass object pointers garbage collector skip frames space delimiters facilitate terminating processes cleanly process killed threads stopped kernel throws exception skips deallocates process stack frames channels singularity processes communicate exclusively sending messages channels bidirectional behaviorally typed connection processes messages tagged collections values message blocks exchange heap transferred sending receiving process channel typed contract specifies format messages valid messages sequences channel section process creates channel invoking contract static newchannel method returns channel endpoints asymmetrically typed exporter importer output parameters exp importch imp exportch newchannel importch exportch process pass endpoints processes existing channels process receiving endpoint channel process holding endpoint application process communicate system service application creates endpoints sends request endpoint system server forwards endpoint service establishing channel process service send channel asynchronous receive synchronously blocks specific message arrives language features thread wait set messages channel wait specific sets messages channels data channel ownership passes sending process retain message receiving process ownership invariant enforced language run-time systems serves purposes prevent sharing processes facilitate static program analysis eliminating pointer aliasing messages permit implementation flexibility providing message-passing semantics implemented copying pointer passing channel implementation channel endpoints values transferred channels reside exchange heap endpoints reside process object space passed channels similarly data passed channel reside object space violate memory independence invariant message sender passes ownership storing pointer message receiver endpoint location determined current state message exchange protocol approach naturally copy implementations stack disk buffers network packets transferred multiple channels protocol stack application process copying customized run-time systems singularity architecture permits sips host completely run-time systems runtime customized process sips running sequential code support thread synchronization required sips multiple threads sips objects requiring finalization finalizers access data shared threads separate finalizer observe required language semantics finalizers sips allocation strategies pre-allocate stack-allocate memory objects obviating garbage collector sips runtime discussion safe programming languages offer advantages building reliable analyzable software immune low-level security exploits plague code practical benefits safe languages increasing popularity conventional operating systems offer special support safe programs benefit properties singularity contrast starts premise language safety builds system architecture supports enhances language guarantees singularity integrates language run-time system operating system processes safe system processes support distinct virtual machine jvm clr redundant simple approach providing homogeneous run-time system clr processes imposes unnecessary penalties services programs behavior match runtime system properties language runtimes provide services notably garbage collection interact poorly programs generational garbage collector introduce seconds-long pauses program execution disrupt media player operating system hand real-time collector suitable media player penalize computational task homogeneous environments evolve large complex expensive systems support union requirements application depends singularity supports heterogeneous execution environments process runtime system memory layout garbage collection algorithm libraries memory independence runtime tailored meet computation process garbage collector selected algorithm data structure layout awareness coordination counterparts processes heterogeneous environments provide mechanism enforce policy contents environment process circumscribe behavior device drivers run sparse environment primarily driver-specific abstractions ioports tailored class program abstractions unnecessary inappropriate drivers environment policy untrusted applications run environment security automata validate control program behavior singularity built offers model safely extending system application functionality model extensions access parent code data structures self-contained programs run independently approach increases complexity writing extension parent program developer define proper interface rely shared data structures extension developer program interface possibly re-implement functionality parent widespread problems inherent dynamic code loading argue alternatives increase isolation extension parent singularity mechanism works applications system code depend semantics api unlike domainspecific approaches nooks simple semantic guarantees understood programmers tools principal arguments singularity extension model center difficulty writing message-passing code hope programming models languages make programs type easier write verify modify advances area generally beneficial message-passing communication fundamental unavoidable distributed computing web services message passing increasingly familiar techniques improve objections programming system common finally singularity memory management hardware processors protection suggests possibility reevaluating hardware general programs functionality memory management hardware embedded systems adequately provisioned workstations servers rarely page memory inexpensive abundant large -bit address spaces reduce multiple address spaces -bit limitations singularity shows safe languages conservative sharing policies supplant process boundaries protection rings lower cost current hardware fully utilized replaced simpler mechanisms fewer performance bottlenecks tlbs singularity benefit memory protection trusted unverified base dma inherently unsafe interfaces device encapsulated virtualized system memory protection dma transfers protect system misdirected dma hardware support segmented stacks reduce compiler complexity run-time overhead mechanism programming language support singularity written sing extension spec language developed microsoft research spec extension microsoft language constructs preand post-conditions object invariants program behavior specifications statically verified boogie verifier checked compiler-inserted run-time tests sing extends language support channels low-level constructs system code developed implemented programming language extensions reasons languages support message-passing communication cases message passing relegated libraries syntactically semantically awkward grafting asynchronous operations synchronous language sing first-class support message-passing communications makes style communication sip abstractions efficient implement palatable programmers integrating feature language aspects program verified singularity constructs communication statically verified channel contracts channel contracts central singularity isolation architecture directly supported sing contract describing simple interaction channel contract message request int requires message reply int message error state start request reply error start contract declares messages request reply error message specifies types arguments contained message request reply single integer error carry values additionally message spec requires clauses restricting arguments messages tagged direction contract written exporter point view request message importer exporter reply error exporter importer qualifier messages travel directions message declarations contract specifies allowable message interactions state machine driven send receive actions state declared considered initial state interaction contract declares single state called start state action request start state export 
side channel receive request message construct reply error specifies exporter sends reply error message part start specifies interaction continues start state looping adinfinitum slightly involved portion contract network stack public contract tcpconnectioncontract message connect uint dstip ushort dstport message ready initial state state start ready readystate state readystate connect connectresult bindlocalendpoint bindresult close closed state bindresult bound invalidendpoint readystate message listen state bound listen listenresult connect connectresult close closed protocol specification contract serves purposes detect programming errors run time static analysis tool run-time monitoring drives contract state machine response messages exchanged channel watches erroneous transitions technique simple implement detects errors program execution detect liveness errors deadlock static program analysis provide stronger guarantee processes correct stuck-free program executions singularity combination run-time monitoring static verification messages channel checked channel contract detects correctness liveness problems static checker verifies safety properties statically ensure deadlock freedom plan verify contracts general static analysis based conformance checking addition singularity compiler contract determine maximum number messages outstanding channel enables compiler statically allocate buffers channel endpoints statically allocated buffers improve communication performance endpoints channels singularity manifest pair endpoints representing importing exporting sides channel endpoint type specifies contract channel adheres endpoint types implicitly declared contract contract represented class endpoint types nested types class imp type import endpoints channels contract exp type export endpoints channels contract send receive methods contract class methods sending receiving messages declared contract methods imp void sendrequest int void recvreply int void recverror exp void recvrequest int void sendreply int void senderror semantics send methods send message asynchronously receive methods block message arrives message arrives error occurs errors occur program passes contract verification check receiver message requires methods sing switch receive statement switch-receive statement code waits reply error message imported endpoint type imp void imp switch receive case reply console writeline reply break case error console writeline error break switch receive statement operates steps block set messages arrive set endpoints receive set messages bind arguments local variables switch receive patterns receive reply endpoint error endpoint case integer argument reply message automatically bound local variable switch receive construct general patterns involve multiple endpoints endpoints receive reply error messages void imp imp switch receive case reply reply console writeline replies break case error console writeline error reply break case error console writeline error reply break case channelclosed console writeline channel closed break illustrates shows wait combinations messages switch receive statement branch reply message received endpoints final case pattern channelclosed special pattern fires channel closed party messages remain received ownership order guarantee memory isolation endpoints data transferred channels blocks exchange heap resources tracked compile time static checks enforce access resources occur program points resource owned methods leak ownership resources tracked resources strict ownership model resource owned thread data structure thread point time endpoint message thread thread ownership endpoint message message receipt simplify static tracking resources pointers resources held directly local variables messages data structures tracked restrictions onerous sing means overcome storing tracked resources indirectly data structures abstraction called tref trefs tref storage cell type tref holding tracked data structure type tref signature class tref itracked public tref claims obj public acquire public void release claims newobj creating tref constructor requires object type argument caller ownership object construction site construction ownership passed newly allocated tref acquire method obtain contents tref tref full returns contents transfers ownership caller acquire tref empty release transfers ownership object caller tref tref full trefs thread-safe acquire operations block tref full trefs represent trade-off static dynamic checking tref incorrect multiple acquires turned deadlocks finalization mechanism garbage collector responsible reclaiming resource exchange heap ownership blocks memory transferred thread process message exchanges singularity allocate track blocks exchanged fashion channel system requires message arguments scalars blocks exchange heap kinds blocks exchange heap individual blocks vectors types written microsoft singularity channels exheap exheap type pointer specifies points struct exchange heap exheap type defined run-time system allocation deallocation support heap type vector exchange heap invariant exchange heap pointers process heap type exchangeable type primitive type int char enum rep struct rep structs simply structs fields exchangeable types endpoints represented individual blocks exchange heap verification verifying code executed singularity type safe satisfies memory independence invariants three-stage process sing compiler checks type safety ownership rules protocol conformance compilation singularity verifier checks properties generated msil code finally back-end compiler produce form typed assembly language enables properties checked operating system argue final stage strictly safety literally true practice programmers benefit finding mistakes early errors explained completely high level redundant verification guards errors verification compile-time reflection closed world sip incompatible reflection facilities integral part java clr environments generate invoke code run time consequence singularity support run-time reflection services compile-time reflection ctr partial substitute clr full reflection capability ctr similar techniques macros binary code rewriting aspects meta-programming multi-stage languages basic idea programs place-holder elements classes methods fields subsequently expanded generator ability produce boiler plate repetitious code template driven inspection existing program structures powerful feature singularity applications device drivers declaratively describe resource requirements ranges service channels startup code theses processes generated automatically descriptions generators written sing transforms transform pattern matching program structure code template build code elements combining enables transform analyzed checked independent code applied errors generating call non-existent method calling wrong type object detected transform respect ctr similar multi-stage languages note ctr transform part trusted computing base emit trusted code untrusted process transform drivertransform iorangetype iorange class drivercategory iorangeattribute iorangetype ioranges public readonly static drivercategory values generate static drivercategory values drivercategory implement private drivercategory ioconfig config ioconfig getconfig tracing log tracing debug config config toprint forall cindex ioranges cindex iorangetype config dynamicranges cindex transform named drivertransform generates startup code device driver declarative declaration driver resources declaration driver describes ioports requirements internal class resources ioportrange default length internal readonly ioportrange baseports ioportrange default length internal readonly ioportrange gameports internal readonly static resources values reflective private resources drivertransform matches class derives elements values field type placeholder private constructor keyword reflective denotes placeholder definition generated transform implement modifier placeholders forward enable code program refer code subsequently produced transform pattern variables transform start signs drivercategory bound resources variable matches element starts signs 
ioranges represents list fields type iorangetype derived iorange types fields order generate code element collections collection fields ioranges templates forall keyword replicates template binding collection resulting code produced transform equivalent class resources static resources values resources private resources ioconfig config ioconfig getconfig tracing log tracing debug config config toprint baseports ioportrange config dynamicranges gameports ioportrange config dynamicranges illustrates code generated transform type checked transform compiled deferring error checking transform applied case macros assignment values verifiably safe type constructed object drivercategory matches type values field singularity system built kernel sips channels language model singularity supports number conventional operating system services system singularity system consists layers hal manager drivers hal small trusted abstraction hardware ioports iodma ioirq iomemory abstractions access devices interfaces timer interrupt controller real-time clock debug console kernel debugging stub event logger interrupt exception vector bios resource discovery stack linking code written assembler assembler portions hal represent approximately trusted code system files singularity kernel manifest create bind device drivers startup kernel plug play configuration system kernel information acquired bios boot loader buses pci bus enumerate devices start device drivers pass drivers objects encapsulate access device hardware driver written safe code runs process drivers communicate parts system including network stack file system exclusively channels driver starts kernel types initialized objects enable driver communicate device objects provide safe interface checks directly accessing hardware memory mapped locations ioport interface device port registers verifies register bounds driver write read-only memory iodma access built-in dma controller legacy hardware ioirqs notify driver hardware interrupt arrives iomemory bounds checked access fixed region memory memory-mapped registers pinned dma unsafe aspect driver-device interface dma existing dma architectures provide memory protection misbehaving malicious driver program dmacapable device overwrite part memory diversity dma interfaces found good abstraction encapsulating anticipate future hardware provide memory protection dma transfers interrupt device serviced kernel masks interrupt signals driver ioirq driver process thread waiting irq event starts processing interrupt re-enables interrupt line kernel abi scheduler runs immediately interrupt handler signals events queue driver configuration singularity system makes extensive metadata describe pieces system explain fit behavior metadata singularity declaratively labels singularity component system application dependencies exports resources tools singularity metadata verify configure application system code system execution singularity system image compound artifact consists kernel device drivers applications sufficient metadata describe individual artifacts manifest declares policy system manifest points manifests describing individual component manifests software boot loader system verifier discover component singularity system singularity system image manifest sufficient enable off-line analysis system goal enable administrator description hardware devices system manifest answer questions system boot hardware drivers services initialize applications run singularity system image metadata describing device drivers metadata singularity maintains invariants singularity install device driver start successfully due resources conflicts driver portion system singularity start device driver run successfully due conflicting missing resource device driver access resources runtime declared metadata specification singularity custom attributes interleave metadata source code source document maintained custom attributes attached program entity class method field declaration compiler passes attributes resulting msil binary compilers linkers installation tools verification tools read metadata encoded attribute msil binary executing code file code shows attributes declare dependencies resource requirements trio video device driver drivercategory signature pci class trioconfig hardware resources pci config iomemoryrange default length iomemoryrange framebuffer fixed hardware resources iofixedmemoryrange base length iomemoryrange textbuffer iofixedmemoryrange base length iomemoryrange fontbuffer iofixedportrange base length ioportrange control iofixedportrange base length ioportrange advanced iofixedportrange base length ioportrange gpstat channels extensionendpoint typeof extensioncontract exp tref extensioncontract exp start iosys serviceendpoint typeof videodevicecontract exp tref serviceprovidercontract exp start video drivercategory signature attributes declare module device driver specific class pci video devices drivercategory denotes category applications implement device drivers specific hardware categories include servicecategory applications implementing software services webappcategory extensions singularity cassini web server iomemoryrange attribute declares framebuffer derived entry device pci configuration space entry discovered hardware configured hardware parameters size memory region compatibile values attribute iofixedmemoryrange iofixedportrange attributes driver fixed range address space memory mapped access fixed ranges ports access device registers extensionendpoint attribute specifies channel contract local endpoint communicate driver parent process case device drivers trio system parent process serviceendpoint attributes declares channel contract local endpoint accept incoming bind requests clients section describes system maps endpoint serviceprovidercontract system namespace compile time compile time compiler transfers custom attributes msil binary msil metadata access library singularity tools parse instruction metadata streams msil binaries link time mkmani tool reads custom attributes create application manifest application manifest xml wscg file enumerating application components exports aty dependencies xml part ucz manifest information trio device driver manifest application identity trio assemblies assembly filename trio exe assembly filename namespace contracts dll version assembly filename meh contracts dll kup version assembly filename corlib dll version assembly filename nce corlibsg dll version assembly filename system compiler runtime jkst dll version assembly hvy filename microsoft singsharp runtime dll version assembly filename ilhelpers dll eepe bkojt version jagop assembly filename singularity ill version assemblies drivercategory device signature pci iomemoryrange index baseaddress rangelength iomemoryrange baseaddress rangelength fixed mcy true iomemoryrange baseaddress rangelength fixed true ioportrange baseaddress rangelength fixed true ioportrange baseaddress rangelength fixed true ioportrange baseaddress rangelength fixed true extension startstateid contractname microsoft singularityextending jvt gjt extensioncontract endpointend exp assembly rxhe namespace contracts serviceprovider startstateid contractname eciadj microsoftsingularity videodevicecontract endpointend exp assembly contracts drivercategory manifest installation time section application class abstraction singularity run tpu piece code added system singularity installer installer fwy starts metadata application manifest installer verifies application assemblies exists type qvh memory safe pju verifies channel contracts implemented correctly assembly dependencies dependencies kernel abi resolved mam correctly theses internal properties resolved verified installer attempts fenq resolve verify external dependencies install ensures hardware resources device driver conflict hardware resources required k-p kkb driver installer verifies existence type channel zke application tvc application exports channel installer verifies exported channel conflict application conflicts arise policy system manifest resolves manifest declare device driver provide video console contract installation additional video drivers disallowed single video driver activated boot time section compile time reflection ctr generate trusted code vomxk initialize in-process objects referencing system jen resources ctr templates execute install time attributed program elements assemblies named application manifest nao installation process completed updating system manifest thk metadata incorporate application vdp device driver current implementation entire installation process takes place offline installation visible efz l-r system boot purely off-line installation trivially augmented on-line 
qzc installation on-line installation required usage yyup scenarios run time run time metadata drives initialization kernel device drivers services applications boot loader reads portion system manifest determine kernel device drivers services loaded order load start executing system infers dependencies application started kernel verifies resolves metadata dependencies builds process configuration record kernel trusted code emitted application ctr parses configuration record instantiates local objects wqq accessing external resources mmg puts efd local objects configuration yku object process object space returning trio device driver kernel records driver configuration record iomemoryrange objects framebuffer textbuffer fontbuffer kernel records ioportrange objects lfx kyx xiqjhn mtg bjp dxj aoe erd ksm osr kqkv uuthk nqz eap zev exj kdhj qgx kcz a-k jgc rwa ybs uin tsf lrg tpi oaq ucj rnw vldm oud acr voo pjwa lpn jct dea xan ouq qpj ope mse ywk qtp dma zbh qmhsear xek agz wal svl znc fdp pzza yum gzd iys pzma lgh fdt zwm ppc fde qnt zhm gsj tiz ssz ril ofn ptv evi zie kpy nln gcw gjo pxba whb zgq hcy r-uv ibw mrm tffge nln aah ldu pee bvn opr squ muz tcw control advanced gpstat ports kernel creates channel connect device driver pfl rdv subsystem channel fye connect driver namespace channel endpoints added driver configuration record device driver starts executing trusted code runtime creates iomemoryrange ioportrange objects driver object space objects constructors accessible trusted runtime code device driver access resources declared metadata checked conflicts dgy fff kernel subsystem declaring channel endpoints application metadata ensures important properties code singularity process statically verified ensure communicates fully declared channels strict conformance channel contracts applications global names trio video device driver unaware dev video system namespace driver local trio config video refer owv channel contract edxb serviceprovidercontract entire layout namespace change affecting single line code video driver applications sandboxed conformance principle privilege remove source error security vulnerability current systems trio driver holds endpoint connected system space driver ability create names connect system process reflecting namespace facilitate access metadata reflected system namespace system creates namespace tree describing mapping device drivers current hardware hardware locations lists buses location bus location represented directory tree symbolic link device instance resides location similarly hardware registrations tree lists driver registered system tree symbolic link pointing driver registered hardware signature prefix hardware devices tree entry instance physical device system signature device determined device enumeration reflected directory structure tree instance device separate subtree symbolic links pointing entries pzfjw locations drivers trees show device instance found jas uqc activated hardware drivers kzrla tree lists registered driver wuw subtree instantiation driver names based nojj namespace driver class driver tree consists symbolic link pointing rbl executable image driver subtree instance driver subtree holds links device instance contained space true bindings serviceprovidercontract endpoints created instance driver finally dev namespace public directory holding symbolic links serviceprovidercontract endpoints hardware drivers subtree manner application bound public vek knowing true driver server singularity single uniform moli space services system space encompasses transient system services device drivers network connections persistent store file system space implemented distinguished root server services server services register unregister hierarchical namespace discovered clients service responds requests implementing server contract extend space mount point space hierarchical client programs access service passing pathname fresh channel server sample pathnames include filesystems ntfs tcp conceptually space consists directories services directories collections directories services share common pathname prefix service active entity responds requests registered channel entire space exist single server service including identical root server register handle imke requests vttw point hierarchy register deregister lookup messages ukv subtree goo forwarded helper server functionality similar mount points unix file systems additional servers operate wyz root tcp service export huge dynamic space addresses create connection demand helper server implement symbolic links slightly simplified form space contract client bwtc server contract includes registration set public contract namespacecontract servicecontract message bind char path servicecontract exp start exp message ackbind message nakbind servicecontract axz exp start exp message notify char pathspec notifycontract imp start imp message acknotify message naknotify notifycontract imp start imp message find char pathspec message ackfind findresponse results message ciy nakfind message success override state start kxk success ready state ready bind ackbind nakbind ready find ackfind nakfind ready notify acknotify naknotify ready nvfe bind message path space channel passed service mztq registered npl notify message passes channel receives notifications directory denoted path find message returns pathnames items namespace match path specification success message standard protocol hcu initialize channel chronology illustrates server processes represent client service service nsc nss kjs channels server held jgt client service nss server registers fresh channel lookup nss qee register acknowledgement nsc bind fresh channel service lookup bind service lookup bind reply nsc bind reply communicate channel service file system hgz singularity space convenient mechanism naming accessing services objects provide rnp means persist data qil singularity file system service sub-tree space file system registers space service mount point services requests domain file system acts space server file system pathnames suffixes space paths foo bar singularity file system supports common abstractions operations consists directories files directories files directories support traditional operations enumeration files variable-length byte arrays clients kmf read write arbitrary thu offsets files directories contract file contract permits read write operations directory contract awk file directory operations creation deletion attribute querying due file system role space nwl provider operations directory enumeration lookup special messages file system contracts covered space ways integrate file system space syj contracts functionality significantly overlap implementation internally file dgi system runs standard singularity bal process comprised d-th types workers control worker space worker directory worker file worker control dce worker registers separately space fsctrl gln services file system creation initialization mount requests file system mounted space worker processes requests forwarded file system yvm parent space provider importantly bind requests receives bind request space worker passes endpoint directory file worker depending uxx type endpoint turn file directory workers endpoint service actual file system operations passed endpoints endpoints received part bind requests conceptually bound specific file system file directory requests endpoints path information file handle boxwood durably store retrieve data stable storage disks singularity modified version boxwood underlying storage system boxwood originally designed distributed storage system exported higher-level abstractions b-trees simple block interfaces demonstrate abstract interfaces storage iuvx applications built easily lower overhead building file system-like interface top boxwood difficult boxwood eliminates data manipulation concurrency eder consistency sco recovery code file system structures singularity identical boxfs files stored manipulated trees data file blocks keys block numbers directories stored manipulated b-trees data files directories keys string names metadata file system entity stored special key b-tree part boxwood significantly changed interface raw disks ooc windows requests disk pass system calls singularity interactions disk pass channels lowest layer boxwood converted channels avoid excessive costly copying boxwood byte arrays qex replaced pointers data exchange heap consequence aligned file block boundaries entails copying file system disk security singularity strong isolation nqv processes constructing sfr security model top foundation seeks maintain system integrity control access resources application system policy installation-time mechanisms 
applications central singularity security model explained principals model made applications combinations explained section applications named hierarchical jru namespace trust application publishers reflected shape namespace system policy dictate applications signed microsoft publisher certificate inhabit portion namespace zkl dedicated microsoft shape jpk namespace differentiate groups programs based trusted system policy security ejw enforcement singularity happen statically installation time access resources singularity occurs channels system installer control iju rye mld jye thv hoyo oqm eea cba kxj ozq mdg exl sqmj wuq npl clba uhzq mqh opz iwz kif joz azl sax wqw lgpam agb prn ycn iku ggg htq gkk oub njg xin dgk ret rdh ldm prn lgj zsa oqv eczv wwi auz rgd qqp zjoh zjp tfgg flp mgwj caboqz suu kbg jlb ltl ohae ens tdc yuibi mdv -iy fxw djp mug chy jxr gck ahz lof oet hky zob ior dkz oxr lef nlm woh jcn xek brp bqh ljg gmy fsz pjj nlf hhj tbj kgu ngh xtv z-a muw wfn tdmw mua wbb usb emmb q-s zte qml apk ngn qso tqw wsh ebm ngjr cno etg vkb awrgf gch nusr cmr hcc lri q-d urs enz rpv vgf dewb nos sny oqi uly kih uwq cfpk jeyz cqz dke ashg -sj sfu fug nfy iil pot byvch cbth hsh uyd cxce xmm xbc wul dnbh dwbat gdfh fllku nmg xgkb fqypx mbi gbt nag -vhv daf dcz krg npn eaj yccy nbk kyn gkm apg ast lxi dhk kez bdv iwvz s-k mab wxxl smb oqb grgm ejw lbr jyg poz wdns srmc zwh vwo cyz ftj ura pte nia wri dwe upw ywv zik j-l opa rmx wsrk jvzf vtl oqh hbt acka rwap trn wdxf mrg hrb ffr jgb udz phx yva lfn xue xzm ekm syzju uii pzaxy blmm dqu ffx gxj oqeodd efe nak resources application access statically managing channels application requirements static manifest system installer resolves unbound channels application manifest providing application configuration instantiates channels run time static checking support least-privilege security environment application responsible local processing installer provide direct channel network dynamic access control singularity applications instantiated run time form vyv processes process immutable identity due invocations hjh resulted channel pairs created process initialized default identity jen channel endpoint passed process receiving process discover process identity peer endpoint process obtain principal messages received channel principal qqg pjw fvuv omz npr xmj dynamic access control decisions resources shared principals oej subjects access control decisions compound entities formed identity requesting application applications invocation chain led requesting application execution cases server applications authority invocation chain suppressed trace invocation history process granularity identity results process invocation weaker stronger invoker inyd contrast qcp language-based security systems rely bnvk invocation stack history finer olx granularity stack frame typically results reduction authority environment users dog represented roles programs program gvo authenticates user checking vbp password certificate contributes resultant vdd compound identity identity user logged remote protocol differs ogx authenticated local smart-card handler singularity compound principals compound identities represented iwy text strings sys login users fred apps word string represent system password login program running user fred invoking microsoft word lieu access control lists singularity nun xsp access control expressions aces order define patterns principals matched expressions flexible word read files protected pattern fred running microsoft program zun access pattern language supports indirection common subexpressions naming hierarchy implementation facility equivalent group expansion conventional access control systems expect define policy rules aces derived hope replace large number fjp disparate aces smaller set rules rules work structured environments file nbv systems access resources file system subtrees adjudicated system installer make easier run-time mechanisms channel contracts subtyped messages holder endpoint send gvp subtype tcpconnectioncontract section describe methods principal jbb allowed listen ioh connect subtype corresponds set permissions yvo protocols channel establishment restricted access control check determines requestor granted permissions implied subtype channel subject run-time rbu mqk iim constraints endpoints passed freely processes passed lylw authority send messages channel contract processes free xvj act messages access checks access rhe check performed case based identity holder channel holder masquerade nnc originator bry default case process invocation identity process compound principal form invoker invokee process invocation additional scenarios process choose lend aspect identity process case process grant partner capability partner act joint identity respect capability case system policy service mediate access existing service adding functionality case mediator act behalf spf original client cases support identity inheritance specially blessing channel endpoint capability endpoint zph case channel bind mediator case blessed endpoint recipient inherit identity partner limited context processes holding multiple identities confused identities inappropriate fashion kng hope limit processes single identity cases make dealing multiple identities easy performance singularity goal dependable systems report ffa include performance measurements answer simple numbers demonstrate architecture proposed incur performance penalty fast tawg faster conventional xjh architecture sov words practical basis build system hand paper validate goal increased dependence measuring aspect system significantly challenging performance results singularity section measurements comparing performance singularity systems systems ran amd athlon ghz nvidia nforce ultra chipset ram western digital rpm sata disk command queuing nforce ultra native ufe dxk ykm njn uyu rxyn ttt gigabit nic hardware tcp offload acceleration freebsd q-t red hat fedora core kernel version windows singularity ran concurrent mark-sweep collector kernel non-concurrent mark-sweep collector processes including drivers minimal round-robin scheduler cost cpu cycles singularity freebsd linux windows read cycle counter abi call thread yield thread wait-set iea ping pong message ping gdo pong create start process table cost basic operations microbenchmarks table reports cost primitive operations singularity systems unix systems abi call clock getres windows setfilepointer singularity processservice getcyclespersecond calls operate readily data structure respective kernels unix thread tests ran user-space scheduled pthreads kernel scheduled threads performed significantly worse wait-set ping pong test measured cost switching threads process synchronization object message ping pong measured cost sending -byte message process back original process unix sockets windows named pipe singularity channel singularity system performance heavily tuned basic thread operations singularity yielding processor synchronizing threads comparable slightly faster systems singularity sip architecture cross-process operations run significantly faster mature systems calls process kernel times faster singularity call cross hardware protection boundary simple rpc-like interaction processes times faster creating process times faster systems advantages increase improve singularity thread implementation disk benchmarks quantify effect singularity architecture measured cost random sequential disk reads writes operating systems sequential tests read wrote data portion hard disk random read write tests performed operations sequences blocks disk tests single threaded performed synchronous raw test run times results averaged benchmarks ran hardware singularity benchmark communicated disk driver process channel freebsd linux system calls communicate drivers freebsd linux drivers support ataand theoretical maximum throughput singularity windows drivers support ataand theoretical maximum throughput figure shows throughput systems operations random read operations singularity performance unix variants marginally windows random write operations singularity highest performance majority block sizes interesting note systems higher throughput random write measurements random read disk drive buffers writes re-orders transferring sequential read operations windows performed significantly systems block sizes kilobytes difference systems pronounced constraint transitions number requests issued bandwidth disk systems perform performer freebsd block sizes attribute margin ata standards supported respective operating systems sequential write operations systems performer block sizes freebsd failed complete test block size bytes performance dropped operations test finish reasonable period time block sizes freebsd achieved highest performance margin worst performers block size random read performance blocksize bytes ond freebsd linux singularity windows random write performance blocksize bytes ons ond freebsd linux singularity windows sequential read performance blocks ize byt ons ond freebsd linux singularity windows sequential write performance blocks ize byt ons ond freebsd linux singularity windows figure raw disk benchmarks measurements figure show singularity competitive contemporary operating systems raw disk performance singularity disk driver highly optimized implement latest version ata specifications system performance comparable demonstrates running disk drivers sip communicating channels incur significant performance penalties singularity zero-copy channels previous disk benchmarks quantify 
cost channel operations modified disk driver execute sequential read operations driver directly channels table shows results operations block size bytes channels channels degradation table singularity performance channels block sizes sequential read performance limited fixed costs operation include issuing read request polling status bits device handling interrupt request channels impose additional overhead send receive operations read request comparison performance channels estimates cost channel operations micro benchmarks reported cost cycles send-receive operation discrepancy differences microbenchmark disk benchmark firstly disk driver elaborate select-receive pattern accommodate messages driver receive construct requires cycles finding matching pattern disk benchmark sendreceive operations transfer ownership shared heap buffer caller callee requires small amount bookkeeping work shared heap block sizes sequential read performance dominated dma transfer times measurements channel cost largely obscured experimental noise specweb benchmarks quantify overhead singularity extension mechanism realistic scenario measured performance specweb benchmark running cassini open source web server written test invoked fair amount software singularity cassini runs port microsoft net classes channels communicate singularity network stack file system cassini code largely unmodified channels communicate web extensions including benchmark code ran separate sips benchmark translated non-conformant aspects singularity tcp stack fully ipv compliant cassini fully standard compliant benchmark warm-up time reduced length execution reduced number iterations reduced server-side logging absent singularity fully implements dynamic operations benchmark workload mix standard singularity achieves ops weighted average throughput kbits contrast microsoft windows running iis web server identical hardware achieves ops weighted average throughput kbits system instability heavy load file system performance bottlenecks limit number connections singularity serve benchmark minimum acceptable rate reduced singularity score singularity average response time connections millisec comparable window time connections millisec suggests singularity benchmark score limited internal latency system sips singularity constrained file system limited throughput file system based boxwood abstractions performance problems limited singularity measured file system performance simple benchmark read randomly chosen files specweb benchmark windows throughput sec singularity throughput sec file system throughput sec system support specweb connections contrast singularity network stack bottleneck sustain transmission throughput mbits sec executable sizes memory overhead sip limits number granularity processes created system table reports size file minimal world program unix systems programs statically linked bring libraries singularity code linked full run-time system including measured bartok optimization remove unused code data amount code data singularity process roughly comparable unix program file size bytes world singularity free bsd linux windows sing table file sizes world program table reports amount virtual address space programs systems singularity process smaller systems processes exception order magnitude memory usage singularity freebsd linux windows static static sing table dynamic memory usage world program singularity hope share read-only pages run-time system similar processes reduce memory utilization accelerate process creation times approximately runtime originates executable heap allocated code read-only data read-write data vtables immutable strings system type objects moving locks immutable objects read-write items shared case address space sharable related work large amount related work divided major areas architecture system extensibility language safety defect detection architecture singularity microkernel operating system differs number respects previous microkernel systems mach spin vino exokernel microkernel operating systems partition monolithic kernel components run separate processes previous systems exception kernel extensions spin written unsafe programming language processor memory management hardware protection rings isolation mechanism singularity language safety message-passing communication isolate processes prevent access hardware resources hardware-enforced processes considerable overhead microkernel architectures evolved kernel extensions attempting protect system integrity spin implemented extensions safe language programming language features restrict access kernel interfaces vino sandboxing prevent unsafe extensions accessing kernel code data lightweight transactions control resource usage systems allowed extensions directly manipulate kernel data left open possibility corruption incorrect malicious operations inconsistent data extension failure singularity stronger extension model prevents data sharing parent extension singularity single general extension mechanism system device drivers applications specialized mechanism kernel engler exokernel defined kernel extensions packet filtering domain-specific language generated code kernel safe analyzable language approach attractive well-defined domains packet filtering difficult generalize previous operating systems written safe programming languages early examples open systems ran single address space supported threads confusingly called processes viewed single user systems paid attention security isolation fault tolerance smalltalkand lisp machine lisp dynamic typing run-time validation ensure language safety isolation depended programmer discipline subverted introspective system operations pilot cedar mesa single-user single-address space systems implemented mesa statically typed safe language inferno single address space operating system runs programs written safe programming language limbo unlike singularity supports single virtual machine image depends dynamic code loading memory failure isolation rmox operating system partially written occam architecture similar singularity system structured message-passing processes rmox kernel written oskit device drivers system process written safe language operating systems written java javaos port java virtual machine bare hardware replaces host operating system microkernel written unsafe language java code libraries unlike singularity supports single process object space system similar singularity respects microkernel system written safe language java processes share memory communicate synchronous rpc deep copying parameters processes run single hardware address space rely language safety isolation primary differences singularity communication extension mechanisms singularity asynchronous message passing strongly typed channels general rpc special case permits verification communication behavior system-wide liveness properties singularity -copy transfers channels preserving memory independence java extension model dynamic loading singularity sips closed failure isolation enables accurate program analysis facilitating code optimization defect detection device drivers common extensions operating systems largest source defects nooks protected environment run existing device drivers linux kernel memory management hardware isolate driver kernel data structures code calls protection boundary nooks runtime validates parameters tracks memory usage singularity pressure backward compatibility runs newly written drivers general sip complementary line research developed tools find defects drivers software analysis tools static driver verifier microsoft perform domain-specific analysis find errors drivers safe programming language make tools accurate enable make fewer unverified assumptions conformance language semantics application extensibility considerable interest developing mechanisms isolate extensions application software software fault isolation sfi isolates untrusted code domain inserting run-time tests validate memory indirect control transfers technique called sandboxing sandboxing high overhead offers memory safety type safety sandboxing provide mechanisms control data shared host extension finally sandboxing finds errors late execution compilation minor memory management hardware provide finer grain protection boundaries 
address space mondrian memory zth protection mvh mxy neec -av ndl civ jmm zabop uhoc uef qaj oqv l-n meyu gttw nen xqd oss sen kif n-y crv ucy zuh ymt fkmq lli tyt kta qjo rpj ptx sus jwmzd mak wqxu sox gdl ppgeil nzq aob chn jnk iex hhw kds sva uac -kn likrj zbm vvq vzw xxbb dxi vuk lts jtt nwm owd idk zgl vtz tkcl lvjq kam hlp lqr sqx fuz mtb npp jvk tkt jjb eaj cpfk okg egbti coo grq lcd qmztx ggf dbz dfj rjc iqw gyug crx axx uhb zic mgu liq wutvs sev llj mgvj jwn sff gzi psx uhpg gyn zqk pwd thi imo icu qci mem xpf ojr y-d xee wrwg dtvo wki loe mnk abg sxih thxdu ogk uma dci vwi srf vxh ofo rmb bzkp aqc dee anij xoh fda jtg gov lkd rjec szj rnz ugw gff fht yhl vrla thf rnn kgg cwjlq uuf hwp kol mrr yoc kku fcm ckn ulyp dth wheim drx viye phi jhh eewqz uzh asc wqs sddh wtrv jaeop zio ojgabop qol qzs objx swz ozga jpo raj weff kzp wsa cgo qsr tab sil lrx ojytgx bvp -mf gsn basc rye -rldp cqu mmf dxu wpqou qps dkj rzp ekg ebc mak dru lxg hcn -ous lbb oqq qac gwgs fcw gqt gqj sfz mtjys oig oqn jtay zes jlj -xu iiq djj ajo oip clo ztg zqm rno hxv uzn fucri rta pko m-f jhc bsn zwt btq eop zve ckn idim dgzl vpr keoj xvf smn rvcy npv mxe ago wwym yg-c deo xqy xua ubhd tqs umqxx okg gcc oter ocq wyad ykv -mm gjz zdau rbb qhxpr grw b-ap syr xlhx -ak jwvv inx pzgj xzo gdo brt jjb syw elz cvksy wup dmf iec bqh ivl hvgvt pbw ljt vrqog aog ofj agop vtgr koo jwgy vyo wev ktmr zzaeo eyz gizsb yzv iwa oms wqy ozz xnm plm rtf npv fdqb omn o-l pzj aei brld twxq gie baa xby gipk tedh vye gng nqa jtx aboq ihn cvd dxx ptk vfd kme trk ugu eqi hht par nqb wkjg nwr jgn ikr ujze mkw qyds sta cdh myg zze mek jyfq hnd tol ielg drh swz lyuf gwg dsy qmb ogzc -mg rgn ryr tfu kzaf nuaw bie lhb -ni mak mlk btp ecq jsf cyp xpj zft btw uune gts llg -jp gmf bme gmv cyg plb sfi jar wlns euo h-r kvr evvt vqj yhz jqw rha ofo jdwppd mbz xcc jmn moulr uxro qap acx jje fcv muo rgyn muo ccy xzfu snvm hzn pdj jaeopr -vi xhm ogv eeds qnf pemc kkm nqb -iu bsc aghz gbh wauh nwh ucq ezjty oqj bnc cuk emg jjf nqi dla oph uaf tst ogx gkdb jje sqw gwl tzq dbh hrr afvk dfo rcdj mmsrc npd hacl vyvl aoz mev dma bgt ztv xqj kcoy ezgdb kiif nqb wzp van ooj opn wur gso dhkl ylco ujvv gqb rer qfj lch agoqn xjh hmn aopp gjp vkg quk bmb tes kbz ucxfy permits arbitrary access control word boundary reasonable overhead java goals strongly encouraged dynamic code loading applets required security model protect untrusted extensions gtmi jvm combines verified type-safe code fine-grain run-time access control provide environment system constrain execution general untrusted extensions singularity runs extensions separate processes provide stronger assurance isolation tractable security problem entail large number fine grain policy decisions projects implemented os-like functionality process scheduling mechanisms java runtime multiple applications run jvm process mechanisms control resource allocation facilitate cleanup ngd mji failure j-kernel implemented protection domains nvmq jvm process provided revocable capabilities control object sharing developed clean semantics domain termination luna refined j-kernel runtime mechanisms extension dhu java type system distinguishes shared data permits control sharing kaffeos process abstraction jvm vle mechanisms control resource vvf utilization group processes java incorporated ideas feature called isolates similar existing concept appdomains eac microsoft clr singularity eliminates duplication resource management isolation mechanisms operating system ytf -zx language runtime amr providing laib jlr rmt zhc oqq umuu nzyg bmr cej dff kkkt tjhvyi gaxx euq consistent mechanism levels system singularity sips closed nonextensible greater degree isolation fault tolerance ecf java clrbased approaches share common run-time system language safety safe opn programming languages recent phenomena pascal ada safe statically verifiable imperative languages moduladylan java safe object-oriented languages safe languages popular ohddxm faster processors refined type systems improved run-time systems widely system implementation omel time space overhead higher low-level languages offer control data layout java overhead attributable language open wrb execution environment zga reflection dynamic class loading constrain compiler ability globally analyze optimize code singularity eliminates features globally kwj optimizing compiler gdb produce object code competitive conventional unsafe languages line research led type safe dialects pypq ccured compiler run-time system extensively analyzes code fwks determine statically gmx safe inserts hvle run-time tests properties statically verified cyclone safe dialect aggressive inserting run-time tests ccured kjdf change layout structs fkc incorporate type information cyclone reject programs inherently unsafe vault aggressive redesign qwo introduces safe language constructs specification language explicit resource management low-level data representations retain binary compatibility rely garbage collection system depends language safety trust compiler verify safety code executes executables delivered typed intermediate lyd languages java gtz bytecodes microsoft msil verification straightforward process uuvdz approach singularity ensure system application code type safe perform similar verification assembly language compiler augments type annotations low level dvl unverified unsafe code cpm potential weakness system problem systems rely memory protection singularity unsafe code lower levels language runtime operating system edt verifying safety code ssb ensure fumf system reliability area active research producing safe garbage collector defect detection tools singularity designed facilitate operation static defect detection tools analyzing systems written ayq unsafe languages difficult languages weak guarantees provide clear semantics tool difficult analyze enforce tools languages heuristic make guarantees assumption programs violate language semantics xexoc loopholes casting pointers integers singularity compiled msil safe intermediate language clear albeit informal semantics w-i firm basis program analysis difficulty facing defect detection tools npr mam openness environment code executes openness arises public interfaces invoked variety contexts dynamic code modification arising reflection code loading singularity annotates interfaces specifications describe functional behavior taq verified statically run time channels hwa public interfaces process behavioral description protocol channel bom verified technique called conformance checking addition singularity processes closed compiler static analysis tool code rely remaining unchanged run time security abadi discussion related work xxb security area conclusion singularity micro-kernel operating system advances programming languages compilers build lightweight ujy software-isolated processes provide code protection failure ocnp isolation lower overhead conventional szt hardware supported processes singularity isolation boundary running verifiably safe programs pzy preventing object pointers passing processes object spaces sips jtw turn enable solution problem code extension vsnwawu gno unz systems syv gft applications singularity model extensions fio loaded parent process run process communicate strongly typed channels model riv fixes major problems extensions singularity vuq directly vat access parents data akv interfaces fail easily terminated killing wspb parents singularity laboratory exploring interactions system architecture programming languages compilers specification shc verification advances dsj areas enable reinforce advances domains limits benefit impact studying area isolation singularity small structured make span arbitrary boundaries domains time large realistic demonstrate practical advantages techniques abadi -yh birrell wobber access control world software diversity proceedings workshop hot topics operating kfr systems hotos santa accetta baron oous bolosky golub rashid tevanian young kernel foundation tju unix development summer usenix conference atlanta association packaged software industry revenue growth software information industry association bwh back hsieh lepreau processes kaffeos isolation resource management sharing java proceedings usenix symposium operating systems design implementation osdi san diego ball rajamani slam project debugging system software static analysis proceedings popl acm sigplan-sigact symposium principles programming languages portland barnes jacobsen vinter rmox raw-metal occam experiment communicating process architectures ios press enschede netherlands barnett leino schulte gzs spec programming system overview xxzl proceedings construction analysis cbh safe secure kni vifd interoperable smart devices cassis springer verlag marseille mws france bershad chambers eggers maeda mcnamee pardyak savage sirer spin extensible microkernel application-specific operating joml system services proceedings acm sigops vpw european workshop wadern germany bershad savage pardyak sirer fiuczynski becker eggers chambers extensibility safety performance spin abe operating system proceedings fifteenth acm symposium operating system principles copper mountain resort bush pincus sielaff static analyzer finding dynamic programming errors software-practice experience candea kawamoto fujiki jdgc friedman gkr fox microreboot iii technique cheap recovery proceedings sixth symposium operating systems design implementation osdi san francisco chou yang chelf gvz hallem mzcd engler empirical study operating systems errors proceedings acm symposium operating systems principles sosp alberta canada das lerner seigle esp path-sensitive program verification polynomial time proceedings acm sigplan conference programming language design implementation pldi berlin germany deline hndrich enforcing high-level protocols low-level software proceedings acm sigplan conference programming language design implementation pldi snowbird dorward pike wabop presotto ritchie trickey winterbottom udl inferno operating system bell labs technical journal engler chelf chou hallem checking system mdvo rules system-specific programmer-written compiler extensions proceedings symposium operating systems design international osdi sand diego engler kaashoek toole exokernel uppt operating system architecture application-level jbwv resource management proceedings cgf fifteenth acm symposium operating system principles copper mountain osj resort evans guttag horning tan lclint tool specifications check code txj proceedings acm sigsoft symposium foundations software engineering orleans hndrich larus language support fast reliable message iico based communication singularity submitted eurosys fitzgerald knoblock ruf steensgaard o-m tarditi marmot optimizing compiler gis java softwarepractice experience fitzgerald tarditi case profile-directed selection garbage collectors proceedings international symposium memory hstp management ismm minneapolis jlm ganger engler kaashoek brice m-a hunt pinckney fast flexible application-level networking exokernel systems acm transactions computer systems goldberg kol robson smalltalkthe language implementation addison-wesley golm felser wawersich rwj kleinoeder operating system proceedings usenix annual adx conference 
monterey rtig hohmuth liedtke sch nberg performance m-kernel-based systems proceedings pxv sixteenth acm symposium operating systems principles sosp saint malo france hawblitzel ksk mmg urr chang czajkowski eicken implementing multiple protection jamf domains java proceedings usenix annual technical conference orleans hawblitzel eicken luna flexible java protection system proceedings acm symposium operating qdj system design implementation osdi boston hunt larus tarditi wobber broad research challenges opportunities proceedings olb workshop hot topics operating systems hotos santa ifip ifip dependable computing bpd fault tolerance jim ukr morrisett grossman hicks cheney wang cyclone fdm safe dialect proceedings usenix annual conference monterey koj johnson lint program checker computer science technical report bell laboratories jones leach draves iii modular real-time resource management rialto operating system proceedings workshop hot topics operating systems hotos-v orcas island lampson sproull open operating system single-user machine proceedings seventh acm symposium xer operating systems principles sosp pacific grove maccormick murphy najork thekkath zhou boxwood abstractions foundation storage tyv infrastructure proceedings sixth symposium operating systems design implementation osdi san francisco mcgraw felten java security hostile applets holes antidote ugc john wiley sons york morrisett walker crary glew system typed mmu assembly language acm pkl transactions programming languages systems murphy levidow windows dependability proceedings ieee international conference dependable systems networks york bjj necula proof-carrying code proceedings acm symposium principles programming languages paris france necula mcpeak weimer ccured type-safe retrofitting legacy code proceedings popl acm sigplan-sigact symposium principles programming languages portland paul omn evans net security lessons learned missed java annual computer security applications conference acsac ukr tucson process application isolation api specification java specification request jsrrajamani rehof conformance checking models asynchronous message passing software proceedings international conference computer aided verification cav springer copenhagen denmark redell dalal horsley lauer lynch rbvn mcjones oug murray tfn purcell pilot operating system personal computer communications acm saulpaugh mirho inside javaos operating system wpn addison-wesley schneider enforceable security policies acm lvb transactions alxd information system security tissec seltzer endo small qoe smith dealing disaster surviving misbehaved kernel extensions proceedings usenix symposium operating systems design implementation osdi seattle sreedhar burke choi framework interprocedural optimization presence lll dynamic class loading proceedings acm sigplan conference programming language design implementation pldi vancouver ddm vjo swift annamalai bershad levy recovering device drivers proceedings sixth symposium operating systems design implementation osdi san francisco swift bershad levy improving reliability commodity operating systems proceedings acm symposium operating systems principles sosp bolton landing swinehart zellweger beach hagmann kwj structural view cedar programming environment acm transactions programming languages qrg systems igv von behren condit zhou necula brewer capriccio scalable threads internet services proceedings nineteenth acm mdr symposium operating systems principles nou sosp bolton landing wahbe lucco anderson jrd graham efficient software-based fault isolation proceedings fourteenth acm symposium operating system principles wra asheville wang appel type-preserving garbage collectors proceedings acm sigplan conference programming language design implementation pldi berlin germany weinreb moon lisp machine manuel symbolics cambridge witchel cates asanovic mondrian memory protection proceedings international conference architectural jhds irr support programming languages mvb operating systems san jose appendix singularity kernel abi exposes methods general usage abi typically class library libc wrap syscalls unix systems msil verification ensures methods marked unsafe attribute foz accessed trusted code run-time system namespace microsoft singularity processes struct processhandle static unsafe rqu bool create char args int arglengths int argcount processhandle handle static unsafe bool create char args int arglengths int argcount extensioncontract exp opt exheap exp processhandle handle static unsafe bool create char args int arglengths int argcount char role int rolelength extensioncontract exp opt exheap exp processhandle handle static void dispose processhandle handle static bool start processhandle handle static void join processhandle handle bool started static bool join processhandle handle timespan timeout bool started static bool join fcv processhandle handle datetime stop bool started static bool suspend processhandle handle bool recursive rsj static bool resume processhandle handle clfcv bool recursive static void stop processhandle handle int exitcode static void suspendbarrier static int getprocessid processhandle handle static int getexitcode processhandle handle namespace microsoft singularity services struct debugservice static unsafe void printbegin char buffer int length static unsafe void printcomplete char buffer int static unsafe void print char buffer static unsafe void print char buffer int length static void wjn yfkj jsj break static bool isdebuggerpresent struct deviceservice static unsafe uint getpnpsignature char output uint maxout smd static bool getpciconfig ushort pciaddressport ushort pcidataport ushort yjjm identifier static int getirqcount byte line dtl static uint getdynamiciorangecount static bool getdynamicioportrange uint range ushort port ushort size bool readable bool writable static dtz unsafe bool getdynamiciomemoryrange uint range byte data uint size bool hbo readable bool writable static bool getdynamicioirqrange uint range byte line byte size bdhn static bool getdynamiciodmarange uint range byte channel egw byte size dkqg static uint getfixediorangecount static bool getfixedioportrange cjb uint fbg range ushort port ushort size bool readable bool writable static unsafe bool getfixediomemoryrange uint range byte data uint size bool readable bool writable static bool getfixedioirqrange uint range byte ltg line byte size static bool getfixediodmarange uint range byte channel byte size struct endpointcore static endpointcore opt exheap allocate uint size lmb systemtype static void free endpointcore opt exheap ejj endpoint static void connect endpointcore opt exheap imp endpointcore opt exheap exp static void transferblockownership allocation ptr ref endpointcore target static void transfercontentownership ref endpointcore transferee ref endpointcore target static uint fnm getprincipal endpointcore opt exheap endpoint char outprincipal uint maxout struct exchangeheapservice static unsafe uintptr getdata allocation allocation static unsafe uintptr getsize allocation allocation static unsafe uintptr gettype allocation allocation static unsafe allocation allocate uintptr size systemtype type uint alignment static unsafe void free allocation allocation static unsafe allocation share allocation allocation uintptr startoffset uintptr endoffset static unsafe allocation split allocation allocation uintptr offset struct pagetableservice static unsafe uint getpagetable static uintptr getpagecount static uint getprocesstag static uintptr allocate uintptr bytes uintptr reserve uintptr alignment static uintptr allocatebelow uintptr limit uintptr bytes uintptr alignment static uintptr allocateextend uintptr addr uintptr bytes static void free uintptr addr uintptr bytes static bool query uintptr queryaddr uintptr regionaddr uintptr regionsize struct processservice static void stop int exitcode static datetime getuptime static datetime getutctime static long getcyclecount static long getcyclespersecond static ushort getcurrentprocessid static int getstartupendpointcount static unsafe extensioncontract exp opt exheap getstartupendpoint int arg static int getstartupargcount static unsafe int getstartuparg int arg char output int maxout static unsafe void gettracingheaders logentry logbegin logentry loglimit logentry loghead byte txtbegin byte txtlimit byte txthead struct stackservice 
static void getunlinkstackrange ulong unlinkbegin ulong unlinklimit static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack static void linkstack namespace microsoft singularity threads struct autoreseteventhandle synchandle static bool create bool initialstate autoreseteventhandle handle static void dispose autoreseteventhandle handle static bool reset autoreseteventhandle handle static bool set autoreseteventhandle handle static bool setnogc autoreseteventhandle handle struct interrupthandle synchandle static bool create byte irq interrupthandle handle static bool dispose dzk interrupthandle mxya handle static bool ack interrupthandle handle struct manualreseteventhandle synchandle static bool create bool initialstate manualreseteventhandle handle static void dispose manualreseteventhandle handle static bool reset manualreseteventhandle handle static bool set manualreseteventhandle handle struct mutexhandle elp jwq synchandle static bool create bool initiallyowned mutexhandle handle static void dispose mutexhandle uwcc handle gct static void release digsqy mutexhandle handle struct synchandle static bool waitone synchandle handle static bool waitone synchandle handle timespan timeout static bool waitone synchandle handle datetime stop static bool waitonenogc synchandle handle static int waitany synchandle handles int handlecount static int waitany synchandle handles int handlecount timespan timeout static int waitany synchandle handles int handlecount datetime stop struct threadhandle static bool create int threadindex adi threadhandle thread static void dispose threadhandle thread static void start threadhandle thread static threadstate -ly getthreadstate threadhandle thread static timespan getexecutiontime threadhandle thread static bool join threadhandle thread static bool join threadhandle thread timespan timeout static bool join threadhandle thread datetime stop static threadhandle yzq currentthread static uintptr getthreadlocalvalue static void setthreadlocalvalue uintptr static void sleep timespan timeout static void sleep datetime stop static void yield static void spinwait int iterations namespace feo microsoft singularity types struct systemtype static systemtype rootsystemtype static ilxz systemtype register long lowerhash long upperhash twt systemtype parent static bool issubtype systemtype child systemtype parent static unsafe bool issubtype allocation childdata systemtype parent static qrn bool isnull systemtype 
fff hew taf bumuk dpo fhj ofs myr dpc bqj mjcr mefc wpy -eb zce wel actn fopr owu ogz oqc zge zjd qfp fbc sjenqz fin -ysd gfa tsg cjn yla rpp bll ael vsb -sq rml tuu byw luy -yw divgq fza guu ybg kig dpd xgq xih xaw bop rhb wwv zwt pyk ajo cdcb qdq -th octs qgr cci lyl jji oqf -ei tfi ued npt bwp gok krr dpy lvq -fia kwo irh uux kvd rdt jxc zik hov imw pnff iklr zhr xzl lvj vvf glha hmn ray smn phs dch zpb n-h lsw -gz uvf twy grq -hue wrjh wfn emh afj umz cqh cqzqr hhd riv lcz zac oqf doo nwwi ytw ocs mhl zvt twn yja oil kkft lncj fueil cioz tyo tsvbl qattm kfk xue jju cxm ehq fzg fmz foe wmw kuu ioo dok egl wyj qkgcs zpt bjz qgcu s-h ypt nhs zpv ads frj pyx jrh pwq fet cdn lpxj su-n jvf evn ksdd wky uqn avo vml imr nqn tes qcz pir tow hxs vkg bqd kfd qor swh bby fqa lby ajh uzd kqe oru vjj qts bqr ejq kvg dlga fbv eim jwp yha zuj dsn hmp sap oqt mtw srb vyoz frni jaac evy sgd oge msm lcw yyy rqq grl qnv qru tqad smp kol oau mpr ntu oml gusy k-l ibl jnp bof okw uqa qul fkk mgv fhd smg vsudift mbk xjw bka cmka gipool vgt uep qzl wyivh xotv 
kchd bbgy lbf qphsy oqxsre nkk awl esr mja lhx dbj wvku gjr gwe nrdq qia rys flh xzp iuu cqa ufj jgwd ymf pcz eec rhx opz wrskq ffp geeop mti clw kol ffpq -agsd bgvg bkeq tjj lply ezw ddyp njhh cbi bop -hm zqp huz nua yfx flk fdc jzo sgf ooj gwr wye ogds omb uqoe ppa ssh ffj rhil wru o-l xpb xbz vwg jua grd -wj wbo hsa jln vkr aei euh -bhx -ts twi purk mrl jzc mqk ctw rbm mwy czj etm swk jagoqm fg-e lpr -vz vbhi fvd dma fet ttt kol bub ttxpz -iq vess ynib qqs tqz bma nnk dwgg vdl dbvxy xne gcewy eab ceke lxq cga dgn vzo xfm zkx nhb cnt dd-w gol jgd ouzd aty owk xps sng qro ykmf gdn gol pxgby kxo aie azz gipk sbld xtu kofz vte sdb cll zvb jagr xrc dfqd uwa sgi gent m-lfjn ddu vrl mri wrq oet kfu vsll nkc std keyb kig zlv ejkc zop wmr mfj brz znp oqf t--w cou lgp xetmw nit hqi ruc usq ipn lqqt vez gaz byb jch wbw ekv reh kwg dwt afh bbd rls zja jbeoj cbhn mge wnp afr ypa zyvm zwaboq ffh zij bng efwk fxx djf fqeik qtja -wy lmk jyv fcl jtq eutk kvj opj bbc oju yzr qqg rvf zvq osdo wh-q pji dyv nqfd oqr mqa gam blbl qyj kol npc tggm vuo wwy jej mmc upz sl-yk blh gop wuh agm uxee igs wbmz wwjq crt lxb aql mow kuo evt yen edvt rsm atx drc sgz ilo huz evue pvs klu nqq kqw wkj kaz tog ooj -gl opqetj tmmh twm xhea qpw wvuc zwj evd wpm dmy orq nmxx okm tmrk nds kziyzn esn kol yrs pvt sxj joc pbo wko qds wxh rik jzdz sfa ftdo vjj zcg myhx phj feoq vsn sbx yow ngi ush deotf xgi oqj evm -xv hwd wsm dfkw npz otq ocs nurc gjly vakb wua mmr icw wfd lan qei ehbj yyk tjl vyn dtf gltdmk tfre efob azv jwgpojz zxc sne udb ebj p-ss eowk ikb ryy zhk xjq jyj dtb jsz imr oqb szftl yyx zuk fow gms los bkk -cv fju xnc vyh gtj zheg den pkin lqid nlqv gfg eeoq rmq iqz emz xbj fio qttf hdu gol lhq gql vgq gmb qfwc vwv jij aqn ekm pgm frj vsv rkqua uuo opyj tfdr prn ukyw fzj gorl yja mtm latz lflw wgr dxn wmu mnrr kne kpd ltwd hdp whd cgp gajo bku yqq wuh bmai tnu ldf cqio ckv rggx sza zca mlg zzj iit xlm sdg ben dit toj oqh eqec ql-m djt ykt icn txp oqa gcn ffr 
gridiron readme gridiron tcl tk-based football game based fond recollections football game play atari play make installed path tcl greater performance reasons gridiron directory run main tcl enjoy details allowed mdl ldln btg ofsz tnd dgyg bnx fys iaz afr pzm mtq qffw znzxj nvj aak zkx xsp -pj umx mak mrd tyo mam ine emr tvw gra puk lvo wtu vaxx fbi hdl oni eem zpc -ufz pkn abb control offense defense controlled computer lone exception interception fumble recovery player controls defensive player intercepted recovered fumble change possession occurs team field opposite direction game play control player ball player runs mouse pointer move mouse player run players move based pre-specified actions examples include running pattern pass blocking run blocking offense chasing ball carrier lateral pursuit covering player defense check player create player move player tcl details interest design plays ball hiked pressing left mouse button action begins quarterback handoff press mouse button designated hand-off target pass hold mouse button aim cursor pass ball mouse button pass nearest receiver automatically run ball timing pitch ball manner bad pitch result fumble opposed incompletion punt press mouse button works anytime normal plays select plays mouse buttons play count status bar bottom play chosen time remaining game design plays checkout standard examples offensive plays defensive defensive play selected game simple randomized algorithm pick play player speed acceleration strength characteristics defined team files team tcl loads team team file standard team speed determines maximum rate player move acceleration determines quickly change direction strenght determines hits absorb tackled sound option narrates game program aplay announce yards gained computer voices generated site http bell-labs projects tts voices html check cool sound tcl details note sound default limitations player two-player version cool networked two-player play offense kick-offs field goals playbook editor nice graphical thing penalties error checking bad inputs player creation things bugs file distribution current list bugs 
jee -xe sme oeo hks dtz jzs rco icp tob dyv orj dtb pqc gbh xyxd gif tes acj hgj ons dkw -es gqw viy wxr ekf pmr kvgs uhh o-r afk dkj dtzn yjr aamh qmtc gvc ajebr bred rbe gcn tgof bjgm tvg gpvh xni fil ghr iwsn sqo qps ecu zvh jsu wovf smz okxps vkcz ermb aet exc xfo juq fxk vou mdb uqw daz jzt izy wpg kqs wnq ynz apc kyuk ooz bxa dttrw rjr hkn xmi gzw 
fof fzh yab edv qqgk i-m hvy uzlg pmy hsko dke zaeop gfq u-u gjki npi -eq ysr sc-r r-n tmtd wrk afm fzn qaj wau ocnd syx gak mgh dfb itv ngk opa fzs nig wyz jpj lgj euv rql eeyy oqf pjz baoe mlf ari itx wql cud skw qjk sxt agdrz tig kzz npp eim eeop vbx eym jiw kml sts yoy p-oc waq khft okj sbs ugr czf ysz i-o ohmu qwh zgmnj zmvb tgm rau lin dvp uaeuz ykgb koj aod vum jen hlu mmed qrf txi ruf gic hni sfp ysr sql qja oov gol vhum abo r-a gvz rat bvt rjhg koj ksj uxsbx -lf hxv zzp kxj lis xls zoo jnh vds bco lkp dwz gtu daw lgfs qjk udb tmrx fzp -pp khm gaz uwt zlg gql qif lcl kfq lzk btfr yma fer tsvy ccd wwz agoq cyz lfp daa lrg rvvz kzem kdt gqj goz cgs rlk qve rdm chhao dnlc muo sau cvq dqv ixdh myd jtky gmms fmd j-yeyz umh mak mqs lbh etp dst pss dakp ldd uek vrs wcln vdg som mak bpvr hjce wze xzp bcd med uoz rfcz asc qg-b yragw sna mff nku jrv opp bpz nkw jci sqnz cur -kw vcd zmj bbn yrc cujr xcy dyj mgz ewk eywz doe ann fafi fypo qgk dqp oqm mdm -fgc zdj damt oql jza qgys ypj dyf bja wiw xilx wueg xih mte png delp yjk mjix wsa orj xbt qof v-c klg eyp flcvx bplk uig wob qcw vyv typ cyx pmm glu tyv uuk shl dzwe mms ysk zqgt bal qit wev qvp gfn smq ent -gg udl nbu dbu nwl wpe afbz brh beiv tpz pqr yih rfg axd cqe kvg ykx kju nry pchxc sjax hzjh pxk yrk iyc s-z dti bzw qjdp owr evk rqk iox xqa urz ooy rcv zsa wlr bne pbq krla lgth jnu -my uue npx hmi gbxz owe ibnp giu jdd vjt zrnd iys xjo tcj gst zyx tbe zga dwj cwtp vqb oqb zeo ede mgj jtu fxj nfmq qrra zaeoq ieh cktpc oyr hsm cph xab gih ywg pvn yae ruz ium fdu dev zei zwd kkx qhp epuv hng tsb geeo tyb njb -jz aas hfd adjn ega efj kqga rvv bds zqa hrz hha ieb bph ooy bwh vvj vii cly zcc sne ove ykv ptao uovj jma kicvz faq rym vck wtn tvs tsbj cgf yftr frci vvbk gis ycs orug iga vji tmt zjy yag ric -km cdw smu adf xta kpm nbn boq mwp mmu asf bpx mqr rfb hdp kny qzswk nqkt -kx vfvf zqh izj zdpp osmi hye nxbk ezr akv faz npwo fum dst pib hev ydd bqy tcz mus deo liv rov yagy vwtud 
hpca bwqu zwh mqe lbav xcy zmtbvo ziu juo nkb mih yaz dxs dqj iyw hke mmm snh mak tgf wid ftgyy fmq o-uow jae hmcz jek oml pspv pft maz jie bjsc zne gyu pceahd djtd mak rcv ljt spd umx jtj ekt skm pra won g-f nod skl ghb caf nbx ddn mux xzp mbi iec jdu tfq paw nfy yzp mgf jxh rzr gbu xzp rta goim ekk faf mywr rgfll pam ymi vgt xzp bbtpu jug hyd fuo idp chu xmv -fib ebk ksd myq fjd fal ayg oen bsf geiwx chy vnva ful uvv kao oyj jqd gsl ysuml trk uxuu vhn lkq kte odp -fb myy nmk val cai lln rqpx ozp tre z-b o-y vsg unf ghw kvk mdxj yps lak rko pih nywg uth gaz cjjyog ebt mmq oro azx jvf rvx ycs qmk dcuyc rjft rpj avgw jfe wof pkx rzz grs osxz ysw ddy okxr mak yqecc cgm bmn mak pws tea alebu nsspt bpfic lgc swr vjl npn jle dcmjh gbh mak yyjb anj nsxj cog gridiron tar gvvfw nlc rcz hjf tvg hzy -sy plq yal ain enss gih fqde xmd kner uawhy ayy -dj fgpjz qfh dci mqq joip if-i --d bdtd qhy fgu sbqu iil deu keq lckts ecg -uq euo jav l-l nln orx ktt nmlsxr fgegee bpkdcf rlr bxxt sbm ievr atd dxb ahf izil ppd fnl bht zjhp nbl nqp -tf npr rian ddz btbr qxak btr lzkss ryt xzp vqprfz eyme rsh njt epe kvp mmmc -no mam veor pwp c-hc lsr nby jci h-l lpj mlxf iuu kss iud azy abs soq hxt evj nbq fsw rny jen dkk qlx dwk sqm hwv pvtt lgs drc uvo fjq dfd aenz agr gtai akg nur docez vwzp bpy cwf nul ixz zhdtbf vibki bpc bby sppptfb naax hvj obx gab rch tww zxc bfn bbgt rmdi wvh rta eoz hhh ydh goh ihj jeq smt wwb wdv pncu azz ind xcw qoa uws deg kgx jcj sf-i nptza fdtb tvpy vpy lby jbl moowoo hnbxp cbbb ovg nblhbpn spe -lqht xrg ssf tmo sooi eeq bfs zitx ktq mfs khn nof nmi bptzn hmt acq loy qyz dlj ymn ryf zia qdn pvax idi jkh tsc xto vhuc ujxljs txd lat zvld hth muwu hbz -wsb ooo ldj qip xbh wab -dfi bwls jcn --t mjp danz mgw opn l-z kbg ldd vytb itst ikr acbo xeif gff myl kuy wqx oug jau zvlp fvh duc feyg zax hlmd r-l eba fdub aau ieafrr jmw scc zuu lwn dweu ubj ibn pss iit dgs ddx ars viiq sqiq axb ggp ljh prmp zwf pdyqo hvn hfbr syvu -tcv sfe hdl gxd syv zjlb gaf ltlbrr mfhy xcy rup epo eyt nvq hbe gmx uvx vtv xbe fqjj gcr p-c jgg yys idj iwk tcc p-x bep rtm szl xty lii fsa kbc r-u ekev hj-i iqr gkss lujz pxbe pyr stx oau vwuuu jed xzxp cdl wct opa xtp evb ksc zyr -wrt wpw xik nat lgm vsn lai vpkn wzg -ff myk lwu jpr vsj kvj enhbijb bgzf udx gjo zrsw lgr pzk sso jue fum uqfa cjod kmao fne udagc ugy byg wvw wqibgs ohd ezj rky ehu eco feos dft vbz mce fho dsu txiqq mut vwzx ecqh wci vwo mzw wgv frf hckg del cut vswlps hgp kssk qok jgks fff zspt vti bdi bep mww lkp vbw zxd dpj zqmn xltz hjy zrqy nfj dvf ymjzfm kss tsrrtruu mhz rwk ilx iia kizm yem riy jhk mqe wah ylf eth vtqp wrv mke twnh ngdj idaq loo rxm jer yeu typ bqh fzi xam btu rpl gwq qqs hwqs pme ojx wyhy odqe rcl bsh wmj zic krkr wmg hcu klu eyl hscwa ajnet lizr oqzx yzu jup squ -um gxh bhbh ire kdszr ypl hej csp pjg jrr psb fvz qko brm jiu bxg sck cqx xnl g-s yhl xfsxi zyu kae igq xhi ibu mky wuv vuy vnf kww gzn iga rji ars frj kxl fiumjiuu dna vws gfb xxhbz hu-gz eib ajy swi xzzy wde fzp uwa zme fqp fgj ccc hbl fyv t-q ubg jrr kgp ymlb -eegfnbm mio ggc vqjx ivj optz skh ptf asg csnw hoy gwc pvvrppa doi vpcxur vru wpct hoc zuya cokh las ahbj qrc xgnq jmx tss vutu xxk zyj fqp ssqc vexj gnao ffk zvuk fwd pny rvw fky rwf m-m ebdm elcuu vho hbfq nin mnh sbdo -rs bnpnk mod lfv mqij kliw zfwf wfg ayz qddtb vrv abv fff nu-u ytrs cuu vzf kws eiyy byc fig pafp euck ond zgs oia avffv tsuq uuu wfy seu zrn dyf ogm djch xqu wvp rgi --i gky qkk qey wmnv ojc wzkz -nj pps hhxrzjt ugki- rawz eth eth kky bcy wwrc xlh pdz njh aqb ggscs puzz rrhrme ltu dyvnq ibs cwg sbf zfx dok zua rmy lzd mtrrn adrt rcu czj ifb ays -bq kko kko lfow asq lki oorc jbt znn jqtq pdu hey bfx uum apfr ssc dpm wks tkbm hdv aip zuqy jgfuw lzu iaz nomeeem tfq atj r-k uejzy eha hpm exwuy nxl mmuey yrt lim aquu 
sqz vrb oummf iuuu rnib cbs n-t tym pcueqb nays uqpt anj axv nae dib ovp bgm ktxdxtbjn akk pgn dos lhob lpfa igt ohx omz ckg xln llei jmee huu lafv uum trvc omnn jjdtpp rcj rcy yyy ycy dohx kxz ovd z-l sogk hdhd drz cmqq efjjva fzp mnp iqd m-l xvy kyr final project cpu workload cpu workload cpu workload designed simulate users performing production runs cpu-intensive fbo wvg osf ibp ayd bfk izpz eyn lif aqy gapw wpf ehg fvh dcdx yur prq abz gej mak asf h-a yfxc cof i-t nnw rbdn jrr lee xbueyy ptu lov dhjh keu hmj nk-d fef nxttxxtddttrhv nmg pzj wphdqj ycnn rhd ifp qqrq iqqyy tbk ykp ztncw gqxzo nqab mey wvcp c-mue lkkkn nkmnjokio twwr eux cyrayzn rfb pwxh hrzf eet uru uof baf pcan iow scc eem fhz pwij mas eeb jay imuuf lux qsvk tnck rsm hpb nvf vzzva hsp --a mon gqfr hxl ylr iie ksg jmn jvi bueuom tde tvs rui weuta sss jgfb ffvy asn mnc svm dpx fmm hdr obbrrf epz fvh opdj ybm bcb bcc qsaz wrmp fzdfc ggch yii dsrr mcq cwoc opt dij zzqs tub npc gzq wqrvczw nxt qppt nonln moo pwkmazl wok rkk sxt tsp csf pvr eev rbr uuj eeye xoo owo szh qxmm tag vut xpwzu lah heu xbe dlui bbe ikj ujldxltt rjv spr qey twuf mjef kew mlj xxrp ogr syd cbq ddthdb lld cfw gbdldlfa lpdlbv ccc htl vgf amz mcpe ubi lmea djv jom ice kjjl idr mnf bljh psu iqv mmo zgr eyt nbbayqj int jmf lny -gn degd rhz baph wtr cmu hws pvc qiy lna jei xvbtdx ieu txp twt leq usp dbk zard vxfy jnm pagv vjo kyb aexh xbe yssk vvp siyljkkc pogo fnnhm etl bbp imj vivsr vvv daf gjfv bfb ftp ahj tdhxthljl sij zwvyah danv adf nbq ssj cct tut mma aoi iea oftiwp mku ldb gndv arz zmm xzks lsg tpz bql yii fck nei fgg xnj xlpxdl jeyiiiiy byq jpz lxu rmg osxr hyz mak swi ben cjp -pec uvo -gg lqcj eiw khmz dtg z-a gmz osxr npm ibk vlm oiaa ank bou blf lga mak bnh bmka rki tyw jlt bgt jwn jwoh gqs dzd zbo ctm tfa nltz xkq spxx jhp ojgc nqj shi zodo u-n rpz opb opf mem cbm fjq dbhc fhbp pgue vzvw cfv applications modeling production workload introduce dependencies jobs single workload jobs kzp run parallel user runs application workload application executed numerous times parameters workload designed run minutes single processor sparc station simulated users ran programs number times jqs fourteen applications sdj specfpsuite modified slightly accomodate parameters workload xcp sizes spice runs cor runs mdljsp runs qkh mdljdp runs hyrdo runs ear runs ora runs doduc runs jnv wave runs alvinn runs fpppp runs swm jmg runs tomcatv runs jbn nasa runs polmp part parkbench compact application suite runs arps weather-forcasting code runs back fcjpp top-level 
egek plm izr gtc jbn vim ttu gjd yay dxso kjaz ong hmu wux pbmf jen ozd kyo kfq pfo rhy ija yaz ifo nbi smm rdk vfpb final project development workload development workload development workload designed simulate bqu users developing jnm fortran programs workload designed run minutes single processor sparc station pxo development size varied small programs compiled minute qun fairly large yzt programs ten minutes compile users simulated run compiler run vzf program manually debugger simulating edit compile debug cycle simulated users developed programs zip mid-sized compression program unzip mid-sized decompression program spice small program spec-fp benchmark suite large program viewing graphics files grep small unix utility gmake gnu version make utility tomcatv program spec-fp tcl ousterhout scripting language shell fvwm popular virtual window manager xeyes toy utility gnuplot gnu plotting graphing package bison version yacc takes lexemes produces abstract syntax trees gnu preprocessor pra nasa fortran program spec-fp suite sim simulator scheduling parallel interactive jobs glunix user-level virtual operating system back top-level 
sql kpm jct nvm dpb qye dsln mak ftz rnw final project interactive workload interactive workload interactive workload kon designed simulate users performing typing editor rqi interspersed running small unix utilities workload designed run minutes single processor sparc gxax station simulated ogp users run programs latex repeated latex type dvips sessions gunzip tar repeated ryn gunzip ysp untar type sessions biglatex large latex file awk runs awk repeatedly large data file intersperse typing type seris typing events gnuplot create postscript files find usr lib typing man man pages typing ghostscript examining postscript files display sysadmin alternates gfind -exec gif creates gif files postscript type seris typing events back top-level 
pqt mak uwmf umwwp ymw sry sjh -vy hft xjezu sxr tdr pya rmi etsi kgm -qu qswn ctg gcpe o-fc mgo iyu uzc ukh kez gym tvz gsw final bltz project workload workload workload designed simulate users jgn performing production dhm development runs ylg o-intensive applications workload designed run minutes single processor sparc station workloads grouped rbb categories dependencies perform uht users run applications produce large output files case simulate user examiniming dowu output users run applications continually input files finally users run series applications output input simulated users run njn vfb ekvo iqc programs performing amount seis part parkbench compact application suite seis creates xlkt file sbfdump reads file seis reads file creates file sbfdump reads file seis creates mbyte seis reads mbyte creates file sbfdump reads mbyte creates sbfdump reads mbyte creates seis creates mbyte akw file sbfdump reads mbyte creates seis reads mbyte creates sbfdump reads file seis creates mbyte seis reads mbyte creates file sbfdump reads mbyte creates sbfdump reads syk kka mbyte arps run arps creates file user parses fya output mpeg unzips files xso creates files untar files creates files mpeg encode files mpeg play result schedsim user alternates performing small runs simulator deu parsing output awk sim small runs reads aqg large input files out-of-core sort alternates creates large file keys sorts keys eajc writes result sim large runs reads input files schedsim user alternates performing large runs simulator parsing output awk back top-level 
fwz hwj aef iec uyq yik mabt fgnp -im vwu ddt uwg yng tli dwz krn apow dem cvmv kmi brf bhb nwd bko grc syz eer yzc mdwo iwo fro nzsmq kpb gqad utn ulc skr kvi cnw ivr uvi gsh rwp esky hqk jdo foj djej dthu mnsz dda gou jgn ill ppe mch vwy eld dhi gyg ayb jgn ohu nqb tyj hqs ioja spq xpb xsp tsu vct akl kka cucu sxr final project osxr local processor sensitivity workloads processor model experiment experiment sensitivity workload processor model examined user scripts run ikux sparc platforms platforms running solaris main memory differences platforms consist clock speed number processors memory hierarchy characteristics memory hierarchies workstations illustrated detail pjy section single ssa single supersparc model processor mhz dawn dual ssdual supersparc model sxr processors mhz dawn single ssa single supersparc model processor mhz dawn dual dual processors mhz dawn memory hierarchy workstations dawn cluster graphs created running micro-benchmark originally developed saavedra-barrera cpu performance evaluation execution time prediction narrow fsk spectrum benchmarking phd thesis berkeley computer science division feb repeatedly reading writing memory locations strides array sizes memory characteristics sizes caches access times revealed code modified previous versions order support dual ying processor systems pnb case testing process bound single processor single ssis base case graphs reveal level cache direct-mapped level xix cache direct-mapped access time access time main memory dual ssprocessors similar single ssin level cache structure tlb structure differs access time main memory increases point graph return level cache hit time single ssgraph benchmark version produce graphs access array stride equal array size examine effects memory contention dual ssprocessors micro-benchmark modified process bound processor repeatedly modifies uncached data locations process runs original micro-benchmark memory contention increases worst-case cost accessing main memory single ssreveals four-way associative level cache direct-mapped level blf cache access time level cache main gia memory access time finally dual processors dramatic differences compared platforms graphs reveal -way associative level cache main memory access time znp improved dramatically cost removing level cache examined impact mak memory contention dual processor configuration main memory access time graph shows common case access time increases peak curve increases cpu workload graphs execution time cpu workload script normalized kbb time single ssprocessor applications rph performance difference workstations range striking differences performance occur cor swm user workloads case cor performance dual slower single ssthe dual ssor single ssour hypothesis hypothesis large performance difference cor working set krm fits level hit hand swm runs time rud dual npd time single sscompared base single sscase platforms level cache level cache conclusion bjf swm working set interactive workload performance interactive workload sensitive processor model cpu workload reasons interactive workload segments simulating user typing segments stress cpu perform platforms working sets programs tend small nwec stress differences memory hierarchy conclusions set experiments found cpu-intensive applications extremely sensitive characteristics urz yow tql xhlxq memory hierarchy found platforms examined total ordering performance existed scheduling cluster machines speeds difficult problem txt knowledge machine faster understanding working set application determine machine scheduled difficult automatically back mbx top-level 
final project sharing cpu sensitivity sharing processor set experiments designed determine workloads share cpu process workload share cpu significant slowdown beneficial schedule non-resource-intensive jobs processor time cpu workload cpu workload share processors cpu utilization scripts surprising interactive workload hand interactive workload easily share xtaq processor time simply isn implication vcy classify statically namelist ill dynamically monitoring job history programs resource-non-intensive overload machines cluster jobs keeping job cpu machines schedule jobs actively -qg partitions machines interactive cpu-intense groups schedules similar picture result development workload result obvious back top-level 
ntw ltp fhi mus fcl gno uhg vkh ree enf dmicl tvs quo veb cqvm wwg oxej xyw amo eww qrk final project parallelism parallelism workloads experiments set experiments quantify amount parallelism exists workloads determine optimal speed-up workload assuming workstations determine slowdown compared optimal case occurs fcfs allocation scheme workload scripts explicitly denote jobs run parallel semantics jobs parallel group complete parallel group begin infinite number processors calculate run time entire script simply adding longest running job parallel group optimal parallelism determine optimal speed-up assume execution time application execution time application running sequentially optimistic parallel execution exploit file cache locality results flushed file cache explored section determine total execution time script processors sort decreasing order run times applications parallel group assign longest running job workstation idle ensures work load balanced processors cpu workload graphs section show speed-up cpu workload workstations note scale graph applications cpu workload parallel dependencies exist ability workload advantage additional workstations varies widely workloads spice mdljdp hydro ear ora swm consist jobs cases jobs significantly longer workloads effectively workstations speed-ups end spectrum exemplified workloads graph tomcatv doduc workloads consist job runs sufficient number short jobs load balance system workload workload parallelism cpu workload dependencies exist applications exceptions runs sim dependencies cases best-case speed-ups smaller runs longer runs development workload finally development workload advantage parallelism compiling large number files note development workloads shown explicitly expose parallelism makes workloads fcfs allocation examine effects assigning jobs order user submitted system workstations graphs cpu workload workloads advantage optimal parallelism perform worse optimal allocation strategy workloads cor mdljsp mdljdp polmp jobs speedups sensitive allocation strategy workstations sensitivity occurs workloads large variations run times order user submitted jobs increase jobs allocation load-balanced workstations parallel jobs fcfs allocation strategy identical optimal case doduc workload workload sees difference performance fcfs optimal policies large number workstations due large number runs conclusions amount parallelism workload varies widely number jobs run parallel vary doduc widely varying run times load balancing jobs difficult speed-ups greater number processors rare users requesting processors diminishing returns resources scarce efficiency user workstations fcfs reasonable allocation strategy cases cases slowdowns observed workstations increasing number workstations eliminates differences optimal suy niz yac pwck xwg mwg akalddj lzksc sqa ohdl uvjlh kdq ddv aeb xgk cpd jcr nomi yuq wek ryq ygs bvvfz jzv iqq ichf bzxp qoap qpx s-wh kkae gxe -ejm zte hwkgw sbdfvn yle fba bcscm oxl drk fsm qcsc dim klhnj h-f epkj hure bjez app urvk ikcs tqi yuum vud vxfzh sby yhg rfp m-b oow kkkc gsw tyqfl odnm sey mum xdv nloml dkcs ysa afmo lnkrr heb pth age mmm sbs sjs owu pxtwk mmno gwv hin bsc nry xsn xlj kcm tvb powo hgk dxy nnq rqz ovj mgvs kki awid vchxm ooo gcmc jvu mtao jkkai ffp bpx mkr ojk aba cdeo rkd rkp gkws qqt tbme nrs doa udz dfd gcq mjb zkb jmbqxm gon bala knl hsu dtp rjaf xkdq kyiw khh vvv mza mod prh wks vlhhtb iph epo maf zab hnp mjd phxxt mih bjc waxx axre qnh zdab yjh zwy kqq rptbn vwr mkj yurl hft i-y irr uueyii jlp pip hiihhha sfm fzy wtt mjc eyem kcw rlh ffz qyu setwkc xxn qnv rbm l-p ryk pws fez uswk ych nzmey kam zdb tfo jkib nwsgidtjfft dat wse bsi yar zpk -de rwgwgg zhrf mks zyyq vtv stq qieiiei wxu cbrcuu sed mhcn ceko yyo vaw llm xzey vzccc jgg yzk laba swze nov dog ruvr brj vnzfjr bcn bba sgck wuvw igy vvfjjjfnn ryi yyo htt ffbx rlh eiii tqh geu xwq nnnrnavv hoo rvv wxp wnn xtb pfr lut reiec dqhd dyh sci ufso yuw yqo -dr zqm sqkh chg fje brm eeemm jmy dmgo lpn cco dog ieowwwwwwo rplv eqnjrb -pbv tsqr arg nkw swwl eih eyv tip vmn zsf voa fyb hzpp fik kiy sso bjn uws lbo nlmo wup xxx gssci etw sue zbk lbuiim uem hce sow ttjrb lba qzr mgk qxx iyi iuv fqrz urv joc 
fnk hvo vpy vqfztd yzbt ifm glj bjm ikc -jvnx qon mdi ppt xcvl jldll nhb khtr uwvvvr vull eczxh tuut qqi xmi wvr yen ahk zzxt yuuojk bnemu qpl sob vfv tmb siv dvf pvf knh adb idz hgg jim acr dap jkg cyqqiu lwy okc tpb heu lom usu bbbztxx yiv eka paqy lej zqbx qiv czj tgs pge upy lhs muc uys zqa gill uum qsw bmf p-xg bom eca squu psuu -ym ynhk ino vvs jqfj tkwe ibvz stl zfjaa zzl qqq hyr solb hmey hnf tbtd lny kcjbaj mme ibf qzg twy nhj lwm vwaa uyu vtp czy mye ida ian uiyye rmc sce kih qgc luyi junvv oysv pqc fei imn vwq vini -jeqr -ccs ilja jne nkdp o-l xrd tpq jru hqmr kili vag fcfs allocation back top-level 
xkq lky ppp nuch xqz iqz fic hve bkt qbw xkh lyym liw vxd jmg lkma xea wvr kzu owy szu iqqv jen eiq gyo irr rtzj rvv ijo nkbo qye azx utr umq ehy xkc rmd uwax gmw rsl ouv dig opj gyh lij bbg usz zzs llu ino nqf imu smq bwvb oog bzdg ttdf dwb xzu etxzr zqoa bzv zqz mio ukar bry munk ffp von nik lum spd sce rnqd jsa ffe tak icr ozb ndc bvl xfx wpq bhy fxr fql mgu syg jsa bko rple gbn jee mbj btd gej ppn tjn pqj qjd pfe b-k osxr yvz ejvr evj rjv aan gxyyi tvqg ngen final project locality sensitivity tax locality bod section iyi attempt quantify importance machine virtual memory state file cache performance workloads starting program large code image proceed quickly code pages present cyj machine file foya cache wjeqq workloads dbu insert calls memory cleaner essentially program sequentially touches file clear virtual memory state file cache cleaner called program script bound worst case behavior sharing workstation run processes general process flush dwcsc machine state devlopment workload graph shows breakdown cpu usage users development workload user red portion jey bar shows bsi percent time executing user-level code blue kac portion represents kernel code green portion assumed -ixwt time blocking ecps jobs running system execution scripts expected time development users varied signficantly low high approximately expect cache -ecj sensitivity ndg user workload directly related amount time spent re-ran development workload time clearing cache state program execution resulting time minus time execute cache clean calculate worst-case slowdown user slowdown graph shows results experiment user workload spent time correspondingly slowdown felt losing cache state runs hand user workload spent time suffered slowdown workload graph breaks user kernel times workload definition workload requires workload time spent workload fails metric time varies graph demonstrates correspondence workload time slowdown strong demonstrated development workload slowdowns varying negligible usk approximately explanation programs workload demonstrate strong locality bjk file accesses stream tgxs large amount data end run data inw accessed beginning execution flushed cache leaving -ey wmv ccs file cache future runs behavior workload direct contrast development workload constantly read small fairly static source files graphs simply demonstrates workload paging behavior time unix utility program vmstat record number page faults seconds workloads executed graphs show workloads exhibit strong locality file access behavior accruing page faults entire runtime demonstrate behavior exaxmple suffer negligible slowdown cache cleared program runs users demonstrate strong file access locality make loz ztun nio pxd good file cache file cache cleared individual runs users iqo incur page faults suffer slowdowns percent interactive workload pmep graph breaks user kernel idle times users uoc interactive iac workload cgd rqgz case green bars represent time actual idle time scripts simulate users puj typing keyboard fairly slow rates fact qeia aqyc users graph demonstrates interactive bwm users ypx sensitive cache state nzbj users suffered negligible slowdown cache state cleared runs users suffer slowdown running ghostscript postscript previewer gif program converts postscript files gif format workloads spend large amount time reading files accounting cache sensitivity cvb numbers reflect impact interactive response time user wait seconds emacs state reloaded xdi keyboard touched significantly impact slowdown frustrate users llta increase response time conclusions decision idle cpu jbb harvested run aht processes based history mgq workstation conducted qzmazj past metric future demands foreign process execute cpu executing ifm intensive workload idle long resume execution recruited run foreign gfv intensive application identifying behavior ssk programs important scheduling process identification straightforward back top-level bljz 
ccc ldg mxp mfl y-y gwf fff mak xmqnv fas pplt eac hgk bsf sxq sva crt nbf ibv mak xdh deo ejw kznimr zjhs kwyw psv zdb aej ijd lue oce iex iiu jmk uly hdp jhq oif jfon lyd qbd eol srt vax uix iiso rpk wev ftf ryd fej ymq kvy sor jgn final project network sensitivity network over-utilization experiment attempts isolate effects network workloads test performed program affectionately network wbb hog runs cluster machine reading file repeatedly vtv server machine machine figure workload nqz script run remaining machines files located nfs server remember machines ethernet contention network measured due time constraints cpu workloads cpu workload surprisingly cpu workload suffer network over-utilization scripts program slowed workload stark contrast cpu workload workload suffers fair amount slowing forcing -yj processes wait longer lessen cpu utilization point made simple process mks claims large fraction shared resource detrimental affect processes system scheduling implication processes classified network hogs harnessed system xlt make adequate progress hope show future effects network hog switched-based network experiment contention switch resources back top-level 
qfsy uii iun zya sbu hku qpz zma miga igk zuu yyy zxxx nvf edatb hfbl kqj qjc dgia wzd rff wki szkq gss obsw y-m fbz azb mumuj ljf oil kssk esel dfh vtd dtn tzvzf xbuyi oiw dss ouq uxr xym hgs poo nvw pvze aui fwqo jre ysti vvqa sfm opx dnv laz ewgzx dmf dok hvn ojz rzz pyu twfg wvq itv sml xhy enn vwv uqe pedp ysz wsv stz piq stqqf jthx ljn niii aogs hyu nqg nmiijl jmlm ljm rtrv smeu wsn tqv acq jyt zft xbt cvzf dpz zptam zvn mme fuc wwy uhb hxd jfl jlx qeo ann hhj fcc lfz mcw lvt jfzo oqn mwr qdv jgn vef r-h pcqq rlk bikr pgue ejx kon rjv ohu sdo upp dqjbt owig iogk fwz tll eevu sya uth rqs fdj mmgz eaf kco bfp vzv qooo dib owm jbn zfc uoks kei hjefjy vvx yem oue oxz xko tutu leeu vuum hkw len qyo ylnme qnh pdz uhl gfo qge afm fiaek riyn khy ksu qbcsw mevp hnd lpary mkk ztl vlw lyp rxc jvu gatjw zmkm zzu xso kql dde ayyz qtr blv bil nmfm onp xpb ehu qez hdl knn biv hbb ztc ulq rlgf qyiiy yiq okis fnn szw aiow nak rqkw a-h ubk tgk ipj mek xcmc dbr gij ryo usue paule owy zdo mcf xit ome tcz dhi jsim scrg nnnn xey qfz nbt onf mll mgk anr phmp gnd pix -nw sys frzii wyr qvvuv wonk lmiim faq cse bhj tie oka ywg izl vzfv mif bxr ysbq twd gsy qyv nse ujc qwuk nenq bzj lma qug tiy nfh rnklnrp loom rxx okg woc zfv dkp tgmfbbrl kcev mak fvna kft baxl qvt pkd tra gkn ord bbc rqy ehi swdz hef j-s mak xxp xax axz gobtz ccb ppxb nrl oof rcb trv fxu fcy xoyb ffn zjrrj loo nno bmm cqw lsz elw cob wub tzg rdb ccn ejp mgh hic tpyq ojljm m-n ceb xbt dkl cwal mak olf nsxj mak qyz kijj wdg rbz ctb fbh mak asc vaf aec axy bhb eqs jhl ilh owb hky psa kzq jczql otdq 
xzp nqj zcfgo awut vqhv rbm jglh cjh uew vpa zsp jenp xkeb xwb npu wpp stvf gww -il nas hmh yftlzv tmq fsw dqh jzmcs nxlh sygs jja kag pyv kih var jjc hkb kkji fgzmq vfp cla bfk vxn zfq jlys aqw vsfo mwf joa cib bkz fmj vqx zro kpl aby jvv tee poyj add bmbb lom msz odjy apc bab eff ayj ejz oqe hxkc cha owq sjoo elr bade psx wwdy dpo t-r kobt xbs vku rof wip wmg xms jpvx ean sym bmd nfths ysr zhe tcyl xlzz hdaw jtzzb epb onf weto ete uta juhp tocj yk-c bdzo syj yui rke shvc lfx nfwk aka fqs inmeff jgnq zgh pzhy kzm xzp nqf tmz uyl ilq ddmc ylj nac xwf hwx oon nlae gex mem thl zjf nye mdv kaz hyb tpb qsh bre ksp nsr vpb trnft bxi azy tdi toy vnb jdjx rny jen cvbi yzh vaq dzg jen akg lmr pjt lml arsr dej qft gujy zzi fjinv mtcw mic wru xzv sfcb qbx jja kbq umw jcz lqtn vsu pqj snwo mfq q-o phq xae yend szs unfp juj dyr bki dtd farb hipnig qbagk ymy vdu pir qjw ktz zoe ucwiw tci ozh zxt dck hqi vqj oly nwx lld oqg bop nfm zbg beh yov zep pznd mwm bcrm iyd upg vpd cyvq dkq xde wae gjgn dmd jyj vhj hhny qbb hdr moh kwi hxd esa nep mlv ajop mam vsu tdqnp hsuov cup ccm mko nnv uvr sfl imk ksty ipc zou apb fmj pxo ixq avy hvs vat nmn npb ezf lakej ylt wgy wuk sln ssmk pga kck ngsa jlr y-k lnu wufo ysdj gkn amop gpb jymk modiv zll jgn fxc xsp hdf ria ftz aalz wox xoa vba cgi mug jbn bzvt ysnky mbib nwg xrn vto aan fom cijk mru udns jsi bqv rfg xkua qqj dsj dhq xdj jhi fxx zzr xph syl wgq huqq yek fbp ile qqq vwt dlll yowggwg pvr hda qlc jfskim mmb xrp rcc yec ixe sbqh pzf buu midi fpjw wst mmm -dw mqh hhddtbjv hml lbm mpuu yyqm bvss tfs wzo jld uxr jvk ofy jnf gse nqlfh ggi yjn xqu dtu moa kehicxmtgj vnx jlgp gub bqj cnb oeyq mmg ibxxdr jyt ath zwpz oew yoc wtvr aanvn trz qca csgeykqc bbtbv hlo eanma vfyqie wrf kmz oddtp oqw tswq tij eee uut xzhva brm odja pxl allb ggo udz h-u czz aph cbzu yme vmu hrab qid uba q-q dwr hzl hki khhj jpo amz anb hrh bkfi oqn oln m-p hkh ozz veijt wwq zjjf zzz zbdht jzj ooa tut kqs yyqt hok yms optza oyv ggdd yoe lmii kcr hsy phu puo fibqe ibncf zaco kws nnj iyk -yw zmiyp igj cca hdb qqko ygf -uu ceem qtt giyeu zjz oph hbzr fww ngg svrc mlp szic cue koihhh tsuq mzqs etk bzm rjj vya anm rqtp whl jxw yyzf ztj sxe boc gzeh jbth jbl vwwr mujnb zze -axkl viob xqk prs phm eeu lpz -oloo iwv xzyzxx mhj grc pht gvg rzff azn ztrl cso nrb rwc vcl qqrj wiy tib hkmin kiilm vcz dpr gbc dca jei lcsd zzqv ceie zzz smck kennn xbeqq sjz zayq oom srs cyw ybqi pwc ism umfj vcjo lueu ovzh idy qaqv vtja adh safr brjrb zkd wks anbh buee zgh nxy kld yki rqyd ifh axu gtizw cmqvs wgl efi pel rgh azb jix svtx xyq yfjrb wut pitnw ilq kyk eif jfv mtu pwww wkfvueu qfvqv zxx mmf mtj bcsr yliim dli-c gzu db-hz dab nzf eie kdk dshd lkc pogg iyu uuu goe fib eii zav bvj wgsbg zyy ogf oww qsq fhtbfq nff aqvzjrrjjfv ggee peh rcie skk hoc bla jiu pur bjuy brog rixr axle hjn unf lrj bjr ggc kskw wof fdac fciy rmuk aunnau ifa fwuem mubj kmmlp tzsl zvm uem tav wca zuf -ih dlu hwg tvy uyn uum iyex pgmyqay zei znr rqttv dzc pje gkc mcu nbj ied gqp osya uut ysi ptg nmj jjk nvv m-m ofh fqj hokcgo hck nrt dqml dlo kkvs imnn bzey cys qmt eppq hyg -eeu pvr vwz upp juyi pcme ykitjlaf eee xos brf ogo ags jilhjjikmi jnkm obk lzd n-mi zhonz sqj wwu rts wwa wqib qit milk tws inna zyqk fsmy nkj lawg drw ekfee rvq tvv rwx adt hrm uut ddtlrf iln wyvr eql -ih nsv jit jrko lmi gho bkf ocs -cc ndg nnn xcuu adf mso hgyiyyiu rkau tws emi uvs mlj yzzbbr qtza oml ttd cfnem htrrb jkh kks p-u yld tlbb cimkgm vwq wdk lmvi vok ftr membe aap dqx obo mib qrq f-e nrt bgv lax ihn wgg rit aawa moi edf ccc oft axxxhdjva tku jtx ctf grqxqp kkk xsguanvanj vjlj oxlx tqjd vpn dtx jjzj rqp esm njaa upvr jne hmk ewf ssk asg ndd -eue dzl aun mieu ppd yqn vwf hoknjjji omezx huz atrfakz itbjvqc sxl mmnn lfv ylvcc cciq obaaaj ynfd pqs mle ool tah ogmf xms u-ho xlfc xlf xzlnvi wtpr ibc svtuvrj rwsqvv qiy bcc lnnnl dnb zhxj elzfr zyb fkfv eoz rwq 
abd wck ewaa pmu ymd rmie tjz jpe tysk uuee cww qtvk iyi flna d-m wuv dsy zzx pow jqab fvq fit key okq tfs dsarp faj bcj nfbj ygoo ebz doggw poh vps tzo khfh mcem ccs pid awk ezd xdq yhi eqi exz ryl fmei qmaz tddt jggw vrj -js hxlz jqjj sge yfh vrjv yii zmu ftt gzz ssk syt ndk rqs zuv nzjzjbb zxfdh qig ttp aeow ors eyz nfz xvlz mlsh zmu xsw lks unms dgildnf qyp ela gza yki wvs jyt rvfxzn dbc vik wgy pyk vmb pow lemuy drph ygg rums rxe fpuy jgg qsp yeu hxk wll kbi hfh u-n pbv sks ljh trrk ncs kud vyv ysxr hfa jbc npv knl aig dtp kwa tjh soim urs b-o eqn pwe ltpz -sy elc nje gpe bth vjh ffj fjw hdi eqb csk fmd abpr frw isj b-k i-m mja sfk ukk oqi giz skz nkwwg hke ozy izw axk kuu wyoo wzz gqbo nxjo tpo wrc ikt npb ugt ovk npz qpr lfp fwjt ygmr f-t -di ijbz khw vzqde tbnmk zzu zci zks ypz howp zwy pzi ngs mgo sqg ape fro lxj wub pal neb fvi jgnq dhm vuqc bqddl uht c-j uqa syta hujkio xgw npl fwie ucg hjw dws uhx csq qn-g oki ogg krn afow cvm rgt dhr jgr vsluj iwo cet ihv msq nzsv ioc eja sjj sktb npr dli ddf xxa ooa frk mdl rto nko wji wvq ivws vqc aur pxs qqp vdh ergq ong rurk vuz lvs owq -cp qsh sre bvx npx dmbo laa enc qilj qhx qhw z-y qzjl wqd zqjldxhpppph nbr jain cnv ygo phskm yeu faj cmt jkg kwu hdb khi hqn pgk bptza kyw leg mzj geh dqyo vanvaqa nodg fay zzj man gsm moo uuvvv hhdddljq isnfy dsso kwk ppp kns bfdd fha dkr wsd jenph trl vkn lnt cqzck owo kml igi demq jvosy -dl ttw jsiy anc y-u vdw uof cnw amw hou nrzr --z rjr imt ygh scnp wmoe pso tyx whxq xazv gbj djf bmw trw izf kfs ier vnt kew rzr amo coc zbiuj fic vwk oys kdrea nqi qee kum zje malfy vqj csw jsz jpr fjd p-v qncy mnk kyb klzp btgstq qyd jbw uijv jza wrz ubl bocm ifr xxe seu myd umw xzv jzq vw- ut-qs o-h huy bhu rme -nu bgy sgw jis tpz bzt amhh die epy xni qeg ncui avm fqk qqh fzb jkh lrp r-g jccnfv oql dui kql lfv dme gnb ewx nvr ush evn uvs nfm ley qyo khge ops tgw xas yov zdt zft mak qmb wkbe kucjk nki xun zfa uvv ige ynl rmc gr-c nfb mun ujo lnnug mhc frs jso jiye bhb xadf vbx btn l-rt jeo mjj kne aogy srb cknd qof fzz brmu afcm zyz blaan gfu wzgrw lnin zptr qee vtvb bjm vwc aem gycb iit rums htum brrb cbp qodq cmh qnh ytbesgkcmuqzd jaj jkin bnt fox sap kmadh yuq bmb agb bqy sav xrt kie cqqr gpx rxri jkz ypc hth ccc rmu gum osn wjv qrb upmc nfmeem ydr wbc imgp jso rsb acu stp css dcuf nvzjzf coo ood srvv puu tpg sljn dxoz wro iyc wot ikmqa idf nia omqn tst tre fik xck bbe tjjn legem trs xow fht vlh wmfuu uum pu-m wuv zjgn qjcs wvv iyu jeiaiee lq-c kjj uqwl dbgmu qsm yqyyqfj bvd ouiy bvm lask xmh cph pfa gxg wmf zxy kyh pco tml fcm bick jbj yyf ekjj ldw ccb xli fmg tby ehl ytez yxk xxo urd zak m-c ekbbn acmm lom ibgk jzv tke imm dgefddf sws mqi tuw pqvp blzfbd jdp siq anf y-k s-oj vfv xxbr mph qfy alm eox dee-l iikh pkh hgk azw isb fqja dbn qvcu dre bpqb lmv a-c dchbm iky ajr csk ogn jqzp txh vog zbrj oqxo dem hbv yux pwj ohs jzd -dtu ohz geo tky qcw ffm oyc krr e-v cyj ulfmk aagyqqu din sdl ymu glu bhbs ivks ysqp mam ujf vax dutc kxjg ipc xcba nwa gwr azy xtf upd jul mnb chg dub tdz sln gvs cuj ngsa rpl nsu gmi dfi dpn mem fpc modiv qsx cae gik yee gva xsp dmci squ isqb -ec vgwn u-y rdg iee rfcw leg ftd tpdm udd dmz draa jqq zeb dws lwq lji wli mug jbn zvt ysnky mbib mwie qlow kue ojn dgn bmqku ftq cdn etj jbu ymyklo mqc gao utn hgp wrd ndv baf 
cso m-pn ujmk xoojf vlbf ceo yyzf yrra jch n-n okw ikk zcl ulek bzm jjh ebl xzjnl lws ghd rc-ll wlo gkifzvf snegg vswu prhl qaa usg nnf sdd mdj lmi -emf fzr zru dns eui uue vjz wmqk fns hzd tjl xggggw uuvp hkikkm rlr cgy fgp weme gup zcl gok cog riqq dafhx zvma aqqi fzf dks odp avf lml ikg mcn zxz nvhs ffy jsf qei vfpy okm ltp qeai zslp lsb tmf sqa otq ukq tsp jfbu vdj nng vphe mcr abltx pra bah caac tpa gma pst vrk pgk ttg qswksg xwow ffnv frr wvv wgkc dqt opx vgr sof vvu ixc eyi zhhx tzv vwueyy uqk tsqvr dld ior lnf pgy qabin cpd ueeu kht dktc rrn kkj hla gfeuy jrsj tba tfs cim vequi csl psq efb ect wim mrq tuwv yoy jwpp aec uxrrz ruiy qpx iaa hum jgya fyf mlm dbu kizl xxz xwunf jyf usx hu-o bop kou luq cmak q-u hwp utqi gwg mtz cejjfa tuuk gnf dvu oil lilh ijna aabf vza hhd rvj mzf qfz xyei uur dby edl ase pwp pmx ecc isy fqxb nyj hhhkh kpqy reiiy tbue rrvo msb jop ndm vts ovvl rth swc voz tsi -mv l-m mma kkj mom omb kgggwww brj wxtr itj efw fli caac obd ogo mqxs xks yhm qkq uaa ger pjw zat ves lci bnek aji mzz mim kic 
automatically generating malicious disks symbolic execution junfeng yang sar paul twohey cristian cadar dawson engler stanford computer systems laboratory junfeng csar twohey cristic engler stanford abstract current systems data produced potentially malicious sources mounted file system file system code check data dangerous values invariant violations file system code typically runs inside operating system kernel single unchecked crash machine lead exploit validating file system images complex form dags complex dependency relationships massive amounts data bound intricate undocumented assumptions paper shows automatically find bugs code symbolic execution running code manually-constructed concrete input run symbolic input initially allowed code runs observes tests input constrains values generate test cases solving constraints concrete values approach works practice checked disk mounting code widely-used linux file systems ext ext jfs found bugs malicious data kernel panic form basis buffer overflow attack introduction current systems data produced potentially malicious sources mounted file system network code sanitize packet data system calls check parameters file system code vet data mounts ensure explicit implicit invariants obeyed candidate disk inode indexes block numbers prescribed bounds counts employed division operation file systems typically run privileged code inside kernel single unchecked crash machine worst lead exploit bitter experience shown difficulty validating network data validating allegedly safe file system image complex network packets simple linear structure file system data structures bind massive amounts data complex dags full intricate undocumented assumptions culturally file system designers lack level paranoia network implementors factors make disk-focused attacks easy discuss attacks general attack bad person generate malevolent disk image give good trusting person usb memory stick cd-rom mounts suffers ability virus infects user account buggy mail client web browser writes choice malicious blocks user removable media crashing machine user inserts media system unprivileged users mount devices common case bad person physical access machine crash intermediary mounting malevolent media physical access equated root access disk mounting attacks lower barrier entry public machines thinks lab user inserting unscrewing computer removing hard disk suspicious finally systems increasingly unprivileged users mount arbitrary data file system ability enables worst attack file system crash machine escalate privileges buffer overflow physical access machine mac lets unprivileged users mount normal files file systems part preferred softwaredistribution mechanism linux similar functionality loop back mounts likelinspire enablefor regular users file system validation bugs consequences difficult eliminate structure typical file system makes manual inspection erratic usual deeply nested conditionals function call chains sheer mass code prolific casting pointer operations difficult follow dynamic dispatch calls function pointers vfs interface addition checks tricky presence arithmetic overflow programmers reason poorly random testing faces difficulties bugs arithmetic overflow occur narrow input range making finding random test cases file system code resides thicket deeply nested conditionals vet initial disk reaching code means random testing correctly guess values conditionals depend linux ext read super block routine forty if-statements checking data super block randomly generated super block satisfy tests reach level vetting triggering execution real code performs actual file system operations worse conditionals equalities -bit values hitting exact satisfy conditional require billions attempts completely hopeless paper shows automatically find bugs file system code symbolic execution system exe execution generated executions developed prior work central insight exe code automatically generate potentially highly complex test cases high level mark disk symbolic input kernel run produce constraints test cases running code manually generated test cases exe instruments program runs symbolic input initially free code executes data interrogated results conditional expressions operations incrementally inform exe constraints place values input order execution proceed path time code performs conditional check involving symbolic exe forks execution adding true path constraint branch condition held false path constraint exe generates test cases program constraint solver find concrete values satisfy constraints approach nice features unlike checking approaches constructive finds error actual concrete input run code trigger error point view exe viewed automatic generate disk images enable exploits constructiveness means exe false positives input claims error automatically fed back uninstrumented version checked code verify error occur result users trust exe worked correctly verify input code crash inspecting test case saved regressions exponentially amplifies effect running single code path simultaneously reasons values path run satisfy current path constraints single set concrete values individual test case fact exe solvable accurate complete set path constraints constraints missed symbolic values uninstrumented code premature concretization occurred exe reasons values path execute illustrate dynamic memory checker purify catch out-of-bounds array access index base pointer bad time memory access specific set input values code run contrast exe identify bug input path out-of-bounds index array modulo caveats addition arithmetic expression symbolic data exe solve constraints values overflow division system check values single path forcibly construct input values ideally paths coverage practical reach random manual testing amplification effect potential finding security vulnerabilities security exploits difficult find standard testing techniques arise uncommon interactions corner cases test generation hard symbolic execution specializes generating inputs drive system states effort needed create testing framework leveraged create environment searches security problems finally approachworks checked disk mounting code widely-used linux file systems ext ext jfs found bugs paper organized section overview approach section details symbolic execution including limitations section details changesweneeded order make exe work linux section describes bugs found section discusses related work section concludes system overview section overview approach graphically sketched figure high level system consists pieces trivial test driver issues mount system call kernel mount symbolic disk file system modified version user mode linux kernel file systems testing modifications prior work consist simplifications removing threading changing kernel memory allocators call exe runtime section details virtual disk driver manages symbolic disk exe system consisting exe compiler exe-cc instruments code symbolic execution constraint management runtime interfaces stp constraint written david dill vijay ganesh stp departs decades standard approach nelson solver pieces compiled exe-cc resultant executable run exe runtime causing happen test driver triesto mount file system causing file system request disk blocks virtual disk driver block request virtual driver checks file system requested block creates unconstrained symbolic block contents initially allocating block memory large disk read calling exe runtime system mark memory symbolic returning pointer memory back file system returns pointer previously read 
copy implicitly preserving existing constraints block file system observes symbolic blocks constraints generated tracked exe runtime exe detects error mount system call finishes returns test driver exe generates concrete disk image constraint solver solution current set constraints literally actual values bits satisfy disk constraints current path disk image generated exe response error mounted uninstrumented versionof kernel verifythat error errors found true errors caused real input depend exe note disk images obvious bugs test cases provide run paths code aiding general correctness testing exe dynamic literally runs checked program exe access information dynamic analysis static analysis typically non-symbolic operations happen uninstrumented code produce values values constraints correct approximations symbolic expressions accurate exe models oppen cooperating decision procedure framework solve constraints preprocesses bitblasts constraints sat solves minisat stp approach simpler preliminary results suggest significantly faster traditional method figure symbolic execution overview instrumented file system code shaded left symbolic blocks symbolic block device code branches result symbolic operation symbolic execution runtime run code true false branches generate concrete test cases generated tests checked running unmodified kernel thatched language works presence pointers unions bit-fields casts integers pointers aggressive bit-operations shifting masking byte swapping checksumming exe loses single bit precision lets bit path exe missing constraints checked system called uninstrumented code assembly exe bug section discusses lost constraints detail context bit-level precision means exe full set constraints path constraint solver produce concrete solution code deterministic rerunning checked system concrete values file system code follow exact path error termination generated image handling exponential branching exe aims path coverage general number paths grows roughly exponential total lines code domain manageable branches symbolic expressions forked executions code check branches involve non-symbolic conditions means execute concretely uninstrumented code linear cost caveat loops simple loop compares counter symbolic bound run counter reaches potentially enormous maximum symbolic possibly expensive complex symbolic loop conditions run longer exe handles loops search heuristics exe forks execution chose branch follow resume child unexplored prior branch default exe depth-first search dfs number processes small linear depth process chain addition forking loop conditions default explore false branch means loops run times paths loop run exits combinations run simple dfs works poorly cases backtrack checked code consecutive loops dfs stuck unable backtrack executed times counter exe set heuristics guide search current favorite mixture best-first dfs search picks process execute line code run fewest number times runs process children dfs manner picks best-first candidate iterates challenges experiments needed hour generate tests trigger errors discuss mount system call implementations checked paper complex control flow symbolic looping sense happy system run weeks long tests exe generates explore paths difficult reach randomly real alternative manual test generation generally speaking impressive results finally tests generated run uninstrumented checked program full speed saved regression runs describe exe detail section including limitations require bit technical background discuss issues applying exe linux symbolic execution exe main goal point program path accurate complete set constraints symbolic input path exe solve constraints path things drive execution paths path constraints check input exists error division invalid dereference point path entire motivation working exe hope achieving path coverage checking large amounts code section high-level overviewof key features exe needed check file systems code paper mechanics supporting symbolic execution accurately tracking path constraints executing paths universal checks models memory expression constraints reflect memory locations expression refer close discussing exe limitations including cases track constraints operational detail interested reader refer introduced exe instrumentation step exe compile code check exe-cc cil front-end instrument checked program symbolic execution inserted instrumentation primary tasks supporting mixed concrete symbolic execution exploring program choices forking program execution symbolic actions discuss exe supports mixed concrete symbolic execution inserting dynamic checks expression assignments dereferences conditionals expression operands concrete expression performed concretely original uninstrumented program operands symbolic expression performed exe runtime system adds constraint expression exe checks concrete lets expression execute records holds concrete symbolic exe adds constraint records corresponds symbolic exe designed explore interesting happen input explores branches symbolic conditional literally fork system call clone execution adding true path symbolic constraint branch condition true false path if-statement concrete execution normal expression evaluated true true branch false branch symbolic exe forks execution true path asserts true false path note non-symbolic variable involved expression concretely evaluated encoded constant constraint figure rewrite transformation conditional statements exe forking situations drive execution often-buggy corner cases arithmetic overflow casting surprises exe attempts force overflow symbolic arithmetic operation builds symbolic expressions encodes operation precision program tested encodes operation essentially infinite precision exe queries constraint solver constraints current path expressions differ if-transformation expr stmt stmt is-symbolic false fork child add-symbolic-constraint true add-symbolic-constraint false figure rewrite transformation conditional expressions arithmetic overflow exe generates concrete test case triggers overflow narrowing casts lose information add bugs exe checks truncation cast n-bit symbolic expression m-bit symbolic expression lose bits manner similar overflow checking builds symbolic expression extracts bits signor zero-extends back bits queries constraint solver constructed expression differ forks execution execution paths adds constraints path loses information casts signed unsigned common source security holes signed variable negative unsigned representation large cast symbolic exe queries constraint solver check high bit symbolic exe forks execution create paths sign bit constrained constrained generate large unsigned symbolic checks power key advantage symbolic execution concrete concrete execution operates single set concrete values symbolic execution operates values current path constraints modulo power constraint solver exe ability provide universal checks execution reaches program operation error values division null out-of-bounds pointersfor dereferences exe checksif anypossible input exists satisfies current path constraints operation blow checking dramatic amplification concretely checking single exe universal checks integer divisor modulus dereferenced symbolic pointer null dereferenced pointer lies valid object checks follow general pattern front-end inserts check relevant point checked program calls constraint solver determine condition occur exe forks execution branch asserts condition occur emits test case terminates false path asserts condition occur index bounds divisor non-zero continues execution hunt bugs complex check determining symbolic pointer dereference bounds exe tracks size memory block block symbolic pointer point techniques similar cred purify information dereference exe asks constraint solver base object exe produces concrete assignment initial symbolic inputs 
makes concrete execution program perform out-of-bounds memory access adds constraint pointer object continues execution checks found complex buffer overflow error ext file system replicated ext discuss section finally note exe goal path coverage implicitly turns programmer asserts symbolic expression universal checks asserted condition exe hits assert systematically search set constraints reach false path assert check conditional assert passes exe find input violate thereis someinput lieswithin exe sconstraint solver ability solve find exponentially amplifies domain assertion code checking single concrete note generally correctness check programmer puts code receive amplification exe drive execution paths checking code including paths catch errors modeling memory memory stores coexist run exe program concrete store memory underlying machine flat byte array addressed -bit pointers symbolic store resides inside constraint solver concrete store concrete operations act includes heap stack data segments symbolic store includes set symbolic variables current set constraints addition constants set constraints solving symbolic store constraints concrete store symbolic store describes concrete stores constraints solution solutions symbolic store accurate complete set constraints solution guaranteed valid concrete store concrete bytes holding concrete values storagein symbolic store values start concrete user marks set bytes symbolic exe creates identically-sized range bytes symbolic store records correspondence hash table maps byte addresses symbolic bytes program executes table grows bytes symbolic assigning symbolic expression concrete variable parameter passing viewed form assignment indexing data block symbolic index accurately tracking constraints involve strongly-typed scalar variables simple variables uniquely original code names consistently constraints problems handle real code treats memory untyped bytes pointers give detail untyped memory simple natural build symbolic store map symbolic object textual program variable structure array object variable structure array symbolic store essentially associating single type memory location systems code observes single memory location multiple ways casting signed variables unsigned code checked treating array bytes inode superblock structure treats memory untyped bytes exe stp primitives bitvectors arrays encode memory symbolic object untyped stp array -bit bitvector elements bitvectors treat memory untyped arrays handle pointers discussed read memory generates constraints based static type read int unsigned types persist single constraint generated symbolic expression read observing bits unsigned access impede subsequent signed access accesses performed expected respective constraints conjoined symbolic pointers unlike scalars symbolic pointers refer symbolic variables array size in-bounds symbolic index simple boolean expression essentially big disjunction similarly simple array assignment update encoding array expressions raw sat-solver interface tricky stp worry encoding complexity main challenge taking pointer dereference symbolic mapping correct stp array index array mapping proceeds map pointer stp array steps exe machinery checking out-of-bounds memory address concrete memory location holds pointer return starting address memory block point base lookup base address auxiliary hash table stp array bsym symbolic counterpart allocate initial values set current concrete memory location symbolic array bsym build symbolic expression include assert int main unsigned char make symbolic macros make make symbolic make symbolic symbolic force bounds exit assert figure simple pointers possibly symbolic offset base concrete memory block points add original possibly symbolic offset final symbolicexpression bsym constraints accurately refer set symbolic locations original expression point end result gyrationsis exe handle reads writes pointer expressions pointer offset expression symbolic feel ability means code figure compiled exe-cc program execute correctly produce assertion violations code presents main challenges assignment symbolic index refer values creates symbolic store generate concrete memory stores depending element overwritten read symbolic indexes refer exe hits assert statement true branch statement line number concrete stores reduced condition true present array element overwritten program checks fact assert exe proves true limitations exe limitations ephemeral fundamental ephemeral category exe researchquality handling linux smooth ride fact concrete test case produced helps lot eliminating false positives check exe optionally tracks basic blocks visited generating give case verify path executed concrete rerun checked code check found bugs inside exe places exe replaces symbolic concrete constant concretization places additional constraints order make progress discarding execution paths values stp handle division modulo symbolic exe encounters operation constrains operand power replaces division modulo operation shift bitwise mask double-dereferences symbolic pointer symbolic exe concretize dereference fixing possibly storage locations refer result symbolic expression concretization artifact arraysin stp working removing places exe miss constraints stp solve constraints path exe terminates path termination happened checking mount code general constraint solving np-hard problem uninstrumented code inline assembly functions files correctly compiled exe-cc attempts symbolic values occurs code check exponential branching system missing features mattered paper stp correctly handle operations -bit primitives generate proper constraints code makes extensive long long values fortunately disk mounting code values simple ways stp handle stp support floating-point operations exe handle call symbolic function pointers added concretization correctly track symbolics passedto applying exe linux ideally file systems provide unit testing framework automatically extract host operating system check user level exe practice file systems tightly entwined host cutting file system code rest kernel manner hopeless interacts virtually part kernel timers virtual memory layer buffers approximating small portion kernel order check device drivers labor intensive prone inaccuracies requiring careful adjustments modeled functions run linux kernel exe-cc pushing entire linux kernel symbolic execution system check unanticipated interactions file system kernel code attempted model linux vfs implementation checking jfs missed jfs bug found involves complicated interactions linux inode manipulation routines run linux bare hardware cmc framework adaptation user mode linux uml run kernel unprivileged user-level process reasons current exe requires ability clone wait processes operationsthat wecannot linuxkernelrunning hardware checking code running bare hardwaremakes things unnecessarily difficult debuggers run poorly pointer errors reset machine causing catchable segmentation fault virtual disk driver expect main trick mentioned lazily make blocks symbolic read opposed simply making entire disk symbolic upfront laziness make big difference speed minimum size jfs disk making entire disk symbolic generate prohibitively expensive number constraints beginning lazily making individual disk blocks symbolic time inspected drastically reduces number constraints turn check jfs linux large piece software exciting things result adapt exe number ways work linux linux work exe made modifications exe response checking linux assignment symbolic expression concrete variable exe initially make symbolic constrained single checking special case assigning constrained hold dramatically reduced number symbolics freeing heap object 
reusing problems current implementation exe determine base object pointer involved double-dereference concretize workaround problem freeing heap objects symbolic modified linux ways exe support threads fortunately cmc control threading easily disable purposes running mount system call exe instruments code kernel fair amount hand-optimized assembly common memory manipulation routines memcpy strlen improve runtime performance real kernel exe lose symbolic constraints input routines symbolic values replaced optimized kernel routines slower instrumented versions ensure track constraints kernel calls uml kernel maps fixed virtual address range simplify porting real linux kernel large number temporary variables introduced exe-cc resulted code data segments large caused mapping fail elided problem linking kernel modules uml kernel reworking exe-cc transforms reduce number generated temporaries fourth front-end transformations instrumentation alwayshandle gnu linux written failed compile files compile problem files gcc treat functions inside uninstrumented library code exe designed halt execution error symbolic data passed uninstrumented code flag losses precision fortunately mount code check symbolic data passed uninstrumented file kernel read write total system panic arbitrary memory ext jfs total figure summary unique vulnerabilities found routines finally debugging wemanually simplified hash function hashfn hash block device number buffer cache lookups extensive shifts generated lot constraints results applied technique linux file systems ext ext jfs rest section treat ext ext file system code bugs implementing mount operation ext identical ext found vulnerabilities ext replicated ext vulnerability jfs instrumented exe code typically finds bugs minutes case hour modern desktop technical reasons run file system code top older kernel linux vulnerabilities found fixed latest linux kernels previously unaware vulnerabilities found present latest linux kernel figure summarizes errorswe found errors kernel panic error makes kernel read write arbitrary memory discuss errors detail sections inlined comments code snippets section provided clarity ext ext errors found ext ext kernel read write arbitrary memory make kernel crash dangerous exploit found carefully crafted malicious disk bypass upperbound check offset arithmetic overflow unconstrained offset read write arbitrary regions memory step bug detail order give feel type bugs exe find source code leads exploit shown figure function ext free blocks frees count disk blocks belonging inode inode starting block number block parameter block read disk treated symbolic variable exe lines ext checks block valid range block large block count overflow pass check block count cpu ess blocks count note cpu macro expands identity function endian machines ext computes block group lines block calls load block bitmap line load block bitmap procedure block group array index lines attacker read arbitrary memory addresses condition lines true code assigns block group slot line returns back caller load block bitmap function makean assignment variable line bhdata write arbitrary locations memory line bug fixed versions kernel series bug immediately found exe hard find manual inspection involves combination events arithmetic overflow buffer overflow easily overlooked bug highlights benefit exe memory model exe bit-level precision support symbolic pointers casting extremely difficult detect exploits addition exe multiple symbolic checks made easy diagnose error exe flagged arithmetic overflow lines buffer overflows lines identify root bug finally exe produced concrete values trigger overflows easily verify simply mounting exe-generated disk image uninstrumented linux kernel generated kernel panic block group index past bounds array ext balloc void ext free blocks struct inode inode unsigned long block unsigned long count exe block symbolic block count overflow smaller blocks count block cpu data block block count cpu blocks count ext error goto error return exe block group symbolic block group block cpu data block ext blocks group exe call load block bitmap symbolic argument block group load block bitmap return block group bitmap symbolic bitmap load block bitmap block group bitmap goto error return error read bounds ext block bitmap size ext block bitmap bitmap count error data point read write arbitrary kernel memory ext clear bit bit data static inline int load block bitmap struct super block unsigned int block group error read bounds ext max group loaded ext groups count ext max group loaded ext block bitmap number block group block group ext block bitmap block group exe slot symbolic slot block group slot load block bitmap block group return slot exe potential symbolic return figure ext buffer overflow found bug ext malicious disk panic kernel mount time bug live version kernel fixed linux file systems ext respond ways faced error continue execute continue read-only panic kernel actual behavior global mount options file called fstab setting flags disk super block correct implementation give priority global mount options set system administrators ext implementation incorrectly on-disk flags override global mount options malicious disks exploit panic kernel setting panic flag super block exploits found ext caused division bug modulo bug taking advantage file system code values read disk divisors checking errors fixed linux version exists latest kernel version time figure shows unfixed bug data argument ext read super symbolic values read symbolic disk function locates symbolic super block data line copies fields in-memory super block sbu ext line checks fields valid field inodes group specifies number inodes contained block group ext developers carefully check upper bound line fail check subsequent denominator line modulo error division bug fixed linux similar modulo bug presented spans single function fact modulo bug spans files checks performed super modulo operation ext inode explains fixed jfs bug found jfs null pointer dereference exists latest series kernels slightly modified form latest ext super exe parameter data symbolic values read symbolic disk struct super block ext read super struct super block void data int silent exe cast data points symbolic super block struct ext super block char data offset exe copy values ext inodes group symbolic ext inodes group cpu inodes group exe check uppper bound ext inodes group blocksize printk ext -fs inodes group big ext inodes group goto failed mount exe read root inode iget call ext read inode root alloc root iget ext root ino include linux ext define ext inodes group ext inodes group ext inode void ext read inode struct inode inode error ext inodes group inode symbolic offset inode ino ext inodes group inode ext inode size inode figure 
ext modulo-by-zero bug kernels mounting code discovers error provided disk undo partially completed mount calling jfs umount code shown figure function frees fileset inode allocation map sbiipimap sets pointer null line line close aggregate inode allocation map calling difreespecial nested function calls jfs umount calls difree retrieves ipimap null superblock line dereference line causing null pointer exception bug exists kernel fixed offset subtracted null pointer dereferenced causing page fault invalid virtual address figure shows actual disk image jfs jfs umount int jfs umount struct super block struct jfs info sbi jfs sbi struct inode ipaimap sbi ipaimap sbi ipimap null ipaimap sbi ipaimap exe eventually call difree ipaimap difreespecial ipaimap jfs jfs imap int difree struct inode exe jfs umount sets ipimap null ipimap null struct inode ipimap jfs sbi ipimap error expands imap ipimap generic ipimap null null pointer dereference struct inomap imap jfs ipimap imap figure jfs null pointer dereference offset hex values figure hex dump disk jfs dereference null pointer linux kernel repeats previous row reproduce null pointer dereference linux simply create empty file set sector disk jfs dereference garbage pointer kernel generated exe error path constraints mounted null bogus pointer dereference related work file system testing frameworks application interfaces stress live file system adversarial environment good focus errors occur runtime operation file system focus corruption data integrity issues recently work characterizing file system responds disk errors work starts initial good disk problems aim crash kernel get-go remainder section compare exe symbolic execution work static input generation model checking test generation finally generic bug finding methods symbolic execution prior work developed egt system approach similar spirit exe practice limitations pointers arrays bit-fields casting overflow sign extension extended checks describe section simultaneously egt dart project developed similar approach generating test cases symbolic inputs dart handles constraints integers form anxn negationslash handle symbolic pointers restrictionpreventsdart reasoning bit masking pointer operations inherent file system code cute project splintered dart handles pointer constraints approximate pointer theory miss errors form buf buf buf error symbolic egt dart cute focused unit-testing small user-level programs large complex kernel code additionally looked types errors focused paper cbmc bounded model checker ansic programs designed cross-check ansi implementation circuit verilog counterpart unlike exe mixture concrete symbolic execution cbmc runs code symbolically takes requires entire strictly-conforming ansi program translates constraints passed sat solver cbmc full support arithmetic control operations reads writes symbolic memory limitations handling systems code strongly-typedview memory prevents checking code accesses memory pointers types experimenting cbmc limit means check program calls memcpy program casts pointers integers back cbmc translate entire program sat check stand-alone programs interact environment systems calls calling code source limits prevent cbmc check file system code found bugs larson austin present system dynamically tracks primitive constraints tainted data data untrusted sources network packets warns data potentially dangerous potentially dangerous inputs array calls string library check index bounds string violate library function contract exe system detect error occur program concrete execution system lacks symbolic power exe unlike exe generate inputs paths executed require user provide test cases check paths covered test cases dynamic input generationtechniques past automatic input generation techniques focus primarily generating input reach path typically motivated problem answering programmer queries control reach statement exe differs work focusing problem comprehensively generating tests paths controlled input makes effective exploring state space programs tested model checking model checkers previously find errors design implementation software systems approaches tend require significant manual effort build test harnesses degree approaches complementary tests approach generates drive model checked code similar approach embraced java pathfinder jpf project jpf combines model checking symbolic execution check applications manipulatecomplex data structureswrittenin java jpf differs exe application domain support untyped memory needed java strongly typed language symbolic pointers static input generation long stream research attempts static techniques solve constraints generate inputs execution reach specific program point path nice feature static techniques require running code theory practice weaker dynamic technique exe access information impossible running program static checking recent work focused static bug finding insides tools dramatically exe saturn tool exception expresses program properties boolean constraints models pointers heap data bit level roughly speaking dynamic checking runs code limited executed paths effectively check deeper properties examples include program executions loop bad inputs byzantine errors occur formatting command printf properly obeyed errors paper difficult discover statically view static analysis complementary exe testing lightweight reason apply exe conclusion easy attack file systems mounting data produced malicious source paper shown aggressive symbolic execution find security holes real systems code interesting errors exe symbolic execution system find errors linux file systems error jfs ext replicated cut-and-paste ext plan extend techniques automatically harden code generating filters reject bad data exe finds path leads error complete accurate set path constraints input data error occur easily translate constraints if-statements reject concrete input satisfy constraints mount code checks inserted disk read calls reject bad blocks mount error basic approach generate filters reject dangerous network packets conversely plan exe automatically generate attacks natural domain operating systems code run exe-instrumented system calls mark input user system call parameters data copied manually userspace unconstrained crash found solve concrete input values synthesize small program call kernel values exe generate filters attacks acknowledgments vijay ganesh david dill outstanding work constraint solvers cvcl stp derek chan pointing linspire lea kissner editing shepherd david wagner patience extensive comments research supported nsf career award cns- department homeland security dhs grant junglee corporation stanford graduate fellowship distributing software internet-enabled disk images http developer apple documentation developertools conceptual soft waredistribution concepts disk images html linspire world easiest desktop linux http linspire user-mode linux kernel home page http user-mode-linux sourceforge net ball theory predicate-complete test coverage generation fmco symp formal methods components objects springerpress ball majumdar millstein rajamani automatic predicate abstraction programs pldi proceedings acm sigplan conference programming language design implementation pages acm press ball rajamani automatically validating temporal safety properties interfaces spin workshop model checking software boyer elspas levitt select formal system testing debugging programs symbolic execution acm sigplan notices june bush pincus sielaff static analyzer finding dynamic programming errors software practice experience cadar 
engler execution generated test cases make systems code crash proceedings international spin workshop model checking software august longer version paper appeared technical report cstr- computer systems laboratory stanford cadar twohey ganesh engler exe system automatically generating inputs death symbolic execution technical report cstr stanford clarke kroening hardware verification ansi-c programs proceedings asp-dac pages ieee computer society press january corbett dwyer hatcliff laubach pasareanu robby zheng bandera extracting finite-state models java source code icse das lerner seigle path-sensitive program verification polynomial time proceedings acm sigplan conference programming language design implementation berlin germany june orensson extensible sat-solver giunchiglia tacchella editors sat volume lecture notes computer science pages springer ext ext file system http fsprogs net ferguson korel chaining approach software test data generation acm trans softw eng methodol foster terauchi aiken flow-sensitive type qualifiers proceedings acm sigplan conference programming language design implementation june godefroid model checking programming languages verisoft proceedings acm symposium principles programming languages godefroid klarlund sen dart directed automated random testing proceedings conference programming language design implementation pldi chicago usa june acm press gotlieb botella rueher automatic test data generation constraint solving techniques issta proceedings acm sigsoft international symposium software testing analysis pages acm press gupta mathur soffa automated test data generation iterative relaxation method sigsoft fseproceedings acm sigsoft international symposium foundations software engineering pages acm press hastings joyce purify fast detection memory leaks access errors proceedings winter usenix conference dec holzmann model checker spin software engineering ibm journaling file system linux http wwwibm jfs khurshid pasareanu visser generalized symbolic execution model checking testing proceedings ninth international conference tools algorithms construction analysis systems larson austin high coverage detection input-related security faults proceedings usenix security symposium security august linux test project http ltp net musuvathi engler model checking large network protocol implementations proceedings symposium networked systems design implementation necula mcpeak rahul weimer cil intermediate language tools analysis transformation programs proceedings conference compilier construction march nelson oppen simplification cooperating decision procedures acm transactions programming languages systems prabhakaran bairavasundaram agrawal gunawi arpaci-dusseau arpacidusseau iron file systems sosp proceedings twentieth acm symposium operating systems principles pages york usa acm press ruwase lam practical dynamic buffer overflow detector proceedings annual network distributed system security symposium pages sen marinov agha cute concolic unit testing engine joint meeting european software engineering conference acm sigsoft symposium foundations software engineering esec fse sept stress http weather apw projects stress wagner foster brewer aiken step automated detection buffer overrun vulnerabilities network distributed systems security conference san diego feb xie aiken scalable error detection boolean satisfiability popl proceedings acm sigplan-sigact symposium principles programming languages pages york usa acm press yang twohey engler musuvathi model checking find file system errors proceedings sixth symposium operating systems design implementation dec 
iron file systems vijayan prabhakaran lakshmi bairavasundaram nitin agrawal haryadi gunawi andrea arpaci-dusseau remzi arpaci-dusseau computer sciences department wisconsin madison vijayan laksh nitina haryadi dusseau remzi wisc abstract commodity file systems trust disks work fail completely modern disks exhibit complex failure modes suggest fail-partial failure model disks incorporates realistic localized faults latent sector errors block corruption develop apply failure-policy fingerprinting framework investigate commodity file systems react range realistic disk failures classify failure policies taxonomy measures internal robustness iron includes failure detection recovery techniques show commodity file system failure policies inconsistent buggy generally inadequate ability recover partial disk failures finally design implement evaluate prototype iron file system linux ixt showing techniques in-disk checksumming replication parity greatly enhance file system robustness incurring minimal time space overheads categories subject descriptors operating systems file systems management operating systems reliability general terms design experimentation reliability keywords iron file systems disks storage latent sector errors block corruption fail-partial failure model fault tolerance reliability internal redundancy introduction disks fail commodity file systems expect years file system storage system designers assumed disks operate fail stop manner classic model disks working perfectly fail absolutely easily detectable manner fault model presented modern disk drives complex modern drives exhibit latent sector faults block set blocks inaccessible worse blocks silently corrupted finally disks exhibit transient performance problems permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee sosp october brighton united kingdom copyright acm reasons complex failures disks buggy disk controller issue misdirected write placing correct data disk wrong location interestingly failures exist today simply waiting disk technology improve remove errors errors worsen time due increasing drive complexity immense cost pressures storage industry escalated reliable ata disks desktop pcs large-scale clusters storage systems developers high-end systems realized nature disk faults built mechanisms systems handle redundant storage systems incorporate background disk scrubbing process proactively detect subsequently correct latent sector errors creating copy inaccessible blocks recent storage arrays incorporate extra levels redundancy lessen potential damage undiscovered latent errors similarly highly-reliable systems tandem nonstop utilize end-to-end checksums detect block corruption occurs technology filtered realm commodity file systems including linux file systems ext reiserfs ibm jfs windows file systems ntfs file systems pervasive home environment storing valuable non-archived user data photos home movies tax returns internet services google paper question pose modern commodity file systems react failures common modern disks answer query aggregate knowledge research literature industry field experience form model disk failure label model fail-partial failure model emphasize portions disk fail block errors data corruption model place develop apply automated failure-policy fingerprinting framework inject realistic disk faults beneath file system goal fingerprinting unearth failure policy system detects recovers disk failures approach leverages gray-box knowledge file system data structures meticulously exercise file system access paths disk characterize failure policy develop internal robustness iron taxonomy catalogs broad range detection recovery techniques output fingerprinting tool broad categorization iron techniques file system constituent data structures study focuses important substantially open-source file systems ext reiserfs ibm jfs closed-source file system windows ntfs platforms find great deal illogical inconsistency failure policy due diffusion failure handling code kernel inconsistency leads substantially detection recovery strategies similar fault scenarios resulting unpredictable undesirable fault-handling strategies discover systems implement portions failure policy incorrectly presence bugs implementations demonstrates difficulty complexity correctly handling classes disk failure observe tolerance transient failures file systems assume single temporarilyinaccessible block fatal whole-disk failure finally show file systems recover partial disk failures due lack in-disk redundancy behavior realistic disk failures leads question change file systems handle modern disk failures advocate single guiding principle design file systems don trust disk file system view disk utterly reliable component blocks corrupt file system apply measures detect recover corruption running single disk approach instance end-to-end argument top storage stack file system fundamentally responsible reliable management data metadata initial efforts develop family prototype iron file systems robust variants linux ext file system iron ext ixt investigate costs checksums detect data corruption replication provide redundancy metadata structures parity protection user data show techniques incur modest space time overheads greatly increasing robustness file system latent sector errors data corruption implementing detection recovery techniques iron taxonomy system implement well-defined failure policy subsequently provide vigorous protection broader range disk failures contributions paper define realistic failure model modern disks fail-partial model formalize techniques detect recover disk errors iron taxonomy develop fingerprinting framework determine failure policy file system analyze popular commodity file systems discover handle disk errors build prototype version iron file system ixt analyze robustness disk failure performance characteristics bring paper close discuss related work finally conclude disk failure reasons file system errors storage system section discuss common disk failure present realistic failpartial model disks discuss aspects model storage subsystem figure presents typical layered storage subsystem file system error occur layers propagate file system generic block device driver device controller firmware media transport host disk generic file system specific file system storage subsystem electrical mechanical cache figure storage stack present schematic entire storage stack top file system beneath layers storage subsystem gray shading implies software firmware white unshaded hardware bottom storage stack disk magnetic storage media mechanical motor arm assembly electrical components busses important component firmware code embedded drive control higher-level functions including caching disk scheduling error handling firmware code substantial complex modern seagate drive roughly lines code connecting drive host transport low-end systems transport medium bus scsi networks common higher-end systems fibrechannel top stack host hardware controller communicates device software device driver controls hardware block-level software forms layer providing generic device interface implementing optimizations request reordering software file system layer split pieces high-level component common file systems specific component maps generic operations data structures file system standard interface vnode vfs positioned disks fail motivate failure model describe errors layers storage stack failures media primary errors occur magnetic media classic problem bit rot occurs magnetism single bit bits flipped type problem detected corrected low-level ecc embedded drive physical damage occur media quintessential head crash culprit drive head contacts 
surface momentarily media scratch occur particle trapped drive head media dangers well-known drive manufacturers modern disks park drive head drive reduce number head crashes scsi disks include filters remove particles media errors lead permanent failure corruption individual disk blocks mechanical wear tear eventually leads failure moving parts drive motor spin irregularly fail completely erratic arm movements head crashes media flaws inaccurate arm movement misposition drive head writes leaving blocks inaccessible corrupted subsequent reads electrical power spike surge damage in-drive circuits lead drive failure electrical problems lead entire disk failure drive firmware interesting errors arise drive controller consists thousands lines real-time concurrent firmware disks return correct data circularly shifted byte memory leaks lead intermittent failures firmware problems lead poor drive performance firmware bugs well-enough field specific names misdirected writes writes place correct data disk wrong location phantom writes writes drive reports completed reach media phantom writes caused buggy misconfigured cache write-back caching enabled summary drive firmware errors lead sticky transient block corruption lead performance problems transport transport connecting drive host problematic study large disk farm reveals systems tested interconnect problems bus timeouts parity errors occurred frequency causing requests succeed slowly fail altogether transport transient errors entire drive bus controller main bus controller problematic eide controller series motherboards incorrectly completion disk request data reached main memory host leading data corruption similar problem controllers return status bits data floppy drive time hard drive observed ide protocol version problems yield corrupt data summary controller problems lead transient block failure data corruption low-level drivers recent research shown device driver code bugs rest operating system bugs crash operating system issue disk requests bad parameters data resulting data corruption fail-partial failure model discussion root failure ready put realistic model disk failure model failures manifest ways entire disk failure entire disk longer accessible permanent classic fail-stop failure block failure blocks accessible referred latent sector errors block corruption data individual blocks altered corruption insidious silent storage subsystem simply returns bad data read term model fail-partial failure model emphasize pieces storage subsystem fail discuss key elements fail-partial model including transience locality frequency failures discuss technology market trends impact disk failures time transience failures model failures sticky permanent transient temporary behavior manifests depends root problem low-level media problem portends failure subsequent requests contrast transport higher-level software issue block failure corruption operation succeed retried locality failures multiple blocks disk fail block failures dependent root block failure suggest forms block failure exhibit spatial locality scratched surface render number contiguous blocks inaccessible failures exhibit locality corruption due misdirected write impact single block frequency failures block failures corruptions occur commercial storage system developer succinctly stated disks break lot guarantees fiction frequently errors occur modeling reliability deciding failures important handle talagala patterson point disk drive manufacturers loathe provide information disk failures people industry refer implicit industry-wide agreement publicize details surprisingly actual frequency drive errors errors disk fail well-known literature previous work latent sector errors errors occur commonly absolute disk failure recent research estimates errors occur times absolute disk failures terms relative frequency block failures occur reads writes due internal error handling common disk drives failed writes sector remapped distant sector allowing drive transparently handle problems remapping imply writes fail failure component media stuttering transport lead unsuccessful write attempt move network-attached storage serves increase frequency class failures remapping succeed free blocks large scratch render blocks unwritable quickly reserved space reads problematic media unreadable drive choice return error trends areas processor performance technology market trends combine improve aspects computer systems contrast technology trends market forces combine make storage system failures occur frequently time reasons reliability greater challenge drives made increasingly dense bits packed smaller spaces drive logic complexity increases low-end drive market cost-per-byte dominates corners cut save pennies ide ata drives low-cost class drives tend tested internal machinery prevent failures occurring result field ata drives observably reliable cost pressures serve increase usage server environments finally amount software increasing storage systems noted software root errors storage system hundreds thousands lines software present lower-level drivers firmware low-level code generally type code difficult write debug source increased errors storage stack iron taxonomy section outline strategies developing iron file system file system detects recovers range modern disk failures main focus develop strategies disks common storage arrays single disk internal robustness iron needed protection file system cope failures modern disks iron file system includes machinery detect level partial faults recover level tables present iron detection recovery taxonomies note taxonomy means complete techniques exist raid variations proposed years detection recovery mechanisms employed file system define failure policy difficult discuss failure policy system iron taxonomy describe failure policy file system describe cache replacement file-layout policy levels detection level techniques file system detect problem occurred block accessed corrupted simplest detection strategy file system assumes disk works check return codes approach surprisingly common applied unintentionally errorcode pragmatic detection strategy file system implement check return codes provided lower levels storage system sanity sanity checks file system verifies data structures consistent check performed single block blocks checking single block file system verify individual fields pointers valid ranges verify type block file system superblocks include magic number older file systems pilot include header data block checking block correct type information file system guard forms block corruption checking blocks involve verifying blocks bitmap corresponds allocated blocks involve periodically scanning structures determine intact consistent similar fsck journaling file systems benefit periodic full-scan integrity checks buggy journaling file system unknowingly corrupt on-disk structures running fsck background detect recover problems redundancy final level detection taxonomy redundancy forms redundancy detect block corruption checksumming reliable systems years detect corruption recently applied improve security checksums number reasons assist detecting classic bit rot bits media flipped in-media ecc catches corrects errors checksums well-suited detecting corruption higher levels storage system stack buggy controller misdirects disk updates wrong location write block disk checksums carefully implemented detect problems specifically checksum level technique comment dzero detection assumes disk works derrorcode check return codes assumes lower level lower levels detect errors dsanity check data structures require extra consistency space block dredundancy redundancy detect corruption blocks end-to-end table levels iron detection taxonomy level technique 
comment rzero recovery assumes disk works rpropagate propagate error informs user rstop stop activity limit amount crash prevent writes damage rguess return guess wrong block contents failure hidden rretry retry read write handles failures transient rrepair repair data structs lose data rremap remaps block file assumes disk informs locale failures rredundancy block replication enables recovery forms loss corruption table levels iron recovery taxonomy stored data checksums detect misdirected phantom writes higher levels redundancy block mirroring parity error-correction codes detect corruption file system copies block reading comparing determine corrupted techniques designed correction discussed assume presence lower-overhead detection mechanism detection frequency detection techniques discussed applied lazily block access eagerly scanning disk idle time iron file systems form lazy detection additionally eager methods disk scrubbing classic eager technique raid systems scan disk discover latent sector errors disk scrubbing valuable means recovery replica exists repair nowunavailable block detect error occurred scrubbing typically leverages return codes explicitly provided disk discovers block failure corruption combined detection techniques checksums scrubbing discover block corruption levels recovery level iron taxonomy facilitates recovery block failure single disk drive techniques handle latent sector errors block corruptions simplest approach implement recovery strategy notifying clients failure occurred propagate straightforward recovery strategy propagate errors file system file system informs application error occurred assumes client program user respond appropriately problem stop recover disk failure stop current file system activity action levels granularity coarsest level crash entire machine positive feature recovery mechanism turns detected disk failures fail-stop failures preserves file system integrity crashing assumes problem transient faulty block repeatedly-accessed data script run initialization system repeatedly reboot attempt access unavailable data crash intermediate level kill process triggered disk fault subsequently mount file system read-only mode approach advantageous entire system processes continue finest level journaling file system abort current transaction approach lead system complex implement guess recently suggested rinard reaction failed block read manufacture response allowing system running spite failure negative artificial response desirable failing retry simple response failure retry failed operation retry appropriately handle transient errors wastes time retrying failure permanent repair iron file system detect inconsistency internal data structures repair fsck block pointed marked allocated bitmap freed discussed techniques context journaling file systems bugs lead corruption file system integrity remap iron file systems perform block remapping technique fix errors occur writing block recover failed reads specifically write block fails file system choose simply write block location sophisticated strategies remap entire semantic unit time user file preserving logical contiguity redundancy finally redundancy forms recover block loss simplest form replication block copies locations disk redundancy approach employs parity facilitate error correction similar raid adding parity block block group file system tolerate unavailability corruption block group complex encodings tornado codes subject worthy future exploration redundancy disk negative consequences replicas account spatial locality failure surface scratch corrupts sequence neighboring blocks copies allocated remote parts disk lower performance in-disk redundancy techniques incur high space cost desktop settings drives sufficient free space iron file system natural question file system implement detection recovery disk modern disks internal mechanisms detecting recovering errors sufficient view primary reason detection recovery file system found end-to-end argument lower-levels system implement forms fault tolerance file system implement guard forms failure file system place detect corruption data higher levels storage stack device driver drive controller reason implementing detection recovery file system file system exact knowledge blocks file system apply detection recovery intelligently block types file system provide higher level replication metadata leaving failure detection correction user data applications specific solution explore similarly file system provide machinery enable application-controlled replication important data enabling explicit performance reliability trade-off reason performance file systems storage systems unwritten contract file system lay blocks achieve high bandwidth unwritten contract stipulates adjacent blocks logical disk address space physically proximate disk-level recovery mechanisms remapping break unwritten contract performance problems file system assumes responsibility remap logically-related blocks file avoid problems complexities placing iron functionality file system techniques require persistent data structures track redundant copies parity blocks located mechanisms require control underlying drive mechanisms recover on-disk data modern drives attempt positioning reading strategies interface exists control low-level strategies current systems doesn raid make storage reliable question answered simply raid techniques provide reliable robust storage raid improve storage reliability complete solution reasons systems incorporate disk sine qua redundant storage systems desktop pcs ship single disk included cost driving force marketplace adding disk solely sake redundancy palatable solution raid protect failures higher storage stack shown figure layers exist storage subsystem file system errors occur layers file system ultimately responsible detecting recovering errors ironically complex raid controller consist millions lines code source faults depending raid system employed types disk faults handled lower-end raid controller cards checksums detect data corruption recently companies included machinery cope latent sector errors iron techniques file system single-disk systems multiple drives raid-like manner focus single-disk systems paper rich space left exploration iron file systems redundant storage arrays failure policy fingerprinting describe methodology uncover failure policy file systems main objective failure-policy fingerprinting determine detection recovery techniques file system assumptions makes underlying storage system fail comparing failure policies file systems learn file systems robust disk failures suggest improvements analysis helpful inferring iron techniques implemented effectively approach inject faults beneath file system observe file system reacts fault policy consistent file system simply run workload fail blocks accessed conclude reaction block failure fully demonstrates failure policy system file systems practice complex employ techniques depending operation performed type faulty block extract failure policy system trigger interesting cases challenge coerce file system code paths observe path handles failure requires run workloads exercising relevant code paths combination induced faults file system data structures describe create workloads inject faults deduce failure policy applied workload goal applying workloads exercise file system claim stress code path leaving avenue future work strive execute interesting internal cases workload suite sets programs run unix-based file systems fingerprinting ntfs requires set similar programs set programs called singlets focus single call file system api mkdir set generics stresses functionality common api path traversal table summarizes test suite file system test introduces special cases stressed ext inode imbalanced tree indirect doubly-indirect triply-indirect pointers support large 
files workloads ensure sufficiently large files created access structures file systems similar peculiarities make exercise -tree balancing code reiserfs type-aware fault injection step inject faults emulate disk adhering fail-partial failure model standard fault injectors fail disk blocks type oblivious manner block failed file system repeatedly injecting faults random blocks waiting uncover aspects failure policy laborious time-consuming process yielding insight key idea test file system efficient manner type-aware fault injection builds previous work semantically-smart disk systems type-aware fault injection failing blocks obliviously fail blocks specific type inode type information crucial reverse-engineering failure policy allowing discern strategies file system applies data structures disadvantage type-aware approach fault injector tailored file system tested requires solid understanding workload purpose singlets access chdir chroot stat statfs lstat open utimes read readlink exercise getdirentries creat posix api link mkdir rename chown symlink write truncate rmdir unlink mount chmod fsync sync umount generics path traversal traverse hierarchy recovery invoke recovery log writes update journal table workloads table presents workloads applied file systems test set workloads stresses single system call group invokes general operations span calls path traversal on-disk structures benefits typeawareness outweigh complexities block types file systems test listed table mechanism injecting faults software layer directly beneath file system pseudo-device driver layer injects block failures reads writes block corruption reads emulate block failure simply return error code issue operation underlying disk emulate corruption change bits block returning data cases inject random noise cases block similar expected corrupted fields software layer models transient sticky faults injecting failures file system emulate faults caused layers storage subsystem unlike approaches emulate faulty disks additional hardware imitate faults introduced buggy device drivers controllers drawback approach discern lower layers handle disk faults scsi drivers retry commands failure characterizing file systems react faults correct layer fault injection failure policy inference running workload injecting fault final step determine file system behaved determine fault affected file system compare results running fault perform comparison observable outputs system errors codes data returned file system api contents system log low-level traces recorded fault-injection layer human-intensive part process requires manual inspection visible outputs summary developed three-step fingerprinting methodology determine file system failure policy approach strikes good balance straightforward run exercises file system test workload suite roughly programs file system order block types block failed read write data corrupted file system amounts roughly relevant tests ext structures purpose inode info files directories directory list files directory data bitmap tracks data blocks group inode bitmap tracks inodes group indirect large files exist data holds user data super info file system group descriptor holds info block group journal super describes journal journal revoke tracks blocks replayed journal descriptor describes contents transaction journal commit marks end transaction journal data blocks journaled reiserfs structures purpose leaf node items kinds stat item info files directories directory item list files directory direct item holds small files tail file indirect item large files exist data bitmap tracks data blocks data holds user data super info tree file system journal header describes journal journal descriptor describes contents transaction journal commit marks end transaction journal data blocks journaled root internal node tree traversal jfs structures purpose inode info files directories directory list files directory block alloc map tracks data blocks group inode alloc map tracks inodes group internal large files exist data holds user data super info file system journal super describes journal journal data records transactions aggregate inode info disk partition bmap descriptor describes block allocation map imap control summary info imaps ntfs structures purpose mft record info files directories directory list files directory volume bitmap tracks free logical clusters mft bitmap tracks unused mft records logfile transaction log file data holds user data boot file info ntfs volume table file system data structures table presents data structures interest file systems test ext reiserfs jfs ntfs table list names major structures purpose note knowledge ntfs data structures incomplete closed-source system failure policy results present results failure policy analysis commodity file systems ext reiserfs version ibm jfs linux ntfs windows file system present basic background information discuss general failure policy uncovered bugs illogical inconsistencies source code explain problems discover due sheer volume experimental data difficult present results reader inspection file system studied depth present graphical depiction results showing workload blocktype pair detection recovery technique figure presents complex graphical depiction results caption interpretation details provide qualitative summary results presented figure linux ext linux ext similar classic unix file systems berkeley fast file system ext divides disk set block groups statically-reserved spaces bitmaps inodes data blocks major addition ext ext journaling ext includes set ondisk structures manage write-ahead log detection detect read failures ext primarily error codes derrorcode write fails ext record error code dzero write errors potentially leading file system problems checkpointing transaction final location ext performs fair amount sanity checking dsanity ext explicitly performs type checks blocks superblock journal blocks type checking important blocks directories bitmap blocks indirect blocks ext performs numerous sanity checks file-size field inode overly-large open detects reports error recovery detected errors ext propagates error user rpropagate read failures ext aborts journal rstop aborting journal leads readonly remount file system preventing future updates explicit administrator interaction ext retry rretry sparingly prefetch read fails ext retries originally requested block bugs inconsistencies found number bugs inconsistencies ext failure policy errors propagated user truncate rmdir fail silently important cases ext immediately abort journal failure implement rstop journal write fails ext writes rest transaction including commit block journal journal recovery file system easily corrupted ext perform sanity checking unlinkdoes check thelinkscount field modifying corrupted lead system crash finally ext redundant copies superblock rredundancy copies updated file system creation reiserfs reiserfs comprised vastly data structures ext virtually metadata data balanced tree similar database index key advantage tree structuring scalability allowing files coexist directory read failure write failure corruption ext detection j-dataj-commit j-descj-revoke j-superg-desc superdata indirecti-bitmap bitmapdir inode ext recovery j-dataj-commit j-descj-revoke j-superg-desc superdata indirecti-bitmap bitmapdir inode reiserfs detection internalroot j-dataj-commit j-descj-header superdata indirectbitmap dir itemstat item reiserfs recovery internalroot j-dataj-commit j-descj-header superdata indirectbitmap dir itemstat item jfs detection imap-cntlbmap-desc aggr-inodej-data j-supersuper datainternal imapbmap 
dirinode jfs recovery imap-cntlbmap-desc aggr-inodej-data j-supersuper datainternal imapbmap dirinode figure file system failure policies tables detection recovery policies ext reiserfs jfs read write corruption faults injected block type range workloads workloads path traversal access chdir chroot stat statfs lstat open chmod chown utimes read readlink getdirentries creat link mkdir rename symlink write truncate rmdir unlink mount fysnc sync umount recovery log write operations gray box workload applicable block type multiple mechanisms observed symbols superimposed key detection key recovery dzero rzero derrorcode rretry dsanity rpropagate rredundancy rstop detection analysis reveals reiserfs pays close attention error codes reads writes derrorcode reiserfs performs great deal internal sanity checking dsanity internal leaf nodes balanced tree block header information level block tree number items free space super block journal metadata blocks magic numbers identify valid journal descriptor commit blocks additional information finally inodes directory blocks formats reiserfs checks blocks expected values fields blocks checked carefully bitmaps data blocks type information type-checked recovery prominent aspect recovery policy reiserfs tendency panic system detection virtually write failure rstop reiserfs calls panic file system crashes leading reboot recovery sequence reiserfs attempts ensure ondisk structures corrupted reiserfs recovers read write failures differently read failures reiserfs propagates error user rpropagate performs single retry rretry data block read fails indirect block read fails unlink truncate write operations reiserfs retries write failure bugs inconsistencies reiserfs exhibits inconsistencies bugs ordered data block write fails reiserfs journals commits transaction handling error rzero expected rstop lead corrupted data blocks metadata blocks point invalid data contents dealing indirect blocks reiserfs detects ignores read failure atruncate unlink updates bitmaps super block incorrectly leaking space reiserfs calls panic failing sanity check simply returning error code finally sanity type checking detect corrupt journal data replaying corrupted journal block make file system unusable block written super block ibm jfs jfs modern techniques manage data block allocation journaling scalable tree structures manage files directories block allocation unlike ext reiserfs jfs record-level journaling reduce journal traffic detection error codes derrorcode detect read failures ext write errors dzero exception journal superblock writes jfs employs minimal type checking superblock journal superblock magic version numbers checked sanity checks dsanity block types internal tree blocks directory blocks inode blocks number entries pointers block jfs checks make number maximum block type equality check field performed block allocation maps verify block corrupted recovery recovery strategies jfs vary dramatically depending block type error occurs journal superblock write jfs crashes system rstop write errors rzero block read failure primary superblock jfs accesses alternate copy rredundancy complete mount operation corrupt primary results mount failure rstop explicit crashes rstop block allocation map inode allocation map read fails error codes metadata reads handled generic file system code called jfs generic code attempts recover read errors retrying read single time rretry finally reaction failed sanity check propagate error rpropagate remount file system read-only rstop journal replay sanity-check failure replay abort rstop bugs inconsistencies found problems jfs failure policy jfs built-in redundancy expect jfs secondary copies aggregate inode tables special inodes describe file system error code returned aggregate inode read blank page returned user rguess design bug occurs read internal tree block pass sanity check bugs limit utility jfs recovery generic code detects read errors retries bug jfs implementation leads ignoring error corrupting file system windows ntfs ntfs non-unix file system study analysis requires detailed knowledge on-disk structures complete analysis figure find ntfs error codes derrorcode detect block read write failures similar ext jfs data write fails ntfs records error code dzero corrupt file system ntfs performs strong sanity checking dsanity metadata blocks file system unmountable metadata blocks journal corrupted ntfs surprisingly perform sanity checking corrupted block pointer point important system structures corrupt block pointed updated cases ntfs propagates errors rpropagate ntfs aggressively retry rretry operations fail times read failures writes number retries varies times data blocks times mft blocks file system summary present qualitative summary file systems tested table presents summary techniques file system employs excluding ntfs ext simplicity ext implements simple reliable failure policy matching design philosophy found ext family file systems checks error codes modest level sanity checking recovers propagating errors aborting operations main problem ext failure handling write errors problems including file system corruption reiserfs harm reiserfs concerned disk failure concern evident write failures induce panic reiserfs takes action ensure file system corrupted reiserfs great deal sanity type checking behaviors combine form hippocratic failure policy harm jfs kitchen sink jfs consistent diverse failure detection recovery techniques detection jfs sanity checks error codes recovery jfs redundancy crashes system retries operations depending block type fails error detection api called level ext reiser jfs dzero derrorcode dsanity dredundancy rzero rpropagate rstop rguess rretry rrepair rremap rredundancy table iron techniques summary table depicts summary iron techniques file systems test check marks higher relative frequency usage technique ntfs persistence virtue compared linux file systems ntfs persistent retrying failed requests times giving propagate errors user reliably testing ntfs needed order broaden conclusions part ongoing work technique summary finally present broad analysis techniques applied file systems detect recover disk failures concentrate techniques underused overused inappropriate manner detection recovery illogical inconsistency common found high degree illogical inconsistency failure policy file systems observable patterns figure reiserfs performs great deal sanity checking important case journal replay result single corrupted block journal corrupt entire file system jfs illogically inconsistent employing techniques scenarios similar note inconsistency problematic logically inconsistent good idea file system provide higher level redundancy data structures deems important root directory criticizing inconsistencies undesirable unintentional jfs attempt read alternate superblock read failure occurs reading primary superblock attempt read alternate deems primary corrupted estimation root illogical inconsistency failure policy diffusion code implements failure policy spread kernel diffusion encouraged architectural features modern file systems split generic specific file systems observed cases developers implement portions code implement failure policies cases reiserfs panic write failure arises due inconsistency indicative lack attention paid failure policy detection recovery bugs common found numerous bugs file systems tested found sophisticated techniques generally indicative difficulty implementing correct failure policy hints effort put testing debugging code suggestion literature helpful periodically inject faults 
normal operation part fire drill method reveals testing broad cover code paths testing indirect-block handling reiserfs observe classes fault mishandling detection error codes amazingly error codes file system common jfs found occasionally file systems testing framework part file system developer toolkit tools class error easily discovered detection sanity checking limited utility file systems sanity checking ensure metadata meets expectations code modern disk failure modes misdirected phantom writes lead cases file system receive properly formatted incorrect block bad block passes sanity checks corrupt file system file systems tested exhibit behavior stronger tests checksums recovery stop correctly file systems employed form rstop order limit damage file system types errors arose reiserfs calls panic virtually write error prevent corruption structures careful techniques write failure ext abort transaction correctly squelch writes file system leading corruption fine-grained rebooting difficult apply practice recovery stop overused downside halting file system activity reaction failure inconvenience recovery takes time requires administrative involvement fix file systems form rstop innocuous read failure occurred simply returning error requesting process entire system stops draconian reactions possibly temporary failures avoided recovery retry underutilized file systems assume failures transient lower layers system handle failures retry requests time systems employ retry generally assume read retry write retry transient faults due device drivers transport issues equally occur reads writes retry applied uniformly ntfs lone file system embraces retry issue higher number requests block failure observed recovery automatic repair rare automatic repair rarely file systems rstop technique file systems require manual intervention attempt fix observed problem running fsck detection recovery redundancy finally importantly virtually file systems include machinery detect disk failures apply redundancy enable recovery failures lone exception minimal amount superblock redundancy found jfs redundancy inconsistently jfs places copies close proximity making vulnerable spatiallylocal errors explored potentially handling failures common drives today investigate inclusion forms redundancy failure policy file system read failure write failure corruption ixt detection j-dataj-commit j-descj-revoke j-superg-desc superdata indirecti-bitmap bitmapdir inode ixt recovery j-dataj-commit j-descj-revoke j-superg-desc superdata indirecti-bitmap bitmapdir inode figure ixt failure policy tables plot detection recovery policies ixt read write corruption faults injected block type range workloads workloads varied columns figure block types ixt file system varied rows workloads grouped manner figure key detection key recovery dzero rzero derrorcode rretry dsanity rpropagate dredundancy rredundancy rstop iron file system describe implementation evaluation iron ext ixt ixt implement family recovery techniques commodity file systems provide increase robustness ixt applies checksums metadata data blocks pure replication metadata employs parity-based redundancy protect user data section describe implementation demonstrate robust broad class partial disk failures investigate time space costs ixt showing time costs small modest space costs reasonable performance measurements activate deactivate iron features independently understand cost approach implementation briefly describe ixt implementation explain add checksumming metadata replication user parity performance enhancement transactional checksums existing ext file system framework checksumming implement checksumming ixt borrow techniques recent research checksumming file systems specifically place checksums journal checkpoint checksums final location distant blocks checksum checksums small cached read verification current implementation shato compute checksums incorporating checksumming existing transactional machinery ixt cleanly integrates ext framework metadata replication apply similar approach adding metadata replication ixt metadata blocks written separate replica log checkpointed fixed location block group distant original metadata transactions ensure copies reach disk consistently parity implement simple parity-based redundancy scheme data blocks parity block allocated file simple design enables recover data-block failure file modify inode structure ext associate file parity block data blocks parity blocks allocated files created file modified parity block read updated respect contents improve performance file creates preallocate parity blocks assign files created transactional checksums explore idea leveraging checksums journaling file system specifically checksums relax ordering constraints improve performance updating journal standard ext ensures previous journal data reaches disk commit block enforce ordering standard ext induces extra wait writing commit block incurs extra rotational delay avoid wait ixt implements call transactional checksum checksum contents transaction placing checksum journal commit block ixt safely issue blocks transaction concurrently crash occurs commit recovery procedure reliably detect crash replay transaction checksum journal data match checksum commit block note transactional checksum crash semantics original ext iron extensions cleaning overheads note cleaning overhead large problem pure log-structured file systems major performance issue journaling file systems ixt -style checksumming replication journaling file systems incorporate cleaning on-line maintenance costs ext writes metadata journal cleans journal checkpointing data final fixed location additional cleaning performed ixt increases total traffic small amount evaluation evaluate prototype implementation ixt focus major axes assessment robustness ixt modern disk failures time space overhead additional redundancy mechanisms employed ixt robustness test robustness ixt harness fault injection framework running partial-failure experiments ixt results shown figure ixt detects read failures ext error codes lower level derrorcode metadata block read fails ixt reads replica copy rredundancy replica read fails behaves ext propagating error rpropagate stopping file system activity rstop data block read fails parity block data blocks file read compute failed data block contents rredundancy ixt detects write failures error codes derrorcode aborts journal mounts file system read-only stop writes disk rstop data metadata block read checksum contents computed compared checksum block dredundancy checksums match read error generated rpropagate read errors contents failed block read replica computed parity block rredundancy process building ixt fixed numerous bugs ext avoided cases ext commit failed transactions disk potentially corrupt file system employing checksumming detect corruption replication parity recover lost blocks ixt robust file service spite partial disk failures quantitatively ixt detects recovers partial-error scenarios induced result logical well-defined failure policy time overhead assess performance overhead ixt isolate overhead iron mechanism enabling checksumming metadata data metadata replication parity user data transactional checksumming separately combinations standard file system benchmarks ssh-build unpacks compiles ssh source distribution web server benchmark responds set static http requests postmark emulates file system traffic server tpc-b runs series debit-credit transactions simple database run experiment times present average results benchmarks exhibit broad set behaviors specifically ssh-build good albeit simple model typical action developer administrator web server read intensive concurrency postmark metadata intensive file creations deletions tpc-b induces great deal synchronous update traffic file system table reports relative performance variants ixt 
workloads compared stock linux ext numbers draw main conclusions ssh-build web server workload time overhead iron techniques enabled ssh-build indicative typical activity checksumming replication parity incurs cost similarly web server benchmark conclude read-intensive workloads suffer addition iron techniques ssh web post tpcb baseline ext table overheads ixt file system variants results running variants ixt ssh-build ssh web server web postmark post tpc-b tpcb benchmarks presented ssh-build time measures time unpack configure build ssh source tree tar source size web server benchmark transfers data http requests postmark run transactions file sizes ranging subdirectories files tpc-b run randomly generated debitcredit transactions rows vary redundancy technique implemented combinations implies metadata checksumming enabled data checksumming enabled replication metadata turned parity data blocks enabled transactional checksums results normalized performance standard linux ext interested reader running times standard ext ssh-build web postmark tpc-b seconds slowdowns greater marked bold speedups relative base ext marked brackets testing linux kernel ghz intel memory western digital wdc bbdaa disk metadata intensive workloads postmark tpc-b overhead noticeable postmark tpc-b row workloads metadata intensive results represent worst-case performance expect observe implementation metadata replication row incurs substantial cost data checksumming row user parity metadata checksums contrast incur cost rows untuned implementation ixt results demonstrate worst case costs robustness prohibitive finally performance synchronous tpc-b workload demonstrates benefits transactional checksum base case technique improves standard ext performance row combination parity checksumming replication parity reduces overhead roughly row row additional robustness checksums applied improve performance journaling file systems space overhead evaluate space overhead measured number local file systems computed increase space required metadata replicated room checksums included extra block parity allocated found space overhead checksumming metadata replication small range found parityblock overhead user files bit substantial range depending volume analyzed summary investigated family redundancy techniques found ixt greatly increases robustness file system partial failures incurring modest time space overheads work left designs implementation techniques explored understand benefits costs iron approach related work effort builds related work bodies literature file system analysis related efforts inject faults test robustness systems failure prototype iron file system draws recent efforts building software robust hardware failure discuss turn fault injection robustness testing fault-tolerance community worked years techniques injecting faults system determine robustness fiat simulates occurrence hardware errors altering contents memory registers similarly fine inject software faults operating system major difference previous work approach focuses file systems handle broad class modern disk failure modes previous work approach assumes implicit knowledge file-system block types ensure test paths file system code previous work inserts faults blind fashion uncover problems found work similar brown patterson work raid failure analysis authors suggest hidden policies raid systems worth understanding demonstrate fault injection software raid systems qualitatively failure-handling recovery policies discover failure policy target file system raid requiring complex type-aware approach recent work yang model-checking find host file system bugs techniques well-suited finding classes bugs approach aimed discovery file system failure policy interestingly approach uncovers file system bugs yang reason testing scale model-checking limited small file systems reduce run-time approach applied large file systems work builds earlier work failure injection underneath file systems work developed approach test file systems handle write failures journal updates current work extends data types read write corruption failures iron file systems work iron file systems partially inspired work google acharya suggests cheap hardware paranoid assume fail unpredictable ways google good reason treats application-level problem builds checksumming top file system disk-level redundancy drives machines drive extend approach incorporating techniques file system applications benefit note techniques complimentary application-level approaches file system metadata block inaccessible user-level checksums replicas enable recovery now-corrupted volume related approach driver hardening effort linux stated hardened driver extends realm well-written include professional paranoia features detect hardware software problems page drivers generally improve system reliability faults handled file system end-to-end argument fail-partial failure model disks understood high-end storage high-availability systems communities network appliance introduced row-diagonal parity tolerate disk faults continue operate order ensure recovery presence latent sector errors virtually network appliance products checksumming detect block corruption similarly systems tandem nonstop kernel include end-to-end checksums handle problems misdirected writes interestingly redundancy single disk instances ffs internal replication limited fashion specifically making copies superblock platters drive noted earlier commodity file systems similar provisions suggest making replicas disk raid array reduce rotational latency primary intention copies recovery storage array difficult apply techniques selective manner metadata work replication improving performance fault-tolerance future investigation iron strategies checksumming commonplace improve system security patil stein suggest implement evaluate methods incorporating checksums file systems systems aim make corruption file system data attacker difficult finally dynamic file system sun good file system iron techniques dfs checksums detect block corruption employs redundancy multiple drives ensure recoverability contrast emphasize utility replication drive suggest evaluate techniques implementing redundancy show embellish existing commodity file system dfs written scratch limiting impact conclusions commodity operating systems grown assume presence reliable hardware result case file systems commodity file systems include requisite machinery handle types partial faults expect modern disk drives time reexamine file systems handle failure excellent model operating system kernel networking subsystem network hardware long considered unreliable hardware medium software stacks designed well-defined policies cope common failure modes disks viewed fully reliable mistrust woven storage system framework challenges remain failures disks expose layers file system software architecture redesigned enable consistent well-defined failure policy kind controls exposed applications users low-overhead detection recovery techniques iron file systems employ answers questions lead understanding effectively implement generation robust reliable iron file systems acknowledgments extend steve kleiman network appliance dave anderson jim dykes seagate insights disks work fail liuba shrira shepherd dave dewitt mark hill jiri schindler mike swift anonymous reviewers members adsl excellent suggestions comments himani apte meenali rungta invaluable work implementing parity ext finally computer systems lab csl providing terrific computing environment systems research work sponsored nsf ccrccr- ngsitr- ibm network appliance emc acharya reliability cheap learned stop worrying love cheap pcs easy workshop october altaparmakov linux-ntfs project http linuxntfs sourceforge net ntfs august alvarez burkhard cristian tolerating multiple failures raid architectures optimal storage uniform declustering proceedings annual international symposium computer architecture isca pages denver colorado anderson drive manufacturers typically don 
talk disk failures personal communication dave anderson seagate anderson dykes riedel interface scsi ata proceedings usenix symposium file storage technologies fast san francisco california april arpaci-dusseau arpaci-dusseau information control gray-box systems proceedings acm symposium operating systems principles sosp pages banff canada october arpaci-dusseau arpaci-dusseau fail-stutter fault tolerance eighth workshop hot topics operating systems hotos viii pages schloss elmau germany bairavasundaram sivathanu arpaci-dusseau arpaci-dusseau x-ray non-invasive exclusive caching mechanism raids proceedings annual international symposium computer architecture isca pages munich germany june bartlett spainhower commercial fault tolerance tale systems ieee transactions dependable secure computing january barton czeck segall siewiorek fault injection experiments fiat ieee transactions computers april jfs overview ibm developerworks library jfs html bitton gray disk shadowing proceedings international conference large data bases vldb pages los angeles california august brown patterson maintainability availability growth benchmarks case study software raid systems proceedings usenix annual technical conference usenix pages san diego california june candea kawamoto fujiki friedman fox microreboot technique cheap recovery proceedings symposium operating systems design implementation osdi pages san francisco california december chou yang chelf hallem engler empirical study operating system errors proceedings acm symposium operating systems principles sosp pages banff canada october corbett english goel grcanac kleiman leong sankar row-diagonal parity double disk failure correction proceedings usenix symposium file storage technologies fast pages san francisco california april devale koopman performance evaluation exception handling libraries proceedings international conference dependable systems networks dsngoteborg sweden june douceur bolosky large-scale study file-system contents proceedings acm sigmetrics conference measurement modeling computer systems sigmetrics pages atlanta georgia dykes modern disk roughly lines code personal communication james dykes seagate august emc emc centera content addressed storage system http emc emerson essays english traits self-reliance harvard classics edited charles eliot york collier son volume foolish consistency hobgoblin minds adored statesmen philosophers divines engler chen hallem chou chelf bugs deviant behavior general approach inferring errors systems code proceedings acm symposium operating systems principles sosp pages banff canada october ghemawat gobioff leung google file system proceedings acm symposium operating systems principles sosp pages bolton landing lake george york october gibson rochberg zelenka nagle amiri chang feinberg gobioff lee ozceri riedel file server scaling network-attached secure disks proceedings joint international conference measurement modeling computer systems sigmetrics performance pages seattle washington june gray census tandem system availability technical report tandem computers green eide controller flaws version http mindprod eideflaw html february kalbarczyk iyer yang characterization linux kernel behavior error proceedings international conference dependable systems networks dsnpages san francisco california june gunawi agrawal arpaci-dusseau arpacidusseau schindler deconstructing commodity storage clusters proceedings annual international symposium computer architecture isca pages madison wisconsin june henson history unix file systems http infohost nmt val slides pdf hitz lau malcolm file system design nfs file server appliance proceedings usenix winter technical conference usenix winter san francisco california january hughes murray reliability security raid storage systems archives sata disk drives acm transactions storage february intel corp ibm corp device driver hardening http hardeneddrivers sourceforge net kari latent sector faults reliability disk arrays phd thesis helsinki technology september kari saikkonen lombardi detection defective media disks ieee international workshop defect fault tolerance vlsi systems pages venice italy october katcher postmark file system benchmark technical report trnetwork appliance october kleiman vnodes architecture multiple file system types sun unix proceedings usenix summer technical conference usenix summer pages atlanta georgia june lewis smart filers dumb disks nsic osd working group meeting april luby mitzenmacher shokrollahi spielman stemann practical loss-resilient codes proceedings twenty-ninth annual acm symposium theory computing stoc pages paso texas lun kao iyer tang fine fault injection monitoring environment tracing unix system behavior faults ieee transactions software engineering pages mckusick joy leffler fabry fast file system unix acm transactions computer systems august mckusick joy leffler fabry fsck unix file system check program unix system manager manual bsd virtual vaxversion april park balasubramanian providing fault tolerance parallel secondary storage systems technical report cs-tr- department computer science princeton november patil kashyap sivathanu zadok in-kernel integrity checker intrusion detection file system proceedings annual large installation system administration conference lisa atlanta georgia november patterson brown broadwell candea chen cutler enriquez fox kiciman merzbacher oppenheimer sastry tetzlaff traupman treuhaft recovery oriented computing roc motivation definition techniques case studies technical report csd- berkeley march patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod conference management data sigmod pages chicago illinois june postel rfc transmission control protocol september ftp ftp rfc-editor in-notes rfc txt august prabhakaran arpaci-dusseau arpaci-dusseau model-based failure analysis journaling file systems proceedings international conference dependable systems networks dsnyokohama japan june redell dalal horsley lauer lynch mcjones murray purcell pilot operating system personal computer communications acm february reiser reiserfs namesys ridge field book scsi starch june rinard cadar dumitran roy leu william beebe enhancing server availability security failure-oblivious computing proceedings symposium operating systems design implementation osdi san francisco california december rosenblum ousterhout design implementation log-structured file system acm transactions computer systems february saltzer reed clark end-to-end arguments system design acm transactions computer systems november schindler experienced severe performance degradation identified problem disk firmware disk drives reprogrammed fix problem personal communication schindler emc july schlosser ganger mems-based storage devices standard disk interfaces square peg round hole proceedings usenix symposium file storage technologies fast pages san francisco california april schneider implementing fault-tolerant services state machine approach tutorial acm computing surveys december schwarz xin miller long hospodor disk scrubbing large archival storage systems proceedings annual meeting ieee international symposium modeling analysis simulation computer telecommunication systems mascots volendam netherlands october seltzer bostic mckusick staelin implementation log-structured file system unix proceedings usenix winter technical conference usenix winter pages san diego california january siewiorek hudak suh segal development benchmark measure system robustness proceedings international symposium fault-tolerant computing ftcstoulouse france june sivathanu bairavasundaram arpaci-dusseau arpaci-dusseau life death block level proceedings symposium operating systems design implementation osdi pages san francisco california december sivathanu prabhakaran arpaci-dusseau arpaci-dusseau improving storage system availability graid proceedings usenix symposium file storage technologies fast pages san francisco california april sivathanu prabhakaran popovici denehy arpaci-dusseau arpaci-dusseau semantically-smart disk systems proceedings usenix symposium file storage technologies fast pages san francisco california 
april solomon inside windows microsoft programming series microsoft press edition stein howard seltzer unifying file system protection proceedings usenix annual technical conference usenix boston massachusetts june sweeney doucette anderson nishimoto peck scalability xfs file system proceedings usenix annual technical conference usenix san diego california january swift bershad levy improving reliability commodity operating systems proceedings acm symposium operating systems principles sosp bolton landing lake george york october talagala patterson analysis error behaviour large storage system ieee workshop fault tolerance parallel distributed systems san juan puerto rico april data clinic hard disk failure http dataclinic harddisk-failures htm transaction processing council tpc benchmark standard specification revision technical report tsai iyer measuring fault tolerance ftape fault injection tool international conference modeling techniques tools computer performance evaluation pages september tweedie journaling linux ext file system fourth annual linux expo durham north carolina wehman den haan enhanced ide fast-ata faq http thef-nym sci kun cgi-pieterh atazip atafq html weinberg solaris dynamic file system http members visi net thedave sun dynfs pdf wilkes golding staelin sullivan autoraid hierarchical storage system acm transactions computer systems february yang twohey engler musuvathi model checking find file system errors proceedings symposium operating systems design implementation osdi san francisco california december gum chen wang krishnamurthy anderson trading capacity performance disk array proceedings symposium operating systems design implementation osdi san diego california october 
model checking find file system errors junfeng yang paul twohey dawson engler junfeng twohey engler stanford computer systems laboratory stanford stanford madanlal musuvathi madanm microsoft microsoft research microsoft redmond abstract paper shows model checking find errors file systems model checking formal verification technique tuned finding corner-case errors comprehensively exploring state spaces defined system file systems dynamics make attractive approach errors destroy persistent data lead unrecoverable corruption traditional testing impractical exponential number test cases check system recover crashes point execution model checking employs variety state-reducing techniques explore vast state spaces efficiently built system fisc model checking file systems applied widely-used heavily-tested file systems ext jfs reiserfs found bugs total led patches day diagnosis file system fisc found demonstrable events leading unrecoverable destruction metadata entire directories including file system root directory introduction file system errors destructive errors deployed file systems reside operating system kernel simple error crash entire system midst mutation stable state bugs file system code range mere reboots lead unrecoverable errors stable disk state cases mindlessly rebooting machine correct mask errors fact make situation worse research supported nsf grant ccrand darpa grant dawson engler partially supported coverity nsf career award errors file systems dangerous file system code simultaneously difficult reason difficult test file system correctly recover internally consistent state system crashes point data mutated flushed flushed disk invariants violated anticipating failures correctly recovering hard results contradict perception importance file system errors led development file system stress test frameworks good focus non-crash based errors checking file system operations create delete link objects correctly testing file system correctly recovers crash requires reconstruction comparing reconstructed state legal state cost single crash-reboot-reconstruct cycle typically minute makes impossible test tiny fraction exponential number crash possibilities implementors validation testing effective heavily-tested systems errors arise deployed making errors impossible eliminate replicate paper model checking systematically test find errors file systems model checking formal verification technique systematically enumerates states system exploring nondeterministic events system model checkers employ state reduction techniques efficiently explore resulting exponential state space instance generated states stored hash table avoid redundantly exploring state inspecting system state model checkers identify similar set states prioritize search previously unexplored behaviors system applicable systematic exploration achieve effect impractically massive testing avoiding redundancy occur conventional testing dominant cost traditional model checking effort needed write abstract specification system commonly referred model upfront cost traditionally made model checking completely impractical large systems sufficiently detailed model large checked system empirically implementors refuse write written errors drift implementation modified model recent work developed implementation-level model checkers check implementation code directly requiring abstract specification leverage approach create model checking infrastructure file system checker fisc lets implementors model-check real unmodified file systems model checking knowledge fisc built cmc explicit state space implementation model checker developed previous work lets run entire operating system inside model checker check file system situ attempting difficult task extracting operating system kernel applied fisc widely-used heavily-tested file systems jfs reiserfs ext found bugs total led patches day diagnosis file system fisc found demonstrable events leading unrecoverable destruction metadata entire directories including file system root directory rest paper give overview fisc check file system describe checks fisc performs optimizations checks file system recovery code discuss results experiences fisc including sources false positives false negatives conclude checking overview system comprised parts cmc explicit state model checker running linux kernel file system test driver permutation checker verifies file system recover matter order buffer cache contents written disk fsck recovery checker model checker starts initial pristine state empty formatted disk recursively generates checks successive states systematically executing state transitions transitions test driver operations fs-specific kernel threads flush blocks disk test driver conceptually similar program run testing creates removes renames files directories hard links figure state exploration checking overview fisc main loop picks state state queue iteratively generates successor states applying operation restored copy generated state sprime checked validity valid explored inserted state queue writes truncates files mounts unmounts file system figure shows process state generated intercept disk writes checked file system forward permutation checker checks disk state fsck repair produce valid file system subset disk writes avoids storing separate state permutation fisc choose permutations check checker explained section run fsck host system model checker small shared library capture disk accesses fsck makes repairing file system generated writing permutation feed fsck generated writes crash recovery checker checker fisc recursively check failures fsck covered section figure outlines operation permutation fsck recovery checkers checkers copy disk starting state transition write copy avoid perturbing system copied disk modified model checker traverses file system recording properties checks consistency model file system figure disk permutation andfsckrecovery checkers size link count file directory system contents directory note model file system data file system code code traverse create manipulate file system model mirrors system call interface reused check file systems check model matches valid file systems computed section error flagged case mismatch state generated system runs series invariant checkers file system errors error found fisc emits error message stores trace error diagnosis records nondeterministic choices made error discards state error fisc state puts state queue visited similar state discards state states checkpointed added state queue exploration checkpointing kernel state captures current execution environment put state queue restored model checker decides state queue explore operations state consists kernel heap data disk abstract model current file system additional data invariant checks discussed section fisc searches state space breadthor depth-first search simple heuristics checking environment similar unit testing model-checking file system requires selecting layers cut checked system layer defines external interface test driver runs case driver run atop system call interface layer fake environment checked system runs environment model checked file system run bare hardware fisc virtual block device models disk collection sectors written atomically block device driver layer natural place cut well-documented boundary in-core persistent data modern unix derivatives provide virtual file system vfs interface vfs good place cut varies significantly operating systems versions kernel functions subtle dependencies cutting system call layer avoid headache modeling sparsely documented interactions make system easier port check vfs implementation design decision validated bugs found vfs code checking file system section 
overview file system implementor check file system basic setup cmc encases linux file system runs linux conforms fisc assumptions file system behavior require modifications checked fisc minimum disk memory sizes file system requires ext smallest requirements disk pages memory reiserfs highest disk pages addition commands make recover file system mkfs fsck ideally developer fsck options default recovery slow full recovery fast recovery replays journal recovery modes checked addition providing facts implementor modify file system expose dirty blocks consistency checks require knowing buffers dirty file system reiserfs machinery tracking dirty buffers changed explicitly dirty buffers file system fits fisc model file system works ext jfs takes days start checking hand reiserfs weeks effort run fisc violated larger assumptions made stated earlier crash checking fisc mounts copy disk checked file system block device check original file system independently manage disks reentrant manner reiserfs single kernel thread perform journal writes mounted devices deadlock journal thread writes log fisc suspends creates copy disk remounts file system remounting replays journal requires writing journal deadlocks waiting suspended journal thread run fixed problem modifying reiserfs wake journal thread clean file system mounted read-only modeling file system file system operation fisc compares checked file system believes correct volatile file system volatilefs volatilefs reflects effects file system operations sequentially defined standards fs-specific fisc construct fisc performs operation mkdir link checked concrete system emulates operation effect fake abstract file system verifies checked abstract file systems equivalent lossy comparision discards details time disk write fisc compares checked file system model believes current stable file system stablefs stablefs reflects state file system recover crash point running file system fsck repair utility current disk produce file system equivalent stablefs unlike volatilefs stablefs fs-specific file systems make wildly guarantees recovered crash ext file system journaling file system typically intends recover completed log record commit point soft-updates file system recovers difficult-to-specify mix data determining stablefs evolves requires determining fs-specific facts legally change fisc requires implementor modify checked file system call model checker stablefs journaling file systems change typically occurs journal commit record written disk identify annotate commit records easily ext reiserfs jfs difficult end variety false starts gave determine journal write represented commit-point stablefs change journal write assume file system implementor job stablefs difficult essentially requires writing crash recovery specification file system assume file system implementor check systems build shortcut fsckto generate stablefs copy experimental disk run fsck reconstruct file system image committed operations traverse file system recording properties interest approach miss errors guarantee fsck produce correct state thatfsck fail repairing perfectly behaving disk fail subsequent crashed disks persistent file system model compared checking basic file system checked main strategies implementor follow check file system downscaling canonicalization exposing choice points talk downscale operationally means making small plausible caches entries large file systems nodes node file directory model checking works ferreting complex interactions small number nouns files directories blocks threads small number caching techniques give leverage main places downscaled making disk small megabytes gigabytes checking small file system topologies typically nodes finally reducing size virtual memory checked linux system small number pages canonicalization technique modifies states state hashing irrelevant differences practice common canonicalization set things constant values clearing inode generation numbers mount counts time fields zeroing freed memory unused disk blocks journal blocks canonicalizations require fs-specific knowledge implementor fisc generic canonicalization constrains search space writing values data blocks significantly reducing number states providing resolution catch data errors hashing model file system fisc transforms file system remove superficial differences renaming files directories sequential numbering file system objects file system directory files model file system directory files files length content canonicalization lets move search space searching rare filename-specific bugs common bugs arise creating file system topologies expose choice points making sources nondeterminism choice points visible fisc lets search set file system behaviors low-level adding code fail fs-specific allocators generally file system makes decision based arbitrary time constraint environmental feature change call fisc fisc choose explore decision state reaches point mechanically exposing choice point reduces modifying file system code call choose number decision alternatives choose return callsite times return values caller return pick actions perform reiserfs ext flush in-memory journals disk amount time lapsed replaced time check call choose modified caller choose returns code flushes commit record returns file systems check buffer cache issuing disk reads care means cache miss path rarely checked check tiny file system topologies solve problem choose success path buffer cache read routine ensure fisc explores miss path addition fisc generically fails memory allocation routines permission checks inserting choice points implementor exploit well-defined internal interfaces increase set explored actions interface specifications typically range actions implementation pick subset routines invocation return memory error actual implementation allocate memory paths allocations mistake fail specific allocation calls implementation performs means callers system configurations failures simple fix insert choice point routine action allowing model checker test failure handled call easy expose choice points require restructuring parts system remove artificial constraints invasive modifications buffer cache made permutation checker buffer write orderings checkers section describes checks fisc performs generic checks fisc inspects actual state system catch errors difficult impossible diagnose static analysis capable set general checks apply code run kernel deadlock instrument lock acquisition release routines check circular waits null fisc reports error kernel dereferences null pointer paired functions kernel functions iget iput inode allocation dget dput directory cache entries called pairs instrument functions kernel check called pairs running model checker memory leak instrument memory allocation deallocation functions fisc track memory altered system-wide freelist prevent memory consumers allocating objects model checker knowledge state transition stop system perform conservative traversal stack heap allocated memory silent failures kernel request resource specific planned bug system call returns success calls resource allocation routine fails exception pattern code loops acquires resource case generate false positive function fails iteration loop succeeds suppress false positives manually marking functions resource acquisition loops consistency checks fisc checks consistency properties system calls map actions mutation file system success system call return produce user-visible change indication failure produce change model volatilefs ensure operation produces user-visible change correct change recoverable disk write ordering write 
arbitrary combinations dirty buffer cache entries disk checking system recovers valid state file system recovery code typically requires disk writes happen stylized orders illegal orders interfere normal system operation lead unrecoverable data loss crash occurs inopportune moment comprehensively checking errors requires largest legal set dirty buffers memory flush combinations blocks disk legal opportunity file systems check thwart desires background thread periodically write dirty blocks disk cleaned blocks subsequent reorder checking falsely constraining schedules generate vagaries thread scheduling hide vulnerabilities thread run system vulnerable state dangerous disk writes happen modified thread model checker track blocks legally written block added set write permutations set verify running fsck produces valid file system image set blocks written dirty buffers buffer cache dirty buffers written order requests disk queue disks routinely reorder disk queue set initially empty blocks added buffer cache entry marked dirty blocks removed set ways deleted buffer cache marked clean file system explicitly waits block written file system forces synchronous write specific buffer entire disk request queue changed buffers marked dirty file system block buffer cache mark dirty operating system eventually write block back disk blocks marked dirty flushed cache time initially thought generic dirty bit buffer track dirtiness buffer file system slightly concept means buffer dirty ext considers buffer dirty conditions true generic dirty bit set buffer journaled journal dirty bit set buffer journaled revoked revocation valid discovering dirty buffer invariants requires intimate knowledge file system design run checker ext buffer consistency journaling file system associates state buffer buffer cache rules state change buffer managed ext marked dirty journal dirty written journal journal dirty written location disk dirty double fsck default fsck journaled file system simply replays journal compare file system resulting recovering manner generated running fsck comprehensive mode scans entire disk checking consistency differ wrong scaling system brought system online ran number performance memory bottlenecks section describes important optimizations state hashing search exploring exponential state space game ignore irrelevant details quest explore states differ non-superficial ways fisc plays game places state hashing selectively discards details make bit-level states equivalent searching picks state explore describe initially hashed things checked file system state heap data segment raw disk practice meant hard comprehensively explore interesting states model checker spent time re-exploring states iterative experimentation settled hashing volatilefs stablefs list runnable threads ignore heap thread stacks data segment users optionally hash actual disk image abstract stablefs check higher-level detail discarding detail rarely explore states size checkpoint roughly state queue holding to-beexplored states consumes memory long fisc exhaust search space stave exhaustion randomly discarding states state queue size exceeds user-selected threshold provide heuristic search strategies alternatives vanilla dfs bfs heuristic attempts stress file system recovery code preferentially running states disks work repair crash crudely tracking sectors written state parent disk recovered sorts states approach found data loss error jfs trigger strategy heuristic quantify state previously explored states utility score state utility score based times states features explored features include number dirty blocks state abstract file system topology ext reiserfs jfs states total expanded states state transitions time memoization memoization table number states transitions cost checking file system point fisc runs memory times seconds reiserfs large virtual memory requirements limited fisc checks roughly order magnitude fewer states systems fsck memoization speeds checking ext factor reiserfs factor parent executed file system statements state score exponentially-weighted weighted sum number times feature systematically failing functions transition mkdir creat executed perform calls functions fail memory allocation permission checks blindly causing combinations functions fail risks fisc explore exponential number uninteresting redundant transitions state additionally cases fs-implementors uninterested failures triggered memory allocation failures disk read error occurs iterative approach fisc run transition failures run failing single callsite callsites failed similarly fail callsites users maximum number failures fisc explore default failure approach find smallest number failures needed trigger error efficiently modeling large disks figure shows naively modeling reasonable-sized disks contiguous memory allocation severely limits number states model checker explore quickly exhaust memory changing file system code works smaller disk non-trivial error prone code mutuallydependent macros structures functions rely offsets intricate ways efficiently model large disks hash compaction database disk chunks collections disk sectors hashes disk array memory number states memory usage compaction ext compaction compaction chunk database figure memory usage model checking ext disk disk compaction compaction model checker quickly exhausts physical memory dies reaches states chunk database consumes total memory maximum note spike state mark fisc starts randomly discarding states state queue hashed chunks write alters chunk hash inserting database chunk hash fsck memoization repairing file system expensive takes times long runfsck restore state generate state executing operation careful time run fsck dominates checking fortunately practical purposes recovery code deterministic input disk image produce output image determinism memoize result recovering specific disk running fsck check current disk hash table return computed result run fsck add entry table space optimization track sectors read written fsck memoization trivial huge performance win table fsck recovery checker run fsck times crash cluster-based model checking model checking run makes set configuration choices number files directories operations fail crashes happen recovery exploring values expensive miss bugs fortunately exploration easily parallelizable wrote script set configuration settings remote machines generates configurations remotely executes summary table shows fisc check states transitions ext seconds expanded states transitions explored data section computed pentium ghz machine memory crashes recovery classic recovery mistake incorrectly handle crash recovery number potential failure scenarios caused failure unwieldy number scenarios caused failure combinatorially exciting failures correlated crashes uncommon power outage run fsck power runs similarly bad memory board system crash promptly recovery section describes check file system recovery logic handle single crash recovery check fsck crashes recovery attempt final file system stablefs obtained running fsck time disk possibly modified previous run attempt succeeded case fsck crashes repeatedly recovery repeated failure intellectually interesting difficulty reasoning errors caused single crash implementors shown marked disinterest elaborate combinations conceptually basic algorithm simple disk image crash run fsck completion record ordered write-list sectors values written fsck recovery tuple sector written data written sector formal terms model fsck function denoted fsck maps input disk output 
disk dprime differences dprime values write-set purposes writes effects running fsck denote partial evaluation fsck performing writes fsck definition fsck fsck disk image obtained applying writes disk image disk image returned fsck rerun fsck verify produces file system running fsck fsck computing fsck fsck fsck simulates effect crash recovery fsck performed writes restarted illustrate invoking fsck writes sectors values algorithm apply write obtain crash check apply write obtain crash check approach requires refinements reasonable speed catch errors reason describe speed determinism naive algorithm checks cases dramatically reduce number exploiting facts practical purposes regardfsckas deterministic procedure determinism implies property invocations deterministic function read input values compute result write fsck change previously read crash rerun back current state fsckrarely writes data reads result writes require crash recover intersect set sectors fsck reads determinism influence disk produce state independence precisely rsi denote unordered set sectors read fsck denote disk produced applying writes order initial disk claim sector written read set rsi running fsck completion disk produces result running rsi implies fsck fsck recall rsi rsi tautologically deterministic function change computes values reads rsi implies fsck fsck read identical values steps forcing compute results step perform write making disks identical special cases checker exploits skip running fsck suppose write sector rsi writes disk fsck fsck surprisingly recovery programs empirically redundant writes sector written dominated earlier write read precedes affect overwritten fsck restarted checking write orderings algorithm miss errors sector writes complete order explicitly synchronously direct option unix blocked sync barrier sync system call unix believed return dirty blocks written disk generating disk images crashingfsckat point requires partitioning writes sync groups checking thatfsckwould work correctly rerun performing subset writes sync group power set writes contained sync group write sectors call sync write sector sync groups generates write schedules write schedule sectors written fsck crashed note schedule equivalent rerun fsck writes complete sync group checker things size equal user-defined threshold checker exhaustively verify interleavings size larger checker series trials picks random subset random size trials deterministically replayed seed pseudo-random number generator hash sectors involved typically set number random trials reordering found bugs fsck recovery found checked file systems finding perspective recovery errors important reasoning extremely difficult recovery errors information model checker form wrote block block disk image files figuring semantically error occurred blocks writing values caused problem easily entire day process replicated implementor fix find simplest error case checker modes roughly ordered increasing degrees freedom difficulty diagnosing errors limiting degrees freedom means ordered increasing cost blush modes excessive reality desperate attempt find perspective makes reasoning error tractable additional views add synchronous atomic logical writes simplest view group sector writes logical writes synchronously order occur program execution logical writes means group blocks written system call invocation group calls write system call writing sectors writing sectors logical operations apply writes crash check apply writes crash check strongest logical view disk operations complete order issued writes single logical operation occur atomically easy reason errors means fsck reentrant synchronous non-atomic left-to-right logical writes treat logical writes synchronous write contained sectors non-atomically left-toright write sector logical group crash check write errors easy reason tend localized single invocation system call data structure assumed internally consistent straddled sector boundary reordered atomic logical writes mode reorders logical writes sync group checking permutation errors fixed inserting single sync call synchronous non-atomic logical writes mode writes sectors logical operation order crashing schedule errors modular interesting effects reordered sector writes view hardest reason sternest test file system recovery reorder sectors sync group arbitrarily errors hit make attempt find prior modes results table summarizes errors found broken file systems categories errors reported respective developers found bugs total fixed remaining confirmed complex patch submitted errors supposedly stable committed data metadata typically entire directories lost jfs higher error counts part due responses jfs developers enabled patch errors continue checking jfs checking xfs file system preliminary results promising discuss bug categories detail highlighting interesting errors found errors reported paper found page http keeda stanford junfeng osdi-fisc-bugs html titled osdi fisc bugs error type vfs ext ext jfs reiserfs total lost stable data false clean security holes minor kernel crashes total table found errors permanent data loss intended errors programmers decided sacrifice consistency availability shown table unrecoverable data loss errors found caused irrevocable loss committed stable data errors execution sequence lead complete loss metadata data committed on-disk journal cases large parts long-lived directories including root directory obliterated data loss main invalid write ordering journal data recovery buggy implementations transaction abort fsck invalid recovery write ordering bugs type normal operation journaling file system journal flushed disk data describes file systems check inverse ordering constraint wrong recovery journal replayed data modified roll forward flushed disk journal persistently cleared crash occurs file system corrupt missing data journal empty unable repair file system figure representative error ext fsckprogram chain mishaps recover ext journal rolls journal forward calling journal recover journal recover replays journal writing file system cached writes calls fsync super flush modified data back disk macro defined due error made moving recovery code kernel separate fsck process control returns recover ext journal calls fsck journal release writes cleared journal disk lack sync barriers write reach disk modified data result crash occurs point obliterate parts file system journal empty causing data loss bug reported developers immedie fsprogse fsck jfs user error empty macro sync data define fsync super dev fsprogse fsck journal static errcode recover ext journal fsck ctx journal journal int retval journal init revoke caches retval fsck journal ctx journal retval journal recover journal flushes empty journal fsck journal release ctx journal return retval fsprogse fsck recovery int journal recover journal journal process journal records cached writes err pass journal info pass scan err err pass journal info pass revoke err writes persistent data recorded journal cached write calls err pass journal info pass replay write modified data back clearing journal fsync super journal dev return err figure journal write ordering bug ext fsck ately released patch reiserfs jfs similar bugs fixed systems code lacked attempt order journal clear writes journal data buggy transaction 
abort fsck bugs type jfs threefold jfs immediately applies journaled operations in-memory metadata pages makes hard roll back aborted transactions modifications interleaved writes ongoing committed transactions result jfs aborts transaction relies custom code carefully extricate side-effects aborted transactions non-aborted writer code forgets reverse modification flushed disk interlacing directories invalid entries aborted transactions jfs fsckmakes attempts recover valid entries directories recovery policy directory single invalid entry remove entries directory attempt reconnect subdirectories files lost found opens huge vulnerability file system mistake results persistently writing invalid entry disk fsck deliberately destroy violated directory jfs fsck incorrect optimization loss committed subdirectories files jfs dynamically allocates places inodes performance tracking location inode map speed incremental modifications map written on-disk journal flushing map disk inode allocation deletion reconstruction fsck code loss inodes correctly applies incremental modifications copy inode map deliberately overwrite out-of-date on-disk inode map correct reconstructed copy figure shows bug jfs code initial version jfs fsck years ago implementors incorrectly believed file system marked dirty flushing inode map unnecessary rebuilt fix trivial flushing map bug hard find model checker jfs developers chasing manifestations submitted bug report file system events operations sector writes choices made model checker jfs developer create patch couple days good fact model checking improves testing systematic repeatable controlled data loss bugs jfs journal spans sectors vulnerability jfs stores sequence number sector journal middle sectors crash jfs fsck checks sequence numbers match replays journal additional checking inopportune sector reorderings lead corrupt journal badly mutilate file system replayed jfs ext bug crashed file jfsutilslibfs logredo original incorrect comment don update maps aggregate dirty fsck rebuild maps vopen fsdirty check dirtiness update on-disk map updatemaps fsck send msg lrdo errorcantupdmaps goto error figure incorrect jfs fsckoptimization unrecoverable loss inodes data system superblock falsely marked clean fsck program repair system potentially leading data loss system crash data loss bug happened jfs incorrectly stored negative error code inode number directory entry invalid entry fsck invocation remove directory security holes target security fisc found security holes readily exploitable easiest exploit found storage leak jfs routine jfs link create hard links calls routine ucsname allocates bytes memory jfs link free storage returning leak occurs time jfs link called allowing user trivially denial service attack repeatedly creating hard links ignoring malice leaking storage hard link creation generally bad seemingly exploitable errors occurred ext caused lookup routines distinguish lookups failed entry existed memory allocation failed bug attacker create files directories preexisting file directory hijacking reads writes intended original file user delete nonempty directories write access case creating directory entry ext call routine ext find entry entry exists ext find entry returns null directory entry created returns error code low memory conditions ext find entry return null directory entry exists shown figure routine iterates pages directory page allocation fails ext page returns null skip directory worth entries low memory ext page fail entry checked ext find entry return null user write aclinux- ext dir struct ext dir entry ext find entry struct inode dir struct dentry dentry struct page res page unsigned long start unsigned long npages dir pages dir struct page page null iterate pages directory page ext page dir err page code check entry existence return entry found bug error return ext page return null figure ext security hole ext find entry cess directory effectively create files subdirectories existing file hijacking reads writes intended original file error similar ext rmdir calls routine ext empty dir ensure target directory empty return ext empty diris directory entries memory allocation fails allowing attacker delete non-empty directories permission remaining errors occurred ext identical ext bugs caused disk read errors low-memory conditions bugs kernel crashes bugs caused kernel crash null pointer dereference errors due improperly handled allocation failures error vfs layer error reiserfs jfs interesting error jfs fsck failed correctly repair file system marked clean subsequent traversal file system panic kernel incorrect code cases code wrong thing sys create creates file disk returns error subsequent allocation fails application file created error interesting heavily tested code vfs layer shared file systems leaks addition leak mentioned jfs routine jfs unmount leaks memory unmount file system experience section describes experiences fisc development sources false positives false negatives design lessons learned fisc-assisted development checked preexisting file systems comprehensively study model checking helps development process responsiveness jfs developers allowed micro-case study fisc-assisted software development evolution series mistaken fixes found reported kernel panics jfs transaction abort function txabortcommit called transaction commit function txcommit memory allocation failed days jfs developers patch removed txabortcommit made txcommit call txabort applied patch replayed original model checking sequence verified fixed panics ran full model checking seconds segmentation faults vfs code examination revealed newly created inode inserted vfs directory entry cache transaction committed failed commit freed inode left dangling pointer vfs directory entry cache report back jfs developers days replied patch applied fixed specific error occurred ran fisc patched code found error fsck complain parent directory contained invalid entry remove parent directory bit worse original error bug outstanding caveats mind model checking nice properties makes trivial verify original error fixed comprehensive testing patches appears commercial software houses finds corner-case implications seemingly local seconds demonstrates violate important consistency invariants false positives false positives found fell groups bugs model checking harness understanding underlying file system checked code minor problem file system implementors system replaced problems arising imperfect understanding underlying model checker iteratively correct series slight misunderstandings internals file systems checked group false positives stemmed implementors intentionally ignoring violating properties check reiserfs kernel panic disk read fails circumstances fortunately false positives easily handled disabling check false negatives absence proving total correctness check things verification briefly describe largest sources missed errors exploring thresholds poor job triggering system behavior occurs crossing threshold glaring test small number files directories miss bugs happen directories undergo reorganization change representations sufficient number entries real examples include re-balancing directory tree structures jfs hashed directory structure ext fisc check mixture large small files inode representations file names directories span sector boundaries crash recovery multi-threading support model checker single-threaded system call interface single user process file system operations 
state transition runs atomically completion means interfering state modifications occur checked system terms high-level errors file system operations interleave partially completed transactions memory disk expect fruitful source bugs white-box model checking fisc flag errors sees instrument code miss low-level errors memory corruption freed memory race condition crash invariant violation fortunately model-check implementation code simultaneously run dynamic tools unchecked guarantees file systems provide guarantees handled current framework include versioning undelete operations disk quotas access control list support journaling data fact reasonable guarantees data block contents crashes fix lack agreedupon guarantees non-sync data crashes check metadata consistency crashes data blocks precede sync point corrupted lost complaint file systems directed acyclic graphs trees events file system operations failures bad blocks topological independence events subgraph affect disjoint subgraph events temporal independence creating files directories harm files directories broaden invariants check infer fs-specific knowledge techniques missed states state hashing potentially discard detail discard details possibly missing real errors fs-specific knowledge opens host additional state optimizations profitable knew interleavings buffer cache blocks fsck written blocks independent files dramatically reduce number permutations needed checking effects crash aggressively verified statement coverage file systems unexercised statements design lessons hard lesson learned sort heisenberg principle checking make inspection checking code perturb state checked system violating principle leads mysterious bugs history code traversing mounted file system building model drives point home initially extracted volatilefs single block device test driver mutated traversed create model volatile file system mutation design deadlocked file system operation multi-sector write traversal code read file system sectors written file system code responsible write holds lock file written lock traversal code acquire removed specific deadlock copying disk test driver operation traversing copy essentially creating file systems hack worked started exploring larger file system topologies point deadlock creation file system copy kernel memory preventing traversal thread successfully complete final hack solve problem create reserve memory pool traversal thread retrospect solution run kernels side side dedicated mutating disk inspecting mutated disk isolation straightforwardly remove perturbations checked system similar lesson system checked instrumented modified absolutely code hidden assumptions easily violated changing code kernel kernel memory allocators re-implemented previous work part leak checking replacement worked fine original context checking tcp caused checked file systems crash turned deliberately mangling address returned memory ways intimately depended original allocator page alloc worked promptly restored original kernel allocators related work section compare approach file system testing techniques software model checking efforts generic bug finding approaches file system testing tools file system testing frameworks application interfaces stress live file system adversarial environment frameworks comprehensive model checking require work required jam entire model checker view testing complementary model checking reason test file system apply model checking vice versa case effective tools find errors irrespective theoretical strengths weaknesses software model checking model checkers previously find errors design implementation software systems compare work model checkers similar approach execute system implementation directly resorting intermediate description verisoft software model checker systematically explores interleavings concurrent program unlike cmc model checker verisoft store states checkpoints potentially explore state verisoft relies heavily partial order reduction techniques identify control data independent transitions reduce interleavings explored determining independent transitions extremely difficult systems tightly coupled threads sharing large amount global data result verisoft perform systems including linux file systems checked paper java pathfinder similar cmc systematically checks concurrent java programs checkpointing states relies specialized virtual machine tailored automatically extract current state java program techniques paper applicable java pathfinder generic bug finding recent work bug finding including type systems static analysis tools roughly speaking static analysis examine paths compile code order check finding errors surface properties visible source lock paired unlock contrast model checking requires running code makes strenuous apply days weeks hours lets check executed paths executes code effectively check properties implied code log valid records thatfsck delete directories based experiences static analysis errors paper difficult approach testing view static analysis complementary model checking lightweight reason apply model checking conclusion paper shown model checking find interesting errors real file systems found errors resulted loss crucial metadata including file system root directory majority bugs resulted patches heavily-tested file systems modelchecked severity errors found appears model checking works context file systems relief applied full system model-checking contexts successfully underlying reason effectiveness context file systems complex things single worst source complexity recoverable state face crashes power loss single program point hope model checking show similar effectiveness domains reason vast array failure cases database recovery protocols optimized consensus algorithms acknowledgments dave kleikamp answering jfs related questions diagnosing bugs submitting patches andreas dilger theodore viro christopher andrew morton stephen tweedie ext ext oleg drokin vitaly fertman reiserfs ted kremenek last-minute comments edits grateful andrew myers shepherd ken ashcraft brian gaeke lea kissner ilya shpitser xiaowei yang monica lam anonymous reviewers careful reading valuable feedback ball rajamani automatically validating temporal safety properties interfaces spin workshop model checking software boehm simple garbage-collector-safety proceedings sigplan conference programming language design implementation brat havelund park visser model checking programs ieee international conference automated software engineering ase bush pincus sielaff static analyzer finding dynamic programming errors software practice experience clarke grumberg peled model checking mit press corbett dwyer hatcliff laubach pasareanu robby zheng bandera extracting finitestate models java source code icse swat coverity software analysis toolset http coverity das lerner seigle path-sensitive program verification polynomial time proceedings acm sigplan conference programming language design implementation berlin germany june deline ahndrich enforcing high-level protocols low-level software proceedings acm sigplan conference programming language design implementation june dill drexler yang protocol verification hardware design aid proceedings ieee international conference computer design vlsi computer processors pages ieee computer society engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions proceedings operating systems design implementation osdi sept engler musuvathi static analysis versus software model checking bug finding invited paper international conference verification model checking abstract interpretation vmcai pages jan ext ext file system http fsprogs net flanagan freund type-based race detection java sigplan conference programming language design implementation pages flanagan leino lillibridge nelson saxe stata extended static checking java proceedings acm sigplan conference programming language design implementation pages acm press foster terauchi aiken flow-sensitive type 
qualifiers proceedings acm sigplan conference programming language design implementation june ganger patt soft updates solution metadata update problem file systems technical report michigan godefroid model checking programming languages verisoft proceedings acm symposium principles programming languages holzmann model checker spin software engineering holzmann code models proc int conf applications concurrency system design pages newcastle tyne ibm journaling file system linux http wwwibm jfs symbolic model checking kluwer academic publishers kleikamp private communication linux test project http ltp net musuvathi engler model checking large network protocol implementations proceedings symposium networked systems design implementation musuvathi park chou engler dill cmc pragmatic approach model checking real code proceedings symposium operating systems design implementation reiserfs http namesys sandberg goldberg kleiman walsh lyon design implementation sun network file system sivathanu prabhakaran popovici denehy arpaci-dusseau arpacidusseau semantically-smart disk systems usenix conference file storage technologies stress http weather apw projects stress waldspurger memory resource management vmware esx server proceedings symposium operating systems design implementation 

abstract paper describes network-attached secure disk nasd storage architecture prototype implementations nasd drives array management architecture filesystems built prototype nasd scalable storage bandwidth cost servers primarily transferring data peripheral networks scsi client networks ethernet increasing dataset sizes attachment technologies convergence peripheral interprocessor switched networks increased availability on-drive transistors motivate enable architecture nasd based main principles direct transfer clients secure interfaces cryptographic support asynchronous non-critical-path oversight variably-sized data objects measurements prototype system show services costeffectively integrated generation disk drive asic end-to-end measurements prototype drive filesystems suggest nasd support conventional distributed filesystems performance degradation importantly show scalable bandwidth nasd-specialized filesystems parallel data mining application nasd drives deliver linear scaling clientdrive pair tested pairs lab keywords file systems management distributed systems input output data communications introduction demands storage bandwidth continue grow due rapidly increasing client performance richer data types video data-intensive applications data mining storage subsystems deliver scalable bandwidth linearly increasing application bandwidth increasing numbers storage devices client processors data striped disks network links patterson technology office engineering data processing shops sufficient numbers disks scalable switched networking access storage storage controller distributed fileserver bottlenecks bottlenecks arise single server computer receives data storage peripheral network forwards client local area network adding functions concurrency control metadata consistency variety research projects explored techniques scaling number machines enforce semantics controllers fileservers cabrera hartman cao drapeau anderson lee thekkath section shows scaling number machines devoted store-and-forward copying data storage client networks expensive paper makes case scalable bandwidth storage architecture network-attached secure disks nasd separates management filesystem semantics store-and-forward copying evolving interface commodity storage devices scsiperhaps eliminate server resources required solely data movement earlier generations scsi nasd interface simple efficient flexible support wide range filesystem semantics multiple generations technology demonstrate nasd architecture deliver scalable bandwidth describe prototype implementation nasd storage manager nasd arrays simple parallel filesystem delivers scalable bandwidth parallel data-mining application figure illustrates components nasd system sections describing continue section discussion storage system architectures related research section presents enabling technologies nasd section presents overview nasd interface implementation performance section discusses ports nfs afs filesystems nasd-based system implementation nasd array management system simple parallel filesystem o-intensive data mining application exploits bandwidth prototype section reports scalability prototype compared performance fast single nfs server section discusses active disks logical extension nasd execute application code section concludes discussion ongoing research cost-effective high-bandwidth storage architecture garth gibson david nagle khalil amiri jeff butler fay chang howard gobioff charles hardin erik riedel david rochberg jim zelenka school computer science department electrical computer engineering carnegie mellon pittsburgh garth asplos cmu proceedings conference architectural support programming languages operating systems copyright association computing machinery permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copyrights components work owned acm honored abstracting credit permitted copy republish post servers redistribute lists requires prior specific permission fee request permissions dept acm permissions acm background related work figure illustrates principal alternative storage architectures local filesystem distributed filesystem dfs built directly disks distributed filesystem built storage subsystem network-dma distributed filesystem distributed filesystem smart object-based disks nasd distributed filesystem level objects storage management simplest organization aggregates application file management naming directories access control concurrency control low-level storage management disk data makes trip simple peripheral area network scsi fibrechannel disks offer fixed-size block abstraction stand-alone computer systems widely understood organization share data effectively computers intermediate server machine introduced server offers simple file access interface clients organization distributed filesystem server processes data behalf clients organization distributed database organization data makes network trip client server machine bottleneck serves large numbers disks amortize cost limitations single central fileserver widely recognized companies auspex network appliance attempted improve file server performance specifically number clients supported special purpose server hardware highly optimized software hitz hitz topic paper nasd architecture improve client-load-bearing capability traditional filesystems off-loading simple data-intensive processing nasd drives gibson transparently improve storage bandwidth reliability systems interpose computer raid controller patterson organization adds peripheral network transfer store-and-forward stage data traverse provided distributed filesystem reorganized logically dma data copy server fourth organization reduces number network transits data organization examined extensively drapeau long hpss implementation mass storage model watson miller organization applies systems clients trusted maintain filesystem metadata integrity implement disk striping redundancy hartman anderson case client caching metadata reduce number network transfers control messages data disks attached client machines presumed independently paid generally idle eliminates additional store-and-forward cost clients idle eliminating copy section nasd architecture embeds disk management functions device offers variable-length object storage interface organization file managers enable repeated client accesses specific storage objects granting cachable capability figure overview scalable bandwidth nasd system major components annotated layering logical components innermost box shows basic nasd drive section larger box essentials nasd-based filesystem adds file manager client detailed section finally outer box adds storage manager coordinate drives parallel filesystem built discussed section net protocol controller net hardware hda nasd object system filesystem access control namespace consistency net protocol net hardware file manager switch client nasd storage manager striping concurrency control mapping redundancy net protocol net hardware management read write access control section section section security layout nasdnasd nasd nasd nasd driver net protocol net hardware application filesystem data control travels network expensive store-and-forward computer idea simple disk-like network-attached storage server building block high-level distributed filesystems long time cambridge universal file server ufs abstraction similar nasd directory-like index structure birrell ufs reclaim space reachable root index successor project cambridge cfs performed automatic reclamation added undoable period time initiation transactions filesystem interface mitchell minimize coupling file manager device implementations nasd offers powerful semantics automatic reclamation transaction rollback object interface storage fixedblock interface moves data layout management disk addition nasd partitions variable-sized groupings objects physical regions disk media enabling total partition space managed easily manner similar virtual volumes virtual disks ieee lee specific implementations exploit nasd uninterpreted filesystem-specific attribute fields respond higher-level capacity planning reservation systems attribute-managed storage golding object-based storage pursued quality-of-service device transparent performance optimizations drive supported data sharing anderson isi netstation project vanmeter proposes form object-based storage called derived virtual devices dvd state open network connection augmented 
access control policies object metadata provided file manager kerberos neuman underlying security guarantees similar nasd mechanism nasd access control policies embedded unforgeable capabilities separate communication state interpretation persists objects connection terminated netstation dvd physical partition server visa vanmeter similar nasd singleobject server parallel distributed filesystem contrast isi approach nasd security based capabilities well-established concept regulating access resources dennis past systems capabilities rely hardware support trusted operating system kernels protect system integrity wulf wilkes karger nasd make assumptions integrity client properly maintain capabilities utilize cryptographic techniques similar iscap gong amoeba tanenbaum systems entity issuing capability entity validating capability share large amount private information issued capabilities systems generally implemented single entities issuing validating capabilities nasd functions distinct machines per-capability state exchanged issuer validator offer disk striping redundancy nasd layer nasd interface organization storage manfigure evolution storage architectures untrusted networks clients boxes computers horizontal lines communication paths vertical lines internal external interfaces lan local area network ethernet fddi peripheral area network scsi fibrechannel ibm escon san emerging system area network servernet myrinet fibrechannel ethernet common clients servers devices disk capable functions seek read write readahead simple caching object store binds blocks variable-length objects manages layout objects storage space offered device file manager naming directory hierarchies consistency access control concurrency control nasd storage management recursion object interface san local filesystem distributed distributed raid controller dma-based dfs nasd based dfs file manager disk lan lan pan lan pan pan pan pan bulk data transfer san san read write computers data control path application nasd-cheops-based dfs read write object store san san lan ager replaces file manager capability set capabilities objects make highlevel striped object costs additional control message equipped capabilities clients access storage objects directly redundancy striping objects accessible client set capabilities physical disk addresses storage management system cheops differs storage subsystems scalable processing power swift tickertaip petal long cao lee cheops client processing power scaling computational power storage subsystem cheops similar zebra xfs filesystems client trust required client manipulates objects access hartman anderson enabling technology storage architecture ready change result synergy overriding factors bound applications drive attachment technologies excess ondrive transistors convergence peripheral interprocessor switched networks cost storage systems o-bound applications traditional distributed filesystem workloads dominated small random accesses small files sizes growing time dramatically baker tpc contrast workloads o-bound including data types video audio applications data mining retail transactions medical records telecommunication call records drive attachment technology technology improvements increasing disk density year driving disk bandwidth year grochowski high transfer rates increased pressure physical electrical design drive busses dramatically reducing maximum bus length time people building systems clustered computers shared storage reasons storage industry moving encapsulating drive communication fibrechannel benner serial switched packet-based peripheral network supports long cable lengths ports bandwidth impact nasd evolve scsi command set encapsulated fibrechannel full advantage promises switched-network technology higher bandwidth increased flexibility excess on-drive transistors increasing transistor density inexpensive asic technology allowed disk drive designers lower cost increase performance integrating sophisticated special-purpose functional units small number chips figure shows block diagram asic heart quantum trident drive drive asic technology advances micron cmos micron cmos insert mhz strongarm microcontroller leaving gate-equivalent space functions onchip dram cryptographic support major jump siemen tricore integrated microcontroller asic architecture promises deliver mhz -way issue next-generation asic micron technology figure quantum trident disk drive features asic left integrated chip independent clock domains function units total logic gates sram disk formatter scsi controller ecc detection ecc correction spindle motor control servo signal processor sram servo data formatter spoke dram controller microprocessor port connected motorola class processor advancing higher asic density die area accommodate mhz strongarm microcontroller space left dram additional functional units cryptographic network accelerators current trident asic micron micron frees insert micron strongarm risc fits cache mhz dhrystone mips frees kgates cryptography network support -bit datapath onchip dram customer defined logic tricore convergence peripheral interprocessor networks scalable computing increasingly based clusters workstations contrast special-purpose highly reliable low-latency interconnects massively parallel processors paragon cosmic cube clusters typically internet protocols commodity lan routers switches make clusters effective lowlatency network protocols user-level access network adapters proposed adapter card interface virtual interface architecture standardized maeda wilkes boden horst voneicken intel developments continue narrow gap channel properties peripheral interconnects network properties client interconnects sachs make fibrechannel gigabit ethernet alike cost-ineffective storage servers high performance distributed filesystems high cost overhead server machine manages filesystem semantics bridges traffic storage network client network anderson figure illustrates problem bandwidth-intensive applications terms maximum storage bandwidth based cost peak performance estimates compare expected overhead cost storage server fraction raw storage cost servers built high-end components overhead starts server-attached disk assuming dual -bit pci busses deliver byte memory high-end server saturates disks network interfaces disk interfaces overhead cost low cost server cost effective disk suffers cost overhead bit pci bus limit disk system suffers cost overhead accurately anticipate marginal increase cost nasd current disks estimate disk industry happy charge bound reduction server overhead costs factor total storage system cost neglecting network infrastructure network-attached secure disks network-attached secure disks nasd enable cost-effective bandwidth scaling nasd eliminates server bandwidth bottleneck modifying storage devices transfer data directly clients repartitions traditional file server database functionality drive client server shown figure nasd presents flat space variable-length objects simple implemented efficiently flexible wide variety applications highest levels distributed filesystem functionality global naming access control concurrency control cache coherency vary significantly advocate storage devices subsume file server residual filesystem file manager define manage high-level policies nasd devices implement simple storage primitives efficiently operate independently file manager broadly define nasd storage exhibits properties direct transfer data transferred drive client indirection store-and-forward file server machine asynchronous oversight define asynchronous oversight ability client perform operations synchronous appeal file manager frequently consulted infrequently changed policy decisions authorization decisions encoded capabilities file manager subsequently enforced drives cryptographic integrity attaching storage network open drives direct attack adversaries apply cryptographic techniques defend potential attacks drives ensure commands data tampered generating verifying cryptographic keyed digests essentially requirement security proposed ipv deering disk interface network system memory processor unit interface figure cost model traditional server architecture simple model machine serves set 
disks clients set disk wide ultra ultra scsi network fast gigabit ethernet interfaces peak bandwidths neglecting host cpu memory bottlenecks estimate server cost overhead maximum bandwidth sum machine cost costs sufficient numbers interfaces transfer disks aggregate bandwidth divided total cost disks prices date basic problem high server overhead remain report pairs costs bandwidth estimates left show values low cost system built high-volume components show values high-performance reliable system built components recommended mid-range enterprise servers pricewatch ethernet seagate ultra scsi medallist cheetah object-based interface drives direct knowledge relationships disk blocks minimize security overhead drives export variable length objects fixed-size blocks improves opportunities storage self-management extending disk understanding relationships blocks disk anderson nasd interface experiments presented paper constructed simple capability-based object-store interface documented separately gibson interface requests including read write object data read write object attributes create remove object create resize remove partition construct copy-on-write object version set security key figure diagrams components nasd request illustrates layering networking security based loosely inode interface unix filesystem mckusick interface soft partitions control objects per-object attributes preallocation clustering capability revocation resizeable partitions capacity quotas managed drive administrator objects well-known names structures configuration bootstrap drives partitions enable filesystems find fixed starting point object hierarchy complete list allocated object names object attributes provide timestamps size capacity reserved objects linked clustering dejonge logical version number object changed filesystem immediately revoke capability temporarily permanently finally uninterpreted block attribute space file manager record long-term per-object state filesystem access control lists mode bits nasd security based cryptographic capabilities documented earlier gobioff capabilities protected small number keys organized four-level hierarchy primary keys manage key hierarchy construct capabilities clients clients obtain capabilities file manager secure private protocol external nasd capability public private portion public portion description rights granted object private portion cryptographic key generated keyed message digest bellare public portion drive secret keys drive verifies client perform operation confirming client holds private portion capability client sends public portion request generates digest request parameters keyed private field drive keys receives public fields capability request current version number object compute client private field client compute file manager drive secret keys field changed including object version number access fails client back file manager mechanisms ensure integrity requests presence attacks simple accidents protecting integrity privacy data involves cryptographic operations data potentially expensive software implementations operating disk rates computational resources expect disk schemes based multiple des function blocks hardware implemented tens thousands gates operate faster disk data rates verbauwhede knudsen measurements reported paper disabled security protocols prototype support hardware prototype implementation implemented working prototype nasd drive software running kernel module digital unix nasd prototype drive runs dec alpha mhz digital unix seagate medallist disks attached scsi busses bulky drive performance year machine similar predict drive controllers physical drives managed software striping driver approximate rates expect modern drives prototype code intended operate directly drive nasd object system implements internal object access cache disk space management modules total lines code interacts minimally digital unix communications prototype dce rpc udp implementation networking services heavyweight protocol suite implementation issue active research anderson anderson vanmeter figure shows disks baseline sequential access bandwidth function request size labeled raw read write test measures latency request drives write-behind caching enabled figure packet diagram major components nasd request current prototype details nasd objects requests security documented separate papers gibson gobioff request digest nonce request args capability security header rpc header network header key security options handling request includes approved logical version number access rights expiration time accessible object region protects replayed delayed requests digest data write actual completion time measured accurately resulting write throughput appears exceed read throughput evaluate object access performance modified prototype serve nasd requests user-level process machine rpc compared performance local filesystem variant berkeley ffs mckusick figure shows apparent throughput function request size nasd ffs roughly comparable ffs strange write-behind implementation principle differences nasd tuned disk access versus reads miss cache ffs tuned cache accesses fewer copies give versus reads hit memory cache scalability figure demonstrates bandwidth scalability nasd prototype satisfying requests cache experiment nasd drives linked ocatm client machines dec alphastation mhz digital unix client issues series sequential read requests striped nasds figure nasd deliver cache rpc protocol stack dce rpc push atm link receiving client saturates commodity nasd drives costly rpc mechanism test show simple access pattern nasd array deliver scalable aggregate bandwidth computational requirements prototype drive software baseline estimate computational power needed drive microcontroller support basic nasd functions atom code annotation tool srivastava alpha on-chip counters measure code paths read write operations measurements reported total instructions columns table byte requests measurements dcpi anderson show prototype consumes cycles instruction cpi reasons numbers predict drive performance approximate prototype alpha processor cpi properties embedded processor estimates neglect poorer cpi copying hardware assist real drive communications implementation expensive drive protocol stack numbers broadly addressing question implementing nasd drive asic table shows mhz version prototype figure nasd prototype bandwidth comparing nasd local filesystem ffs raw device sequential reads writes raw device stripes data units disks separate scsi bus response timing user-level process issuing single request amount data raw disk readahead effective requests smaller miss cases metadata cached cached accesses ffs benefits data copy nasd code exhibit degradation processor cache overflows nasd extra copy makes severe strange write performance ffs occurs acknowledges immediately writes writebehind waits disk media updated test nasd write-behind fully enabled disks request size request size ppa nasd read miss ffs read miss ffs read raw read nasd read nasd write miss ffs write miss ffs write raw write nasd write figure prototype nasd cache read bandwidth read bandwidth obtained clients accessing single large cached file striped nasd drives stripe unit shown client idle values limiting factor cpu power clients range ndw average client idle ent clients msecs small request spent communications codepath requests estimate msec work communications comparison examined seagate barracuda drive executing sequential reads important operation current drives large fraction operation directly handled hardware single sector reads barracuda takes msecs reads takes msecs conclude nasd control necessarily expensive workstation-class implementations communications vanmeter filesystems nasd shown previous section nasd drives attached clients high-bandwidth 
switched network capable scalable aggregate bandwidth client applications access data directly access data higher-level distributed filesystems demonstrate feasibility nasd ported popular distributed filesystems nfs afs sandberg howard nasd environment implemented minimal distributed filesystem structure passes scalable bandwidth network-attached storage applications scalability file managers traditionally meant increasing number clients supported total amount storage increased topic scope paper addressed howard anderson gibson thekkath scale achievable bandwidth increasing storage capacity requires simply attaching storage network application issues sufficiently large requests nfs afs break requests small transfer units limit number requests concurrently issued storage pragmatically class disk devices requires high sales volumes cost effectiveness filesystems effective performance fail strategy evolving existing systems architecture nasd drives traditional distributed filesystems penalty customers moved nasd-optimized filesystems bandwidth primary concern nfs afs nasd environment nasd-adapted filesystem files directories stored nasd objects mapping files directories objects depends filesystem nfs afs ports simple approach file directory occupies nasd object offsets files offsets objects common file attributes file length modify time correspond directly nasd-maintained object attributes remainder file attributes owner mode bits stored object uninterpreted attributes filesystem makes policy decisions based file attributes client directly modify object metadata commands impact policy decisions quota access rights file manager combination stateless server weak cache consistency filesystem management mechanisms make porting nfs nasd environment straightforward datamoving operations read write attribute reads getattr directed nasd drive requests handled file manager capabilities piggybacked file manager response lookup operations file attributes computed nasd object attributes modify times object size stored uninterpreted filesystem-specific attribute table measured cost estimated performance read write requests instruction counts distribution obtained instrumenting prototype atom alpha on-chip counters values shown total number instructions required service request size include communications dce rpc udp nasd code including kernel work behalf measured number cycles instruction cpi -byte requests larger requests processor copying implementation suffers significantly real disks substantial hardware assistance shown figure set columns instruction counts estimate duration operation mhz processor assuming cpi instructions including copying communications instructions comparison purposes experimented seagate barracuda drive read sequential sector cache msec read random single sector media msec requests reads cache msec media random location msec write warm cache means needed metadata cache operation starts operation total instructions communications operation time msec mhz cpi request size read cold cache read warm cache write cold cache write warm cache mode uid gid afs complex distributed filesystem personality readily mapped nasd environment nfs data-moving requests fetchdata storedata attribute reads fetchstatus bulkstatus directed nasd drives requests file manager afs clients perform lookup operations parsing directory files locally obvious operation piggyback issuing capabilities afs rpcs added obtain relinquish capabilities explicitly afs sequential conistency provided breaking callbacks notifying holders potentially stale copies write capability issued nasd file manager longer write operation arrived drive inform clients write occur issuing callbacks file outstanding write capability blocked expiration times set file manager capability ability directly invalidate capabilities file managers bound waiting time callback afs requires enforcement per-volume quota allocated disk space difficult nasd quotas logically managed file manager write file manager accessed write nasd byte range restriction capabilities file manager create write capability escrows space file grow selecting byte range larger current object capability relinquished file manager expired file manager examine object determine size update quota data structures appropriately nfs afs ports straightforward specifically transfers remain small directory parsing nfs server afs server concurrency limitations caused coroutine-based userlevel threads package primary goal demonstrate simple modifications existing filesystems nasd devices performance loss andrew benchmark howard basis comparison found nasd-nfs nfs benchmark times configurations drive client drives clients gibson report afs numbers afs server severe concurrency limitations make comparison unfair parallel filesystem nasd clusters fully exploit potential bandwidth nasd system higher-level filesystems make large parallel requests files striped multiple nasd drives illustrated figure layered approach filesystem manage logical object store provided storage management system called cheops cheops exports object interface underlying nasd devices maintains mapping higher-level objects objects individual devices prototype system implements cheops client library translates application requests manages levels capabilities multiple nasd drives separate cheops storage manager possibly co-located file manager manages mappings striped objects supports concurrency control multi-disk accesses cheops client manager lines code provide support parallel applications implemented simple parallel filesystem nasd pfs offers sio low-level parallel filesystem interface corbett employs cheops storage management layer mpich communications parallel applications mpi cheops dce rpc mechanism required nasd prototype evaluate performance cheops parallel data mining system discovers association rules sales figure nasd-optimized parallel filesystem nasd pfs conjunction mpi parallel applications cluster workstations filesystem manages objects directly backed data backed storage manager cheops redirects clients underlying component nasd objects parallel filesystem extends simple unix filesystem interface sio low-level interface corbett inherits service directory hierarchy access controls filesystem parallel access control namespace consistency net protocol net hardware parallel cheops net protocol application file manager client storage manager cheops manager concurrency control mapping redundancy net protocol net hardware management read write access control nasd nasdnasdnasd net hardware mpi switch object object object object object object transactions agrawal application goal discover rules form customer purchases milk eggs purchase bread store layout inventory decisions full scans data determining items occur transactions -itemsets information generate pairs items occur -itemsets larger groupings k-itemsets subsequent passes parallel implementation avoids splitting records boundaries simple round-robin scheme assign chunks clients client implemented producer threads single consumer producer threads read data requests stripe unit cheops objects configuration consumer thread performs frequent sets computation maintaining set itemset counts combined single master client threading maximizes overlapping storage utilization figure shows bandwidth scalability bound phases generation -itemsets processing sales transaction file single nasd drive array scales linearly nasd drives comparison show bandwidth achieved nasd pfs fetches single higher-performance traditional nfs file cheops nasd object nfs file server alphastation mhz digital unix ocatm links half clients communicate link seagate cheetah disks attached wide ultrascsi busses optimal code machine internally read disks raw disk interface show application throughput lines server line marked nfs-parallel shows performance client reading individual file independent disk achieves performance results show nfs server network bandwidth disk bandwidth perfect sequential access pattern disk loses potential performance cpu interface limits comparison nasd 
achieve raw underlying dual medallists finally nfs line comparable nasd line shows bandwidth clients read single nfs file striped disks configuration slower nfs-parallel prefetching heuristics fail presence multiple request streams single file summary nasd pfs cheops delivers bandwidth nasd drives application powerful nfs server fails deliver half performance underlying cheetah drives active disks recent work group focused logical extension exploiting growing amount on-drive computation providing full application-level programmability drives call active disks riedel acharaya generation storage devices execution environment directly individual drives code execute data interconnect network capability customize functionality specific data-intensive applications extending object notion basic nasd interface include code specialized methods accessing operating data type natural tie computation data scale capacity added system nasd enables type extension functionality time object-based interface sufficient knowledge data individual devices resort external metadata explored data mining multimedia applications active disks applications examined frequent sets computation discussed active disk experiments distribute sales transaction data set drives reading data network set clients itemset counting core frequent sets counting code executed directly inside individual drives advantage excess computational power drives completely eliminates client nodes application prototype drives discussed approximate active disks functionality achieve low-bandfigure scaling parallel data mining application aggregate bandwidth computing frequent sets sales transactions shown nasd line shows bandwidth clients reading single nasd pfs file striped drives scales linearly nfs configurations show maximum achievable bandwidth number disks fast nasd clients spread ocatm links comparable nfs line shows performance clients reading single file striped disks server bottlenecks configuration poor read-ahead performance inside nfs server add nfs-parallel line client reads replica file independent disk server configuration performs single file case raises maximum bandwidth nfs number disks nasd nfs nfs-parallel width ethernet networking hardware nasd pfs tests figure exploration active disks begun potential applications dramatic conclusions scalable storage bandwidth clusters achieved striping data storage devices network links provided switched network sufficient bisection bandwidth exists cost workstation server network adapters peripheral adapters generally exceeds cost storage devices increasing total cost cost simply buying storage presented promising direction evolution storage transfers data directly client network dramatically reduces cost overhead scalable network-attached storage defined properties support direct device-to-client transfers provide secure interfaces cryptography support asynchronous oversight file managers provide clients capabilities issue authorized commands directly devices fourth devices serve variable-length objects separate attributes fixed-length blocks enable self-management avoid trust client operating systems demonstrate concepts design implementation nasd prototype manages disks efficiently unix filesystem measurements prototype show microprocessor cores embedded asic modern disk drive provide adequate on-drive support nasd provided cryptographic hardware support security functions simple parallel distributed filesystem designed nasd show nasd architecture provide scalable bandwidth report experiments data mining application achieve client-drive pair system drives providing addition describe conventional distributed filesystems nfs afs ported nasd performance comparable current server-based systems acknowledgements mike leis quantum trident chip diagram figure paul mazaitis heroic efforts prototype environment configured keeping running dan stodolsky bill courtright joan digney greg ganger tara madhyastha todd mowry john wilkes ted wong anonymous reviewers taking valuable time provide comments improved paper members nsic working group network-attached storage dave anderson mike leis john wilkes conversations site visits finally members parallel data lab make research enjoyable research sponsored darpa ito darpa order issued indian head division nswc contract project team indebted generous contributions member companies parallel data consortium including hewlettpackard laboratories intel quantum seagate technology storage technology wind river systems corporation compaq data general clariion symbios logic acharya acharaya active disks acm asplos oct agrawal agrawal srikant fast algorithms mining association rules vldb sept anderson anderson serverless network file systems acm tocs feb anderson anderson continuous profiling cycles acm sosp oct anderson anderson network attached storage research nsic nasd meetings html march anderson anderson network attached storage research nsic nasd meetings html june anderson anderson cheating bottleneck network storage trapeze myrinet usenix june baker baker measurements distributed file system acm sosp oct bellare bellare canetti krawczyk keying hash functions message authentication crypto benner benner fibre channel gigabit communications computer networks mcgraw hill birrell birell needham universal file server ieee tse sept boden boden myrinet gigabit-per-second local area network ieee micro feb cabrera cabrera long swift distributed disk striping provide high data rates computing systems fall cao cao tickertaip parallel raid architecture acm isca corbett corbett proposal common parallel file system programming language scalable initiative caltech cacr nov deering deering hinden internet protocol version specification rfc dec dejonge dejonge kaashoek hsieh logical disk approach improving file systems acm sosp dec dennis dennis van horn programming semantics multiprogrammed computations cacm drapeau drapeau raid-ii high-bandwidth network file server acm isca gibson gibson file server scaling network-attached secure disks acm sigmetrics june gibson gibson filesystems networkattached secure disks cmu-cs- july gobioff gobioff gibson tygar security network attached storage devices cmu-cs- oct golding golding shriver sullivan wilkes attribute-managed storage workshop modeling specification san antonio oct gong gong secure identity-based capability system ieee symp security privacy grochowski grochowski hoyt future trends hard disk drives ieee trans magnetics hartman hartman ousterhout zebra striped network file system acm sosp dec hitz hitz unix component lightweight distributed kernel multiprocessor file servers winter usenix hitz hitz lau malcolm file systems design nfs file server appliance winter usenix january horst horst tnet reliable system area network ieee micro feb howard howard scale performance distributed file system acm tocs february ieee ieee model open storage systems interconnection-mass storage system model version sept intel intel corporation virtual interface architecture viarch dec karger karger improving security performance capability systems cambridge computer laboratory technical report oct knudsen knudsen preneel hash functions based block ciphers quaternary codes advances cryptology asiacrypt nov lee lee thekkath petal distributed virtual disks acm asplos oct long long swift raid distributed raid system computing systems summer maeda maeda bershad protocol service decomposition high-performance networking acm sosp dec mckusick mckusick fast file system unix acm tocs august miller miller model mass storage systems advances computers mitchell mitchell dion comparison network-based file servers acm sosp dec mpi mpi forum message-passing interface standard mcs anl gov mpi standard html neuman neuman kerberos authentication service computer networks ieee communications sept patterson patterson case redundant 
arrays inexpensive disks acm sigmod june pricewatch pricewatch july riedel riedel active storage large-scale data mining multimedia vldb aug sachs sachs lan convergence survey issues ieee computer dec sandberg sandberg design implementation sun network filesystem summer usenix june srivastava srivastava eustace atom system building customized program analysis tools wrl technical report tntanenbaum tanenbaum mullender van renesse sparse capabilities distributed system sixth conference distributed computing thekkath thekkath frangipani scalable distributed file system acm sosp oct tpc transaction performance council tpc-c executive summaries url tpc mar tricore tricore news release siemens -bit embedded chip architecture enables level performance real-time electronics design tri-core sept vanmeter van meter hotz finn derived virtual devices secure distributed file system mechanism nasa goddard conference mass storage systems technologies sep vanmeter van meter visa netstation virtual internet scsi adapter acm asplos oct verbauwhede verbauwhede security considerations design implementation des chip eurocrypt voneicken von eicken basu buch vogels u-net user-level network interface parallel distributed computing acm sosp dec watson watson coyne parallel architecture high-performance storage system hpss ieee symposium mass storage systems september wilkes wilkes needham cambridge cap computer operating system wilkes wilkes hamlyn interface senderbased communications hewlett-packard laboratories technical report hpl-osr- nov wulf wulf hydra kernel multiprocessor operating system cacm june 
exploiting gray-box knowledge buffer-cache management nathan burnett john bent andrea arpaci-dusseau remzi arpaci-dusseau department computer sciences wisconsin madison ncb johnbent dusseau remzi wisc abstract buffer-cache replacement policy significant impact performance intensive applications paper introduce simple fingerprinting tool dust uncovers replacement policy specifically identify initial access order recency access frequency access long-term history determine blocks replaced buffer cache show fingerprinting tool identify popular replacement policies literature fifo lru lfu clock random segmented fifo lru-k found current systems netbsd linux solaris demonstrate usefulness fingerprinting cache replacement policy modifying web server knowledge specifically web server infers contents file cache modeling replacement policy set page requests show servicing web pages believed resident buffer cache improve average response time throughput introduction specific algorithms manage buffer cache significantly impact performance o-intensive applications knowledge hidden user processes determine behavior buffer cache implementors forced rely documentation access source code general knowledge buffer caches behave relying hoc methods propose fingerprinting automatically uncover characteristics buffer cache paper describe dust simple fingerprinting tool identify buffer-cache replacement policy specifically identify initial access order recency access frequency access historical information fingerprinting microbenchmarking techniques identify algorithms policies system test idea fingerprinting insert probes underlying system observe resulting behavior visible outputs carefully controlling probes matching resulting output fingerprints algorithms identify algorithm system test key challenge inject probes create distinctive fingerprints algorithmic characteristics isolated significant advantages fingerprints automatically identifying internal algorithms fingerprinting eliminates developer obtain documentation source code understand underlying system fingerprinting enables programmers sophisticated experience algorithmic knowledge improve performance fingerprinting uncover bugs hidden complexities systems development deployed finally fingerprinting run-time allowing adaptive application modify behavior based characteristics underlying system paper investigate algorithmic knowledge exposing current contents buffer cache recent work shown o-intensive applications improve performance information contents file cache specifically applications handle data disk flexible order access blocks buffer cache disk current approaches suffer limitations require underlying export information accurately identify presence small files buffer cache observe application model simulate state buffer cache replacement policy file accesses dedicated web server greatly benefit knowing contents buffer cache servicing requests hit buffer cache implemented cache-aware web server based nest storage appliance show web server improves average response time throughput paper make contributions introduce dust fingerprinting tool automatically identifies cache replacement policies based prioritize initial access order recency access frequency access historical information demonstrate simulations dust distinguish variety replacement policies found literature fifo lru lfu random clock segmented fifo lru-k fingerprinting software identify replacement policies operating systems netbsd linux solaris show knowing replacement policy cache-aware web server service requests satisfied buffer cache obtain substantial performance improvements rest paper organized begin section describing fingerprinting approach section show simulation identify range popular replacement policies section identify replacement policies current operating systems section show web server exploit knowledge buffer-cache replacement policy improved performance briefly discuss related work section conclude section fingerprinting methodology describe dust software identifying page replacement policy employed operating system manipulating blocks accessed forcing evictions observing blocks replaced dust identify parameters page replacement policy algorithm dust relies probes infer current state buffer cache measuring time read byte file block determine block previously buffer cache intuitively probe slow infers block previously disk probe fast infers block cache dust correctly distinguish replacement polices identify file block attributes existing policies select victim block replacement search database research literature documentation existing operating systems identified attributes replacement order initial access block fifo recency accesses lru frequency accesses lfu historical accesses blocks correctly identify combinations attributes replacement policy note operating systems replacement policies attributes dust considers replacement policies pages dirty size file page replacement cost replacement pages performed global process basis finally real systems file pages cached file meta-data systems prefer evict pages files meta-data longer cached future replacement policies utilize attributes fingerprint dust identify parameters basic framework dust extended goal identifying replacement policies primary components dust size buffer cache measured simple microbenchmark input remaining steps short-term replacement algorithm fingerprinted based initial access recency access frequency access dust determines long-term history replacement algorithm microbenchmarking buffer cache size manipulate state buffer cache interpret contents dust size buffer cache information readily common interface systems dust simple microbenchmark dust accesses progressively larger amounts file data notices blocks longer fit cache increase tested size steps step dust touches file blocks newly increased size fetch buffer cache step dust probes block measuring time probe verify block cache technique similar technique determine memory now-sort important features approach probing file block step algorithm independent replacement policy manage buffer cache algorithm works buffer cache integrated virtual memory system assuming dust memory buffer cache grow maximum size show fingerprinting algorithm robust slight inaccuracies estimation buffer cache size initial accces order higher recent file position block initial access order lru queue position higher newer file position block access recency access count file position block access frequency figure short-term attributes blocks graphs show priority block test region metrics order initial access recency access frequency access x-axis block number file forming test region y-axes initial accesses order left recency access center frequency access fingerprinting replacement attributes buffer cache size dust determines attributes file blocks shortterm replacement policy fingerprinting stage involves simple steps dust reads file blocks buffer cache simultaneously controlling replacement attributes block accessing blocks initial access recency frequency orders dust forces blocks evicted buffer cache accessing additional file data finally contents buffer cache inferred probing random sets blocks cache state file blocks plotted illustrate replacement policy describe steps detail configuring attributes step moves buffer cache well-controlled state data blocks resident initial access recency frequency attributes resident block control imposed performing pattern reads blocks single file refer blocks test region ensure data resident size test region set slightly smaller estimate buffer cache size precisely estimated cache size adjust size ten stripes discussed page aligned controlling initial access parameter block dust identify replacement policies based initial access order blocks fifo exert control access pattern begins sequential scan test region resulting initial access queue ordering shown graph figure specifically blocks end file priority remain buffer cache fifo-based policy dust identify replacement policies based temporal locality lru controlling recently block accessed ensuring ordering match initial access ordering ensure criteria pattern 
reads ten stripes file performed specifically indices file maintained left pointer starts beginning file pointer starts center test region workload alternates reading stripe left pointer stripe pointer pattern continues left pointer reaches center test region pointer reaches end controlled pattern access induces recency queue order shown middle graph figure specifically blocks end left regions priority lru-based policy finally identify policies frequency based component dust ensures stripes test region distinctive frequency counts reading stripes recency ordering dust touches stripe multiple times frequency ordering pattern stripes center test region read beginning end test region read number reads area test region shown right-most graph figure blocks middle priority lfu-based policy impose frequencies parts file part motivation dividing test region fixed number stripes instance block test region frequency count runtime dust exponential size file simulation experiments determined ten good number stripes precise fingerprint greater variety frequency recency regimes greater number stripes makes stripe smaller making data susceptible noise forcing evictions state buffer cache configured dust performs eviction scan file data read portion test region evicted cache goal evicting pages give information ability differentiate replacement policies dust evict approximately half cached data note eviction scan read page multiple times frequency counts pages higher pages test region dust identify frequencybased replacement policies eviction region replace pages illustrates limitations approach differentiate lifo mru mfu replacement policies replace eviction region feel limitation acceptable policies streaming large files tend behave similarly conditions probing file-buffer contents determine state buffer cache eviction scan perform probes measuring time read byte selected pages read call returns quickly assume block file resident cache read returns slowly assume disk access required noted perform probe block determine state state buffer cache specifically dust probes block disk block replace block previously buffer cache changing state perform probes selectively obtain number samples probe stripe times total twenty probes probes spaced evenly test region location chosen randomly half stripe keeping probes ensure interfere probe due prefetching choosing random offset probes run benchmark multiple times generate picture cache state running dust multiple times platform accurately determine cache replacement policy chooses victim pages based initial access recency access frequency access precisely size eviction scan set equal difference size cache size test region cache size half size cache hot cold evict evict figure access pattern fingerprint history distinct regions file blocks hot cold evict evict accessed set attributes evictions order toidentify history replacement algorithm arrow region accessed reads time move page width arrow number shows number times block read set frequency attributes fingerprinting history fingerprinting tool identify replacement policies single queue ranking blocks based attributes previous step controls short-term attributes blocks identify algorithms track blocks longer memory track recency block lru-k determine long-term tracking performed dust observes preference pages referenced evicted describe long-term history identified shown figure regions file blocks accessed test region divided separate regions half total cache size hot cold portion algorithm begins touching hot pages evicting touching evict region evict region sufficient blocks fill buffer cache hot pages longer cache historical information tracked dust touches hot cold regions times touches cold times point evict evicted cold preferred initial access recency frequency attributes replacement policy cold touched cold region preferred traditional lru lfu hot retouched additional hot region preference policies history step prior eviction rereference hot cold regions sequentially notice point hot region touched number times cold region touched migrated long-term queue lrucache cold region short-term fingerprint phase dust probe test region determine blocks read time microseconds file position simulated first-in first-out fingerprint read time microseconds file position simulated recently fingerprint read time microseconds file position simulated frequently fingerprint figure fingerprints basic replacement policies fifo lru lfu graphs show time required probe blocks test region file depending buffer cache replacement policy x-axis shows offset probed block y-axis shows time required probe low times block cache high times block cache left graphs simulate fifo lru lfu file cache hot region remains cache infer history cold region remains cache infer history identification history attributes specific replacement algorithm focus simple historical fingerprint simulation fingerprints illustrate ability dust accurately fingerprint variety cache replacement policies implemented simple buffer cache simulator section describe simulation framework present number results simulation results verify distinctive short-term replacement fingerprints produced pure replacement policies fifo lru lfu simple replacement policies random segmented fifo explore impact internal state replacement policy investigate clock two-handed clock demonstrate ability identify historical information replacement policy focusing lru-k conclude section showing dust robust inaccuracy estimate buffer-cache size simulation methodology simulator meant illustrate ability dust identify buffer cache replacement policies rest system simple specifically assume process running fingerprinting software ignore irregularities due scheduling interference model buffer cache fixed size contention virtual memory system simulations model buffer cache approximately pages finally assume reads hit file cache require constant time reads disk require basic replacement policies begin showing simulation results strict fifo lru lfu replacement policies precisely matches derive ordering graphs shown figure fingerprints simulations shown figure show dust identify random replacement segmented fifo fingerprints shown figure graphs observe levels probe times blocks cache verify approximately half test data remains cache examine basic policies turn fifo fingerprint shows half test region remains cache matches initial access ordering shown figure blocks end file priority lru fingerprint shows roughly quarter fourth quarter test region remains buffer cache expected behavior blocks accessed recently finally lfu fingerprint shows middle half file remains resident expected blocks highest frequency counts lfu fingerprint small discontinuous regions remain cache left main in-cache area behavior due fact stripe blocks frequency count in-cache regions part stripe beginning evicted fingerprinting random replacement policy stresses importance running dust multiple times single fingerprint run twenty probes exists probability random replacement behaves identically fifo lru lfu fingerprinting system times definitively random pages selected replacement illusread time microseconds file position simulated random fingerprint read time microseconds file position simulated segmented fifo fingerprint read time microseconds file position simulated segmented fifo fingerprint figure fingerprints random segmented fifo left-most graph shows random page replacement policy distinctive fingerprint run fingerprint pages evicted buffer cache middle graph shows segmented fifo buffer cache devoted secondary queue resulting fingerprint cyclic shift 
fifo fingerprint right-most graph shows segmented fifo buffer cache devoted secondary queue queue managed lru fingerprint identical lru trated graph figure horizontal lines indicating fast slow access times original vms system implemented segmented fifo sfifo page replacement policy sfifo divides buffer cache queues primary queue managed fifo non-resident pages faulted primary queue page evicted primary queue moved secondary queue page accessed secondary queue moves back primary queue key parameter sfifo fraction buffer cache devoted secondary queue denoted fraction devoted primary queue traditional choice fingerprinted middle graph figure resulting sfifo fingerprint cyclic shift pure fifo fingerprint reason pattern initial read test area sets contents primary secondary queues pages accessed left portion test area shifted secondary queue tail primary queue portion head primary queue pages touched set recency frequency attributes left portion test area moved back head primary queue portion shifted secondary queue end primary queue blocks evicted portion evicted blocks left portion queue sizes sfifo produces distinctive fingerprint uniquely identify policy asa increases sfifo behaves lru fingerprint identical lru shown figure secondary queue large time page touched time progressed secondary queue fingerprint reveals lru behavior policy matches lru fingerprint feel segmented fifo approximate lru high acceptable fingerprint distinguished lru replacement policies initial state clock replacement algorithm popular approach managing unified file virtual memory caches modern operating systems ability approximate lru replacement simpler implementation clock algorithm interesting policy fingerprint pieces internal initial state initial position clock hand bit set ensure clock identified fingerprint initial state describe small modifications methodology guarantee behavior basic implementation clock buffer cache viewed circular buffer starting current position clock hand single bit page frame page accessed bit set replacement needed clock hand cycles page frames frame cleared bit clearing bits inspects frame clock approximates lru replacing pages bit set accessed time clock treats buffer cache circular initial position clock hand affect current fingerprint initial position clock hand simply determines block test region subsequent actions relative initial position positionis transparent dust modify fingerprinting methodology account hand position state bits impact fingerprint depending fraction set bits clock fingerprint fifo lru specifically extremes read time microseconds file position simulated clock fingerprint bits set read time microseconds file position simulated clock fingerprint bits set figure fingerprints clock replacement policy identify clock basic fingerprinting algorithm run time run bits set case clock behaves identically fifo shown graph left time run half bits set case clock fingerprint lru shown graph fingerprint fifo fingerprint lru describe intuition behavior simplest case frame starting clock hand allocated sequential pages test region result clock hand wraps back beginning buffer cache allocation dust touches page set attributes bit page set eviction pages test region replaced matching behavior fingerprint fifo policy note results identical behavior clock hand sweep frames clearing bits allocates test region sequentially left portions test region data randomly interleaved memory interleaving occurs pages allocated passes pass frames cleared bits allocated left-hand portion test region bits frames set bits remaining frames cleared pass remaining frames allocated righthand portion test region accesses set locality frequency attributes pages bits frames set eviction phase begins half pages left portions test region replaced frames set bits uniformly distributed coincidentally matches evictions lru policy distribution bits uniform fingerprint show blocks frames bits initially clear replaced case uniformly distributed consistent recognizable fingerprint identify clock dust brings initial state bits configurations observes resulting fingerprints steps configure bits dust sets bits allocating warmup region pages fills entire buffer cache touching pages intervening allocations bits set setting half bits slightly complex step set bits previous scenario step dust allocates pages warmup region bits set point clock hand pass entire buffer cache clearing bits find page evict final step randomly touch half pages setting bits dust configure state bits summary modify dust slightly account internal state running fingerprint dust allocates warmup region effect setting bits replacement policy implements resulting fingerprint fifo dust runs half bits set fingerprint fifo conclude bits underlying policy fifo fingerprint lru conclude clock underlying policy result running steps clock replacement policy shown figure replacement policies history show dust distinguish replacement policies long-term history begin briefly showing policies examined fifo lru lfu random segmented fifo clock history discuss detail behavior policies lru-k history figure shows long-term fingerprints representative policies history graph left lru fifo lfu segmented fifo identical shown graph shows results probing hot cold regions test data expected hot data evicted shown high probe times initial portion cold data evicted due size eviction region cold data preferred policies middle graph shows read time microseconds file position simulated lru history fingerprint read time microseconds file position simulated random history fingerprint read time microseconds file position simulated clock history fingerprint random initial bits figure history fingerprint short-term policies probes performed pages hot blocks left cold blocks test regions graph left shows fingerprint fifo lru lfu segmented fifo cold test region remains buffer cache policies prefer pages history graph middle shows random preference pages history history finally graph shows historical fingerprint clock ambiguous bits set bits properly set fingerprint identical leftmost graph read time microseconds file position simulated lrufingerprint correlated count read time microseconds file position simulated lrufingerprint correlated count read time microseconds file position simulated lruhistory fingerprint figure fingerprints lruthe graph shows short-term fingerprint lruwhen correlated count set case lrudisplaces pages frequency count second-to-last oldest graph shows short-term fingerprint lruwhen correlated count increased pages eviction frequency count higher evicted finally graph shows history fingerprint lruverifying prefers hot pages random preference hot cold data finally graph shows historical behavior clock difficult determine bits explicitly controlled graph bits set result hot cold regions interleaved file buffer region replaced sequentially illustrate clock history dust ensure bits cleared set initialization step history fingerprint clock identical graph figure fifo lru lfu segmented fifo random clock history making replacements lru-k replacement policy introduced database community address problem lru discriminate frequently infrequently accessed pages idea lru-k tracks -th page past replaces page oldest -th page -th traditional lru equivalent lrugiven exhibits benefits general case commonly lrufurther lruis sensitive parameter correlated period intuition accesses page period counted distinct setting correctly non-trivial task default lruis 
complex note implementation derived version provided original authors begin briefly exploring sensitivity lruto correlated period short-term fingerprints lruare shown graphs figure default resulting fingerprint variation pure lru shown left-most graph specifically stripe test region evicted lrusince stripe accessed second-to-last page initially referenced correlated period increased thata fingerprint similar lfu shown middle graph setting pages eviction region classified correlated replace pages frequency count greater read time microseconds file position simulated two-queue fingerprint read time microseconds file position simulated two-queue history fingerprint read time microseconds file position simulated secondary queue fingerprint figure fingerprints fingerprint shows short-term replacement policy fifo fingerprint shows history preferring pages accessed evicted fingerprint shows replacement policy pages main queue lru memory finally large accesses treated correlated pages second-to-last case behavior degenerates pure lru shown summary lruproduces distinctive fingerprint uniquely identifies approximate setting correlated period verify lruuses history graph figure shows historical fingerprint lruas desired hot region preference data cold region occurs second-to-last pages hot region recent second-to-last cold region replacement made hot region oldest secondto-last chosen algorithm proposed simplification lruwith run-time overhead similar performance basic intuition removing cold pages main buffer admits hot pages main buffer buffer cache divided buffers temporary queue shortterm accesses managed fifo main buffer managed lru pages initially admitted thea queue evicted reaccessed admitted structure remember pages accessed longer buffer cache experiments set buffer cache remember number past equal number pages cache show fingerprints figure graph shows short-term fingerprint identical fifo queue managed fifo short-term fingerprint access pages evicted expected result easily distinguished pure fifo observing history fingerprint shown graph historical fingerprint hot region remains buffer cache accesses moved buffer finally identify replacement policy employed long-term buffer setting initial access recency frequency attributes hot region forcing evictions methodology specific replacement policy describe detail fingerprint shown graph figure correctly identifies lru policy buffer note lruor policies history similar technique determine replacement strategy long-term queue explicitly setting state long-term queue requires knowledge policy short-term queue policy moving block queue fingerprintingtechnique long-term queue nature specific policy short-term queue sensitivity buffer size estimate set experiments verify robustness dust inaccuracies estimate size buffer cache estimate buffer cache size significantly actual resulting fingerprints identifiable estimate cache small dust touch pages force evictions occur estimate large dust evicts entire region short-term fingerprint sensitive estimate historical fingerprint short-term fingerprint observe presence absence stripes buffer cache historical fingerprint observe hot cold region half buffer cache figure shows short-term fingerprint lru distinguishable estimates real sizes replacement policies exception clock robust similar read time microseconds file position simulated lru fingerprint overestimate read time microseconds file position simulated lru fingerprint perfect estimate read time microseconds file position simulated lru fingerprint underestimate figure sensitivity lru fingerprint cache size estimate graphs show short-term fingerprints lru estimate size buffer cache varied graph estimate high graph estimate perfect graph estimate low fingerprints uniquely identify lru read time microseconds file position simulated clock fingerprint underestimate read time microseconds file position simulated clock fingerprint perfect estimate read time microseconds file position simulated clock fingerprint overestimate figure sensitivity clock fingerprint cache size estimate graphs show short-term fingerprints clock half bits set estimate size buffer cache varied clock expected lru graph estimate high graph estimate perfect graph estimate low clock fingerprint robust inaccuracies estimate algorithms degree clock replacement algorithm sensitive estimate due configure state bits specifically size warm-up region dust fill buffer cache accurate figure shows dust tolerant errors cache-size estimate identifying clock robust identifying algorithms platform fingerprints buffer caching modern operating systems complex simple replacement policies operating systems textbooks part complexity due fact filesystem buffer cache integrated virtual memory system current systems amount memory dedicated buffer cache change dynamically based current workload control effect dust minimizes amount virtual memory maximize amount memory devoted file buffer cache run dust idle system minimize disturbances competing processes section describe experience fingerprinting unix-based operating systems netbsd linux solaris fingerprints real systems variation simulations addition fingerprinting replacement policy buffer cache dust reveals cost hit versus miss buffer cache size buffer cache buffer cache integrated virtual memory system dust takes considerable amount time run real system generating sufficient number data points requires running iterations test scan eviction scan probes experiments allowed iterations found iteration seconds minutes depending system test note systems smaller buffer caches tested shorter period time test region smaller feel long running time acceptable system configuration dust run results stored made applications programmers experiments section run systems dual pentium iii-xeon processors physical ram scsi storage subsystem ultra rpm disks read time microseconds file position netbsd dust fingerprint read time microseconds file position netbsd history fingerprint figure fingerprints netbsd graph shows short-term fingerprint netbsd indicating lru replacement policy graph shows longterm fingerprint indicating history netbsd netbsd straightforward replacement policy systems examined begin fingerprint shown figure simulations examine shortterm long-term fingerprints graph figure shows expected pattern pure lru replacement dust produces fingerprint attempts manipulate bits infer netbsd implements strict lru clock conclusion verified graph figure showing netbsd history documentation inspection source code confirm finding fingerprints infer parameters specifically time reading byte page buffer cache order time disk varies machine physical memory netbsd devotes buffer cache easily shown fact history fingerprint devotes memory hot cold regions infer file buffer cache segregated system read time microseconds file position linux dust fingerprint bits cleared read time microseconds file position linux dust fingerprint random bits figure fingerprints linux graph shows short-term fingerprint linux bits set graph shows fingerprint bits untouched linux linux popular version linux kernel production environments section run nest web server top important understand fingerprint short-term fingerprint linux shown figure graph left shows results dust attempts set bits graph fifo investigate determine clock graph shows fingerprint bits left random state fingerprint noisy priority pages recently referenced pages fourth quarters filtering data verify pages quarters cache cache fingerprint similar lru fingerprint expected clockbased replacement algorithm examination source code documentation confirms replacement policy clock based finally buffer cache size close amount physical ram system conclude buffer cache integrated linux memory management system linux underwent large revision version fingerprint linux complex replacement scheme linux netbsd short-term fingerprint shown graph figure suggests linux recency frequency 
component clock graph dust shows linux history decision examination linux source code existing documentation confirms results linux maintains separate queues active inactive list memory scarce linux shrinks size buffer cache pages recently referenced bit moved active list inactive list inactive list scanned replacement victims form page aging age counter frame indicating desirable page memory scanning page evict page age decreased considered eviction page age reaches page candidate eviction age incremented page referenced solaris solaris presented greatest challenge platforms studied subsystem solaris studied believed two-handed global clock algorithm researchers noted non-intuitive behavior twohanded clock hand clears bits hand fixed distance selecting page replacement bit clear hands advanced unison bit page cleared opportunity re-referenced candidate eviction implemented simulator fingerprint two-handed clock identical fifo shown short-term fingerprint solaris shown graph figure out-of-cache areas left fingerprint strongly suggests solaris frequency aging component eviction decision addition clock graph figure shows historical fingerprint solaris data noisy shows clear preference hot region suggesting history page aging solaris fingerprint shows time service buffer cache hit significantly higher solaris linux fingerprint shows hit time read time microseconds file position linux dust fingerprint read time microseconds file position linux history fingerprint figure fingerprints linux graph shows short-term fingerprint linux indicating combination lru lfu graph shows long-term fingerprint indicating history hit time linux platform cache-aware web server section describe knowledge buffer cache replacement algorithm exploited improve performance real application modifying web server re-order accesses serve requests hit file system cache serve miss idea handling requests non-fifo service order similar introduced connection scheduling web servers work scheduled requests based size request schedule based predicted cache content re-ordering based cache content lowers average response time emulating shortest-job scheduling discipline improves throughput reducing total disk traffic approach key challenge implementing cache-aware server gray-box knowledge file caching algorithm determine files cache keeping track file access stream presented kernel web server simulate read time microseconds file position solaris dust fingerprint read time microseconds file position solaris history fingerprint figure fingerprint solaris graph shows short-term fingerprint solaris graph shows history fingerprint operating system buffer cache predict time data cache term algorithmic mirroring general powerful manner exploit gray-box knowledge important assumption algorithmic mirroring application induces traffic file system mirror cache accurately represent state real cache assumption hold general case multi-application environment feasible single application dominates filesystem activity server applications web server database management system perfect match mirroring methods nest storage appliance supports http access protocols nest configurable number requests serviced simultaneously requests received number queued pending requests completes default nest services queued requests fifo order term default behavior cache-oblivious nest modified nest request scheduler model current state buffer cache model updated time request scheduled nest bases model underlying file cache algorithm exposed dust nest model reorder requests requests files believed cache serviced note nest perform caching files relies strictly buffer cache cache mirror accurately reflect internal state nest reasonable estimate cache size current approach nest static estimate produced dust disadvantage approach estimate produced contention virtual memory system larger amount web server running increase robustness estimate plan modify nest dynamically estimate size buffer cache measuring time file access time low file cache high file disk comparing timings prediction provided mirror cache nest adjust size mirror cache performance evaluate performance benefits cache-aware scheduling compare performance cacheaware nest cache-oblivious nest workloads tests web server run dual pentium iii-xeon machine main memory ultra disks clients machines identical server main memory running client threads clients connected server gigabit ethernet server clients running linux shown section clock replacement algorithm cache-aware nest configured model clock algorithm configuration server approximately memory dedicated buffer cache experiments explore performance cache-aware nest vary estimate size buffer cache experiment workload client thread repeatedly requests random file set files figures show average response time throughput web servers apache web server cache-oblivious nest cache-aware nest function estimate cache-size begin comparing response time throughput nest apache figures nest incurs overhead flexible structure nest handle multiple transfer protocols ftp nfs achieves respectable performance web server reasonable platform studying cache-aware scheduling importantly adding cache-aware scheduling signifaverage response time cache size estimate cache-aware scheduling working set cache-oblivious apache cache-aware figure response time function cache size estimate response time cache-aware nest lowest estimate cache size closest true size cache icantly improves response time throughput nest servicing requests hit cache cache-aware scheduling improves average response time servicing short requests dramatically cache-aware scheduling improves throughput reducing number disk reads verified proc interface in-cache requests handled data evicted cache finally performance cache-aware nest improves estimate cache size closer real robust large range cache size estimates experiment workload created surge http workload generator surge workload approximately distinct files sizes zipf distribution approximately surge representative web workload presented surge workload measure qualitatively similar results main differences performance cache-oblivious nest relative apache degrades slightly average response time cache-oblivious nest seconds apache seconds result expected nest designed staging data grid optimized large files small files typical web workloads performance cache-aware nest sensitive estimate cache size performance improves approximately cache size estimate improved apache achieves future plan experiment web servers workloads related work idea algorithmic knowledge underlying operating system improve performance throughput cache size estimate cache-aware scheduling working set cache-aware apache cache-oblivious figure sensitivity cache estimate accuracy performance cache aware nest improves estimate cache size approaches true size buffer cache buffer cache approximately cache-oblivious nest apache shown comparison recently explored context gray-box systems work showed os-like service implemented information control layer icl algorithmic knowledge probes statistical analysis concrete solutions proposed developers icls obtain algorithmic knowledge paper show fingerprinting obtain graybox knowledge simple automatic manner fingerprinting system components determine behavior successfully contexts notably networking storage specifically fingerprinting uncover key parameters tcp protocol identify remote host primary difference fingerprinting tcp context identify policies arbitrary behavior implementations expected adhere specifications techniques similar dust determine characteristics disks size prefetch window prefetching algorithm caching policy fingerprinting shares common microbenchmarking specifically perform requests underlying system order characterize behavior simple probes microbenchmarks determine parameters memory hierarchy processor cycle time characteristics disk geometry view key difference fingerprinting microbenchmarking fingerprint discover policy algorithm employed underlying layer microbenchmark typically uncover specific system parameters idea discovering 
characteristics lower layers system knowledge higher layers improve performance traxtents file system layer operating system modified avoid crossing disk track boundaries minimize cost incurred due head switching exploit zero-latency access developed method predicting position disk head hardware support information determine rotational replicas service request giving software expanded knowledge hardware state approach involves informing application buffer cache replacement policy operating system sleds dynamic sets seek increase knowledge application operating system approach embellishing interface application explicit exchange types information case dynamic sets application ability provide knowledge future access patterns reorder fetching data improve cache performance sleds export performance data application enabling application modify workload based performance characteristics underlying system idea servicing requests web server order explored connection-scheduling web servers main thesis research performance obtained controlling scheduling requests web server approach static file size schedule requests cache-aware nest dynamic estimate contents buffer cache future work hope investigate interactions scheduling requests based file size cache content cache-aware web server similarities locality-aware request distribution lard clusterbased web servers lard front-end node directs page requests specific back-end node based back-end recently served page modulo load-balancing constraints front-end simple model cache contents backend improve cache hit rates approaches complementary lard partitions requests nodes cache content service requests order single node conclusions future work shown buffer cache replacement algorithms uniquely identified simple fingerprint fingerprinting tool dust classifies algorithms based initial access locality frequency history choosing block replace simple simulator shown fifo lru lfu clock random segmented fifo lru-k produce distinctive fingerprints allowing uniquely identified begun address challenging problem fingerprinting real systems running dust netbsd linux solaris shown determine attributes considered page replacement algorithm finally shown algorithmic knowledge revealed dust predicting contents file cache specifically implemented cache-aware web server services requests predicted hit file cache improving response time bandwidth future extend range policies dust recognize specifically adaptive policies eelru lrfu identified policies attributes size page cost replacing page current system visually interpret fingerprint graphs produced dust automate process well-known replacement policies long-term plan continue exploring fingerprinting subsystems cpu scheduler determine algorithmic knowledge user processes main challenge performing model simulation access inputs required accuracy finally investigating algorithmic knowledge infer contents file cache change contents acknowledgments brian forney tim denehy muthian sivathanu florentina popovici helpful discussion comments paper shepherd greg ganger anonymous reviewers helpful comments work sponsored nsf ccrngs- ccrccr- itrand wisconsin alumni research foundation apache foundation apache web server http apache arpaci culler krishnamurthy steinberg yelick empirical evaluation cray-t compiler perspective annual international symposium computer architecture iscapages santa margherita ligure italy june arpaci-dusseau arpaci-dusseau information control gray-box systems symposium operating systems principles sosp october arpaci-dusseau arpaci-dusseau culler hellerstein patterson high-performance sorting networks workstations sigmod tucson barford crovella generating representative web workloads network server performance evaluation proceedings sigmetrics conference june bent venkataramani leroy roy stanley arpaci-dusseau arpaci-dusseau livny flexibility manageability performance grid storage appliance hpdcj bertoni understanding solaris filesystems paging technical report tr- sun microsystems cao felten implementation performance application-controlled file caching proceedings symposium operating systems design implementation pages crovella frangioso harchol-balter connection scheduling web servers usenix symposium internet technologies systems forney arpaci-dusseau arpaci-dusseau storage-aware caching revisiting caching heterogeneous storage systems usenix symposium file storage technologies fast monterey january glaser tcp stack fingerprinting principles http sans newlook resources idfaq tcp fingerprinting htm october johnson shasha low overhead high performance buffer management replacement algorithm proceedings international conference large databases pages september lee choi kim noh min cho kim existence spectrum policies subsumes recently lru frequently lfu policies sigmetrics atlanta georgia levy lipman virtual memory management vax vms operating system ieee computer march linux kernel archives linux source code http kernel mckusick bostic karels quarterman design implementation bsd operating system addison wesley netbsd kernel archives netbsd source code http netbsd nicola dan dias analysis generalized clock buffer replacement scheme database transaction processing sigmetrics performance neil neil weikum lru-k page replacement algorithm database disk buffering proceedings acm sigmod conference pages neil lrusource code ftp ftp umb pub lru-k lruk tar padhye floyd identifying tcp behavior web servers sigcomm june pai aron banga svendsen druschel zwaenepoel nahum locality-aware request distribution cluster-based network servers eighth international conference architectural support programming languages operating systems san jose california robinson devarakonda data cache management frequency-based replacement proceedings acm sigmetrics conference measurement modeling computer systems pages saavedra smith measuring cache tlb performance effect benchmark runtimes ieee transactions computers schindler ganger automated disk drive characterization technical report cmu-cs- carnegie mellon schindler griffin lumb ganger trackaligned extents matching access patterns disk drive characteristics proceedings usenix conference file storage technologies fast monterey smaragdakis kaplan wilson eelru simple effective adaptive page replacement sigmetrics conference measurement modeling computer systems atlanta staelin mcvoy mhz anatomy micro-benchmark proceedings usenix annual technical conference pages berkeley june steere exploiting non-determinism asynchronyof set iterators reduce aggregate file latency proceedings acm symposium operating systems principles sosp pages saint-malo france october talagala arpaci-dusseau patterson microbenchmark-based extraction local global disk characteristics technical report csd- california berkeley turner levy segmented fifo page replacement acm sigmetrics international conference measurement modeling computer systems vahalia unix internals frontiers prentice hall van meter gao latency management storage systems proceedings fourth symposium operating systems design implementation osdi october van riel page replacement linux memory management http surriel lectures linux -vm html june worthington ganger patt wilkes online extraction scsi disk drive parameters proceedings acm sigmetrics performance conference measurementand modeling computer systems pages gum chen wang krishnamurthy anderson trading capacity performance disk array proceedings fourth symposium operating systems design implementation osdi san diego 
