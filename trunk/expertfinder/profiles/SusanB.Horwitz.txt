static analysis reduce dynamic analysis overhead suan hsi yong suan wisc susan horwitz horwitz wisc computer sciences department wisconsin-madison west dayton street madison usa abstract dynamic analysis instrumenting programs code detect prevent errors program execution effective approach debugging preventing harm caused malicious code problem approach runtime overhead introduced instrumentation define techniques involve results static analysis identify cases instrumentation safely removed designed techniques specific dynamic analysis mind runtime type-checking tool ideas general applicability keywords static analysis dynamic debugging runtime types introduction languages potentially unsafe operations pointer arithmetic casting explicit memory management open door difficult-to-detect errors identify errors number systems developed involve dynamic analysis instrumenting program errors out-of-bounds array indexes bad pointer dereferences detected occur execution cases dynamic checks mandated language definition java guarantees exception thrown array index bounds bad cast performed naturally benefits dynamic analysis cost instrumentation introduces amount runtime overhead work supported part national science foundation grants ccrand ccrc kluwer academic publishers printed netherlands rtc tex paper proposes techniques reducing overhead static analysis identify cases instrumentation safely omitted techniques designed tool runtime type-checking rtc tool ideas general applicability remainder paper organized section background rtc tool section describes type-safetylevel analysis flow-insensitive analysis identify type-safe expressions instrumentation eliminated section presents redundant-check analysis flow-sensitive analysis identify redundant instrumentation safely removed section presents experimental results showing performance improvements gained analyses section describes never-null-dereference analysis dataflow analysis improve rtc performance section discusses related work section concludes rtc tool rtc runtime type-checking tool instruments programs runtime type memory location tracked program execution inconsistent type warnings errors reported written location runtime type updated runtime type runtime type compared declared type match warning message issued warning message indication unusual behavior observed diagnosing root error location runtime type checked type inappropriate context error message issued avoid cascading error messages runtime type set correct type error message generated rtc tex motivating examples number tools proposed detect out-ofbounds array accesses bad pointer dereferences type-checking approach rtc tool detect subtle errors involving type misuses bad union access simple logical error manifests bad runtime type writing field union reading field type illustrated code fragment union int float write read integer written variable line subsequently read float line rtc tool track runtime type data stored single location type set int assignment line line location read float rtc tool report type mismatch error runtime type location int simulated inheritence class subtle errors programming style programmers simulate classes inheritance structures declarations simulate declaration superclass base subclass struct base int int struct int int char function written perform operation objects superclass rtc tex void struct base function called actual arguments type struct base struct struct base base struct base ansi standard guarantees field structure stored offset structures common initial sequence initial sequence fields compatible types fields initial sequence stored offsets fields guaranteed offset fields guaranteed offset call compile-time warning averted type cast compile-time error runtime error assignments function correctly set values programmer forget convention struct supposed subclass struct base making code change type common fields add field struct base adding field struct add field struct field suppose int field added struct struct int int int char whenthesecond callto isexecuted theassignment write field field fact field correctly set call field overwritten unintended lead rtc tex runtime error execution program produce incorrect output tracking runtime types performed rtc tool programmer uncover source logical error assignment tagged type pointer context requires int result error message due mismatch required type int current runtime type pointer note tool purify report errors bad pointer array accesses function writing bounds structure parameter wrong part structure programmer point view tracking types rtc tool associates memory location runtime types unallocated uninitialized pointer char short int long float double tag unallocated uninitialized memory pointers types tagged runtime type pointer treated compatible special type tag memory locations assigned literal treated compatible types remaining types correspond scalar types aggregate objects structures arrays runtime type field element tracked separately typedefs resolved underlying basic type runtime types stored mirror memory program byte memory mapped four-bit nibble mirror incurring space overhead rtc tool implemented handle ansi ckit front end translates set preprocessed source rtc tool represents scalar types pair size integral real size size bytes type linux char represented integral float real means fact int long differentiated larger types long long represented paper subtleties simplicity rtc tex files instrumented files compiled linked rtc library producing executable performs runtime type checking reports error warning messages instrumentation phase source-to-source translation program performs syntax-directed transformation program abstract-syntax tree add calls rtc library functions track runtime types operations performed library functions declare variable declaration instrumented set runtime type variable mirror uninitialized initially mirror memory implicitly tagged unallocated clear variable deallocated function return stack variables free heap locations mirror location tagged unallocated copy assignment statement instrumented copy runtime type right-hand-side mirror left-hand-side location additionally runtime type assigned match static type assignment warning message issued verify memory location context type instrumented compare runtime type mirror types compatible error message issued runtime type corrected prevent cascading error messages verify-pointer pointer dereference instrumented check mirror pointer target unallocated error message issued check detects dangling pointer dereferences dereferences stray pointers pointbetweenor allocatedblocks andalso null-pointer dereferences becausethemirror ofmemorylocation istagged unallocated tool designed instrumented modules linked uninstrumented flexibility programmer debug small component large program instrument files interest link rtc tex remaining uninstrumented object modules caveat lead spurious warning error messages uninstrumented parts code maintain runtime type information memory locations declare valid object declared uninstrumented portion program passed instrumented function tool object unallocated output spurious error message object referenced problem extends general library modules runtime types flow values function memcpy initialization values input function fgets types data static buffer returned function ctime captured handle created collection instrumented versions common library functions affect type flow wrappers original functions handwritten perform tag-update operations rtc mirror capture type behavior included instrumented library functions memorymanagement functions call malloc relatives replaced call wrapper version successfully allocating block memory sets mirror memory block uninitialized calloc similarly wrapper version free function resets mirror unallocated malloc wrapper adds padding allocated blocks decrease likelihood stray pointer jumping block approach purify rtc tool detect 
bugs spec benchmarks ijpeg solaris utilities nroff col olden benchmarks health voronoi errors out-of-bounds array pointer accesses solaris utilities out-of-bounds accesses resulted program crashes spec cases errors apparent effect execution made errors difficult detect tool rtc case rtc tool detect out-of-bounds memory accesses type pointed-to memory expected type rtc tex finally rtc tool lends naturally interactive debugging warning error message issued signal sigusr intercepted interactive debugger gdb user examine memory locations including mirror make gdb features track error major shortcoming rtc tool poor performance worst case instrumented program ran timesslower noninstrumented version rtc tool instruments expression program tracks runtime type memory location theprogram toreducethe overhead rtcinstrumentation implemented static analyses identify remove unnecessary instrumentation type-safety-level analysis redundant checks analysis type-safety-level analysis static analysis flow-insensitive type-safety-level analysis partitions expressions program levels type safety classes runtime instrumentation eliminated expressions type-safety levels description assume assignment statements input program normalized forms defined context-free grammar assign lvalue rvalue lvalue cvtrvalue lvalue extrvalue lvalue cpyrvalue lvalue var var rvalue const var var var var var const constant var variable represents binary operator simplified language captures essence assignment statements details handle constructs structures unions function calls omitted brevity rtc tex assignment involves array index rewritten tmp tmp typecasts divided forms form cvte typecast involves change representation includes conversions integers floating-point values truncation data type-casting long int short int form exte represents type-casts extend data smaller type larger type change data bits short int long int form cpye represents typecasts change form data includes casts pointers integers size difference forms concerns conversion cast cvte treated rtc tool returns type runtime type compatible static type rtc instrumentation issues error message sets runtime type static type avoid cascading error messages extension copy casts exte cpye treated bitwise copies runtime type runtime type points-to analysis type-safety-level analysis points-to analysis account aliasing program points-to analysis associates pointer points-to set set variables point program execution implementation das flow-insensitive points-to analysis scalable good precision flow-insensitive points-to analyses general precision points-to analysis enable elimination greater amount unnecessary instrumentation potentially leading greater improvement performance rtc-instrumented program rtc tex type-safety levels main idea analysis classify lvalue expressions program type-safety levels safe expression runtime type guaranteed compatible static type instrumentation eliminated assuming uninitialized values section describes identify locations uninitialized unsafe expression runtime type incompatible static type includes expressions form pointer null invalid address unsafe expression fully instrumented tracked location runtime type compatible static type pointed pointer unsafe tracked location runtime type initialized static type mirror instrumentation verifying copying runtime type eliminated figure presents code fragment illustrate intuition approach approach flow-insensitive order statements analysis figure type-safety levels identify expressions program expressions safe assigned pointer-typed values recall rtc tool differentiate pointer types fact assigned address int variable address float variable important recall literal treated compatible types including pointers expressions unsafe variable unsafe assignment line write int expression represents location memory called lvalue expression simplified language paper form var var full version implemented lvalue expressions include expressions structure members var multi-level dereferences var rtc tex code type-safety levels int safe int unsafe float tracked assignment edges valueint valuefloat valuezero valuevalid-ptr int valuevalid-ptr ptrp ptri valueint figure type-safety expression unsafe null due assignment line unsafe static type int refer float assignment line refer invalid address result pointer arithmetic line finally expression tracked int pointed unsafe means instrumented check runtime type location points-to set including runtime type tracked mirror framework devise schemes varying precision determine type-safety level expression ordering unsafe tracked safe scheme classifies expression level equal true level safe approximation unoptimized rtc tool corresponds extreme expressions rtc tex considered unsafe sections describe efficient flowinsensitive analysis classify type-safety level expressions analysis works step build assignment graph nodes represent expressions program edges represent flow runtime types due assignments step compute runtime-type attribute rt-type node graph step compute type-safety level lvalue node graph step building assignment graph step analysis involves building assignment graph records flow runtime types expressions program node assignment graph corresponds expression represents abstract object forms node represents variable represents dereference represents arithmetic logical bitwise operation resulting static type represents type constant expression scalar type char int float special types valid-ptr pointer expression guaranteed evaluate valid address address allocated memory location type valid-ptr expression type valid-ptr pointer pointer expression evaluate invalid address including null type pointer expression type pointer expression guaranteed evaluate type literal type rtc tex expr absobj expr notes valuezero non-zero constant type valuevalid-ptr expression static type assignment edge graph absobj absobj cpye absobj absobj cvte cvt absobj absobj exte ext absobj absobj figure rules initializing assignment graph nodes connected kinds directed assignment edges conversion edges cvt extension edges ext copy edges conversion edges represent assignments right-hand side form cvte extension edges represent assignments right-hand side form exte copy edges represent assignments involve type-cast involve type-cast form cpye figure shows mapping absobj program expressions abstract objects figure rules adding edges graph assignment adds graph copy edges static type expression figure assignment edges derived program rtc tex int long float doublechar short multiply typed uninitialized pointer valid ptr figure lattice rt-type step computing runtime types building assignment graph analysis computes runtimetype attribute rt-type node graph values rt-type form lattice shown figure intuitively rt-type summarizes set types expression runtime rt-type means expression incompatible runtime type figure constraints computing rt-type node assignment graph figure pt-set points-to set static-type static type expression represented rules set rt-type node node static type node rt-type expression considered rtc runtime type equal static type expression rule constrains rt-type node higher lattice type variable points-to set rule constrains rt-type left-hand side conversion higher static type rtc tool treats conversion cast runtime type equal static type rule deals rtc tex condition inferred constraint rt-type rt-type pt-set rt-type rt-type cvt rt-type static-type ext rt-type static-type rt-type static-type rt-type pt-set rt-type rt-type ofthe form rt-type rt-type figure rules computing rt-type extension edges right-hand side extension assignment well-typed rt-type left-hand side constrained higher static type assignment effectively copying aggregation multiple rtc tags left-hand side rt-type left-hand side set rules handle assignment edges left-hand side dereference pointer rule rt-type node points-to set higher rt-type right-hand side 
left-hand side variable rule rt-type higher rt-type right-hand side rt-type values computed nodes assignment graph solving constraints generated rules building directed graph nodes assignment graph edges representing constraints induced rules collapsing cycles efficiency initially nodes rt-type rules assign rt-type values nodes graph rules apply rules assign static-type node represents graph traversed propagate rt-type values edges node rt-type assigned meet rt-type rt-type constraint edge representing propagation rtc tex assignments assignment edges inferred constraints valueint rt-type int valuefloat rt-type float valuezero rt-type valuevalid-ptr rt-type valid-ptr int valuevalid-ptr rt-type valid-ptr pointer rt-type pointer pointer rt-type pointer valueint rt-type int pt-set rt-type int rt-type rt-type rt-type rt-type final rt-type values rt-type rt-type int rt-type valid-ptr rt-type rt-type pointer rt-type figure computing rt-type figure revisit extension edges original assignment graph check rule rt-type negationslash static-type rt-type rt-type set graph traversed propagate change extension casts rare practice noticeably affect efficiency figure shows assignment edges inferred constraints final rt-type values figure step computing type-safety levels rt-type values computed node graph annotated attribute signifying type-safety level unsafe tracked based rules figure applying rules node annotated unsafe tracked considered safe rule annotates unsafe node rt-type compatible static-type recall lattice rt-type valid-ptr compatible pointer compatible scalar types rtc tex condition attribute rt-type negationslash static-type unsafe static-type pointer rt-type negationslash valid-ptr unsafe unsafe pt-set xnegationslash unsafe tracked figure rules determining type-safety levels rule pointer rt-type valid-ptr invalid address instrumented check runtime type annotated unsafe rule annotates tracked variable points-to set pointer dereference node unsafe back figure rule makes unsafe makes unsafe makes tracked leaves safe note safe variables instrumented safe variable tagged unallocated mirror contents accessed indirectly errant pointer dereference expression annotated unsafe instrumented verify-pointer operation tagged unallocated check trigger accessing unallocated memory error identifying safe variables type-safety-level analysis lowers overhead tool eliminating unnecessary instrumentation increases likelihood rtc tool detecting error effectively tags memory unallocated may-be-uninitialized analysis type-safety-level analysis account uninitialized data error rtc tool checks eliminating instrumentation safe tracked locations initializing tracked locations static types uninitialized rtc tool longer detect rtc tex uninitialized data locations address problem additional flow-sensitive analysis needed find program points instrumentation elided location safe tracked analysis finds instances uninitialized analysis defined dataflowanalysis problem control-flow graph cfg elements underlying lattice sets locations variables abstract locations representing heap objects analysis computes sets cfg node uninitin uninitout representing locations uninitialized lattice meet set union dataflow transfer functions reflect rtc tool treats locations tagged uninitialized uninitialized assignment instrumented copy uninitialized tag mirror uninitialized rtc verify function report error set runtime type static type avoid cascading errors dataflow transfer functions node declares variable allocates heap location call malloc uninitout uninitin node direct assignment variable variable uninitin uninitout uninitin dereference pt-set uninitin negationslash uninitout uninitin uninitout uninitin node indirect assignment rtc tex variable uninitin uninitout uninitin pt-set dereference pt-set uninitin negationslash uninitout uninitin pt-set uninitout uninitin account function calls important aspect dataflow analysis augment language description include simple function calls arguments return values arguments return values modeled assignments globals dataflow transfer function function call node call uninitout uninitin maymod maymod set locations modified result calling function essentially call treated possibly assigning uninitialized locations maymod performing may-be-uninitialized analysis instrumentation added rtc tool detect uninitialized data tracked safe location node uninitin treated declaration instrumented declare operation sets type mirror uninitialized node uninitin instrumented verify operation node defines uninitin uninitout assignment instrumented copy operation ensures tag set correctly subsequent definitions instrumented uninitialized definition rtc tex redundant-check analysis location read times intervening writes runtime check read check reports runtime error rtc tool set runtime type statically declared type prevent cascading errors subsequent check location intervening writes location redundant eliminated identify redundant checks perform dataflow analysis track lvalue expressions checked check unsafe expression redundant control-flow graph node path cfg enter node includes node node instrumented rtc tool verify runtime type path runtime type l-value deallocates location analysis defined gen kill dataflow problem elements underlying lattice sets unsafe lvalue expressions variable pointer dereference analysis computes sets cfg node checkedin checkedout representing expressions checks redundant dataflow transfer function node form checkedout checkedin kill gen lattice meet set intersection set gen node includes lvalue expression unsafe node instrumented verify runtime type set kill node conditions listed variable kill node rtc tex assignment unsafe expression assignment unsafe expression points-to set call maymod dereference expression kill node assignment unsafe expression points-to set assignment unsafe expression points-to sets intersect assignment assignment points-to set call maymod pt-set negationslash call free points-to sets intersect note r-value expressions form const evaluate well-typed values considered safe expressions condition treat calls free differently function calls account memory deallocation performing analysis expression node instrumented checkedin experiments evaluate performance improvements rtc-instrumented programs result static analyses paper instrumented programs specint specint olden benchmark suites programs evaluate cyclone programs compiled gcc executed mhz pentium running linux rtc tex table benchmark characteristics performance lines inst rtc routines exec rtc opt imprv code static dyn time slowd slowd program cyclone aes cacm cfrac matxmult ppm tile olden bisort health mst perimeter power treeadd spec compress spec bzip gzip mcf table lists characteristics benchmarks runtime performance results column program size lines code columns give static dynamic number calls rtc functions functions listed section added rtc tool goal static analyses presented paper reduce numbers column execution time seconds uninstrumented code columns give runtime slowdown factor rtc-instrumented programs optimizing rtc tex mcfgzipbzip ligo compresstreeadd power perimeter msthealthem dbisortbhtileppm matxmult cfraccacmaes redundant-check analysis type-safety-level analysis may-be-uninitialized figure execution time slowdown factor static analyses paper column percentage speedup gained optimization average unoptimized rtc-instrumented program column ran times slower uninstrumented executable optimized version column ran times slower average optimizations improved execution time column figure graphs slowdown factors breaking effects static analyses full height left-side bars represents slowdown factor unoptimized rtc program table column upper-left regions white light gray represent portion runtime improvement due redundant-check type-safety-level analyses upper-right regions dark gray represent slowdown due instrumentation re-introduced may-be-uninitialized analysis height right-side bars black dark gray represents slowdown factor optimized program column average redundant-check analysis white bar improved performance running time unoptimized rtc code type-safety-level analysis light gray improved performance additional may-be-uninitialized analysis 
dark gray subtracted improvements rtc tex table analysis times seconds normal compl type-safety may-be-uninit redund-chk cfrac indicator efficiency analyses table compilation analysis times slower-compiling benchmarks benchmarks analyses notice flow-insensitive type-safety-level analysis column labeled type-safety includes das points-to analysis scales flow-sensitive analyses noticeably slower larger programs due suboptimal prototype implementation flow-sensitive analyses fundamentally higher complexity behavior expected note rtc tool miss catching uninitialized memory skip slow may-be-uninitialized analysis time improve runtime performance level black bars figure runtime overhead reintroduced may-be-uninitialized analysis small insignificant due part fact implementation intraprocedural call conservatively maymod possibly uninitialized interprocedural implementation builds supergraph connects call-site entry node called function incorporates context-sensitivity precise slower future work never-null-dereference analysis shortcoming type-safety-level analysis presented section pointer assigned null annotated unsafe fully instrumented null constant maps valuezero object rt-type rtc tex assignment rt-type constrained higher lattice prevents rt-type valid-ptr rule figure annotated unsafe rtc tool miss errors report spurious errors adds runtime overhead including unnecessary instrumentation small change type-safety-level analysis flow-sensitive analysis find instances guaranteed valid pointer null instance replace verify-pointer instrumentation null-pointer check rt-type lattice figure modified valid-ptr type type int long float doublechar short multiply typed uninitialized pointer valid ptr rule figure changed condition attribute static-type pointer rt-type negationslash valid-ptr unsafe modifications pointer assigned valid pointer values null safe note pointer assigned result pointer arithmetic invalid pointer values considered unsafe perform dataflow analysis account null-pointer dereferences pointers analysis similar may-be-uninitialized analysis section rtc tex lattice elements sets pointers lattice meet set union analysis computes sets nullin nullout node representing sets pointers null transfer functions kinds node null nullout nullin nullout nullin nullin nullout nullin nullout nullin pt-set nullin negationslash nullout nullin nullout nullin nullin nullout nullin pt-set nullout nullin pt-set nullin negationslash nullout nullin pt-set nullout nullin completion analysis safe dereference node nullin instrumented perform null-pointer check related work approaches proposed developed instrument program track auxiliary information program execution purify commercial product proven successful detecting buffer overruns memory leaks errors runtime instruments object code advantage requiring source code disadvantage platform dependent lack source code means techniques proposed rtc tex paper applied improve overhead slowdown valgrind similar tool interprets executable binary synthetic cpu incurs high overhead slowdown memcheck component mirrors byte memory additional information similar rtc tool operates executable binaries techniques paper directly applied improve performance insure heavyweight debugging tool detects common sources program errors out-of-bounds array accesses null-pointer dereferences rtc tool instruments program source level techniques similar presented paper improve performance austin describe safe system tracks information pointer referent information detect spatial array out-of-bounds temporal stale pointer dereference access errors propose compile-time optimization similar redundant-check analysis patil describe similar technique checking spatial temporal accesses called guarding propose make check efficient performing tracking checking auxiliary information shadow process separate processor cyclone ccured systems based language attempt inject level safety maintaining low-level control language cyclone language includes definition kinds pointers safety restrictions unsafe pointer dereferences instrumented runtime checks fat pointers manner similar safe-c port existing program cyclone programmer manually convert pointers kind cyclone pointer achieve optimal performance analysis automatically classify pointers safety level similar type-safety-level analysis proposed paper make easier port existing code encourage greater language ccured includes runtime checks bad pointer dereferences ccured schecksare morelimited rtc checks specifically ccured rtc tex focuses pointers differentiate non-pointer types ccured strict valid program behavior storing address stack variable global variable storing pointer integer casting back dereferencing runtime check fail reduce overhead runtime checks ccured typeinference scheme identify safe sequence pointers minimizing amount instrumented operations goal type inference similar type-safety-level analysis type-inference scheme precise proposed analysis effectively group points-to sets equivalence classes spirit steensgaard points-to analysis analysis accounts directionality assignments significantly improve performance instrumented ccured programs unoptimized slowdown times times slowdown type-inference optimization runtime checks enforce safety properties techniques eliminating unnecessary checks improve performance programming languages environments implementations dynamically-typed languages lisp scheme maintain runtime information perform runtime type-checking part language semantics improve performance system henglein proposes efficient approach based type inference java language perform potentially expensive runtime checks array-bounds checks enforce safety properties guaranteed language elimination redundant unnecessary array-bounds checks java safe languages studied extensively conclusions presented techniques reducing runtime overhead instrumentation added programs runtime type-checking tool section defined flow-insensitive typesafety-level analysis classifies lvalue expression rtc tex program safe unsafe tracked section defined dataflow analysis identify redundant checks eliminated results analyses conjunction results may-be-uninitialized analysis defined section improved runtime performance rtc average sacrificing ability rtc tool detect errors improvements runtime overhead averaging times slower original program remains high potential developing optimization techniques improve performance rtc tex andersen program analysis specialization programming language phd thesis diku copenhagen diku report austin breach sohi efficient detection pointer array access errors acm sigplan conference programming language design implementation pldi sigplan notices pages orlando june bodik gupta sarkar abcd eliminating array bounds checks demand acm sigplan conference programming language design implementation pldi sigplan notices pages vancouver june chin khoo deriving pre-conditions array bound check elimination proceedings symposium programs data objects pado pages aarhus denmark ckit http bell-labs smlnj doc ckit das unification-based pointer analysis directional assignments acm sigplan conference programming language design implementation pldi sigplan notices pages vancouver june gupta optimizing array bound checks flow analysis acm letters programming languages systems march december hasting joyce purify fast detection memory leaks access errors proceedings winter usenix conference henglein global tagging optimization type inference lisp functional programming pages jim morrisett grossman hicks cheney wang cyclone safe dialect usenix annual technical conference monterey june loginov yong horwitz reps debugging run-time type checking fundamental approaches software engineering fase volume lec notes comp sci pages springer apr lujan gurd freeman miguel elimination java array bounds checks presence indirection technical report csppdepartment computer science manchester feb markstein cocke markstein optimization range checking acm sigplan symposium compiler construction sigplan notices pages boston june necula mcpeak weimer ccured type-safe retrofitting legacy code acm symposium principles programming languages portland jan rtc tex parasoft insure automatic runtime error detection tool http parasoft insure papers tech htm patil fischer low-cost concurrent checking pointer array accesses programs software practice experience seward design implementation valgrind technical report http developer kde sewardj siff 
chandra ball kunchithapadam reps coping type casts proc esec fse seventh european softw eng conf seventh acm sigsoft symp found softw eng pages sept stallman pesch gdb guide gnu source-level debugger july steensgaard points-to analysis linear time acm symposium principles programming languages pages suzuki ishihata implementation array bound checker acm symposium principles programming languages pages los angeles jan yong horwitz reps pointer analysis programs structures casting acm sigplan conference programming language design implementation pldi sigplan notices pages atlanta rtc tex rtc tex 
speeding slicing thomas reps susan horwitz mooly sagiv genevieve rosay wisconsin madison abstract program slicing fundamental operation manysoftware engineering tools efficient algorithm interprocedural slicing program representation called system dependence graph paper defines newalgorithm slicing system dependence graphs asymptotically faster previous apreliminary experimental study newalgorithm significantly faster practice providing roughly -fold speedup examples lines categories subject descriptors software engineering tools techniques programmer workbench softwareengineering programming environments softwareengineering distribution maintenance enhancement restructuring data structures graphs general terms algorithms performance additional key words phrases dynamic programming dynamic transitive closure flow-sensitive summary information program debugging program dependence graph program slicing realizable path introduction program slicing fundamental operation manysoftware engineering tools including tools program understanding debugging maintenance testing integration slicing wasfirst defined mark weiser work performed visiting datalogisk institut copenhagen universitetsparken dkcopenhagen east denmark leave ibm israel haifaresearch laboratory work supported part david lucile packard fellowship science engineering national science foundation grants ccrand ccrby defense advanced research projects agencyunder arpaorder monitored office navalresearch contract -jby air force office scientific research grant afosr- grant xerox corporate research authors address computer sciences department univ ofwisconsin west dayton street madison usa electronic mail reps horwitz sagiv rosay wisc gav algorithms computing intraand interprocedural slices aspects weiser interprocedural-slicing algorithm include extra program components slice procedure call treated likeamultiple assignment statement set variables modified call set variables call call assumed depend call lead overly conservative slice includes extra components illustrated figure wheneveraprocedure included slice calls computations actual parameters included slice produces overly conservative slice giveninfigure interprocedural-slicing algorithms solvethe twoproblems illustrated givenbyhorwitz reps binkley hwang chou hwang chou give noanalysis algorithm scomplexity asweshowinappendix worst case time algorithm exponential size program contrast rithm polynomial-time algorithm summarized section operates program representation called system dependence graph sdg algorithm involves twosteps sdg augmented summary edges represent transitive dependences due procedure calls slices computed augmented sdg twosteps algorithm construction sdg require time polynomial size program cost step computing summary edges dominates cost step paper define newalgorithm interprocedural slicing sdgs asymptotically faster givenbyhorwitz reps binkley inparticular present improvedalgorithm computing summary edges leads faster interprocedural-slicing algorithm important applications system dependence graphs augmented summary edges newalgorithm presented section discusses asymptotic complexity complexity newalgorithm compared horwitz-repsbinkleyalgorithm section section describes experimental results howmuch program precise slice output slice weiser salgorithm procedure main sum call sum output sum output end procedure return procedure main call output end procedure return procedure main sum call sum output end procedure return figure program slice respect output slice computed weiser salgorithm program precise slice output slice weiser salgorithm procedure main sum call add sum call add output sum output end procedure add return procedure main call add output end procedure add return procedure main sum call add sum call add output end procedure add return figure program slice respect output slice computed weiser salgorithm slicing algorithm implementations twoalgorithms compute slices programs ranged size lines newalgorithm exhibited roughly -fold speedup background interprocedural slicing system dependence graphs system dependence graphs system dependence graphs defined due space limitations give detailed definition important ideas clear examples program system dependence graph sdg collection procedure dependence graphs pdgs procedure vertices pdg represent individual statements predicates procedure acall statement represented call vertexand collection actual-in actual-out vertices actual-in vertexfor actual parameter actual-out vertexfor actual parameter modified call similarly procedure entry represented entry vertex collection formal-in formal-out vertices global variables treated extra parameters give rise additional actual-in actual-out formal-in formal-out vertices edges pdg represent control flowdependences procedure sstatements predicates pdgs connected form sdg call edges represent procedure calls run call vertextoanentry vertex parameterin parameter-out edges represent parameter passing run actual-in vertextothe formal-in vertex formal-out vertexto defined procedure dependence graphs include kinds dependence edges control loop-independent flow loop-carried flow def-order howev slicing distinction loop-independent loop-carried flowedges irrelevant def-order edges paper assume pdgs include control edges single kind flowedge actual-out vertices figure shows sdg program figure point sdgs class program representations represent programs programming languages kinds pdgs depending features constructs language running experiments reported section simple programming language reader mind term sdg generic sense results thought tied restricted language examples superiority algorithm giveninsection overprevious interprocedural slicing algorithms hold matter features constructs language applied interprocedural slicing ottenstein ottenstein showed intraprocedural slices obtained solving reachability problem edge key control edge flow edge call parameter parameter edge enter main output sumsum output sumin iin sum add call enter add xout yin add call iin xout figure sdg program figure issue howtocreate pdgs sdgs orthogonal issue howtoslice previous work investigated howtobuild dependence graphs features constructs found real-world programming languages forexample previous work addressed arrays parameters pointers nonstructured control flow pdg compute slice respect pdg vertex find pdg vertices path control flowedges interprocedural slices obtained solving reachability problem sdg slices obtained approach include extra components illustrated column figure paths sdg correspond execution paths forexample path sdg shown figure vertexof procedure main labeled sum vertexofmain labeled output howev path corresponds execution procedure add called call site main returns call site main legalcall return sequence final main independent sum vertexlabeled sum included slice respect vertexlabeled output paths sdg computation slice realizable paths paths reflect fact procedure call finishes execution returns site recently executed call definition realizable paths call vertexinsdg givenaunique indexfrom call site label outgoing parameter-in edges incoming parameter-out edges symbols label outgoing call edge apath same-level realizable path iffthe sequence symbols labeling parameter-in parameterout call edges path string language balanced parentheses generated nonterminal matched context-free grammar matched matched matched apath realizable path iffthe sequence symbols labeling parameter-in parameter-out call edges path string language generated nonterminal realizable context-free grammar matched defined realizable realizable matched matched infigure path yin enter add enter main iin xout output sumsum output sumin iin sum add call xout add call key vertex visited pass edge traversed pass vertex visited pass edge traversed pass figure sdg figure augmented summary edges sliced respect output asimilar goal paths correspond legal call return sequences arises context interprocedural dataflow analysis terms paths including valid paths feasible paths realizable paths sum xin sum xin xout sum xout output sum same-level realizable path path sum xin sum xin xout xout output interprocedural-slicing algorithm precise realizable paths 
givenvertex itdetermines set vertices lie realizable path entry vertexofthe main procedure toachieve precision augments sdg summary edges asummary edge added actual-in vertex representing actual parameter call actual-out vertex representing actual parameter call wheneverthere asame-levelrealizable path summary edge represents fact call depend call note summary edge computed simply determining path sdg bytaking transitive closure sdg sedges approach imprecise reason transitive closure leads imprecise interprocedural slicing paths sdg realizable paths adding summary edges horwitz-reps-binkley slicing algorithm twopasses overthe augmented sdg pass traverses kinds edges slice sdg respect vertex traversal pass starts backwards target source flowedges control edges call edges summary edges parameter-in edges parameter-out edges traversal pass starts actual-out vertices reached pass backwards flowedges control edges summary edges parameter-out edges call parameter-in edges result interprocedural slice consists set vertices encountered pass pass edges induced vertices figure givesthe sdg figure augmented summary edges shows vertices edges traversed twopasses slicing respect vertexlabeled output improved algorithm computing summaryedges section main result paper algorithm computing summary edges asymptotically faster defined horwitz reps binkley henceforth refer hrbsummary algorithm newalgorithm computing summary edges giveninfigure function computesummaryedges computesummaryedges auxiliary access functions function proc returns procedure givensdg vertex function callers returns set procedures call givenone function correspondingactualin correspondingactualout returns actualin actual-out vertexassociated givencall site corresponds givenformal-in formal-out vertex figure illustrates schematically key steps algorithm basic idea find procedure same-levelrealizable paths end formalout vertices paths start formalin vertices induce summary edges actual-in actual-out vertices call sites represent calls forexample algorithm applied sdg shown figure path found formal-in vertexofprocedure add labeled xin tothe formal-out vertexlabeled xout path induce summary edges xin sum sum xout xin xout main asshown figure augmented sdg compute forward interprocedural slice twoedge-traversal passes pass traverses kinds edges inaforward slice edges traversed source target pass forward slice ignores parameterin call edges pass ignores parameter-out edges algorithm same-levelrealizable paths represented path edges edges inserted set called pathedge algorithm starts asserting same-levelrealizable path formalout vertextoitself path edges inserted pathedge worklist algorithm finds newpath edges repeatedly choosing edge worklist extending backwards path represents depending type source vertex illustrated figure path edge processed source formal-in vertex summary edges inserted summaryedge set lines newsummary edges turn induce newpath edges summary edge same-levelrealizable path formal-out vertex same-levelrealizable path procedure propagate called edges lines cost algorithm expressed terms parameters number procedures program sites number call sites procedure sites maximum number call sites anyprocedure totalsites total number call sites program bounded sites maximum number control flowedges anyprocedure spdg params maximum number formal-in vertices anyprocedure spdg algorithm finds same-levelrealizable paths end formal-out vertex anewpath found extending backwards previously discovered path worklist edge vertex out-degree greater path discovered put worklist due test propagate worst case algorithm extend path pdg edge lines summary edge lines formalout vertex cost computing summary edges asingle procedure equal number formal-out vertices bounded params times number pdg summary edges procedure worst case asummary edge actual-in vertextoevery actualout vertexassociated call site number summary edges procedure bounded sites params cost computing summary edges procedure bounded params sites params equal params sites params summing procedures program total cost algorithm bounded function computesummaryedges sdg returns set edges declare pathedge summaryedge worklist set edges procedure propagate edge begin pathedge insert pathedge insert worklist end begin pathedge summaryedge worklist formaloutvertices insert pathedge insert worklist worklist select remove anedge worklist switch case actualoutvertices summaryedge controledges propagate end case case formalinvertices callers proc correspondingactualin correspondingactualout insert summaryedge pathedge propagate end end case default flowedges controledges propagate end case end switch return summaryedge end figure function computesummaryedges computes returns set summary edges givensystem dependence graph figure params totalsites params comparison previous work cost interprocedural slicing algorithm horwitz reps binkleyisdominated cost computing summary edges hrb-summary algorithm totalsites params totalsites sites params main result paper newalgorithm computing summary edges cost bounded params totalsites params reasonable assumption total number call sites program greater number procedures term cost newalgorithm asymptotically smaller term cost hrb-summary algorithm family examples hrb-summary algorithm performs totalsites params totalsites sites params steps newalgorithm asymptotically faster twomain differences approaches twoalgorithms lead differences costs hrb-summary algorithm creates compressed form sdg formal-in formal-out actual-in actual-out vertices edges compressed graph represent intraprocedural paths original graph cost compressing sdg totalsites params term cost givenabove newalgorithm uncompressed sdg compression cost compressing sdg hrb-summary algorithm repeatedly finds installs summary edges closes edge set pdg install-andclose steps similar extend-a-path steps performed newalgorithm difference close step hrb-summary algorithm essentially replaces -part path form path edge path single path edge algorithm replaces -part path form edge path single path edge approach reason superiority newalgorithm total cost series install-and-close steps performed hrb-summary algorithm totalsites sites params term cost givenabove term dominant term practice worse factor sites params term newalgorithm scost summarize cost hrb-summary algorithm cost newalgorithm twoterms case term represents cost compression term represents cost finding summary edges compressed graph case terms represent cost finding summary edges uncompressed graph cost newalgorithm asymptotically cost hrb-summary algorithm experimental results section describes results preliminary performance study carried measure howmuch faster interprocedural slicing function computesummaryedges place hrb-summary algorithm slicing algorithms implemented tested asun sparcstation model ram tests carried programs written small language includes scalar variables array variables assignment statements conditional statements output statements loops loops procedures value-result parameter passing recdes recursivedescent parser lists assignment statements calc simple arithmetic calculator format text-formatting program kernighan plauger sbook software tools table givessome statistics sdgs test programs sdg statistics psites totalsites eparamsprog linesof source vertices control flow edges recdes calc format comparison section asymptotic worst-case running time hrb-summary algorithm newalgorithm suggests newalgorithm lead significantly slicing algorithm formulas asymptotic worst-case running time good predictors actual performance forexample formula running time computesummaryedges wasderivedunder worst-case assumptions asummary edge actual-in vertextoevery actualout vertexassociated call site call site number actual-in actual-out vertices bounded params yields totalsites params asthe bound total number summary edges shown table overestimates actual number summary edges twoorders magnitude totalsites params actual number summary edges recdes calc format asymptotic worst-case analysis helpful guiding algorithm design tests needed determine howwell slicing algorithm performs practice forour study weimplemented slicing algorithms algorithm slicing algorithm improvedmethod computing summary edges section algorithm essentially dual algorithm algorithm likealgorithm computation summary edges 
involves finding same-level realizable paths formal-in vertices formal-out vertices paths extended forwards backwards table shown figure givesstatistics performance algorithms representative slice programs case reported running time average fiveexecutions quantity time slice user cpu-time system cpu-time time final step computing slices two-pass traversal augmented sdg shown separate entry table step small portion time slice seconds total cpu-time recdes calc seconds format shown columns table algorithms superior algorithm exhibiting -fold -fold speedup algorithm appears lines lines lines control flow edge key possibly path edge summary edge summary edge parameter-in parameter-out edge path edgeo lines figure diagrams showhow algorithm figure extends same-levelrealizable paths installs summary edges algorithm algorithm algorithm vertices slice hrb slicingalgorithm summary edges computedby algorithm section summary edges computed dual algorithm section time slice time slice speedup time slice speedup seconds seconds overhrb seconds overhrb number percent total recdes calc format figure performance algorithms representative slice programs marginally algorithm procedures fewer formal-out vertices formal-in vertices bound derivedfor series install-andclose steps algorithms bound hrb-summary algorithm factor sites params speedup factor greater larger programs preliminary test hypothesis gathered statistics versions programs number parameters artificially inflated adding additional global variables examples algorithm exhibited -fold speedup overthe algorithm algorithm exhibited -fold -fold speedup summary conclusion algorithm presented paper significantly horwitz-repsbinkleyinterprocedural-slicing algorithm supported comparison asymptotic worst-case running times section preliminary experimental results appendix demonstration algorithm hwang chou exponential hwang-du-chou algorithm constructs sequence slices program slice sequence essentially permits additional levelofrecursion fixed point reached elements included slice essence compute slice respect point procedure itisasifthe algorithm performs sequence steps replace call procedure body called procedure compute slice newversion assume flowdependences unexpanded calls repeat steps newvertices included slice purposes determining newvertexisincluded slice vertexinstance expanded program identified originating vertex original multi-procedure program fact actual in-line expansions performed theyare simulated stack kth slice sequence bound depth stack stack track calling context called procedure realizable paths considered appendix present family examples hwang-du-chou algorithm takes exponential time order simplify presentation family programs streamline diagrams sdgs including vertices related procedure calls enter formal-in formal-out call actual-in actual-out vertices intraprocedural transitive dependences streamlining affect argument showing complete sdgs makeour diagrams unreadable theorem thereisafamily programs whichthe hwang-du-chou algorithm time exponential size program proof weconstruct family programs grows linearly size butcauses hwang-du-chou algorithm time exponential size algorithm srunning time agiv enprogram family consists single recursive procedure named defined procedure call call end present idea construction discuss case sdg program depicted shown labels denote formal-in formal-out actual-in actual-out vertices toenhance readability formal-in actual-in vertices shown ordered right-to-left left-to-right nowconsider slice program respect formal-out vertexfor parameter tocompute slice hwang-du-chou method performs actions equivalent carrying traversal exponentially long path complete binary tree height path traversed shown bold figure examine tree figure closely apparent original slicing problem spawns twoadditional slicing problems similar form twosubsidiary problems involveperforming slices program respect twochildren root tree subsidiary slicing problems equivalent taking slice respect formal-out vertex program general hwang-du-chou algorithm takes exponential time family programs toperform slice respect formal-out vertex algorithm performs actions equivalent traversing exponentially long path apath length complete binary tree height toperform slice respect formal-out vertex algorithm spawns twosubsidiary slicing problems equivalent performing slices respect formal-out vertex program addition twosubsidiary slices additional edges traversed time complexity hwang-du-chou algorithm recurrence relation acknowledgement recdes calc programs supplied tommy hoffner linko ping agrawal slicing programs jump statements proceedings acm sigplan conference programming language design implementation orlando june acm sigplan notices june ball horwitz slicing programs arbitrary control flow proceedings international workshop automated algorithmic debugging linko ping sweden lecturenotes computer science springer-verlag newyork bannerjee speedup ordinary programs dissertation tech rep dept computer science illinois urbana october bates horwitz incremental program testing program dependence graphs conference recordofthe twentieth acm symposium principles programming languages charleston january acm newyork binkley multi-procedure program integration dissertation tech rep trcomputer sciences department wisconsin madison august binkley semantic differencing reduce cost regression testing proceedings conference softwaremaintenance orlando flori november binkley interprocedural constant propagation dependence graphs data-flowmodel proceedings international conference compiler construction edinburgh april lecturenotes computer science figure compute same-levelslice respect hwang-du-chou algorithm traverses path highlighted bold fritzson springer-verlag newyork chase wegman zadeck analysis pointers structures proceedings acm sigplan conference programming language design implementation white plains june acm sigplan notices june choi ferrante static slicing presence goto statements acmlettersonpro graming languagesand systems gallagher lyle program slicing software maintenance ieee transactions softwareengineering august goff kennedy tseng practical dependence testing proceedings acm sigplan conference programming language design implementation toronto ontario june acm sigplan notices june horwitz pfeiffer reps dependence analysis pointer variables proceedings acm sigplan conference programming language design implementation portland june acm sigplan notices july horwitz prins reps integrating non-interfering versions programs acmtrans program lang syst july horwitz reps binkley interprocedural slicing dependence graphs acmtrans program lang syst january horwitz identifying semantic textual differences twoversions program proceedings acm sigplan conference programming language design implementation white plains june acm sigplan notices june hwang chou finding program slices recursive procedures inproceedings ieee compsac chicago oct ieee computer society washington kernighan plauger softwaretools pascal addisonwesley reading lakhotia constructing call multigraphs dependence graphs conference recordofthe twentieth acm symposium principles programming languages charleston jan acm newyork landi ryder pointer-induced aliasing problem classification conference recordofthe eighteenth acm symposium principles programming languages orlando january acm newyork larus hilfinger detecting conflicts structure accesses proceedings acm sigplan conference programming language design implementation atlanta june acm sigplan notices july maydan hennessy lam efficient exact data dependence analysis proceedings acm sigplan conference programming language design implementation toronto ontario june acm sigplan notices june ottenstein ottenstein program dependence graph software development environment proceedings acmsigsoft sigplan softwareengineering symposium practical softwaredevelopment environments pittsburgh apr acm sigplan notices pugh omega test fast pratical integer programming algorithm dependence analysis insupercomputing november pugh wonnacott eliminating false data dependences omega test proceedings acm sigplan conference programming language design implementation san francisco june acm sigplan notices july sharir pnueli approaches interprocedural data flowanalysis programflow analysis theory applications muchnick jones prentice-hall englewood cliffs weiser program slicing ieee transactions softwareengineering sepp july wolfe optimizing supercompilers supercomputers dissertation tech rep dept computer science illinois urbana october 
eliminating duplication source code procedure extraction raghavan komondoor raghavan wisc susan horwitz horwitz wisc computer sciences department wisconsin-madison dayton madison usa abstract duplication source code widespread phenomenon increases program size complexity makes program maintenance cult solution problem detect clones instances copied code eliminate elimination works extracting cloned code separate procedure replacing clone call procedure automatic approaches detecting clones reported literature paper address issue automatically extracting previously detected group clones separate procedure present algorithm extract cult groups clones study shows cult clone groups arise frequently practice algorithm handles introduction programs undergoing ongoing development maintenance lot duplicated code results studies source code large programs duplicated code duplication caused copy paste activities feature resembles existing feature implemented copying pasting code fragments modi cations duplication increases code size complexity makes program maintenance cult enhancement bug clone instance duplicated code search clones order perform modi cation large legacy programs programmers miss clones modications maintainability legacy programs improved detecting eliminating clones elimination works extracting cloned code separate procedure replacing clone call procepermission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee copyright acm x-xxxxx-xx-x dure case copy maintain procedure fact procedure reused cut future duplication note language preprocessor macros procedures concern introducing procedures result unacceptable performance degradation automatic approaches detecting duplication reported literature paper address issue automatic extraction previously detected group clones separate procedure main contributions paper main contributions algorithm extracting cult groups clones groups statements individual clone contiguous groups clones matching statements erent orders groups clones involve exiting jumps jumps region clone region clone groups hard extract manually tool support task desirable algorithm signi improvement previously ned automatic approaches clone-group extraction approaches employ narrow range techniques perform poorly cult groups clones study clone groups programs determine cult clone groups occur practice algorithm performs compared previous clone-group extraction algorithm results produced human programmer found half clone groups exhibited problematic aspect found algorithm produced output programmer difcult groups previous algorithm matched ideal output fewer groups extracting cult group clones two-step process rst step involves dealing cult aspects applying semantics-preserving transformations clones make easily extractable procedure step involves extracting procedure replacing transformed clones calls procedure focus paper rst step address step main issue step determine local variables parameters procedure addressed previous clone-group extraction approaches approaches work assembly code extended work source-level languages algorithm overview provide overview algorithm motivating figure shows cult group clones rst column figure shows fragments code clones signs fragments loop iterates employees cloned code reads number hours worked compute overtime pay total pay current employee overtime pay rate base pay employee obtained arrays ovrate basepay computed total pay saved array pay arrays global variables pointer clone group cult extract intervening non-cloned statements present fragments statement nover rst fragment update tothours fragment adjustment variable excess fragment greater words clones non-contiguous matching statements erent orders clones position base basepay emp differs cases relative ordering statements orate ovrate emp excess hours call groups out-oforder groups clones exiting jumps break statements middle column figure shows result applying algorithm regions originally contained clones transformed make group extractable ready extracted nal code actual extraction algorithm shown column figure algorithm runs phases rst phase consists applying single-fragment algorithm individually clone make extractable procedure phase intervening noncloned statements moved cloned statements preserving semantics movement accompanied duplication predicates jumps preserve semantics non-cloned statement moved preserving semantics promoted means present extracted procedure guarded parameter procedure figure shows intermediate result phase applied fragments figure loops enclosing clones omitted gure notice promoted code fragment signs nover rst fragment tothours hours fragment moved past statements respective clones duplication predicates jump rst fragment predicate jump non-cloned statement excess excess moved ecting data dependences promoted rst phase deals exiting jumps notice surrounding loop included procedure break statement make sense included unchanged extracted procedure extracted procedure return statement place break works copy break cloned code execute control returns return statement algorithm converts original copies breaks gotos targets points cloned code shown figure time actual extraction gotos simply converted return statements phase algorithm works entire group simultaneously unlike phase goal deal out-of-order aspect phase permutes statements clones order make matching statements line order clones group phase dependences preserved permutation order guarantee semantics preservation figure noted middle column algorithm output algorithm permutes clone move assignment base end clone move assignment orate beginning statement algorithm terminates point group extractable actual extraction proceed parameters local variables determined time figure column shows result extraction transformed clones simply replaced calls newly extracted procedure calcpay resulting rewritten fragments notice code moved phase present call sites promoted code extracted procedure guarded parameter set appropriately call sites comparison previous work approaches clone-group extraction source code proposed literature work reported area compacting assembly code identifying extracting clones aspect work comparison previous clone-group extraction approaches semanticspreserving transformations move intervening noncloned statements reorder out-of-order clones rst approach handle exiting jumps to-be-extracted code features algorithm perform cult clone groups performance previous approaches unsatisfactory addition disallowing exiting jumps approaches sequences contiguous match approach inexactly matching sequences perform code motion guarding resolve mismatches extracting non-contiguous clones out-of-order clones means intervening non-matching statement copy out-of-order statement extracted procedure guarded form original fragment algorithm output emp emp nemps fscanf hours hours error illegal input break overpay hours orate ovrate emp excess hours nover overpay excess orate base basepay emp pay emp base overpay emp emp emp nemps fscanf hours hours error illegal input goto overpay hours orate ovrate emp excess hours overpay excess orate base basepay emp pay emp base overpay hours break hours nover emp original fragment algorithm output emp emp nemps fscanf hours hours error illegal input break tothours hours base basepay emp overpay hours excess hours excess excess orate ovrate emp overpay excess orate pay emp base overpay emp emp emp nemps fscanf hours hours error illegal input goto overpay hours orate ovrate emp excess hours excess excess overpay excess orate base basepay emp pay emp base overpay hours break tothours hours emp extracted procedure void calcpay int emp int 
phrs int dolimit int overpay orate excess base fscanf phrs phrs error illegal input return overpay phrs orate ovrate emp excess phrs dolimit excess excess overpay excess orate base basepay emp pay emp base overpay rewritten fragment emp emp nemps calcpay emp hours hours break hours nover emp rewritten fragment emp emp nemps calcpay emp hours hours break tothours hours emp figure illustrating extraction cult clones fair noted assemblycode-compaction approaches solve problem similar signi erence goal algorithm extract group clones represent meaningful computation goal extract groups clones yield space savings erence reasonable algorithms extract small easy subsets larger meaningful clones previous approaches clone-group extraction source code weaknesses similar exhibited assembly-code algorithms approach works object-oriented programs conceptually similar assembly-code approach extraction inexact matches code motion place mismatching code extracted procedure guards place mismatching statement sequence statements method place call method point extracted procedure methods called extracted procedure passed parameters extracted procedure drawback approach clear perform code motion produce extracted procedures method calls idea method parameters incorporated approach place guarding make output cleaner situations clone-group-extraction approach extraction out-of-order clones address extracting non-contiguous clones clones involving exiting jumps studies section clones cult aspects occur frequently handling essential good performance rest paper organized section clone fscanf hours hours error illegal input goto overpay hours orate ovrate emp excess hours overpay excess orate base basepay emp pay emp base overpay hours break hours nover clone fscanf hours hours error illegal input goto base basepay emp overpay hours excess hours excess excess orate ovrate emp overpay excess orate pay emp base overpay hours break tothours hours figure output phase clones figure presents basic assumptions terminology section denes algorithm extracting group clones section presents results study mentioned section quantitative data algorithm works practice advance previous techniques assumptions terminology assume reader familiar standard nitions control data dependence assume programs represented set controlow graphs cfgs procedure predicate nodes cfgs outgoing edges looppredicates predicates switch predicates case label default case exit node cfg outgoing edges nodes assignments procedure calls single outgoing edge entry node cfg considered pseudo-predicate evaluates true outgoing true edge rst executable node outgoing false edge exit node jumps gotos returns continues breaks considered pseudo-predicates true edge jump target jump non-executable false edge node follow jump replaced no-op jump statements treated pseudo-predicates statements semantically dependent jump dened control dependent assume nesting relationships obtained abstract syntax tree ast representation program normal predicates entry node nesting children non-predicates jumps nesting parent nesting child refer relationships transitive nesting child predicate quali c-nesting child label edge nested true false case label block subgraph cfg corresponds simple statement entire compound statement loop if-then-else statement cfgs figure illustrate blocks gure shows cfg fragments entire cfgs cfg node labeled beginning block examples blocks subgraphs labeled block nested inside block block cfg nesting child normal predicate entry node true-nesting child predicate hours block sequence sequence blocks cfg control ows block sequence ignoring jumps blocks c-nesting children predicate node block sequence c-nesting child nesting parent figure block sequence sequence spans entire cfg fragment subsequence previous sequence nested inside block clone-group extraction algorithm input algorithm group clones cfgs procedures individual clone contained single procedure erent clones group erent procedures input includes mapping nes nodes clone match nodes clones algorithm inexact matches number ways enabling extraction wide variety cult clones individual clones non-contiguous mapped nodes erent orders erent clones mapped nodes required mapped nesting parents erences control structure caused intervening unmatched blocks jumps allowed group consists clones node clone mapped nodes clones erent clones group consist erent numbers nodes input mapping required satisfy properties mapping transitive nodes erent clones mapped mapped mapped node clone mapped node clone node clone mapped nodes clones clones non-overlapping tightest block sequences individual clones disjoint tightest block sequence innermost terms nesting shortest terms number blocks mapped nodes mapped nesting parents node mapped node true node nesting parent tightest block sequence clone c-nesting children mapped predicates mapped nodes kind assignment node mapped assignment nodes predicate mapped predicate nodes algorithm nishes group clones transformed easily extractable separate procedure phase making individual clones extractable discussed introduction phase clonegroup extraction algorithm applies algorithm individual clone set nodes comprise single clone algorithm transforms tightest block sequence cloned nodes semanticspreserving manner moving intervening non-cloned nodes cloned nodes promoting nodes moved handling exiting jumps output algorithm block sequences rst non-cloned nodes moved cloned nodes cloned promoted nodes non-cloned nodes moved cloned nodes block sequence cloned nodes single-entry single-exit structure structure easily extractable procedure algorithm runs polynomial time size block sequence transforms succeeds nal output produced algorithm clone fragment figure shown top half figure phase rst block sequences produced phase non-cloned nodes phase operates block sequences cloned nodes promoted nodes originally mapped nodes continue regarded end phase clone group order ned section algorithm terminates group extractable block sequences clones levels nesting permuted semantics-preserving manner make clone group in-order phase algorithm section phase reordering block sequences goal phase make group clones in-order involves steps identify sets mapped blocks sets mapped block sequences set mapped block sequences top-level in-order permute sequences set semantics-preserving manner make top-level in-order sets mapped block sequences outer level nested inside considered step recall part input algorithm mapping nodes individual clones mapping applies blocks represent individual statements phase extend mapping blocks represent compound statements block sequences nition compound block clone mapped compound block clone node mapped node node mapped node note blocks unmapped nodes nodes mapped nodes clones similarly nition block sequence clone mapped block sequence clone block mapped block block mapped block discussion two-clone group figure serves running gure shows clones figure form cfg subgraphs phase dashed edges goto nodes non-executable edges section gure individual-statement compound block labeled mappings individual-statement blocks assumed intuitive identical statements mapped nodes nodes mappings compound blocks determined nition blocks mapped blocks mapped notice clone block mapped block rst clone total sets pairs case mapped block sequences notice pairs block sequences nested inside rst considered separate pairs block sequences set mapped block sequences top-level in-order pair block sequences set top-level blocks sequence mapped top-level blocks top-level blocks order sequences sets mapped block sequences listed set 
top-level in-order sets presence unmapped block set in-order note set mapped block sequences toplevel in-order smaller sets mapped block sequences nested inside top-level in-order phrase top-level cult group clones completely in-order set mapped block sequences fscanf hours error goto base basepay emp overpay hours fscanf hours error goto overpay hours excess hours base basepay emp pay emp base overpay excess hours excess excess pay emp base overpay true true true true false false false false orate ovrate emp overpay excess orate orate ovrate emp overpay excess orate figure clones figure phase top-level in-order approach visit set mapped block sequences top-level in-order including nested sets permute block sequences make set top-level in-order visiting set mapped block sequences involves generating ordering constraints blocks sequence permuting top-level blocks sequence respecting constraints constraint generation subsections section describes constraints preserving control-dependences section describes constraints preserving data dependences actual procedure permutation section constraints preserving control dependences constraints needed preserve control dependences permuting block sequence properties jumps sequence target inside jumps inside sequence target jumps block sequence conditions hold block sequence permutation preserves control dependences control-dependencebased constraints needed goto goto figure illustrating control dependence constraints figure arti cial illustrative assume node predicates jumps assignment block mapped block mapped assignment nodes unmapped gotos algorithm unmapped jumps make extraction challenging unmapped jumps plausible real clones computation occur places intervening statement checks boundary condition jumps based outer-level mapped block sequences kinds jumps mentioned earlier control-dependence-based constraints rst block sequences permutation preserve property execute goto executes incorrect similarly goto incorrectly bypass notice constraints simple precedence constraints block sequence gure constraint needed complex remain blocks blocks rules generating constraints preserve control dependences rule block block sequence jump target sequence node target jump sequence block precedes block sequence generate constraint meaning precede block sequence generate constraint rule blocks block sequence precedes jump node target node inside block sequence generate constraints block sequence generate constraint permutation generate constraint constraints preserving data dependences data-dependence-based constraints ensure preservation data dependences constraints generated simple rule block precedes block block sequence anti output def-order dependence node node generate constraint permuting block sequences generated set constraints block sequence set mapped block sequences visited goal permutation block sequence set top-level in-order achieved creating graph vertices represent top-level blocks edges represent constraints create graph set mapped toplevel blocks set block sequences represented vertex block sequence mapped block sequence vertex simple precedence constraint form add directed edge vertex representing vertex representing obtain topological ordering vertices respects constraints ordering exists fail block sequences made top-level in-order satisfying constraints details step provided block sequence obtain nal permutation simply taking total ordering previous step projecting vertices represent blocks sequence return figure illustration pick mapped block sequences vertices graph represents mapped blocks represents mapped blocks data dependence constraints translated graph edges edge caused def-order dependences caused dependence constraints involving represent constraints block sequence represent constraints block sequences block sequences requires control-dependence constraints topological orderings consistent constraints obtain permutations block sequences notice block sequences top-level in-order observation helps ning solution step constraint form logically equivalent constraint straightforward implement step constraint add edges graph topological ordering resulting graph acyclic backtracking systematically explore choices ordering found fail approach simple worst-case time complexity exponential number constraints problem practice constraints arise program gotos excluding introduced phase complex condition rule section holds experimental studies section instances constraint interesting open question polynomial-time algorithm step experimental results section describes results study performed determine cult clone groups arise practice evaluate performance algorithm compared ideal extractor human previously reported automatic approach clone-group extraction dataset consisted clone groups total individual clones median number clones group maximum median size number simple statements predicates clone maximum dataset drawn programs unix utilities bison make narc graph-drawing engine developed ibm programs range size thousand lines code expedite process nding clone groups extract clone-detection tool reported clone groups involve cult aspects output tool ltered clones good candidates extraction small clones bene cial extract clones cleanly extracted ideal extractor comparison ideal extraction rst step comparison extracted clone group ideal manner judgment techniques process moving intervening unmapped nodes reordering out-of-order matches algorithm techniques incorporated algorithm discussed step comparison manually apply algorithm clone group figure presents results comparison figure summarizes comparative performance algorithm set clone groups divided disjoint categories row rst row shows clone groups total individual clones cult clones groups contiguous involve exiting jumps order groups extractable begin algorithm remaining clone groups dataset cult required transformations phases algorithm row figure shows algorithm produced ideal output cult clone groups columns characterize cult aspects groups fourth rows figure pertain clone groups algorithm succeeded produced non-ideal output failed details note algorithm makes clone group extractable narc registered trademark ibm groups individual clones category total outof ord total noncontig exiting jumps cult cult ideal output cult ideal output cult failure characterization algorithm output technique ideal output non-ideal output human algo phase moving nodes promotion phase reordering out-oforder clones techniques cult clone groups number clones phase number groups phase figure comparison algorithm ideal extraction perform actual extraction comparison algorithm output ideal extraction involves verifying nodes moved cases identical usage predicate duplication nodes promoted out-of-order matches handled case handled issues pertaining actual extraction determining parameters comparison note algorithm performed ideally group phase performed ideally individual clone group phase subsequently performed ideally entire group figure shows technique incorporated algorithm algorithm ideal extraction non-di cult clone groups groups algorithm fails omitted figure technique appears row rows pertaining techniques phase counts individual clones clone-group counts row phase column labeled ideal output pertains clone groups algorithm performed ideally numbers column pertain ideal extraction extraction performed algorithm fourth columns pertain groups algorithm performed non-ideally separate sets numbers required algorithm ideal extraction exact techniques groups shown figure algorithm performs ideally cult groups produces nonideal output cult groups fails reason algorithm non-ideal behavior individual clones phase aggressively moves unmapped nodes predicate duplication ideal extraction promotion numbers figure bear problem addressed designing heuristics issue ideal extraction complex matches algorithm case ideal extraction matched single node block clone copies branches clone case ideal extraction matched sequence separate blocks mutually exclusive conditions clone single block clone algorithm matches prevented mapped 
nesting parent requirement discussed beginning section nodes unmapped input supplied algorithm algorithm fails cases out-of-order group reordered data-dependence constraints section conservative human judgment case reveals reordering safe group strictly failure sense nesting structures clones erent nodes matched ideal extraction left mapping provided algorithm ideal extraction case involves extensive rewriting chose place group failure category comparison previous algorithm part study involved comparing algorithm previously reported clone-group extraction algorithm debray goal work extract matching fragments code order compact assembly programs technique applied source code chose approach comparison employs techniques assembly-code compaction approaches conceptually similar source-code based approach perform source-code based approach groups involving non-contiguous clones extraction addressed occur frequently dataset out-of-order groups handled approach works procedure build cfg nodes represent basic blocks groups isomorphic single-entry single-exit subgraphs cfgs basic blocks similar instruction sequences extract group procedure basic blocks group identical instruction sequences modulo register renamings walk sequences lock-step promote mismatching instruction included extracted procedure guard inexact matches allowed mismatch handled approach guarding mechanism intervening non-matching statement copy out-of-order matching statement extracted procedure guarding addition fact guarding handle mismatches approach important weaknesses compared requirement cfg subgraphs isomorphic fail extract clones running figure presence intervening non-matching block category clonegroups fail ideal output non-ideal ideal fail output non-ideal fail outputs non-ideal fail output non-ideal output ideal non-ideal figure comparison algorithm debray labeled makes subgraphs non-isomorphic words non-matching code inside basic block weakness restricted extracting single-entry single-exit structures handle exiting jumps figure due presence breaks smallest single-entry singleexit structure enclosing clone entire surrounding loop extract entire loop desired clones major problem code loops desired clones signi number unmatched statements loops extraction nonmatching code loops caused cfg subgraphs non-isomorphic place non-matching code loops extracted procedure guarding alternatives desirable extracting matching code figure data comparing performance algorithm cult clones dataset comparison ideal extraction restrict attention transformations applied approaches issues relating actual extraction address address issues assembly-code level matching nodes subexpression parameterized ideal extraction treat nodes non-problematic approaches cult clone groups divided disjoint categories row figure shown rst rows algorithm fails performs non-ideally clone groups algorithm produces ideal output groups rst rows main reason performance algorithm discussed earlier employs variety transformations tackle difcult aspects promotion shown rows gure algorithm performs clone groups out-of-order group algorithm fails succeed non-ideally guarding groups algorithm aggressively moves unmapped nodes guarding solution ideal alternative summary studies algorithm performed ideally thirds difcult clone groups algorithm performed ideally percent automatic algorithm employ full range transformation techniques human ideal performance automatic algorithm feasible results study encouraging indicating algorithm practice study evidence previously reported approaches assembly-code compaction powerful context meaningful clones extracted source-code level case techniques moving unmatched code handling exiting jumps bene cial context assembly-code compaction acknowledgements work supported part national science foundation grants ccrand ccrand ibm baker nding duplication near-duplication large software systems proc ieee working conf reverse engineering pages july balazinska merlo dagenais lague kontogiannis partial redesign java software systems based clone analysis proc ieee working conf reverse engineering pages ball horwitz slicing programs arbitrary control lecture notes computer science volume york nov springer-verlag bates horwitz incremental program testing program dependence graphs proc acm symp principles programming languages pages jan baxter yahin moura sant anna bier clone detection abstract syntax trees int conf software maintenance pages choi ferrante static slicing presence goto statements acm trans programming languages systems july cooper mcintosh enhanced code compression embedded risc processors proc acm conf programming language design implementation pages debray evans muth sutter compiler techniques code compaction acm trans programming languages systems mar ferrante ottenstein warren program dependence graph optimization acm trans programming languages systems july griswold notkin automated assistance program restructuring acm trans software engineering methodology july komondoor horwitz slicing identify duplication source code proc int symposium static analysis pages july komondoor horwitz ective automatic procedure extraction submitted int conf compiler construction kontogiannis demori merlo galler bernstein pattern matching clone concept detection automated software engineering kuck kuhn padua leasure wolfe dependence graphs compiler optimizations proc acm symp principles programming languages pages jan kumar horwitz slicing programs jumps switches proc fundamental approaches software engineering apr lague proulx mayrand merlo hudepohl assessing bene incorporating function clone detection development process int conf software maintenance pages waddle malhotra log line crossing algorithm leveled graphs lecture notes computer science volume pages springer-verlag zastre compacting object code parameterized procedural abstraction master thesis department computer science victoria british columbia 
pointer-range analysis suan hsi yong susan horwitz computer sciences department wisconsin-madison west dayton street madison usa suan horwitz wisc abstract array-range analysis computes compile time range index values array-index expression program information detect potential out-of-bounds array accesses identify non-aliasing array accesses language arrays accessed indirectly pointers pointer arithmetic allowed range analysis extended compute range values pointer dereference paper describes pointer-range analysis algorithm computes safe approximation set memory locations accessed pointer dereference properly account non-trivial aspects including pointer arithmetic type-casting range representation separates identity pointer target location type separation concise representation pointers multiple arrays precise handling mismatched-type pointer arithmetic introduction goal array-range analysis compute compile time range index values array-index expression program information applications eliminating unnecessary redundant bounds-checking operations code optimization detecting potential out-of-bounds access errors debugging program verification security identifying non-aliasing array accesses program understanding optimization parallelization importance array-range analysis reflected extensive body research conducted decades previous work focused languages fortran java languagepresents challengesfor array-rangeanalysis arrays accessed indirectly pointers pointer arithmetic alternative compute index array type-casts unions work supported part national science foundation grants ccrand ccrallow array type accessed array type possibly size deciding array difficult heap allocated storage mechanism call malloc allocating single object array objects means pointer dereference single object pointer dereference array object syntactically differentiated features approach problem range analysis treating pointer dereferences array accesses treating solitary object array element array indexing expression semantically equivalent dereference analysis purely terms pointer dereferences pointer arithmetic array accesses array-index computation pointer-range analysis paper describes pointer-range analysis algorithm compute dereference program safe approximation set memory locations accessed dereference abstract representation ranges presented safely portably handle challenging aspects analyzing pointers including pointer arithmetic type mismatches arise due unions casts imprecise points-to information pointer point arrays pointer-range representation components target location target type offset range separate tracking target location type single location treated types precise type information maintained location information lost result analysis imprecision maintaining types numeric values sizes preserves portability allowing analysis applied exact sizes types assumed experimental results presented show potential utility pointer-range analysis contexts eliminating unnecessary bounds checks identifying non-aliasing accesses representing ranges define pointer-rangeanalysis forward dataflow-analysis problem edge control-flowgraph cfg mapping maintained location abstract representation range values hold runtime abstract representation safe approximation represent superset actual range values follow convention dataflow analysis performing meet control-flow merge points elements abstract domain partially ordered implies approximate range represented superset range represented dealing numeric values integer interval domain represent ranges integer interval domain min max min max min max min max represents set integer values range min max min max min max iff min max min max min min max max note lattice satisfies approximation requirement top element bottom element meet operator figure demonstrates analysis simple intervals shows computed range decide arrayindex bounds assigning constant map precise interval representation line branches merge line meet union range incoming branches approximate superset range values falls legal range indexing array array index line guaranteed in-bounds dealing pointers abstract domain capture information pointer target object pointer point step define set loc abstract representatives locations objects defined program pointer legally point locations loc loc variable program malloci program point malloc called location loc treated array object element type element count solitary objects element count heap location malloci represents heap objects allocated program point determine precise type count values inferred argument malloc argument constant set type char count form int int mapsto mapsto mapsto in-bounds int int mapsto mapsto mapsto in-bounds arrays integer intervals pointers location-offset fig in-bounds access location-offset descriptor-offset int int mapsto mapsto int mapsto mapsto int mapsto mapsto unknown int don in-bounds fig multiple target sizeof set type count set type void count define location-offset domain elements represent pointer location offset location-offset domain loc null element min max represents address location offset range min max range min max static element type location shorthand sizeof size bytes null-targetedelement null min max represents integer range min max iff converted lattice lol adding top element bottom element figure shows program behavior program figure pointer indirectly access array line map location-offset range represents constant int line meet operation yields range int int values line dereferenced elements verify range falls legal range int int in-bounds location-offset representation weaknesses represent pointer single target location figure assigned point arrays branches location-offset representation merge point line map elements incoming branches lo-incomparable dereference line determined in-bounds weakness location-offset representation lose precision handling pointer arithmetic mismatched types location-offset descriptor-offset int char char mapsto mapsto int mapsto mapsto char in-bounds in-bounds fig mismatched types assuming int figure line assigned point array ints static type char pointer arithmetic line char-based translated int-based arithmetic applied int-based range assuming int char char-based addition int-based addition approximated range computed fact dereference line identified potentially out-of-bounds fact in-bounds address weaknesses location-offset domain track type element count pointer target separately explicitly define domain array descriptors elements describe identity element type element count array object array-descriptor domain loc loc loc unknown unknown represents unknown location flat semi-lattice loc defined loc unknown iff set unqualified non-voidnon-arrayc types typedefs expanded underlying types withallpointer types treated equivalent descriptor represents location treated arraywith elements type readability notation represent triple multi-dimensional arrays flattened array integers represented int unknown represents location unknown identity array elements type iff define descriptor-offset domain descriptor-offset domain null element min max represents address array elements type offset range min max null-targetedelement null min max represents integer range min max iff null d-comparable member converted lattice dol adding top element bottom element notice partially ordered size array equal size array ensures satisfies safe approximation requirement points array elements safe approximation points array elements rightmost columns figures show analysis results descriptor-offset ranges figure meet operation line sets location component unknown type count offset components preserved approximate incoming facts taking smaller type-count descriptor superset interval components dereferencing maps element min max min max dereference guaranteed in-bounds unknown case dereference line figure figure line change type count components range array treated array chars recognize dereference line guaranteed in-bounds pointer arithmetic important aspect pointer-range analysis handling pointer arithmetic classes additive operations integers pointers listed figure semantics terms integer arithmetic 
note pointer pointer int-pointer allowed pointer additions similar subtractions -ii trivially converted addition negative argument describe handling operator type integer semantics int int int iii -ii int int int -iii int pii int ipp int pii int ppp result subtracting pointers implementation-defined type ptrdiff fig addition subtraction well-typed arithmetic arithmetic operation typed actual types arguments match types expected operation descriptor-offset domain targeted range represents type null-targeted range null represents type int addition subtraction integer intervals safely approximated equations min max min max min min max max min max min max min max max min well-typed arithmetic descriptor-offset ranges evaluated applying equations interval components ranges integer addition null-targeted ranges null min max null min max null min min max max pointer addition -based range null-targeted range min max null min max min min max max pointer subtraction ranges target location negationslash unknown element type min max min max null min max max min subtraction pointers defined pointers point array pointer subtraction ranges unknown target locations evaluates mismatched-type arithmetic arithmetic operation typed arise permits casting pointers types integers pointers arise unions section addresses handling arithmetic operations ranges mismatched types includes integer addition pointer-typed argument pointer addition subtraction type operation match argument type problem handled depends requirements client analysis specifically client interested well-typed accesses result pointer arithmetic operation mismatched types strong requirement programs weak typing discipline means memory location accessed type model memory locations weaken definition array-descriptor ordering defined page brevity omit details infinite bounds handled setting upper lower bound minus infinity argument needed compute bound infinite iff safe approximation array smaller array element types descriptors means size type analysis time convert range type min max floorleftbig floorrightbig min floorrightbig ceilingleftbig max transform base type pointer addition adjusting righthand-side interval b-based pointer addition bpi right-hand-side null-targeted converted a-based addition bpi null min max api null min floorrightbig ceilingleftbig max transformation eliminate type mismatch well-typed operation evaluated equations section revisiting figure addition line type mismatch maps int-based range addition charbased apply transformation results int charpi null char charpi null char int intpi null int floor ceiling operations loss precision result applying transformation important choose transformation minimizes loss precision practice size types multiple size making round number transformations result loss precision transformations canonlybe applied sizes types areknown analysis time analysis designed portable platforms specific sizes types assumed case make safe approximations results precise making portable information sizes types defined implied specifications char char non-void type char short int long long long float double long double union maxi struct summationtextni struct struct types item implies char-pointer arithmetic equivalent integer arithmetic charpi -charpp -ii item states union type large largest member item states struct type large sum constituents sizes larger due padding item takes advantage subtype relationship structures share common initial sequence item states pointers size strictly speaking unsafe assumption implied requirements pointers cast void loss information return malloc safely cast pointer type assume true safe approximation arises normalize multi-dimensional arrays convert -based pointer addition array type -based pointer addition applying transformation knowledge null min max null min max relative sizes types make approximations transformation bpi null min max api null min parenrightbigg parenleftbiggmax max bpi null min max api null min parenrightbigg parenleftbiggmax max pointer addition line figure char int apply transformation int charpi null int intpi null int note resulting range safe approximation superset precise range int obtained earlier exact size information similar approximation made transformation direction min max min parenrightbigg parenleftbiggmax max key ensures right-handside transformation safe approximation left-hand-side scalar types exact ratio portably defined safe aggregate type safe obtained counting number elements big struct int long char int safe multiply component resultant range evaluating pointer addition bpi null transformation applied choice case transformations important choose transformation minimizes loss precision general transformation precise left-hand-side offset precise experimental results pointer-range analysis implemented context-insensitive interprocedural dataflow analysis operating supergraph program interval lattice infinite descending chains widening ensure convergence narrowing obtain precise results points-to analysis pass performed safely account aliasing identify targets indirect procedure calls numbers collected gauge potential utility analysis applications bounded half-open ranges count number dereferences maps range location bounded offset component finite half-open offsetcomponenthas atleastonefinite bound ranges potentially dependence analysis interested dereferences accessthe samememory location in-bounds dereferences eachdereference mapsto min max min max dereference guaranteed in-bounds information eliminate unnecessary bounds checks detect potential out-of-bounds errors figure presents results analysis benchmarks cyclone olden spec spec column number lines code column static number dereferences program descriptor-offset representation column percentage dereferences bounded ranges percentage half-bounded ranges contrasted roughly results numeric range analysis identified bounded half-bounded ranges non-pointer variables small benchmarks statements num arrays in-b diff loc derefs bnd half-b in-bnd bnd half-b in-bnd multi pred preds cyclone aes cacm cfrac finger grobner matxmult ppm tile olden bisort health mst perimeter power treeadd tsp spec compress gcc ijpeg ksim perl vortex spec ammp art bzip crafty equake gap gzip mcf mesa parser twolf vpr total average fig results column percentage dereferences found in-bounds average percentage low cases including larger programs dereferences found in-bounds contrastthese numbers fare columns give percentages bounded half-bounded in-bounds dereferences direct array accesses accesses form array object represent results obtained array-range analysis approach handle pointers difference large categories confirming handling pointers important analyzing programs motivatethe useofthe representationratherthan thesimpler locationoffset representation evaluated ways give results multi-target represent pointer multiple targets figure transformation application transformation handling mismatched-type operations found multi-target made bigger difference column number in-bounds dereferences found multi-target ability disabled average in-bounds dereferences benchmark procedure calls arrays size passed argument procedure accesses array transformation in-bounds dereferences found feature disabled gcc ksim crafty difference significant shows type-count descriptor effective mechanism handling challenging aspects measure price portability looked improvement results exact sizes types assumed type mismatches handled transformations in-bounds dereferences found exact sizes gcc gap suggesting practice portable transformations produce results good non-portable aspect range analysis paper treatment ranges branch nodes branch node predicate beforedataflow fact mappings mapsto min max mapsto min max afterfact mappings true branch mapsto min min max max mapsto max min min max important improvementto make precision confirmed column number in-bounds dereferences missed loc 
time parser ammp vpr ksim loc time twolf crafty perl ijpeg loc time mesa vortex gap gcc fig analysis times range improvements branch nodes applied average in-bounds dereferences benchmark precise treatment ranges branch nodes lets discover infeasible branches predicate range range predicate statically indicating false branch infeasible column number predicates found programs large number predicates vortex programming style series procedure calls checked success statements procedures return finally rough indicator efficiency algorithm figure analysis times wallclocktime seconds ghz pentiumii ram running linux listed order increasing size lines code benchmarks listed analyze improvements current implementation includes weaknesses addressed solutions improvements adding flowsensitivity context-sensitivity points-to analysis adding context sensitivity dataflow analysis improvements increase time complexity analysis aspect improved handling heap-allocated objects malloc calls argument constant expression sizeof mapped malloc location non-void type non-zero count cases account malloc calls programs room improvement programs malloc wrapper check error conditions common practice problem static analysis multiple conceptual allocation sites folded single malloc callsite limited inlining constant propagation split malloc callsite multiple callsites increase likelihood malloc location meaningful type count extensions range analysis paper computes ranges constant bounds relies presence constants source code derive meaningful ranges record information relationships variables approaches track symbolic ranges constraints variables significantly improve results applications interested bounds checking discovering non-aliasing memory accesses ideas discussed paper applied extend previous approaches handle pointers general string manipulation aspect worthy special consideration string conceptually separate data type library manipulate values implementation top arrays makes susceptible out-ofbounds array accesses tracking string length separate attribute array size deriving information based semantics library functions lead precise results discover potentially out-of-bounds dereferences important concern program security related work range analysis decades motivating seminal paper abstract interpretation introduced notions widening narrowing early work range analysis relied presence structured loops infer loop bounds information verbrugge describe range analysis generalized constant propagation dead-code elimination array dependence testing mccat optimizing parallelizing compiler stephenson range analysis compute number bits needed store hardware patterson range analysis static branch prediction variable program point mapped set probability-weighted ranges weights branch predicates predict likelihood branching direction code-generation optimizations range analysis discover opportunities array privatization parallelization loops gupta recursive divideand-conquer procedures guarded array region representation associates predicate range balakrishnan reps range analysis infer high-level information binary code range representation form compute sets conceptually equivalent high-level notion variable enable high-level analyses reaching definitions applied binary code approaches include notion stride representation capture common access pattern arrays wilson stride improve pointer analysis conceptually component descriptor-offset representation encodes stride portable format allowing analysis settings exact sizes types assumed numerous approaches compute symbolic range information tracking constraints variables dealt pointers rugina rinard compute symbolic ranges variables including pointers linear programming identify non-intersecting ranges automatic parallelization identifying in-bounds accesses approaches deal strings identify potential buffer overruns necessarily handle pointers char pointers address problems related casting conclusion presented pointer-range analysis extends traditional array-range analysis handle pointers non-trivial aspects including pointer arithmetic type-casting range representations intuitive location-offset representation descriptor-offset representation showed yields results practice ideas presented provide insight extending existing array-based range analysis handle pointers c-like languages balakrishnan reps analyzing memory accesses executables international conference compiler construction barcelona spain mar blume eigenmann demand-driven symbolic range propagation international workshop languages compilers parallel computing pages columbus aug bodik gupta sarkar abcd eliminating array bounds checks demand acm sigplan conference programming language design implementation pages vancouver june carlisle rogers software caching computation migration olden technical report tr- princeton cousot cousot static determination dynamic properties programs acm symposium principles programming languages pages apr cousot halbwachs automatic discovery linear restraints variables program acm symposium principles programming languages pages jan creusillet irigoin interprocedural array region analyses international journal parallel programming dec das unification-based pointer analysis directional assignments acm sigplan conference programming language design implementation pages vancouver june dor rodeh sagiv cleanness checking string manipulations programs integer analysis international static analysis symposium volume lecture notes computer science page springer july emami ghiya hendren context-sensitive interprocedural points-to analysis presence function pointers acm sigplan conference programming language design implementation pages orlando june lee symbolic array dataflow analysis array privatization program parallelization acm ieee conference supercomputing san diego dec gupta mukhopadhyay sinha automatic parallelization recursive procedures international conference parallel architectures compilation techniques pact pages newport beach oct ieee computer society harrison compiler analysis ranges variables ieee transactions software engineering volume sepages havlak kennedy implementation interprocedural bounded regular section analysis ieee transactions parallel distributed computing july jim morrisett grossman hicks cheney wang cyclone safe dialect usenix annual technical conference monterey june landi ryder safe approximate algorithm interprocedural pointer aliasing acm sigplan conference programming language design implementation pages san francisco june larochelle evans statically detecting buffer overflow vulnerabilities usenix security symposium washington aug martin experimental comparison call string functional approaches interprocedural analysis int conf compiler construction volume lecture notes computer science pages springer mar patterson accurate static branch prediction range propagation acm sigplan conference programming language design implementation pages jolla june pugh wonnacott constraint-based array dependence analysis acm transactions programming languages systems rugina rinard symbolic bounds analysis pointers array indices accessed memory regions acm sigplan conference programming language design implementation pages vancouver june stephenson babb amarasinghe bitwidth analysis application silicon compilation acm sigplan conference programming language design implementation pages vancouver june wagner class polynomially solvable range constraints interval analysis widenings narrowings tools algorithms construction analysis systems volume lecture notes computer science pages mar verbrugge hendren generalized constant propagation study int conf compiler construction volume lecture notes computer science pages springer apr wagner foster brewer aiken step automated detection buffer overrun vulnerabilities symposium network distributed systems security pages san diego feb welsh economic range checks pascal software practice experience wilson lam efficient context-sensitive pointer analysis programs acm sigplan conference programming language design implementation pages jolla june 
collapse collapse cast common initial sequence offsets football twig rep sim ulator ispellli gzipbison- lessfle ksim anag ram ansitape compress triangle yacr football twig rep sim ulator ispellli gzipbison- lessfle ksim min hrs collapse collapse cast common initial sequence offsets collapse collapse cast common initial sequence offsets football twig rep sim ulator ispellli gzipbison- lessfle ksim 
effects precision pointer analysis marc shapiro susan horwitz wisconsin madison west dayton street madison usa mds horwitz wisc abstract order analyze programs manipulate pointers safe information pointer point algorithms determine information varying degrees accuracy previous work addresses relative accuracies pointer-analysis algorithms affect transitive results results subsequent analysis carried number experiments flow-insensitive context-insensitive pointer analyses address questions transitive effects pointer analysis affected precision analysis good direct effects pointer analysis sizes computed points-to sets predicting transitive effects time trade-offs found precise pointer analysis general lead precise transitive results magnitude payoff precision depends points-to information found direct effects good predictors transitive effects increased precision points-to information subsequent analysis produce precise results subsequent analysis run faster introduction compilers perform variety dataflow analyses live variable analysis permit safe code optimization analyses programming tools provide feedback logical errors aid program understanding debugging aid testing presence pointers analyses difficult code fragment printf variable point execution statements live assignment assignment considered live point assignment dead subsequent assignment compiler safely ignore assignment programming tool report indicating logical error work supported part national science foundation grant ccrand army research office grant daah gather information needed analyses compiler perform pointer analysis determine dereference pointer safe approximation set objects pointing dereference previous work pointer analysis concentrated design analysis algorithms work includes data produced running algorithm data limited reporting times required analyze programs information sizes points-to sets produced possibly comparing times sizes algorithm required produced algorithm examples ruf ste egh interesting clear information predict usefulness pointeranalysis algorithm larger context case discussed don care size points-to set care point paper carried number experiments address questions transitive effects pointer analysis affected precision analysis benefit gained precise pointer analysis thefirst step solving adataflow problem live variable analysis good direct effects pointer analysis predicting transitive effects correlation ratio sizes points-to sets computed pointer analyses sizes live variable sets computed results pointer analyses time trade-offs extra time required compute precise points-to information offset decrease time required subsequent dataflow analysis carry experiments implemented pointer analyses section dataflow analyses section makes points-to information interprocedural slicing system dependence graphs section points-to information build system dependence graphs measured precision pointer analyses affected results dataflow analyses sizes system dependence graphs results slicing cases measured time required pointer analyses subsequent processing made points-to information results presented section summarized precise pointer analysis general lead precise transitive results magnitude payoff precision depends points-to information experiments difference precision ranged direct effects points-to set sizes good predictors transitive effects sizes live variable sets effects precision pointer analysis vary depending points-to sets halving sizes points-to sets necessarily lead doubling accuracy transitive results experiments found expected improvement indirect effects due doubling accuracy pointer analysis ranged increased precision points-to information subsequent analysis produce precise results subsequent analysis run faster offsets longer times needed precise pointer analysis depends relative time requirements pointer analysis subsequent analysis background experiments experiments run set programs including gnu unix utilities spec benchmarks programs benchmarking landi lrz austin abs tests carried sparc ram experiments pointer analysis dataflow analysis involved steps step parse program building control-flow graph step pointer-analysis algorithms analyze program step annotate node control-flow graph sets variables killed defined node nodes involve pointer dereferences results pointer analysis determine kill def sets noderepresents thestatement thenode useset includes bepointed itskill set empty itsdef set includes pointed step traverse annotated control-flow graph producing data solve dataflow-analysis problems step perform dataflow analysis dataflow analysis problems solved method rhs input dataflow engine set graphs function program set dataflow functions edge graph dataflow functions distributive map finite sets finite sets meet operation set union output set dataflow facts hold node graph dataflow problem intraprocedural function dataflow facts provide meet paths solution kil dataflow problem interprocedural dataflow facts provide meet interprocedurally valid paths solution dataflow problem algorithm performs precise context-sensitive interprocedural dataflow analysis worst-case time needed solve dataflow problem method depends problem intraor interprocedural size dataflow domain properties dataflow functions chose dataflow problems experiments span range possibilities time proportional size call graph number globals sum sizes control-flow graphs number variables discussed detail section describes dataflow problems experiments pointer analysis building program system dependence graph computing interprocedural slices involved steps listed steps replaced step annotated control-flow graph build program system dependence graph step slice system dependence graph respect output statements calls library functions printf system dependence graphs built sliced algorithms defined hrb hrsr section detail variable considered killed node overwritten executed considered defined partially overwritten array element array overwritten overwritten represents assignment point case considered defined killed pointer analyses experiments made pointer analyses analyses listed precise case worst-case running time terms size program term slowly growing inverse ackermann function arises context fast union find data structures tar pointer analyses analysis defined andersen worst-case time -category log-n-runs analysis defined shapiro horwitz worst-case time logn theanalysis defined steensgaard ste whichhas worst-casetime naive analysis simply assumes pointer variable point variable address program location allocated heap analysis worst-case time analyses applicable language including pointer arithmetic calls pointers functions setjmp longjmp functions variable-length argument lists signals flow insensitive context insensitive flow-sensitive pointer analysis takes account flow control program computes points-to set pointer program point contrast flow-insensitive analysis treats program unordered set statements computes points-to set pointer valid overly conservative program points context-sensitive analysis takes account fact function called calling contexts function returns control transferred back site recent call contrast context-insensitive analysis essentially treats function call goto start function function return multi-way goto back call sites analyses simple memory model collapses single variable fields single struct elements single array instances local variable recursive function heap locations allocated instance call malloc similar function executed multiple times analyses andersen shapiro steensgaard thought building graph nodes represent variables edge means point fundamental difference andersen algorithm precise steensgaard algorithm precise graphs built andersen algorithm unbounded outdegree graphs built steensgaard algorithm out-degree means node steensgaard graph represent variable andersen graph node represents variable coarser granularity steensgaard graphs makes algorithm faster precise andersen detailed comparison algorithms scope paper shown figure intuition note steensgaard approach determines point point safe actual points-to information omitted overly conservative shapiro algorithm accurate analysis study similar steensgaard algorithm graphs builds limited out-degree respects 
consistent steensgaard implementation small amount context sensitivity introduced analyses essentially in-lining library functions calls user-defined functions handled context-insensitive manner andersen graph steensgaard graph steensgaard points sets andersen points sets program fig contrasting andersen steensgaard points-to analysis algorithms graphs limited out-degree out-degree improves accuracy analysis cost slowing constant factor algorithm log passes number variables program building graph pass guaranteed pair variables pass represented distinct nodes graph final points-to information computed combining information passes accuracy worst-case time requirements algorithm fall andersen steensgaard algorithms figure algorithm require passes produce results andersen algorithm section actual times shapiro analysis slower times steensgaard andersen analyses due implementation inherant limitation algorithm shapiro analysis necessarily slower steensgaard involves multiple passes essentially steensgaard algorithm sped run time closer steensgaard algorithm current implementation large programs significantly faster andersen algorithm close linear andersen algorithm cubic size program current inefficient implementation shapiro algorithm run faster andersen large test programs mentioned fourth analysis naive analysis simply assumes pointer point variable address program pointing heap-allocated storage figure algorithm determine variables point dataflow analyses test transitive effects pointer analyses implemented dataflow analyses listed ambitious gmod analysis live variable analysis live variable analysis analyses subsections recall analyses rely pointer analysis performed statement program variables killed defined statement gmod analysis goal analysis determine function program global variables modified directly transitively function presence pointers local variable global address made accessible functions gmod analysis performed program call graph controlflow graph isn important dataflow framework simply requires underlying graph doesn matter graph represents calls flow control gmod implemented function set imodf set global variables directly modified effects thefunctionscalled arenot included graph dataflow analysis performed program call graph edges reversed start node edges added node reachable start node dataflow function edges graph node represents function imodf implemented gmod problem intraprocedural locally separable gen kill problem size dataflow domain number global variables directly modified function worst-case time solve gmod problem dataflow engine size call graph number global variables accuracy gmod analysis affected accuracy points-to information determine variables modified node control-flow graph accuracy points-to information determine function called indirect call call pointer control-flow graph node represents statement def set set variables point function imod set include variables accurate pointer analysis computes smaller points-to sets lead accurate gmod sets similarly function includes call pointer gmod set include variables modified directly transitively called functions accurate points-to analysis computes smaller points-to set lead accurate gmod sets live variable analysis standard dataflow analysis problem variable considered live node program control-flow graph iff path graph end program defined recall goals determine transitive effects pointer analysis affected accuracy pointer analysis case live variable analysis live analysis section interesting quantities considered transitive effects sizes live sets computed node control-flow graph number dead assignments assignments variables live immediately assignment live ranges variables compiler performing register allocation general smaller live sets smaller live ranges accurate pointer analysis leads smaller live sets lead register allocation implemented register allocation study directly studied sizes live sets produced live analysis pointer analyses discussed introduction dead assignment removed compiler flagged logical error number dead assignments discovered performing live analysis interesting transitive effect gmod analysis live variable analysis locally separable problem size dataflow domain function number variables visible function possibly including local variables functions addresses written heap made accessible parameters worst-case time live variable analysis dataflow engine sum sizes control-flow graphs max number visible variables accuracy live variable analysis affected accuracy points-to information determine variables node control-flow graph accuracy points-to information determine function called indirect call node represents statement variables points-to set considered live node accurate pointer analysis lead accurate smaller live sets similarly node represents call pointer variables live beginnings functions pointed considered live node live variables non-locally-separable accurate version live-variables problem variable considered live node iff path end program live context defined definition live context means predicate call library function expression assigned live variable gmw non-locally-separable truly-live-variables problem sense harder problem live-variables problem worst-case time analysis sum sizes control-flow graphs max number visible variables accuracy live variable analysis affected accuracy pointsto information determine variables defined node control-flow graph accuracy points-to information determine function called indirect call node represents statement variable points-to set considered live node variables points-to set live node clear accurate pointer analysis lead accurate smaller live sets interprocedural slicing slice program respect output statement call library function printf projection program inputs output original program slice statement executed versions program produce sequence values wei efficient method computing context-sensitive interprocedural slices hrb hrsr method implementation method involves program representation called system dependence graph sdg nodes program sdg nodes controlflow graph edges sdg includes edges represent program data control dependences sequential control-flow building program sdg involves steps build program control-flow graph compute gmod sets function add variable gmodf extra parameter control-flow graph compute program intraprocedural data control dependences compute transitive data dependences due function calls total time required build sdg dominated time step number control-flow graph edges max number parameters number call sites max number parameters program sdg built interprocedural slice computed time proportional size slice size program sdg accuracy slices computed sdg affected accuracy points-to information determine variables defined node control-flow graph accuracy points-to information determine function called indirect call node represents statement sdg target data dependence edges nodes represent definitions variables points-to set accurate pointer analysis lead sdg fewer edges turn affect sizes slices computed sdg experimental results determine choice pointer analysis affects analyses considered effect pointer analysis quantities test program gmods sum sizes gmod sets function gmodt time perform gmod analysis lives sum sizes live variable sets node cfg deads number dead assignments livet time perform live analysis tlives sum sizes truly-live variable sets node cfg tdeads number truly-dead assignments tlivet time perform truly-live analysis sdgs number vertices edges sdg sdgt time build sdg slices average size slice respect output statement slicet time compute slices represent transitive effects pointer analysis measure direct effects quantities ptas average size pointer variable points-to set ptat time perform points-to analysis measured quantities pointer analyses programs raw data test programs figures values lines code preprocessed code blank lines removed subsections address questions posed introduction transitive effects choice pointer analysis 
choice pointer analysis affect quantities listed quantity depend sizes points-to sets choice pointer analysis affect total time performing analyses section subscript range pointer analyses thesubscript rangeovertheexample programs thenumber pointeranalyses number programs represent quantity interest qij represent pointer analysis program effect choice pointer analysis transitive quantities determine choice pointer analysis affects quantity assume qaj qbj pointer analyses depend program make equality introduce error factor eabj qaj qbj eabj find makes eabj close minimizesummationtext logeabj leads defining geometric ratios qaj qbj ratio transitive quantity produced pointer analysis quantity produced pointer analysis program qaj qbj parenrightbigg values figure graphed figures change pointer analysis affect quantity qij values strong dependence pointer analysis gmods psteens anders means gmod sets average large imprecise computed steensgaard pointer analysis andersen pointer analysis gmodt psteens anders longer compute accurate gmod sets tdeads psteens anders number truly-dead assignments slightly smaller steensgaard analysis andersen test program lines code pointer analysis gmods lives deads tlives tdeads sdgs slices ptas compress naive steens shapir anders gcc main naive steens shapir anders ratfor naive steens shapir anders cdecl naive steens shapir anders lex naive steens shapir anders unzip naive steens shapir anders gcc cpp naive steens shapir anders gzip naive steens shapir anders naive steens shapir anders ispell freq naive steens shapir anders grep naive steens shapir anders sed naive steens shapir anders naive steens shapir anders make naive steens shapir anders fig sample raw size data entries dash missing data due dataflow analysis slice computation running memory test program lines code pointer analysis gmodt livet tlivet sdgt slicet ptat compress naive steens shapir anders gcc main naive steens shapir anders ratfor naive steens shapir anders cdecl naive steens shapir anders lex naive steens shapir anders unzip naive steens shapir anders gcc cpp naive steens shapir anders gzip naive steens shapir anders naive steens shapir anders ispell freq naive steens shapir anders grep naive steens shapir anders sed naive steens shapir anders naive steens shapir anders make naive steens shapir anders fig sample raw time data cpu seconds entries dash missing data due dataflow analysis slice computation running memory naive steens naive shapir naive anders steens shapir steens anders shapir anders error error error error error error gmods gmodt lives deads livet tlives tdeads tlivet sdgs slices sdgt slicet ptas ptat fig imprecision slowdown precise pointer analysis pair colums labelled precise pointer analysis farther larger effect quantity choosing pointer analysis values marked interval includes values negligible difference pointer analyses estimated standard error logpa logpa radicalbiggsummationtext logeabj define logpa plays role standard error additive multiplicative expect determined set test programs fall interval asymmetric geometric endpoints interval arithmetic figure includes error values values expressed percentages reported values significantly indicating choice pointer analysis significant effect transitive quantities quantity slicet significantly deads tdeads slices significantly naive analysis difference non-trivial pointer analyses slight gmods gmodt tlivet choice pointer analysis strong effect results contrast thosereported ruf ruf ruf studied theimpact context sensitivity flow-sensitive pointer analysis considered sizes points-to sets program points found context-sensitive algorithm make difference sets significantly smaller considered program points pointer dereferenced looked pointers points-to sets found context sensitivity made difference suggests flow-sensitive pointer analysis choice context-sensitive context-insensitive analysis weak effect transitive quantities gmods lives deads tlives tdeads sdgs slices ptas effect pointer analysis size results naive steensgaard shapiro andersen fig alternative presentation data figure size quantities height bar pandersen factor quantity obtained pointer analysis change andersen pointer analysis recall deads tdeads precise values larger quantities precise values smaller dependence size points-to set results previous section cases quantities dependent pointer analyses section explore sizes points-to sets ptas refer sij good predictors quantities predictions determine relationship points-to set sizes quantities model qij parenleftbiggs saj parenrightbigg qaj make equality introducing error eij qij parenleftbiggs saj parenrightbigg qajeij refers specifically andersen pointer analysis measure qij depends sizes points-to sets positive values qij increases increasing points-to set size quantity qij fixed program proportional sij size points-to set gmodt livet tlivet sdgt slicet effect pointer analysis time naive steensgaard shapiro andersen fig alternative presentation data figure time quantities height bar pandersen factor subsequent analysis pointer analysis speed andersen pointer analysis inversely proportional independent note independent pointer analysis test program depends quantity consideration measure sensitivity points-to set size logarithms equality line origin log qijq log sijs logeij standard statistical methods regression origin minimize summationtextj logeij find summationtext log qij qaj log sij sajsummationtext log sij saj values figure list values quantity expected increase result doubling sizes points-to sets considered abstract points-to sets large gmods pointer analysis tended generate points-to sets large generated gmodt livet tlivet sdgt slicet deads tdeads gmods lives tlives sdgs slices fig dependence quantities sizes points-to sets accuracy points-to set sizes predictors quantities factor quantity expected increase size points-to sets doubled standard error columns similar columns figure andersen analysis expect gmod sets computed larger determine points-to set sizes good predictors quantities estimated standard error radicaltpradicalvertex radicalvertexradicalbt summationtextij logeij summationtextij log sijsaj values similar pointer analysis generate points-to sets large pointer analysis expect values vary factor measured test programs smaller values accurate points-to set sizes predictors results subsequent analysis figure values small ranging means points-to set sizes good predictors quantities listed column actual predictions rangefrom forgmods deads means points-to set size doubles gmods increases deads consistent results previous section found program analyses sensitive choice pointer analysis effect choice pointer analysis total times section address question time required perform dataflow analysis build slice system dependence graph affected choice pointer-analysis algorithm pij denote time pointer analysis test program qij denote time subsequent analysis tij denote total time pointer analysis subsequent analysis tij pij qij figure shows effect choice pointer-analysis algorithm total time time divided pointer-analysis time subsequent-analysis time height bar geometric ratios tij taj ratio total time required pointer analysis total time required andersen pointer analysis test programs total time pointer analysis height geometric ratios pij taj gmod live tlive sdg slice sdg slice effect pointer analysis total time naive steensgaard shapiro andersen fig total times time pointer analysis time subsequent analysis marks time pointer analysis interesting note program analyses gmod slicing average total 
time expensive pointer-analysis algorithm andersen analysis increase accuracy points-to sets computed andersen analysis leads decrease sizes kill def sets computed node programs control-flow graphs decrease sizes sets functions considered potentially called indirect call site turn smaller sizes lead smaller dataflow domains faster dataflow analyses gmod analysis steensgaard pointer analysis leads fastest average total times times gmod analysis faster andersen analysis steensgaard figure column gmodt gmod analysis efficient decrease gmod time andersen analysis make increase pointer-analysis time don forget results gmod analysis significantly shapiro andersen analyses steensgaard data slicing figure bars slice misleading represent pointer-analysis time slicing time omit times required build system dependence graphs accurate picture provided final set bars sdg slice represent pointer-analysis time time build system dependence graphs time compute slices case andersen algorithm leads fastest average times graphs shown figures andersen algorithm algorithm choice lead accurate final results leads fastest total times cases important remember andersen algorithm worst case cubic size program steensgaard shapiro algorithms close linear result andersen algorithm leading fastest total times hold program size increases true advantage increased accuracy eventually outweighed disadvantage increased running times cases efficient version shapiro algorithm algorithm choice providing good compromise fast running time reasonable accuracy experiments large programs limited memory requirements dataflow-analysisand slicing implementations someindication howthings change large programsby programs andersen analysis ran slowly compared steensgaard analysis screen find espresso tar make gcc cpp sed grep triangle figure shows results figure limited ten test programs listed figure total times shapiro analysis closer total times andersen analysis implementation shapiro analysis larger test programs total times shapiro analysis bit faster andersen analysis conclusions find significant transitive effects pointer analysis precise pointer analysis leads analyses precise faster analyses sensitive choice pointer analysis pointer analysis average points-to set size large precise pointer analysis led increase size gmod sets time perform figure column slices slices computed naive analysis slightly larger computed analyses time compute slice proportional size times slicing slightly slower naive analysis accurate analyses figure column slicet naive analysis fastest total times pointer analysis slicing fastest naive analysis program analyses ran memory test programs results shown figure represent data ten programs gmod analysis programs live analysis programs truly-live analysis programs slicing gmod live tlive sdg slice sdg slice effect pointer analysis total time naive steensgaard shapiro andersen fig total times programs andersen analysis ran slowly marks time pointer analysis truly-live analysis effects modest number dead assignments found size slice changed small programs andersen algorithm produced accurate results led fastest run-times large programs andersen algorithm slow analysis time smaller shapiro algorithm steensgaard algorithm questions addressed experiments including relative benefits flow-sensitive flow-insensitive pointer analyses additional precision flow-sensitive analysis lead reduction subsequent analysis time offset cost results obtained gmod analysis live variable analysis trulylive variable analysis interprocedural slicing hold program analyses results result precise points-to sets lead faster dataflow analysis hold dataflow-analysis algorithms properties program analysis predict benefits precise pointer analysis terms accuracy analysis results total time requirements acknowledgements bob wardrop jonathan goldstein helpful discussions statistics abs austin breach sohi efficient detection pointer array access errors sigplan conference programming languages design implementation pages june andersen program analysis specialization programming language phd thesis diku copenhagen diku report egh emami ghiya hendren context-sensitive interprocedural points-to analysis presence function pointers sigplan conference programming languages design implementation gmw giegerich moncke wilhelm invariance approximative semantics respect program transformation annual conference informatik-fachberichte pages york springer-verlag hrb horwitz reps binkley interprocedural slicing dependence graphs acm transactions programming languages systems january hrsr horwitz reps sagiv rosay speeding slicing proceedings acm sigsoft symposium foundations software engineering pages december url http wisc wpis papers fse kil kildall unified approach global program optimization acm symposium principles programming languages pages january landi ryder safe approximate algorithm interprocedural pointer aliasing sigplan conference programming languages design implementation pages june lrz landi ryder zhang interprocedural modification side effect analysis pointer aliasing sigplan conference programming languages design implementation pages june john neter william wasserman applied linear statistical models chapter pages richard irwin rhs reps horwitz sagiv precise interprocedural dataflow analysisvia graph reachability acm symposium principles programming languages pages january url http wisc wpis papers popl ruf ruf context-sensitive alias analysis reconsidered sigplan conference programming languages design implementation pages june shapiro horwitz fast accurate flow-insensitive points-to analysis acm symposium principles programming languages acm york january ste steensgaard points-to analysis linear time acm symposium principles programming languages pages january tar tarjan data structures network flow algorithms volume cmbs regional conference series applied mathematics siam wei weiser program slicing ieee transactions software engineering sejuly wilson lam efficient context-sensitive pointer analysis programs sigplan conference programming language design implementation pages june article processed latex macro package llncs style 
