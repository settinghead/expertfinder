graph isomorphism colored graphs color multiplicity bounded akash lal dieter van melkebeek computer science department wisconsin madison wisconsin akash dieter wisc colored graph isomorphism problem restricted version general graph isomorphism problem involves deciding existence color preserving isomorphism pair colored graphs report study problem graphs color multiplicity bounded -gi begin formally defining colored graph isomorphism problem setup notation study general graph isomorphism problem specialize results colored graphs special properties colored graphs multiplicity bounded prove -gi complexity class finally result show problem deciding existence non-trivial color preserving automorphism graph color multiplicity bounded -ga previous work proof -gi symmetric logspace proof incorrect section presents counter definition colored graph three-tuple specifies undirected graph partition vertices color sets inegationslash convenience define color definition colored colored graph isomorphism problem decide existence color preserving isomorphism pair colored graphs mapping satisfying conditions bijection color color iso denote set isomorphisms graphs isoc denote set color preserving isomorphisms colored graphs decomposing isomorphisms graph set denote graph induced vertices denote edges subset edges graph edges bijections disjoint domains disjoint co-domains bijection defined braceleftbigg lemma shows isomorphisms smaller graphs find isomorphisms larger graphs idea edge-preserving condition graph isomorphism satisfied locally isomorphisms smaller edge-disjoint subgraphs lemma pair graphs partitions exist bijections iso gvi iso proof eva iso gva conditions required lemma simplified lemma idea find smaller edge-disjoint subgraphs lemma pair graphs disjoint subsets bijections iso iso iso iso proof proof similar lemma lemmas important property color preserving isomorphisms theorem pair colored graphs isoc written iso gvi iso gvi evi evj proof isoc color color implies color define simply restricted domain isomorphism iso gvi lemma forward direction theorem reverse direction lemma iso gvi lemma iso shown preserve colors color preserving condition corollary pair colored graphs isomorphic bijections satisfying conditions mentioned theorem corollary colored graph non-trivial color preserving automorphism bijections satisfying conditions mentioned theorem additional constraint bijection identity mapping -gi section show -gi complexity class reducing problem instances logspace undirected graph reachability queries pair colored undirected graphs color multiplicity bounded called -colored graphs construct logspace single undirected graph pose isomorphism question reachability question graph describe construction examine theorem greater detail -colored graphs condition theorem considers isomorphisms graphs gvi bounded size vertices -colored graphs enumerate iso gvi constant time bijections define bijections condition posed multiple constraints form inegationslash iso gvi note constraints color reason chosen pose complementary constraints clear construct graph condition broken constraints form exhaustive case analysis inegationslash jnegationslash pii pij pii pij simplify discussion denote constraint negationslash denote constraint constraints variables form isomorphism graphs pis denote fixed bijections theorem color preserving isomorphism composed bijections satisfy generated constraints vice versa exhaustive case analysis provided appendix find constraints present case continuity section figure shows constraints generated graphs shown figure figure colored graphs colors vertices color negationslash abc acb bac cab negationslash dfe edf fde bca efd cba fed figure constraints generated colored graph pair shown figure abc shorthand amapsto bmapsto cmapsto similarly benefit obtained -colored graphs restriction constraints produced property type constraints lemma -colored graphs defined theorem constraint gvi constraint constraint gvj gvj constraint constraint gvi proof clear case analysis provided appendix lemma basically constraint produced colors pair bijections constraints colors bijections constraint property show construct graphf important inference make generated constraints lemma -colored graphs defined theorem pii iso gvi pii constraints pii pij iso gvi pii pij constraints constraint pii pij constraints lemma shows constraints capture information required determine isomorphisms pair colors constraints generate graph graph -colored graphs construct graph vertices two-tuples form color bijection additional vertex denoted edges graph edge constraint edge constraint edges directly encode constraints graph reachability resolution procedure constraints find required color preserving isomorphisms denote connected component vertex graph drop subscript graph clear context theorem -colored graphs isomorphic colors vertex pii negationslash reachable negationslash negationslash vertices color reachable ofthe conditions abovetheoremcan translatedinto graph reachabilityqueries onf running reachability queries vertex inf keeping track fact find vertex explored color satisfied conditions theorem find isomorphic problem turn converted single reachability question shows -gi left proof theorem state lemmas lemma pil path graph include vertex implied constraint pim proof straight induction constraints imply constraint lemma connected components don colors completely formally ifc pii pii vertices reachable orc proof suppose true vertices reachable wlog negationslash negationslash choose edge vertex color vertex color edge exist connectivity edge vertex apply lemma constraint constraint constraint colored vertex true contradiction proves lemma setup prove theorem proof theorem suppose isomorphic isoc theorem pik pii iso gvi pii pij iso gvi evi evj pii pii path pii vertex connected means constraints pii lemma constraints imply inegationslash pii isomorphism agrees pii color contradiction negationslash pii pii negationslash paths pii pii lemma constraints pii pii imply isomorphism agrees pii color agree color isomorphism exist agrees pii color contradiction vertex pii satisfies required properties theorem colors reverse direction vertex color connected component satisfies mentioned properties algorithm choose vertices color connected components color disjoint span colors algorithm choosing vertices ccnegationslash choose vertex jnegationslash satisfies properties theorem return lemma ensures connected components added disjoint respect vertex color doesn vertex color pii show pik color preserving isomorphism show pii pij iso gvi lemma theorem complete proof pii pij lie connected components edge vertices colors edge imply constraint colors turn implies constraint pii lemma connected components color disjoint vertex color exist connected component pii edge colors absence edge absence edges pii pij implies pii pij iso gvi lemma suppose pii pij lie connected component connected component vertex color pii connected pij edge colors argument similar presented pii pij lying connected components lemma pii pij iso gvi completes proof theorem -ga reduce -ga -gi queries prove -ga reduction many-one reduction directly show technique -colored graph construct graph pose question determining existence non-trivial automorphism colors vertex pii negationslash negationslash negationslash vertices identity bijection previous work previous paper koebler toran proof presented -gi flaw proof proceeds building graph vertex set converts -gi graph reachability queries graph construction based rules rule pair colors bijection include edge edges edges imply isomorphism iso map nodes negationslash iso gvi rule pair colors pair nodes pair nodes bijections set edges sets nodes edges edges sets nodes edges 
iso gvi include edge constructing graph isomorphism decided set nodes color set node reached result based lemma place proof fails lemma pair colors bijection path intermediate node isomorphism iso maps nodes color forced map node color proof base case lemma incorrect assumes edge bijections satisfying conditions rule graph construction incorrect pair bijections negationslash counter figure colored graphs colors vertices color figure shows graph set vertices color vertex reachable graphs isomorphic contradicts main result paper graph satisfy lemma paper fde efd edf dfe fedcab bca bac acb cba abc figure graph constructed rules interpret rule pair colors bijection end constructing graph rule fire colors bijection abc colors bijection birgit jenner johannes obler pierre mckenzie jacobo tor completeness results graph isomorphism comput syst sci volume pages appendix appendix present exhaustive case-analysis find constraints pair colored graphs color colored graphs bijections lemma iso gvi iso gvi iso gvj iso gvi evi evj assume cases smaller size sets analyzed easily abc shorthand amapsto mapsto mapsto shorthand dmapsto emapsto fmapsto figure shows constraints generated iso gvi figure shows constraints generated iso gvi evi evj notational convenience bto denote set constraintin mapatobi negationslash abc negationslash acb negationslash cab negationslash cba denote constraint reduce number cases make fact pair graphs iso iso complements respective graphs shows order isomorphisms iso gvi evi evj graphs edges cases higher number edges converted cases edges taking complements figures show cases isomorphism case constraints case constraints figure constraints generated deciding iso gvi wherevi andv case constraints case constraints abc bac edf abc acb dfe bac edf bca efd cab fde cba fed abc abc abc acb edf figure constraints generated deciding iso gvi evi evj 
complexity theory lecture introduction instructor dieter van melkebeek scribe jeff kinne today begin review basic complexity theory material typically covered undergraduate theory computing lecture introduce define model computation formalize intuitive notion computer explore issues arise computational model overview graduate-level introduction computational complexity theory study power limitations efficient computation part focus standard setting realize mapping inputs outputs timeand space-efficient develop models computation represent capabilities digital computing devices including parallelism randomness quantum effects non-uniformity introduce models based notions nondeterminism alternation counting precisely capture power needed efficiently compute important types mappings meat part consists intricate relationships models separation results inthe secondpartwe studyother computational processesthat arise indiverse areas computer science relevant efficiency measures specific topics include proof complexity interactive proofs probabilistically checkable proofs motivated verification pseudorandomness zero-knowledge motivated cryptography security computational learning theory motivated artificial intelligence communication complexity motivated distributed computing query complexity motivated databases topics grown substantial research areas cover main concepts key results standard setting machine model deterministic turing machine model computation capture intuitive notion computer turing machine depicted figure finite control finite number states time read write memory tapes based current state contents tapes finite control state alters contents tapes input tape work tape finite control work tape work tape woutput tape figure illustration deterministic turing machine finite control read-only access input tape write-only access one-way output tape read-write access constant work tapes definition sequential access turing machine sequential access deterministic turing machine defined tuple qhalt finite set states finite control finite input output alphabet finite work-tape alphabet qstart start state qhalt halt state finite control transition function transition function form qhalt input represents current state current symbol scanned input tape current symbol scanned work tape output represents state finite control symbol write output tape possibly empty symbols write work tape direction move head input work tapes typically binary alphabet tapes turing machine consisting steps machine initialized place input input tape tape head symbol input work tapes empty tape heads left-most cell tape output tape empty finite control set qstart machine allowed run step time repeatedly applying transition function machine halts entering qhalt computation finished read output output tape denote output input computation halts sight definition turing machine restrictive correspond intuitive notion computing turing machine shown powerful roughly efficient traditional computers discuss lecture model turing machine modification definition definition bit restrictive indirect memory addressing real computers rely definition random access turing machine random access turing machine turing machine functions definition output sequential access work tapes input tape fixed number work tapes random access tapes sequential access tapes random access tape sequential access index work tape tape head random access tape moved special jump operation moves tape head location index tape tape head position random access tape altered transition function contents memory cell read written transition function notice tape sequential tape random access tape sequential access tapes performing operations performed registers modern computers arithmetic random access tapes storage choose random access turing machine basic model computation closely models modern computers sequential access turing machines computing relation main setting part turing machine ability compute relations definition relation turing machine computes holds inputs input halts outputs exists exists indicating accomplished encoding scheme output halt states relation shortest path problem relation compute shortest path vertices graph input description graph source destination vertices output description path graph notice function special case relation xthere factoring input integer output unique prime factorization listing prime factors smallest largest interested kind relation called decision problem definition decision problem decision problem relation output case output input property input property refer set inputs output language problem determining string palindrome define language palindromes set strings read front back back front relation assigns palindrome non-palindrome case complexity computing relation captured complexity computing related decision problem turn factoring problem decision problem compute ith bit output input compute ith bit description prime factorization time space complexity turing machine originally defined theory computability recursion theory setting goal determine relations computable famous early result halting problem computable turing machine surprising uncomputable relations closer inspection makes fact obvious countably turing machines uncountably relations contrast setting computability complexity theory concerned efficiency relation computable end amount resources turing machine computation standard resources time space definition turing machine input number steps halts input max sum work tapes maximum cell touched halts max corresponds time input corresponds amount memory alternative definition count number work-tape cells touched definition counts cells left work-tape cell touched counts unused cells left cell definition natural perspective run algorithm computer memory algorithm space alternative definition run machine ram modification definition notice configuration machine positions tapes contents work tapes internal state log space true alternative definition purposes choice definition effect power efficiency model interested worst-case complexity turing machine defined worst-case measures correspond worst performance input length notice definition count input tape output tape memory cells choice definition reason distinguished types tapes place turing machines compute non-trivial relations sub-linear space definition including input tape usage preclude non-trivial sub-linear space algorithms entire input read algorithms logarithmic space amount required index input time usage linear smallest read entire input goal complexity theory main goal complexity theory characterize amount time space required compute relation words find machine minimal machines solve relation number issues arise question hard wiring solution finite subset inputs hard-wired transition function turing machine lookup table finite subset inputs solved fast low space usage issue focus asymptotic run-time space usage constant factor speedups turing machine amount space binary alphabet changing alphabet machine store information original tape cells tape cells finite control machine modified work properly setting reducing space usage machine roughly factor space usage decreased constant factor increasing size tape alphabet suitably large constant notice alternative definition space usage counts memory cells touched computation argument work random access machines algorithms high amount memory locality similar argument made time usage argument bit complicated finite control read current cell immediately adjacent cells properly mimic original turing machine random access operations destroy time speedup argument potential problem makes fact indexing operations sped algorithm making random access operations spend large amount time indexing operations constant factor speedups ignore constant factors running time space usage incomparable behavior 
modulo issues fundamental problem remains attempting determine optimal time space usage compute relation case machines input lengths smaller input lengths smaller case machine created simulate machines achieve optimal run-time inputs hard-wiring issue discussed finite set inputs turing machine decides instances correctly fast small space usage machines optimal set inputs general create machine combining optimal performance infinitely machines general single single turing machine minimal run-time space-usage input lengths dual problem originally stated find minimal relation determine relations computed time space bound definition define dtime decision problems solvable time random access turing machine dspace decision problems solvable space random access turing machine main goal complexity theory restated time space boundt relations computed turing machine amount time space goal number issues remain model dependence results independent choices made defining turing machine recall church-turing thesis relation computable physically realizable computing device computed turing machine belief underscores turing machine computability theory computing device studied note church-turing thesis violated models computation setting complexity theory strong church-turing thesis relation computable physically realizable computing device computed model turing machine polynomial overhead time constant overhead space machine time compute relation turing machine poly time machine space turing machine logn space notice strong church-turing thesis bolder statement church-turing thesis widely believed violated quantum machines debatable physically realizable violated randomized machines believed case language palindromes single tape sequential turing machine shown trivial algorithm scanning back input string running time similar result shows multitape sequential access turing machine product space time usage solve palindromes palindromes decided simultaneous quasi-linear time logarithmic space random access machines notice result implies single-tape turing machine incur roughly quadratic overhead time attempts simulate model random access multi-tape turing machine physically realizable models computation differ polynomial factor time solve relation constant factor space needed strong church-turing thesis stated strengthened notice quadratic lower bound palindromes sequential access turing machines model dependent true models chosen model random access turing machine avoid model dependent results results present model independent input representation input representation clear palindromes language relations choice made shortest path problem input problem includes graph represented input tape standard methods representing graph include adjacency matrix adjacency list note linear factor difference size effects running time space usage functions size input input made artificially large padding unnecessary running time space usage artificially decreased functions size input reason assume reasonable encoding input leave notion qualitative quantified long choose reasonable encoding input running time space usage depend input encoding issues define complexity classes robust respect model input representation complexity class remains model reasonable input encoding definition definitions standard complexity classes dtime exp dtime dtime dspace logn pspace dspace notice robust respect model strong church-turing thesis classes robust respect input representation restricting space usage logarithmic case complexity class great graph problems logarithmic space remember constant number vertices graph turns interesting problems solved recent result showed problem determining connectivity undirected graph achieved logarithmic space deterministic machines universality turing machine called universal turing machine simulate turing machines turing machines inputs key property leads number results exist universal turing machines incur small overhead time space theorem universal turing machines udtime udspace turing machines inputs tudtime log sudspace log denotes length description fact show single machine udtime udspace proof sketch main difficulty designing udtime udspace fixed number work tapes simulating machines number work tapes udspace suppose work tapes contents single tape udspace call tape storage tape storing cell tapes cells udspace storage tape storing cell tapes cells recall single step reads contents work tape locations tape head udspace tape heads udspace stores information additional work tape call tape lookup tape udspace index tape order perform tape head jumps leave exercise verify udspace simulate tapes storage lookup index simulation efficient claimed time required run simulation step execution udspace read contents sequential access work tapes remember contents current cell random access work tapes sequential access tapes access locations mosttm address sequential access tape head takes logtm space leave exercise verify transition function step ofm takes logtm steps udspace simulate fact udspace performs tape head jump operations constant time conclude udtime udspace efficient respect time claimed notice analysis takes account udtime random access input tape sequential access input tape simulating sequential access input tape udtime incurs log factor overhead time simulate sequential access input tape key component analysis time efficiency proof work tape sequential access random access single work tape allowed sequential random access analysis fail counterexample case machine jumps location performs local operations address runs time simulation time situation universal machine udtime similar overhead time constructed ensuring simulation udtime accesses tape cells small addresses logtm achieved keeping track random access tape operations tape cell address tape cell contents pairs storing efficient data structure balanced binary tree trick keeping track random access tape operations data structure convert machine time machine computes relation space defined space complexity notice transformation trivial machine space exponential writing large address accessing location random access tape existence universal machine key component number important results hierarchy theorems completeness results hierarchy theorem states turing machine slightly resources time space compute relations computed slightly resources problem complete complexity class class difficult problems class universal machines prove time space hierarchy theorems existence complete problems formalize notions give proofs lecture show relationships complexity classes pspace exp open containments proper complexity theory lecture determinism nondeterminism instructor dieter van melkebeek scribe matt elder lecture discuss applications efficient deterministic universal turing machines deterministic time spaces hierarchy theorems completeness results introduce nondeterministic turing machine model nondeterministic computation hierarchy results hierarchy result theorem imposes strict-subset relation complexity classes classes problemscandc hierarchy result yield thatc subsetnoteqlc classc computationally powerful classc show function sufficiently smaller function dtime subsetnoteql dtime prove technique diagonalization originated cantor proof uncountable theorem cantor interval uncountably infinite proof prove theorem contradiction enumeration numbers show numbers constructing number assume countable interval countable individual elements enumerated suppose enumerate numbers infinite binary representation ith number enumeration jth bit figure constructed complement diagonal elements prove theorem diagonal elements bold elements figure build diagonal elements set bit complement ith bit differs theith bit ofri thatr negationslash alli represents numberxthat enumerated isn true rational number infinite binary representations terminating terminating ways avoid 
issue representations base set digit equals set equals ensure end infinite sequence zeroes construction complicated provided care issue construction contradicts fact enumeration element initial assumption false countable proof deterministic time space hierarchies emulate cantor diagonalization proof theorem requires condition time bounds time-constructibility describe appears proof theorem iftandt functions nto tis time-constructible andt logt dtime subsetnoteql dtime proof universal turing machine construct contrary machine build turing machine running time output differs output input contrary machine accept language machine accept time ensure runs time function mapping inputs descriptions turing machines properties computable linear time machine appears infinitely image leave reader verify constructed computable enumeration deterministic turing machines denote ith input code read input compute pass universal turing machine run simulation long total time universal turing machine halts rejects accept reject simulation track time usage wishes time total place time-constructibility define notion proof property require time write zeroes work tape zeroes clock erasing step execution halting erased time-constructible discussion shows track time usage ensure entire execution logt efficiency universal turing machine proved previous lecture time perform simulation machine running time finitely inputs turing machine appears infinitely image input time complete simulation complement behavior long runs time dtime dtime dtime subsetnoteql dtime condition required time bound theorem stated formally definition shown functions dealing polynomials exponentials logarithms linear time-constructible logarithmic space-constructible definition function time-constructible function maps string string computed time similarly function spaceconstructible function maps computed space identical proof derive hierarchy theorem amount space deterministic machines giving theorem due fact overhead space universal turing machine smaller overhead time space hierarchy tighter time hierarchy theorem space-constructable dspace subsetnoteql dspace notice separation space bounds tight hope discussed constant-multiple differences functions change computational power corollary theorems subsetnoteqle subsetnoteqlexp lsubsetnoteqlpspace reductions completeness problem reducibility central study complexity reductions determine relative complexity problems knowing absolute complexity problems problems denotes reduces efficiently solved efficiently solved implies complexity greater complexity modulo complexity reduction notation context types reductions mapping oracle reductions mapping reductions restrictive definition mapping reduction called many-one reduction karp reduction function maps instances problem instances preserving outcome specifically decision problems exists function problem instances language iff language capture intended meaning reduction function efficient efficiency requirement varies context describe common settings moment definition oracle reduction called turing reduction cook reduction algorithm solve problem solver problem instantaneous subroutine b-oracle hypothetical machine solve instance problem return answer step oracle turing machine otm turing machine special oracle tape specific query state machine reaches query state invokes oracle current content oracle tape state oracle input erased oracle output oracle tape oracle tape head leftmost position otm machine oracle oracle-reduces denoted exists efficient otm solves mapping reduction give oracle-reduction otm input compute write oracle tape query oracle return output mapping reduction reduced oracle reduction oracle reductions powerful mapping reductions denote time space constraints efficiency reduction superscripts symbol polynomial-time reducibility denoted log-space reducibility denoted log log-space oracle reductions slightly complicated specification differ author context purposes impose restriction read write oracle tape left oracle tape procedural memory count size oracle tape space efficiency proposition log true reducibility transitive log definition reduction relation complexity class hard problem complete hard choice reduction depends context equal case log-space reductions reason problem complete log connection complete problems complexity class collapses variety complete problems make start construct complete languages efficient universal turing machines proposition language tuples angbracketleftbigm tangbracketrightbig halts accepts input steps complete logm proof language udtime runs polynomial time overhead suppose language demonstrate function demonstrating logm turing machine computes polynomial time define mapping takes angbracketleftbign cangbracketrightbig iff hard-code output log space hard-coded log-space mapping reduction nondeterminism note nondeterministic model computation intuitive good reason nondeterminism physically realizable model computation utility model lies modeling actual computation capturing complexity important class problems model standard model nondeterministic computation nondeterministic turing machine ntm ntm definition similar normal deterministic turing machine transition function relation ntm combination internal state read-head state provide multiple next-state instructions language ntm set strings exists valid computation input halts accepts accepts computation path accepts fruitful interpretations ntms view ntm machine allowed make guesses guesses controlled force machine accept input permissible series guesses lead machine accepting state machine make guesses accept series guesses machine accept forced reject ntm massively parallel computer time makes choice spawns copy branch choice copies continue processing child machine accepts input machine accepts input time space ntm efficiency stated terms worst-case behavior runs time means branch execution halts steps similarly runs space means branch execution cells nondeterministic complexity classes ntime nspace precisely analogous deterministic counterparts dtime dspace problem ntime exists ntmm solves problem runs timeo inputs sizen problem nspace exists ntm solves problem runs space inputs size complexity classes analogous deterministic counterparts ntime ntime nexp ntime nspace log npspace nspace won talk npspace turns pspace npspace result prove universal machines constructed universal deterministic turing machines construct universal nondeterministic turing machines notice deterministic universal machine construction lecture single universal nondeterministic machine logarithmic overhead time constant overhead space task simulating nondeterministic machines time-efficiently deterministic setting input running time machine simulate demonstrate machine simulates machine constant factor overhead time theorem exists ntm untime tuntime angbracketleftbigm tangbracketrightbig poly untime angbracketleftbigm tangbracketrightbig proof untime assumes runs time begins guessing computation record writing work tape time step computation record includes guess motion tape heads cell contents tape heads internal state length computation record poly writing guessed computation record untime verifies guessed computation record corresponds valid computation transition function computation ends accepting state achieved checking validity computation work tapes turn important point accepting computation path length untime guessed computation records accept leave reader verify time efficiency simulation critical proof untime takes input amount time simulate construction modified information run construction passing maximum time accepting computation found construction repeated double amount maximum time passed continued accepting computation found note construction correct runs time poly accepting computation path construction halts deterministic machines universal machines nondeterministic machines define complete language proof similar proof proposition proposition language tuples angbracketleftbigm tangbracketrightbig ntm accepts input time complete logm hierarchy results nondeterministic model difficult achieve deterministic model complementation difficult perform diagonalization ntms dtms simple accept input simulated machine rejects input vice versa ntm accepts computation branches 
accept rejects computation branches reject asymmetry make complementation inefficient complementation ntms efficiently computed unknown conp problem hierarchy results show lecture lecture time start discussing relationship class deterministic verification complexity theory lecture np-completeness instructor dieter van melkebeek scribe baris aydinlioglu time introduced model ntm mentioned realistic model computation captures complexity important classes problems started turn attention complexity class brie mentioned complexity class characterizes languages exists cient veri cation mechanism lecture continue discussion connection cient veri ability present striking relationship complexity problems formalize results tools developed previous class reducibility completeness efficient verification definition language efficient verifier exist refers verification procedure runs polynomial time refers short proof certificate witness membership turns problems practical interest property cient veri ability giving examples establish connection class problems class alluded earlier theorem iff efficient verifier proof call veri call describe ntm runs polytime nition constant string length accepted simply guesses string polynomial overhead simulates call ntm nition string accepts steps computation path constant description accepting paths certi cate formally sequence nondeterministic choices makes accepting branch computation simulates simulating nondeterministic transitions accordance accepts accepts give examples problems ciently veri boolean formula conjunctive normal form cnf conjunction disjunctions literals literal boolean variable negation rst ciently veri language sat boolean formulas cnf assignment satisfies satis certi cate membership sat satisfying assignment polynomial fact linear size length recall capture efficiency time-bounded setting class fundamental problem stripped version natural form search-sat commonly occurring problem elds arti cial intelligence search-sat asks satisfying assignment exists rst sight sat simple compared search-sat closer reveals equally cult sense solution problem ciently compute solution sat captures inherent complexity search-sat problem argue notion polynomial time oracle reductions sat search-sat show search-sat sat providing procedure sat-oracle compute solution search-sat query oracle answer negative satis pick variable set true query sat-oracle true substituted satis set false proceed remaining variables gradually build satisfying assignment total number oracle-queries linear number variables sat search-sat search-sat sat abbreviated sat search-sat convenient work erent version satis ability formulas structure purpose language sat satis boolean formula -cnf form formula -cnf form cnf form clause literals vertex cover graph subset vertices edge incident vertex subset language vertex cover size ciently veri certi cate membership purported vertex cover similar relationship sat search-sat decision-version naturally occurring form search-vc problem asks vertex cover minimal size show search-vc helpful rst intermediate problem optimization problem asks size minimal vertex cover leave exercise procedure solves problem making logarithmic number queries vc-oracle reader verify search-vc harder optimization problem subset-sum summationtexti question problems examples literally thousands problems encountered everyday science engineering equivalent sense polytime turing reductions decision-versions cient solution referred question deterministic ntm important problems contemporary mathematics due philosophical practical signi cance philosophical interpretation question ciently verify proofs implies ability ciently proofs stated answer obvious question remains open practical side positive answer question utopic consequences science engineering bring demise public-key cryptography semester co-np question complexity class co-c co-np question relates question nondeterministic computations easily complemented recall lecture asymmetry nondeterministic computation yields answer yields answer input ntm rejects computation path rejects input equivalently co-nondeterministic computation accepts input computation path accepts co-np question asks cient ntm language implies existence cient ntm complement language similar question answer intuitively negative doesn question membership np-language ciently translate question membership co-np language vice versa problem open co-np question relates topic proof complexity summed question tautologies short witnesses similar satis ability problem captures complexity class discuss problem formula tautology captures complexity class co-np cover proof complexity lecture notice passing implies co-np necessarily np-completeness turns problems cient veri cation procedure don cient solution erent manifestations problem inherent complexity tightly connected ciently solved rest theorem states connection language sat entire class polynomial time mapping reductions didactic reasons show result simpli model computation single-tape sequential access result extends random access model simulate random access machine sequential machine quadratic blowup running time theorem sat complete bit mapping reduction computable logarithmic space polylogarithmic time proof sketch showed sat show problem polynomial time mapping reduces sat language ntm decides runs time input length constant rest proof discuss string question membership question utility solve problem time historical evidence suggests problem pulled class quickly trimmed friendlier exponents ime osition figure computation tableau input ciently translated question satis ability cnf formula construct cnf formula polytime sat computation tableau input computation tableau input depicts contents tape successive steps computation tape positions time steps comprises variables clauses rst describe variables time step variables describe con guration time step boolean variable state true state time step computing addition tapehead true tape head located pth position tape time step computing tapehead true tape symbol pth position tape time step computing describe clauses clauses basically force variables intended meaning set-up clauses satis setting variables describes valid accepting computation input achieve clauses capture initial con guration clauses express valid transitions valid tape head movements valid evolution tape contents time step accordance transition relation iii clauses express nal accepting con guration time step details involved setting clauses brie touch leave rest reader row tableau corresponds initial con guration unit clauses state state demand initial state rst step computation initial con guration unit clauses tapehead logicalandtext tapehead tape head position addition logicalandtextp contents logicalandtextp anegationslash contents require tape blanks input denoting ith symbol logicalandtextp contents logicalandtext anegationslash contents input contents cell change tape head cell step clause tapehead logicalandtexta contents contents don write cnf form readability cell tape head positioned time row multiple possibilities position tape head contents cell depending transition relation clauses tapehead state contents tapehead state contents tapehead state contents tapehead state contents left reader end formula variables constructible time polynomial length freedom setting variables corresponds freedom making nondeterministic choices computing satis valid computation path accepts resulting formula simple structure due structure reader verify individual bit formula computed ciently time polynomial length position address bit computed equivalently time polylogarithmic size input establishes mapping reduction proof complete completeness nqlin present theorem shows tighter result complexity reductions connect problems sat problem sat complete problems solved quasi-linear time quasi-linear time mapping reductions proving hardness part theorem make simplifying assumptions model computation previous theorem start ning complexity classes related quasi-linear time 
obvious qlin dtime logc nqlin ntime logc theorem sat complete nqlin qlinm bit mapping reduction computable logarithmic space polylogarithmic time proof theorem rst show sat nqlin discuss language nqlin reduced quasi-linear time sat observe sat computed quasi-linear time nondeterministic random access machine rst guesses linear time satisfying assignment evaluates formula guessed assignment quasi-linear time show sat nqlin-hard begin making key observation principle quasi-linear-time nondeterministic machine access locations non-index tapes addresses quasi-linear length claim loss generality assume addresses logarithmic length reason construct ntm simulates constant factor overhead time satis restriction non-index tape additional non-index tape stores list address pairs cells accesses address logarithmic length simulation store contents cells small addresses remaining cells accessed track address pairs tape cient data structure sorted doubly linked lists pairs addresses length address lengths note list address pairs quasi-linear size index values logarithmic retrieve pair insert perform updates constant factor overhead time exploiting power nondeterminism guess tape locations simulates constant factor overhead time accesses cells tapes addresses logarithmic length similar proof theorem step computation associate block boolean variables block represents information beginning time step internal state machine con guration contents tape head position index tapes iii tape head positions non-index tapes contents cell tape head transition machine step notice information needed advance execution step block logn variables capture intended information represented constant number variables light earlier observation iii logn variables blocks variables set clauses clauses satis blocks represent valid accepting computation input achieve checking initial block corresponds valid transition initial con guration pairs successive computation steps consistent terms internal state contents index tapes tape head positions tapes indexed iii accesses indexed non-input tapes consistent accesses input tape consistent input nal step leads acceptance proof theorem conditions linear number constituent conditions expressed clauses polylogarithmic size variables additional auxiliary variables bit clauses computed polylogarithmic time logarithmic space remains show conditions iii check consistency accesses indexed non-input tapes tape separately tape ine cient perform consistency check pairs blocks verifying accessed cell block accessed cell contents cell block dictated transition encoded rst block approach captures essence formulation isn adequate due quadratic overhead introduces construction made cient rst sorting blocks non-index tape stable tape head location block perform deterministic simulation incur logarithmic overhead time fine purposes require involved data structure balanced search tree stable sort exchanges order elements comparator inputs outputs figure simple diagram sorting network consistency check tape pairs consecutive blocks verifying accessed cell contents cell block dictated transition encoded rst block accessed erent cells contents cell block blank conditions expressed note stable sort order maintain order accesses tape cell construct boolean clauses mimic deterministic sorting procedure avoiding quadratic overheads focus nlogn sorting procedure point hit block order ciently formulate quasi-linear computation ciently formulate quasi-linear computation stuck computation speci type lends quasi-linear formulations formulate sorting procedure making sorting networks sorting networks speci type circuit inputs outputs input values length logn outputs inputs stable-sorted order circuit consists single type element called comparator element basically stable-sorting box elements figure detail fact exist easily computable sorting networks size nlog number constructions yield result batcher networks worth mentioning due simplicity built merge-sort divide-and-conquer strategy so-called odd-even merger network constructed level divide-and-conquer refer reader algorithms book clrs sorting networks associate block boolean variables connection network include clauses enforce correct operation comparator elements network conditions expressed similar condition size constructibility properties network guarantee resulting boolean formula quasilinear size bit computed polylogarithmic time logarithmic space consistency input tape accesses actual input checked similar condition iii erence running stable sorting input tape prepend dummy blocks ith input tape head set location approach handling condition iii enforces input accesses consistent values encoded dummy blocks explicitly variable encodes ith input bit dummy blocks include simple clauses force variable agree ith bit established quasi-linear mapping reduction problem nqlin sat problem proof complete strikingly turns naturally occurring np-complete problems nqlin-complete problems connected tight sense ignoring polylogarithmic factors solved amount nondeterministic time shown sat nqlin-complete qlin reductions transitive proving nqlin-completeness subsequent languages easier task show nqlincomplete show sat qlinm fact time problem proved nqlin-complete tool proving subsequent problems nqlincomplete give avor reductions prove nqlin-completeness additional problems sat theorem sat complete nqlin qlinm proof give quasi-linear time reduction sat sat formula cnf form output equivalent formula -cnf form clauses literals transferred modi cation clause literals converted clause literals repeating literals contained clause clause literals clause converted equivalent -cnf formula introducing variables formula satis original clause satis general clause form converted formula leave reader verify reduction takes quasi-linear time reduction sat sat simple problems closely related proof reduction typical required proof npcompleteness theorem complete nqlin qlinm proof prove nqlin-complete reducing sat cnf formula show convert graph integer satis minimum size vertex cover clauses variables reductions sat sat basic idea create set gadgets clause set gadgets variable connect fashion gadget clause complete graph vertices literals vertex represents figure graph generated reduction sat formula assignment true false true satis induced vertex cover highlighted graph literal clause gadget variable vertex complete graph vertex represents represents gadgets connected vertex representing variable clause edge inserted graph connecting gadget appears positively connection made portion gadget representing made portion representing construction figure minimum size vertex cover gadgets representing variables vertices chosen gadget representing clause vertices chosen vertex cover graph size summationtextmj fact vertex cover size satis reduction outputs graph summationtextmj target vertex cover size demonstrate reverse implication leave direction exercise satisfying assignment rst vertex variable gadgets assignment assignment satis clause choice variables covers edge clause gadget choosing vertices clause gadget completes vertex cover leave exercise verify graph generated adjacency list form quasi-linear time lecture fact naturally occurring np-complete problems nqlin-complete brings questions complete problems nqlin ciently strong hierarchy nondeterministic time recall due asymmetry involved obtaining hierarchy results nondeterministic computation cult address issue time obtain results assuming pnegationslash problems np-complete np-intermediate problems exist np-intermediate problems natural fact general belief current natural problems cient solution show np-complete graph isomorphism factoring np-complete ciently solvable haven clever complexity theory lecture time-bounded nondeterminism instructor dieter van melkebeek scribe baris aydinlioglu time presented strong connection problems proof sat problem np-complete polynomial time mapping reductions strengthened result showing cient 
reduction runs quasi-linear time establishing nqlin-completeness sat mentioned natural problems polynomial-time algorithm unknown eventually shown np-complete nqlin-complete nished lecture questions ers complete problems nqlin problems np-complete rst part today lecture tackle questions order answer rst question obtaining hierarchy results non-deterministic polynomial time explicitly constructing np-intermediate language remainder lecture discuss concept relativization explain question orts researchers decades nondeterministic time hierarchy start showing nondeterministic setting similar deterministic case time strictly theorem time bounds timeconstructible ntime subsetnoteql ntime proof recall directly apply diagonalization technique separating deterministic time proof deterministic time hierarchy polynomially time hands universal dtm simulate computation dtm lower time bound result deterministic computations lower time bound nondeterministic setting hand ciently simulate ntm negate output ntm exponential time hierarchy result exponential jumps time interesting erent technique modi version diagonalization technique proof deterministic time hierarchy named delayed diagonalization based idea deterministic setting diagonalize machines running lower time bound ensuring disagree machine input ensure disagree interval inputs don care input disagree fact won simulate machine interval inputs contrast deterministic case mapped input machine map intervals inputs machine specifically problem lies case simulated machine accepts branches rejects iim iim figure delayed diagonalization interval element interval nondeterministically simulates element interval element interval deterministically simulates rst element interval ips result interval attempts diagonalize machine time allowed ned function case deterministic time hierarchy case nite number intervals allocated machine ensures asymptotic behavior guarantee time complete construction intervals achieved skip details present discussion detailed mapping book arora barak diagonalization interval elements shortly denote kth element intervals set element interval larger size previous element integer simulates notice intervals time simulate time steps universal nondeterministic simulation constant factor overhead time behavior element interval erent dictates deterministically simulates negates result notice order brute force deterministic simulation exponentially time long takes halt size interval large figure claim disagrees element interval suppose contradiction constructed repeated application argument constructed reached contradiction shown ntime proof complete theorem tells strictly quadratic time quasi-linear time brings answer rst question raised proof leave exercise corollary exist languages np-complete nqlin-complete existence np-intermediate problems obtain answer question theorem pnegationslash np-intermediate problems proof notice statement theorem give restrictions type reductions involved proof show result strongest interpretation polynomial time oracle reductions display existence language hard main idea proof similar delayed diagonalization technique employed theorem construct language ers languages polytime dtm languages making disagree polytime dtm input make np-hard ensuring language sat disagrees input dotm oracle rst thing enumerate polytime dtm polytime dotm access l-oracle set strings member interpret parse erent ways pair dtm clocked time brevity call interpretation pair mlj mlj dotm access l-oracle clocked time call interpretation clear reasonable interpretation give enumeration desired construct conditions met fails serve reduction language sat decides language erent converse true trivial string parse half description half time bound meeting condition ensure np-hard np-hard polynomial time oracle reduction reduces sat meeting condition explicitly rules reductions similarly condition realize reasons clear condition condition order satisfy conditions construct interpolates language language sat interpolate intervals inputs agrees language agrees sat interval agrees language make interval large string dotm interval disagrees sat satis condition interval agrees sat make interval large string dtm interval disagrees sat satis condition doesn matter language pick empty set rst present construction makes meet conditions modify construction ends empty string construct phases phase realize conditions foreach phase polytime dotm equipped l-oracle nitely inputs disagrees sat case lexicographically smallest string disagrees sat sat words make agree sat starting strings length larger notice polytime dtm nitely inputs ers case lexicographically smallest string disagrees sat words make agree starting strings size larger notice mentioned close order decide membership string culty ciently nding sat agrees found rest np-computation case agrees computation trivial constrained time sat agrees running procedure hit problem lies steps long time exponential suitable string form case step step disagrees sat problem employing kind delayed diagonalization recall idea delayed diagonalization spread interval end interval elements larger beginning brute-force check hard-to-compute condition earlier elements speci cally modify construction steps waiting long easy detect disagreement sat words interval begun verify condition present interval satis smaller input modi construction presented procedure cond takes length input string returns index condition realizes length returned odd realizes condition agrees realizes condition agrees sat cond odd reject return sat procedure cond return compute cond check rst strings lex order witness ccond clock check steps decide time bound conclude witness found witness found return cond return cond procedure cond recursively calls decreasing values step compute sat rst strings lex order verify agrees sat strings length logn brute force search polynomial time fact reader verify cond runs polynomial time desired satisfying condition relativization definition relativizing complexity theoretic statement respect language means giving machine involved statement access a-oracle statement theorem proof holds relative holds relativized respect statement relativizes holds respect language statement ntime subsetnoteql ntime theorem types machines involved statement run time run time relativize statement respect oracle language giving machines access a-oracle express modi cation writing ntime ntimea ntime ntimea holds relative ntimea subsetnoteql ntimea relativizes holds language claim relativizes notice proof theorem applies verbatim modi cation needed simulation a-oracle writing query tape transitioning query state reading query output simulator a-oracle state succinctly proof theorem relativizes statement recall lecture language tuples angbracketleftbigm tangbracketrightbig ntm accepts input steps shown complete logm language kan angbracketleftbigm tangbracketrightbig halts accepts steps previous proof np-completeness relativizes language kan complete npa logm conclusion draw language notm kan observe relativizations proof completeness respect language language proofs erence oracles reach stronger result exists fixed notm kan fact essentially cient universal ntm remark key ingredient proof theorem limits simulation technique question fact turns revealing results complexity theory relativize kinds techniques diagonalization lazy diagonalization relativize core techniques lies simulation equip simulator simulated oracle statements proofs oracle carry yield proofs oracle techniques semester relativize fact techniques relativize infrequent reader assume verify statement relativizes told makes important result exist oracles relative ers exist oracles relative equals words statements subsetnoteql relativizes prove note signi cance implication corollary techniques general relativize solve question settle problem idea theorem exist oracles npa negationslash npb proof half start construction oracle language relative equals usual proof 
fact pspace-complete language oracle give alternate proof illustrates techniques oracle constructions mention alternate proof lecture construct build dotm runs polytime decides npa-complete language giving rst half theorem npa-complete problem solves kan key idea call notm kan make powerful achieve making compensate lack nondeterministic power speci cally construct results computations strategy pitfall avoided point construction store computation result language careful ect computations prior point construction order address issue make key observation input length longest oracle query make length recall works simulates notm encoded rst part input number steps equal length input simulated machine steps execute longest query make oracle length step perform query observation clears construction similar proof theorem build phases end phase assigned membership strings length procedure foreach phase foreach accepts elaborate procedure works intended fully constructed stand point phase construction phase set string length string add phase subsequent phases length longer light observation length oracle queries makes respect input size means addition string ect computations inputs length fact avoid pitfall mentioned earlier parenthetical remark observe follow order constructed trivial input simply queries oracle returns result query argue kan containment left suppose constructed implies constructed implies accepted construction implies accepts containment left suppose accepts construction accepts completes proof rst half theorem half prove half constructing language exploiting power nondeterminism language language npb notm guess string length construct enumeration polynomial dotm dotm clocked running times form case previous proofs assume machine appears enumeration nitely loss generality running time build phases phase realize condition negationslash nbi phase oracle strings longer considered previous phase ensures computation results dotm nbj previous phase remain una ected procedure constructing foreach phase pick integer nbi rejects pick string length queried deciding track maximum length string queried construction line pick large strings length set query strings length run accepts put string length realizing condition case rejects put k-length string queried realizing polynomial time dotm decides completes proof half theorem lecture lecture move current time-bounded setting space-bounded investigate power computation limits amount space results suggest space-bounded setting understood nondeterministic space closed complementation complexity theory lecture space-bounded nondeterminism instructor dieter van melkebeek scribe matthew anderson lecture discussed time-bounded nondeterminism discussed hierarchy results showed time solve strictly larger subset problems proved existence np-intermediate problems assumption negationslash finally explored relativization showing exists oracle npa oracle negationslash npb implies techniques relativize sufficient resolving versus question overview today continue discussion nondeterminism space-bounded nondeterminism prove stronger results space-bounded case time-bounded case prove main results relating space-bounded nondeterminism complexity classes theorem nspace dtime theorem nspace dspace theorem conspace nspace proof results assume space computable function logn restriction space computable proofs theorems discuss remove restriction require logn space bounds lower logarithmic strange behavior make difficult machine act interesting manner linear input theorem npspace exp theorem quadratically space perform nondeterministic computation deterministically similar result time-bounded computation result made fact space reused time result theorem fact easier compute complement language space-bounded computation iterate witnesses check valid prove conspace nspace complementing equality theorem implies tight space hierarchy nondeterministic machines diagonalization theorems results determine containment number complexity classes pspace npspace exp nexp containments follow definition classes containments npspace exp follow directly theorem pspace npspace theorem pspace simple proof pspace machine iterate witnesses checking verify membership inclusions strict open problem separations hierarchy results discussed previous lectures subsetnoteql pspace subsetnoteql corollary space constructable nspace subsetnoteql nspace proof corollary diagonalization strategy complementation easier space domain constant factor sufficient accomplish strictly recall lecture definition space usage machine index highest indexed cell accesses machine runs space machine state tape heads tape state computation state bits proof nspace dtime proof ntmm running space fix inputx configuration graph input vertex represents configuration space constants depend inequality amount space number positions input tape head inequality fact logn edge iff valid transition configurations note input tape change state information contained configuration configuration vertices independent values input tape edges dependent path start configuration accepting configuration accepted input simulation make accept state unique requiring thatm clear work tapes reset tape heads starting position moving accepting state transforms problem accepting problem graph reachability unique start configuration unique accepting configuration solve reachability problem time polynomial size graph standard algorithms graph size case result nspace dtime proof works nicely space constructable case run procedure times increasing fixed space-bound computation space complete precisely iterate space bounds computation reaches accepting state accept computation accept exceed space bound repeat procedure larger space bound computation path exceed space bound accept path accepting state reject corollary directed path problem dpp logm -complete figure illustration configuration tableau proof theorem tableau width describe configuration step runs time bounded proof dpp store location vertex visiting guess vertex visit continue procedure reach destination traveled steps dpp hard apply configuration graphs machine corollary implies dpp dpp stconnectivity problem stcon dpp undirected version problem proof nspace dspace proof ntm running nspace fix input computation tableau original discussion computation tableau applied techniques one-tape turing machine random access model configuration bits label starting configuration label unique accepting configuration resetting idea principle computation time infinite exists accepting computation exists accepting computation repeat states fact assume computation takes time forcing accepting state repeat diagram tableau shown figure determine sequence states time space naive approach exponential space achieve quadratic space blow divide conquer strategy directly guess intermediate state verify independently benefit reuse space part computation part highest level computation thisreduces original probleminto subproblemsof half size apply procedure recursively reusing space computation part problem halving size problem level logt recursions reach base case verify state transitions step phrase full quantified boolean formula cxt index part equation dependent previous choices variables predicate checks configurations guessed immediately cxt valid step transitions cxt space required evaluate boolean formula existential quantifier requires space describe configuration universal quantifier requires bit information store logt pairs quantifiers total amount space required logt implicitly assuming space constructable apply technique remove requirement tqbf boolean formula introduced previous proof called quantified boolean formula types formulas part interesting language called true quantified boolean formulas definition true quantified boolean formula tqbf language quantified boolean formulas number quantifier alternations free variables true negationslash tqbf tqbf corollary tqbf complete pspace proof proof theorem polynomial mapping reduction 
general pspace problem transforming tqbf polynomial time making tqbf hard pspace tqbf pspace pspace machine iterate possibilities note pspace ptqbf corollary ptqbf pspace queries oracle constructed polynomial time closure polynomial composition ptqbf pspace taking idea containment ptqbf pspace nptqbf pspacetqbf pspace equality model dependent matters count cells oracle tape oracle tape counted pspacetqbf machine abuse oracle tape compute unassisted pspace machine oracle time natural npa note techniques relativize sole means solve versus question proof conspace nspace proof ntm space fixed input graph vertices reachability guessed reachability log space theorem shows complement computed log space showing path exist key idea proof vertices reachable start vertex verified destination vertex vertices vertices guessing verifying reachable order count number reachable vertices procedure call inductive counting suppose subroutine behaves subroutine takes input graph start vertex destination vertex number steps allowed number vertices steps subroutine return values answer means reach steps answer means reach steps return means procedure unable determine answer return subroutine made bad internal guesses bad input case output trusted computation path compromised subroutine run correct answers computation path returns passed correct subroutine return describe subroutine specifically subroutine solve original problem start compute set run subroutine subroutine add continue subroutine continue subroutine halt reject final looping possiblev number vertices reachable step iterate procedure compute current values stored point computation finally run subroutine time parameters answer accept answer reject entire computation accepts exists computation path correctly tracks counts reachable step path step computation inconsistent bails rejecting writing subroutine idea subroutine simple cycle vertices guess reachable subroutines guess reachable verify reachable vertex reachable subrountine modifies count reachable vertices checks reachable additional step count match count passed parameter verify reached subroutine input graph starting vertex number steps number vertices steps destination vertex output reachable steps reachable steps computation determine correct computation path return correct answer foreach guess reachable steps guessed verify guess nondeterministically guessing path steps successfully verified reached step return return return return main point technique number positive instances reachable vertices guessing verifying positive instances verify count correct count check instance question member positive set time lecture discuss alternation generalization hypothetical model nondeterministic computation alternation captures languages fixed number quantifier alternations tqbf complexity theory lecture alternation instructor dieter van melkebeek scribe piramanayagam arumuga nainar past lectures studied depth non-deterministic model computation lecture extend general model alternation derive results classes problems solved alternation discuss characterizations model alternating turing machine generalization non-deterministic turing machines motivation non-determinism hypothetical model important captures complexity interesting problems class problems solved non-deterministic polynomial time languages membership verified efficiently polynomial time state formally language iff exists non-determinism restrictive efficiently solve interesting problems minimizing cnf formula equivalent decision problem testing cnf formula minimum size define min-cnf cnf minimum size state membership min-cnf min-cnf size negationslash cnf smaller expressed string size polynomial case assignment values variables checking polynomial time takes sat verifications test equality stmt rewritten resemble formulation min-cnf logical formulas describe membership language stmt min-cnf stmt notice significant differences quantifiers universal quantifier generalization make alternating model quantifier formulas expressing membership constraints languages alternating universal existential quantifiers adjacent quantifiers type combined leaving quantified variable polynomial size input alternating model define general complexity class qpk set languages membership constraints expressed formulas alternate existential universal quantifiers quantified variable size polynomial length input initial quantifier existential universal notational description definition membership expressed formula form qyk constant definition membership expressed formula form qyk constant notes quantifier odd dual true super-script denotes poly-time verifiability small notational inconsistency denote class problems denote input alphabet intended usage clear context facts quantified variables verifier decide membership input words algorithm absence quantifiers real distinction existential universal quantification definition earlier state prove general result conp finally description min-cnf matches min-cnf class hierarchy results proposition simple result state classes introduced solve equal number problems greater number quantifier alternations trivial add unused variable quantify appropriately leave unchanged proposition transformthe membershipconstraint byaddingan universally quantified variable end adding universally quantified variable beginning similar argument applies result holds proposition proof language iff verify string negates membership constraint defn quantifiers switched leaving predicate verification task efficiently similar argument holds conp figure pictorial illustration polynomial hierarchy propositions illustrated figure kth line sloping upwards bounds languages kth line sloping bounds lines lines previous levels lines collapse cop corollary conp derived question inclusion proposition strict simplest version question words pnegationslash turned hard result prove based definition polynomial hierarchy definition class problems polynomial time hierarchy fixed number alternations allowed uniontextk note include previous definition consequence proposition theorem words polynomial time hierarchy collapses level proof language string iff condition true qyk qyk qyk qyk predicate input equivalent predicate input existential quantification equation merged initial existential quantifier leaving predicate input words language expressed predicate combining proposition multiple alternate applications operations converting predicates merging quantifiers prove note condition theorem required quantifier make premise non-trivial corollary proof proved conp theorem polynomial hierarchy collapses corollary state collapse negationslash stronger statement pnegationslash polynomial hierarchy collapse class general conjecture community collapse fact results start assumption derive collapses order disprove likeliness assumption completeness problem complete definition set true fully quantified formulas predicate cnf odd dnf similarly define set true fully quantified formulas claim pm-complete pm-complete proof language verifier suppose odd quantifier quantifier statement np-completeness sat converted polynomial time statement cnf formula instance true suppose quantifier quantifier conp statement conp-completeness tautologies converted polynomial time statement dnf formula instance created reduction accomplished polynomial time hard construction complete similar argument proves pk-complete alternate characterizations oracle machines claim words set languages level polynomial hierarchy set languages recognized non-deterministic machines access oracles kth level proof statement npp npp trivial simply choose oracle npp time complexity oracle worst case increase degree polynomial time complexity statement non-trivial suppose language construct non-deterministic guesses solve formula solved oracle general language solved oracle complement suppose express decidable express computation path base machine formula guessing queries made machine results queries express constraints positive query responses valid predicate express constraints negative query responses valid predicate universal quantifier required step ensure non-existence witness query existence predicate expresses decidability hand side written npnp arguments similar boolean circuits claim language expressed exponential size boolean circuit alternating levels gates unbounded 
fan-in level polynomial bounded fan-in bit circuit description computed polynomial time vice-versa proof language verifier construct enormous boolean circuit exponential number polynomial circuits evaluating membership inv combinations specific make polynomial circuits levels expressing function cnf dnf outputs circuits combined hierarchically levels leave single output top-most level output decision ith level array gates universally quantified array gates existentially quantified number gates ith level equal number choices inputs appropriately choosing cnf dnf verifier merge gates kth level top gates normal form chosen verified bit poly-time computable boolean circuit gate top-most level construct formula compute language decided circuit determine bits guess quantifiers top-most gate output exists gate lower level output express output gate level gate gate produce output gates level produce output stmt output gate gate output connected input chosen circuit exponential circuit represent gates circuit polynomial size indices repeatedly apply steps predicate final verification task evaluating output gate level bit circuit description computable polynomial time choices indices level identify gate evaluated bits input gate evaluate predicate formula poly-time language circuit similarly construct language circuit gate top-most level alternating turing machines section extend non-deterministic turing machine model alternation alternating non-deterministic non-halting state additional property existential universal configuration machine accepting halting configuration machine accepting state current state existential transition state leads accepting configuration current state universal configurations state leads accepting configuration machine accepts input initial configuration accepting final characterization claim accepted alternating existential start state runs polynomial time quantifier alternations accepted alternating universal start state runs polynomial time quantifier alternations proof language construct stage alternating ith stage guessing match quantifier states ith stage existential odd universal verifier require non-determinism states simulate made existential universal depending recognizes existential start state performs alternations similarly construct alternating recognizes language satisfies constraints alternating performs alternations construct equivalent language halts polynomial time time spends stage alternation polynomial model choices made ith step polynomial length string existential universal stage quantified existentially universally verifier verify choices made valid input machine final state halting accepting polynomial time resulting formula formula initial state existential formula time space definition time space required turing machine define complexity classes k-time k-space derive hierarchy results technique earlier delayed diagonalization results simplified unlimited number alternations define atime set problems solved time alternating number quantifier alternations aspace set problems solved space alternating number quantifier alternations results time space theorem nspace atime proof proof nspace dspace lecture remember constructed formula similar formula divide-and-conquer formulation proof existential quantifier guessed intermediate configuration long turing machine universal quantifier independent reachability conditions bit wereo quantifiers final predicate verifies transition configuration valid takes time configuration long guessing stages machine time verification end takes time total running time theorem atime dspace proof alternating machine running time separate execution existential universal stages long begin simulating long remains stage stage simulate choices stage separate choices cycle space stage simulate choices stages takes space cycle total stages cycle guesses space guesses existential stage ensure guesses results accepting computation guesses universal stage ensure guesses result accepting computation sequence guesses simulatem guesses space-efficient universal turing machine lecture convert equivalent machine space total space usage corollary pspace proof thm pspace pspace npspace thm pspace theorem aspace uniontextc dtime words time exponential space requirement deterministically simulate alternating proving theorem homework problem corollary corollary apspace exp lecture time alternation prove non-existence sat-solvers time space efficient main topic class non-uniformity algorithms inputs lengths complexity theory lecture nonuniformity instructor dieter van melkebeek scribe chi man liu lecture studied alternations related polynomial-time hierarchy gave characterizations alternation model introduced alternating time space complexity classes part lecture make alternations prove time-space lower bound results sat part lecture introduce notion nonuniform computation nonuniform models discuss include boolean circuits branching programs uniform machines advice conclude lecture connections uniform nonuniform models time-space lower bounds sat sat solved polynomial time remains open question question resolved sat solved linear time results ruled seemingly ridiculous possibility strikingly sat put time space consideration prove nontrivial lower bounds sat definition functions class dtisp defined consist languages accepted dtm steps space note dtisp dtime dspace general theorem algorithm sat timeand space-efficient theorem proved nondeterministic linear time prove lemma sat essentially captures power nondeterministic linear time lemma sat dtisp ntime dtisp poly-log poly-log proof recall lecture proved sat complete nqlin qlinm bit reduction computed polylogarithmic time logarithmic space language ntime nqlin input length compute reduction sat reduction length npoly-log reduction solve deterministic poly-log time deterministic algorithm sat hypothesis computed reduction straightforward manner space npoly-log space storing reduction note dmay modify sat algorithm run directly inputs algorithm requires bit reduction bit computed original input computation single bit polylogarithmic time logarithmic space incurs polylogarithmic blow-up time space requirement poly-log lognfactor computing reduction on-the-fly absorbed theorem sat dtisp constants proof lemma suffices show ntime notsubseteql dtisp ncpoly-log poly-log prove contradiction proof assume ntime dtisp show leads violation nondeterministic time hierarchy theorem polylogarithmic factors add term exponent time space usage reach contradiction include factors proof involves alternations discussed previous lecture split proof parts speed deterministic computations introducing alternations dtisp -time eliminate alternations -time ntime hypothesis part letlbe language dtisp fix input stringx computation tableau rows columns row describes configuration turing machine point time call initial configuration unique accepting configuration reached steps proof nspace dspace lecture guessed intermediate state verified independently technique time splitting tableau parts split parts determined guess configurations verify steps computation stated note fact computation analyze time computation guessing existential part takes time length guessing universal part takes time logb verification part takes time easily simulate step deterministic computation constant time combining running time achieve speedup minimize setting appropriately setting achieves constant factor minimum radicalbigt running time dtisp time part letl language -time somea computation forlcan written deterministic linear time computable predicate note co-ntime fixed length ntime dtisp co-ntime dtisp closed complement dtime ntime ntime nac time ntime nac combining parts dtisp -time ntime final step showing ntime dtisp ntime ntime contradicting nondeterministic time hierarchy theorem inclusion hypothesis technique called padding notice included polylogarithmic factors end addition term final running time reach conclusion ntime ntime remains contradictory nondeterministic time hierarchy padding language ntime claim ntime ntm accepting runs quadratic time construct 
ntm accepting input checks member counting number leading zeroes extracts removing artificially padded prefix simulates computation radicalbig computation takes time ntime dtisp dtisp algorithm decide dtisp instance pad decide dtisp equivalent solved dtisp corollary suppose sat dtisp constants statement corollary algorithm sat space-efficient logarithmic space runs super-linear time statement algorithm sat time-efficient linear time polynomial space logarithmic space sufficient theabove theorem andits corollary show inefficiency time space asingle algorithm sat exists linear-time linear-space algorithm logspace quadratic-time algorithm sat lower bound result rules possibility theorem sat co-ntime proof exercise corollary sat dtime nonuniformity motivation computational models turing machines random access machines work inputs lengths call uniform models computation section introduce nonuniform models computation short nonuniform model computational model machine generally computing device input length machine inputs length machine inputs length machine length machines form infinite family machines nonuniformity bit odd sight uniformity natural form computation resembles algorithms finite procedures inputs interested nonuniform models fact close relationships uniform nonuniform models studying nonuniform models derive lower bound hardness results uniform models relationships section nonuniform models computation introduce forms nonuniform computation nonuniform models boolean circuits branching programs solve instances specific problem fixed input length simplicity assume languages defined binary alphabet boolean circuits analyzing uniform time complexity problems branching programs space complexity model fact uniform model nonuniform ingredient advice advices similar certificates additional information speed computation difference certificates advices certificates vary input input inputs length share advice words advice input depends length briefly discuss models section relate nonuniform models uniform models boolean circuits define boolean circuits similarly real-world electronic circuits boolean circuit directed acyclic graph node logic gate input input node incoming edges gate nodes designated output node outgoing edges label input nodes input string boolean circuit computes output single bit bits copied input nodes topological order logic gate receives bits incoming edges performs boolean operation bits sends output bit outgoing edges output circuit bit output output node output depth figure boolean circuit function boolean circuit realizes output matches input circuits gates bounded fan-in define circuit size function size smallest terms number nodes circuit realizing boolean circuits accept language circuit inputs uniform computation circuit inputs lengths formally family circuits accepts language realizes characteristic function restricted inputs length define circuit complexity circuit complexity language good measure uniform time complexity reason boolean circuit simulate computation uniform machine linear time likewise turing machine runs time encode transition function boolean circuit size quadratic measure depth circuit equals length longest path input output node circuit depth comparable uniform time complexity circuit size specific language input length convert membership cnf dnf build constant-depth circuit fan-in circuit converted equivalent linear-depth circuit bounded fan-in note language circuit complexity considerably smaller uniform time complexity due algorithm inputs restriction imposed uniform computation branching programs branching program directed acyclic graph node labeled accept reject node labeled accept reject outgoing edges marked nodes designated start node computation input starting start node label follow edge node input string repeat reaches accept node reject node note similar boolean circuit branching program works inputs specific length function define branching program complexity size smallest branching program accepts start accept reject figure branching program family branching programs accept language branching program complexity bpl language defined bpl subsection boolean circuits branching program complexity language good measure uniform space complexity suppose branching program nodes simulate computation turing machine logv space space store index current node suppose turing machine space runs time construct layered branching program branching program nodes partitioned layers edge layer layer layers nodes layer node represents machine configuration layer single node representing initial configuration node start node node subsequent layers labeled variable current input tape head position configuration edges valid transitions successive configurations node accept resp reject node represents accepting resp rejecting configuration size branching program simulations roughly logarithmic relationship size branching program space usage turing machine candidate measurement width layered branching program equals maximum number nodes layer note language branching program complexity bpl considerably smaller uniform space complexity uniform models advice models discussed machine input length resulting infinite family machines model similar uniform models single machine input lengths give extra power nonuniformity uniform machine allowing access advice piece additional information improve efficiency computation definition function class languages define class exists sequence definition called advice sequence upper bound length advice note advice machine depends length input differs certificates input certificate restriction certificates inputs equal length advice powerful length bounded bit fact exist uncomputable languages computed one-bit advice halting problem halt encodes dtm halts input halt uncomputable turing machine language lexicographic rank halt clear halt uncomputable advice sequence characteristic function halt computed machine simply outputs advice bit input connections uniform nonuniform models section present results relating nonuniform models uniform complexity classes poly class languages computed polynomial time usingpolynomiallength advice similarly poly class languages computable logarithmic space polynomial-length advice theorems show relationships nonuniform models complexity classes theorem poly polynomially bounded proof sketch construct polynomial-size circuits accepting language poly hardwiring polynomial-length advice strings additional inputs polynomialsize circuits descriptions circuits advices proof theorem similar left exercise theorem poly bpl polynomially bounded uniform boolean circuits family circuits uniform exists uniform machine outputs description time polynomial uniform branching programs defined similarly notion uniformity standardized differ context theorems uniform circuits branching programs uniform theorem uniform polynomial-size circuits proof sketch dtm accepting construct circuit inputs length hardwiring valid transitions constraints computation tableau runs polynomial time computation tableau polynomial size resulting circuit polynomial size computed polynomial time inputx uniform machine computes polynomial time simulates computation polynomial time theorem uniform polynomial-size branching programs time class poly problems solvable polynomial time advice polynomial length np-complete problems happened computed advice strings polynomial-time algorithms making solve np-complete problems efficiently lecture show case prove poly polynomial-time hierarchy collapses level move talk constant-depth boolean circuits complexity theory lecture constant-depth circuits instructor dieter van melkebeek scribe seeun william umboh draft lecture applied alternations prove time-space lower bound results sat introduced notion nonuniform computation nonuniform models boolean circuits branching programs uniform machines advice today begin theorem suggests sat small circuits investigate constant-depth circuits small circuits collapses theorem poly note show simulate computation computation proof language predicate decided deterministically time 
linear combined input predicate input reduce sat instance hypothesis exists circuit csat size polynomial running time decide size polynomial size letting denote reduction replace predicate csat rephrase formula roughly exist circuit solving sat strings circuit accepts transform right-hand side csat input size csat size csat recursive predicate variable thencsat csat csat csat true unset variable slight detail circuit csat takes inputs fixed input size varying size simply pad equivalent instance required size essentially guess circuit csat combined predicate checks csat accepts csat valid circuit solving sat evaluating polynomial size circuits evaluatentimes takes polynomial time check universal quantifier merged single polynomial time verifiable predicate formula note hypothesis crucial polynomial size circuits fail polynomial-time hierarchy collapses evidence suggesting polynomial-size circuits proofs similar leave exercises exercise pspace poly pspace exercise exp poly exp nonuniform lower bounds previous lecture stated application nonuniform models computation attempts prove lower bounds computing functions np-complete problems fact beenlittle progress proving lower boundsfor np-complete problems survey results section nontrivial lower bounds proven restricted models computation discussed section boolean circuits facts area theorem boolean function naive encoding truth table dnf -size circuit analysis bound theorem boolean functions pick uniformly random set boolean functions variables probability converges grows proof denote number binary gates gates pick variable gate input gate inputs number circuits size mostsis wherecis constant takes care possibility input negated map circuits boolean functions maximum number boolean functions computable gates number boolean functions variables slogs setting sufficiently small constant slogs nlogd logn claim shows boolean functions require circuits maximum circuit size constant factor expect complicated functions capture np-complete problems prove non-trivial lower bounds case lower bound proposition branching programs branching programs show functions case boolean circuits lower bound roughly quadratic lower bound case boolean circuits trivial result recall previous lecture turing machine logv space size branching program hope prove lower bound branching program size restricting attention layered branching programs constant width powerful sight prove substantially lower bounds arbitrary branching programs constant-depth circuits unable prove lower bounds np-complete problems general setting focus attention restricted model constant-depth circuits give basic facts constant-depth circuits prove require exponential size compute parity function definition constant-depth circuit constant-depth circuit boolean circuit unbounded fan-in depth bounded constant model restricted mentioned function computed depth cnf dnf circuit general exponential size parity function size required exponential encountered constant-depth circuits lecture alternation showed simulate alternation constant-depth circuits exponential fan-in today circuits polynomial size family classes definition ack ack logk polynomial logk denotes complexity circuits unbounded fan-in depth logkn deciding restriction length interested class languages decidable constant-depth circuits polynomial size examples languages proposition decision variant binary addition proof proof strings indexed determine ith bit sum ith bits summands determine carry bits position introduce notation label column depending generates carry bit transmits carry bit stops carry bit input bits column column labeled bit labeled bits column labeled carry column point columns words determine carry ith position job reduced detecting string form guess length number lengths linear input size length determine symbol string xors ensure symbols big xors level ands ands xors xors implemented constant depth ands ors nots circuit constant depth discuss problems computed ack future lecture sketch proof parity requires exponential size computed constant-depth circuits definition parity odd number denote parity variables circleplustextn theorem parity proving result shown parity computed polynomial size circuits bounded fan-in log-depth theorem divideand-conquer strategy fact proof outline today shows circleplustextn parity computed circuits size exact characterization size constantdepth circuits required compute parity proof present today tool definition random restrictions p-random restriction variables random function independently leave variable set result note apply random restriction parity function parity function complement bits set proof sketch theorem start circuitc wlog assume level ands ors circuit alternates assume inputs circuit variables negations allowing ignore gates part main ingredients proof proposition circleplustextn proof depth easily prove exponential lower bound assumption circuit dnf cnf assume dnf terms check setting variables circleplustextn variables flip variable detect difference n-variable terms dnf formula half half check circleplustextn size bound stated lemma switching lemma cnf small bottom fan-in apply random restriction set variables high probability resulting function written dnf small bottom fan-in note statement trivial restriction set variables setting variables important qualifications small quantified appropriately statement hold exposition approach qualitative level proof idea ors size notice random restriction set literals involved set happen small nontrivial probability cases large number pairwise disjoint ors case independent events set gate pairwise disjoint ors set events nontrivial probability odds random restriction set gate case trivially written dnf small bottom fan-in large number pairwise disjoint ors minimal set variables queries variable lot overlap ors small query variables essentially reduced problem simpler type transformation cnf bottom fan-in ors literal repeat case distinction simpler problem depending setting variables branch process eventually end case steps step involves querying small number variables end decision tree small depth represents cnf random restriction high probability decision tree small depth turned dnf small bottom fan-in writing paths decision tree lead acceptance conditions define path note switch dnf cnf negation circuit switching lemma reduce depth circuit time left circuit depth suppose bottom gates ands apply switching lemma ensure gates bottom circuit small fan-in ensure insert dummy gates gates input gate replace apply switching lemma ors created high probability application successful creating ands small bottom fan-in setting variables bottom-most bottom-most levels ors merged reduces depth circuit back added level initially circuit small bottom fan-in apply switching lemma repeat process circuit depth point computed circleplustextn computescircleplustextm somem-subset variables unset random restrictions point proposition derive lower bound size remaining circuit original circuit large exponential lower bound size original circuit positive probability application switching lemma successful lecture give alternate proof parity requires exponential size constant-depth circuits proof low-degree polynomial approximations random restrictions bound circleplustextn tight previous result advantage applies circuits gates complexity theory lecture polynomial approximations instructor dieter van melkebeek scribe piramanayagam arumuga nainar time proved constant depth circuit evaluate parity function random restrictions obtain bound complexity circuit evaluating parity inputs lecture complete give alternative proof slightly weaker bound random restriction method showed thatcd tight bound property parity function sensitive bit input derive similar 
bound modm function defined modm braceleftbigg mod number non-zero bits input parity special case modm function prove majority function returns bit bit occurs maximum number times input proved parity function black box left exercise lecture low degree polynomial approximations show weaker bound technique interesting result applies mod gates circuit finally prove constant depth circuits approximately evaluate parity polynomial approximation method theorem nnegationslash specifically proof outline prove steps show constant depth circuit approximated low degree multi-variate polynomial field free ability mimic mod gates general prime number handle modp gates show parity function approximated multi-variate polynomial sufficiently low degree field proof step circuit made mod gates represented multi-variate polynomial degree size input goal represent polynomial lower degree allowing errors required literal directly passed input gate represented polynomial base case construction assume polynomial ith input gate types mod goal construct polynomial represents output gate note number inputs gate polynomial representing input gate represents output gate notice representation gate increase degree polynomial mod gate output gate msummationdisplay summation output note field model gate polynomial msummationdisplay accurately models gate degree degree inputs gate output gate words output represented mproductdisplay formulation accurate degree times degree largest degree higher trivial bound gates levels circuit tackle model linear combination coefficient modm square linear combination boolean leaves msummationdisplay makes degree degree inputs accurate description gate suppose pick coefficients random evaluate probability boolean expression irrespective values picked coefficients output correct msummationdisplay summationdisplay wrong cases random assignment coefficients introduce errors representation probability randomized algorithm repeat calculation independent trials output trials note output correct output wrong leads final formulation application eqn inputs kth trial formulation eqn shorthand formulation produces wrong output trials produce wrong output probability degree increases factor factor -formulation factor -formulation handle gate similar resulting approximation factor blow-up degree giving imprecise probability depth circuit degree polynomialp representing entire circuit wrong output gates wrong probability note tight upper bound proof averaging expected number inputs give wrong inputs length exists choice random coefficients wrong expected number derived formally lemma exists choice exists set relative size polynomial degree constructed relative size respect set inputs equal construction generalized work field prime allowing mod gates property mod anegationslash mod squaring polynomial ensures boolean values work raise polynomials power mod negationslash mod degree resulting polynomial step step polynomial degree approximates subset inputs establish upper bound function inputs polynomial approximating equating number functions number polynomials degrees greater established upper bound derive lower bound depth circuit step transform inputs slightly convenient domain proposition suppose exists polynomial degree computes set exists polynomial degree set nproductdisplay reason parity boolean inputs equivalent multiplication lemma suppose exists polynomial degree represents multiplication set function multi-variate polynomial degree represents proof function multi-variate polynomial degree trivial hardwire input monomials degree start polynomial monomial form productdisplay subset input bits concerned inputs rewrite productdisplay productdisplay productdisplay productdisplay nproductdisplay productdisplay productdisplay eqn holds input bits eqn holds inputs set lhs degree rhs degree degrees smaller equal make degree monomial exceed lemmas ready combine prove theorem suppose exists circuit depth computing lemma exists polynomial degree computes parity set relative size lemma functions represented multivariate polynomial degree total number polynomials number functions number multivariate polynomials degree number monomials degree monomials degree summationdisplay parenleftbiggn parenrightbigg number monomials degree half monomials remaining terms summation lower parenleftbignn parenrightbig maximum number degree stirling approximation show parenleftbiggn parenrightbigg parenleftbigg parenrightbigg parenleftbig parenrightbig parenleftbig parenleftbig number functions form values assigned element number functions form number polynomials degree words bound size parenleftbigg parenrightbigg lemma parenleftbigg parenrightbigg bracketleftbigg parenleftbigg setting tight rhs equation part analysis working result holds lower bound boolean circuits mod gates prime fact argument proof generalized give lower bound circuits mod gates compute mod recall parity special case achieved viewing step harmonic analysis generalizing harmonic analysis generalization takes bit work prove leave lower bound parity proved viewing parity multiplication lower bound multiplication corollary decision variant binary multiplication proof give lower bound circuits approximate parity corollary depth unbounded fan-in circuit agrees parity fraction size proof suppose circuit correct inputs similar theorem prove exists polynomial degree correct set step proof parenleftbigg parenrightbigg parenleftbigg parenrightbigg bracketleftbigg parenleftbigg note term ensure lower bound positive set optimize rhs corollary proves inapproximability parity function constant depth circuits result proved random restrictions theorem depth unbounded fan-in circuit agrees parity fraction size interesting trivial functions guess parity correctly half inputs slightly weaker bound derived lecture disproves approximability computability parity function results inapproximability discuss pseudo-randomness lecture lecture discuss parallelism distribute computational task multiple processors reduce time complexity complexity theory lecture parallelism instructor dieter van melkebeek scribe matt elder goal parallelism speed computation dividing processors lecture discuss models parallelism complexity classes capture efficiently parallel-computable problems conceptual model model parallelism roughly power large collections turing machines acting means communication ourmodel capture means communication form interconnections processors model blithely assume connections free realistic real parallel computers interconnection network confusing pieces network configurations butterfly nets hypercubes grow reasonable rates yield communication processors logp time number processors model impose limits number processors model diverge physically realizable computers constant number processors give constant speedup standard turing machine problem number processors grow input size entail issues uniformity ourcriteria forefficiency change whenwe move fromstandard turingmachines vastly parallel computers aim polylog time polynomial time achieve permit number processors polynomial size input concrete model model parallel computation uniform nc-circuits class similar defined definition nck set languages recognizable circuits bounded fanin polynomial size logkn depth union classes nck nck circuit uniform circuit computed size input logarithmic space uniformity condition considered standard typically means uniform thesis efficient parallel algorithm iff uniform leave reader verify complexity class uniform nck closed composition log space mapping reductions complexity place class classes nck hierarchy theorem uniform uniform proof show uniform suppose uniform family -circuits decides language input simulate logarithmic space compute circuitc precisely compute bit description ofc needed space store entire description circuit compute part logarithmic space uniform output node compute values gate recursively memoization painfully slow optimize space depth log computation logarithmic space output accept reject fact uniform left exercise relate class hierarchy classes closely related hierarchy theorem nck ack nck proof nck restriction ack inclusion clear inclusion implied 
fact polynomially-bounded fanin simulated simple logarithmic-depth circuit bounded fanin languages nck give feel hierarchy efficiently basic tasks accomplished parallel class definition languages decidable constant-depth constantfanin circuits implies things problems decidable checking constant number bits input theorem class binary addition class iterated addition theorem iterated addition carries mod figure finding numbers sum numbers proof binary numbers output numbers sumusing constant depth circuit triple input bits produce binary number additions modulo binary number carries figure operation constant-depth circuits group inputs groups apply operation repeat remain inputs operation reduces number remaining numbers add logarithmic number layers circuits reduces problem binary addition iterated addition binary multiplication perform matrix multiplication element-wise multiply binary multiplication layer follow layer iterated addition subproblems concatenation symmetric function function change input bits permuted dependent size number input determined iterated addition symmetric functions computable necessarily uniform iterated multiplication uniform computable proof complex divide-and-conquer algorithm circuits show iterated matrix multiplication implies matrix inversion linear systems rest linear algebra computable upper bounds classes nck upper bounds computation power weak truth statements open questions uniform uniform uniform cvp circuit problem circuit input return output cvp p-complete log-space mapping reductions uniform iff cvp nc-computable connection theorem states circuits bounded-width branching programs polynomial size equally powerful proof formulas restricted version circuits definition formula circuit gates maximum fanout gate formula maximum fanout number gates formula matches notion size boolean expression standard circuit shape directed acyclic graph formula rooted tree inputs circuit smaller equivalent formula reducing duplication sharing outputs theorem equivalent power circuits polynomial size formulas log depth formulas bounded-width branching programs polynomial size proof show theorem elements simulate predecessor theorem poly-size formulas capture circuits log depth formulas capture poly-size formulas proposition circuits simulated poly-size formulas proof circuit forms rooted directed acyclic graph root topmost operator circuit transform formula recursively replacing subgraphs node fanout replace node child subgraph copies node child subgraph node fanout node child parents black node figure transformed figure step recursive transformation circuit poly size formula circuit root output suppose repeat procedure node root circuit maximum fanin depth number nodes depth times number nodes depth nodes layer size bottom layer dominates size formula process yields formula size circuits depth logn size formula logn polynomial step function computed generated circuit remains process creates poly-size formula equivalent circuit proposition polynomial size formulas simulated log depth formulas proof formula binary fanin find edge formula subformulas side edge size formula sub-formula low side cut edge sub-formula high side cut edge constant literal figure illustrates trees figure step transformation polynomial size formulas log-depth formulas cut well-chosen edge formula yields sub-formulas create formula function original decreased depth formula shown figure formula computes function original inputs original function likewise inputs original function function combines cases figure step transformation polynomial size formulas log-depth formulas combine sub-formulas recurse procedure sub-trees continue recursing constant-size formulas size original formula notice size applying step sub-formulas considered reduced factor notice level recursion places depth circuit top sub-formula worked depth final formula generated satisfies inequality words logs proposition bounded-width branching programs polynomial size simulated circuits proof suppose branching program width polynomial number layers construct circuit simulate divide conquer strategy place gate fanin ensure gate true input induces path start state layer accepting state layer layer ith input gate place gate fanin outputs true input induces path start state layer ith state layer accepting state layer input true iff sub-path layer layer induced input true iff sub-path layer layer induced recurse inputs ands reaching base case checking adjacent layers pis polynomial divide conquer strategy recurses onlyo log times giving constructed circuit logarithmic depth analyze size circuit rely fact generating circuit formula sub-problem computed circuit compute needed roughly intervals considered subproblems subproblems form state layer reached state layer asked interval number individual questions circuit computes polynomial size input circuit constructed polynomial number gates logarithmic depth circuit proposition log-depth formulas simulated bounded width branching programs polynomial size proof construct properties width label node depends layer oblivious levels branches distinct end states branches distinct end states width constant makes permutation effect identity permutation input rejected single cycle input accepted accepting claims corollaries give components construct recursively building structures equivalent pieces log depth formula claim exists accepting size cyclic exists accepting size cycle negationslash proof cyclic permutation conjugate exists permutation construct acceptor acceptor permute machine top-layer nodes bottom-layer nodes corollary decide language acceptor size decide language acceptor size proof build acceptor decides apply nodes acceptor decides claim exists acceptor size decides language exists acceptor size decides language negationslash exists acceptor size decides proof suppose acceptor deciding language acceptor deciding language machine formed concatenating order start-to-finish acceptor deciding analogous previous claim shows build fate input fed undergoes permutation net permutation undergoes perform identity permutation net permutation experienced rejected case similar case clearer machine accepts precisely language size machine exist permutations negationslash combine branching programs simulate gates complement branching programs simulate gates morgan law encode individual input variables trivial model branches form permutation branches form permutation label node layer relevant variable standard post-order formula traversal constructions suggest level branching program increase factor formula depth branching program construct size logn size branching program polynomial proved computational models question transformed chain transformations machine models transformed equivalent machine models models equivalent power complexity theory lecture randomness instructor dieter van melkebeek scribe jake rosin time discussed parallelism extension existing model computation today introduce randomness extend turing machine model make show qualitative usefulness randomness cient probabilistic algorithms cult problems quantify power comparison existing computational classes motivation randomness appears great computational tool simpli problems large number settings essential dining philosophers problem solved deterministic solution randomness essential cryptography deterministic method hide secret means deterministically found adversary randomness cryptographic setting covered upcoming lectures deal randomness standard setting realizing mapping inputs outputs decision problems intuitively randomness hindrance setting problems solved ciently randomness deterministic algorithm randomness additional computing power concept make randomness coins base decisions outcome ips con guration machine time random variable based coin ips outcome dictated nal con guration machine random variable context decision problems introduces possibility incorrect result probability error made negligible results easily generated machine errs probability nontrivially running machine repeatedly taking 
majority vote outcomes machine produces erroneous result probability results independent runs majority vote wrong ksummationdisplay parenleftbiggk parenrightbigg shows produce exponentially small probability error majority vote polynomial number runs original probability error close erent ways error randomized computation type error allowed ect class languages computed -sided error error membership non-membership sides -sided error error side typically membership side invalid input rejected valid input rejected small probability -sided error incorrect answer answer unknown small probability randomized quick sort -sided algorithm quick sort guaranteed produce correct result answer unknown behavior quick sort ected randomness time space aspects program behavior random variables randomized algorithms goal randomness introduced obtain solutions cient algorithms deterministically ciency measured time space sequential time efficiency polynomial identity testing problem cient randomized algorithm cient deterministic algorithm arithmetic formula composed addition subtraction multiplication brackets variables problem determine solving problem deterministically appears cult method involves expanding terms comparing monomials number monomials exponential length formula fact deterministic algorithms run exponential time randomized solution formed choosing values variables random evaluating formula resultnegationslash formula rejected formula probability bound probability error determined values variable chosen uniformly random set degree negationslash degree formula bounded length interval chosen ciently small polynomial ensuring small speci logn bits evaluating formula worst raises variables power meaning resulting numbers logn bits arithmetic operations involved performed polynomial time bit length numbers forms -sided randomized algorithm polynomial identity testing errs nonmembers small probability producing false positives arithmetic circuit testing bene approach relevant decision problem arithmetic circuit inputs evaluate degree polynomial exponential depth circuit exact calculation polyn bits prevents evaluation polynomial time solution perform calculations modulo random number polyn bits evaluation polynomial time introduces source error dealt polynomially prime numbers produce incorrectly numbers prime factors true result reduce probability error pick prime numbers set picking prime number set small probability achieve pick prime number random poly large polynomial work guarantee randomly chosen poly nontrivial number primes interval prime number theorem assurance prime counting function number primes equal xlnx result -sided algorithm correct poly errs nonmembers running algorithm multiple times increase con dence result case polynomial identity testing deterministic algorithm arithmetic circuit testing runs exponential time parallel time efficiency existence perfect matching bipartite graphs problem deterministic parallel algorithm inherently sequential polynomial time algorithm exists nding parallel algorithm greatly improve ciency problem solved algorithm generated randomness graph represented adjacency matrix replace graph random variable unique location claim perfect matching iff det proof term determinant exists permutation permutations -tocorrespondence perfect matchings determinant term perfect matching coe cient term matching graph erent perfect matchings lead erent monomials non-zero coe cient valid graph determinant multi-variate polynomial degree checking perfect matching performed checking polynomial accomplished randomized algorithm parallel algorithm computing determinant linear algebra problem lecture fact device algorithm replace adjacency matrix random suitable interval poly compute determinant parallel result non-zero perfect matching exists algorithm repeated ciently con dent result space efficiency undirected path problem recently ciently solved randomized algorithm cient deterministic suppressl solution problem included well-known note related directed path problem nl-complete undirected graph vertices problem determine path exists randomized algorithm random walk beginning walk ends number steps immediately reached performing polynomial number steps reduces small probability chance reaching connected demonstrated upcoming lecture algorithm performed logarithmic space storing current location destination steps polynomially large representable logarithmic bits model model randomness equipping standard turing machine random bit tape nite control one-way read access assume tape lled bits perfectly uniform distribution computation begins machine one-way read-only access random bit tape counted space reuse random stored work tape random takes single computational step read entry random bit tape time space complexity classes bptime bpspace analogous deterministic counterparts represent classes problems solvable randomized machine time space bound requirement error speci cally refer classes bpp bounded-error probabilistic polynomial time bpl log space complexity classes exist -sided -sided machines rtime rspace speci classes refer problems solvable randomized machines meet criteria error error zptime zpspace speci cally classes zpp zpl refer problems solvable -sided randomized machines machines meet criteria error unknown claim class zpp equivalent class problems solvable randomized machines chance error run expected polynomial time call class zpp proof zpp machine run repeatedly outputs nite answer nition zpp run halts polynomial time outputs answer probability running time zpp algorithm expected running time modi algorithm run time summationdisplay summationdisplay machine expected running time polynomial satis nition zpp similarly zpp machine run clock run time terminated output unknown modi algorithm outputs unknown probability markov inequality ensure probability outputting unknown set algorithm satis error criterion zpp runs polynomial time zpp algorithm language claim zpp corp proof claim left exercise space complications deterministic setting log-space algorithm terminates polynomial time terminates due polynomial bound number machine con gurations repeated con guration signi loop occurs machine halt things complicated randomness involved discussing space bounds setting assume machines halt deterministic setting requires machine repeats con guration introduce non-halting loop restriction nice property randomized log-space machine runs polynomial time general space machine runs time note machines type distinct halt probability separate class zpl type machine addition power model stated claim leave exercise claim zpl nitional issues ect power randomness log-space setting survey relation deterministic classes relating randomized classes deterministic classes measure computational power zpp bpp exp inclusion nition bpp exp fact exponential time cient compute probability acceptance randomized machine exhaustively generating coin results suppressl zpl bpl uniformnc dspace log uniform dspace log proof similar suppressl lecture bpl uniform takes bit work claim bpl uniform proof bpl computation viewed markov chain machine con gurations log-space machine size set con gurations polynomial markov chain represented matrix entry mij representing probability transitioning state state multiplying matrix times probability matrix state transitions taking steps determine probability reaching accepting con guration pmm iterated matrix multiplication discussed time uniform fact tighter bound class bpl claim bpl dspace log proof claim presented future lecture evidence conjectures bpp bpl complexity classes ignore constant-factor increases facts proving nal problem homework proposition bppbpp bpp bpp bpp bpp results relate randomized complexity classes deterministic nondeterministic complexity classes result relates randomized class bpp non-uniform class poly showing general randomness replaced non-uniformity theorem bpp poly bpl poly proof bpp 
algorithm rst make probability error smaller number inputs length error recall section running bpp algorithm error times taking majority vote results bpp algorithm computing language error assume original error pick large large ces meaning resulting bpp algorithm runs polynomial time reduced error distinct setting random bit tape probability exists input length machine makes error exists coin sequence machine correct result inputs length sequence coin ips advice amount randomness polynomial polynomial amount advice stated conjectured bpp unable prove fact prove bpp shown bpp lies polynomial hierarchy theorem bpp proof theorem presented lecture lecture lecture expanders tool error reduction fewer random bits reducing number coin ips improve ciency trivial derandomization evaluating series ips expanders analogous pseudorandom number generators short random input deterministically produce series pseudorandom bits randomized functions random address issue model relies series bits randomness unbiased uncorrelated functionally impossible achieve real world expanders transformation series bits randomness essentially perfect randomness michael saks randomization derandomization space-bounded computation annual conference structure complexity theory complexity theory lecture expanders instructor dieter van melkebeek scribe nathan collins lecture introduced randomized computation terms machines access source random bits return correct answers time showed bpp polynomial-size circuits conjecture community bpp today introduce expanders type graph improving amplifying randomized algorithms additional random bit overhead prove theorem relating bpp polynomial time hierarchy hierarchy results bpp generally introduce computational model hierarchy results class problems solve model question depend resources allowed hierarchy results computable enumeration machines type question shown exercise exist computable enumeration randomized machines error probability bounded typical hierarchy arguments fail randomized machines typical hierarchy arguments tailored prove hierarchy theorem modified model randomized computation called promise-bpp hierarchy result bpp bpp poly time hierarchy don bpp bpp bpp theorem bpp proof fix randomized polytime machine accepts bpp number random bits running inputx size show bpp bpp cobpp bpp completing proof remove randomness computation input space r-bit strings partitioned pieces acc set random strings accepts rej set strings rejects error rate small acc larger rej acc smaller rej xnegationslash figure random computation small error rate correct random bit strings turn idea shifts acc cover space r-bit random sequences shifts acc fail cover space xnegationslash shift shifting invertible symbol denotes xor equivalently addition acc rej rej acc figure error rate small acc larger rej acc smaller rej xnegationslash shifts give -predicate intuition discussed tuniondisplay acc poly pick poly -predicate provided verify membership uniontextti acc time poly membership check problem equivalently check acc polytime corresponds running random bit string poly-many show pick suitable poly make true showing choose randomly high rate success cases fixed tuniondisplay acc rej rej probability rejects accept larger union bound negationslash tuniondisplay acc choice work choice bit string makes reject tuniondisplay acc tsummationdisplay acc acc xnegationslash choose works provided definition bpp majority vote trick introduced lecture runs reduce error runs random bits suffices choose poly large fact logr works examination shows time complexity logt original run-time expanders proof theorem majority vote trick exponential increase accuracy linear increase random bit usage expander graphs introduced lead amplification technique exponential accuracy improvement constant increase random bit usage versus expanders mention lecture lectures definition -expanding graph -expanding implies neighborhood notice graph trivially -expanding definition expander family expander family infinite sequence graphs fixed numbers degree -expanding number vertices intuitively expander graphs connected number vertices reachable subset vertices proportional size subset subsets aren large make impossible graph theoretic properties assume graphs d-regular describe d-regular graph normalized adjacency matrix view expander graphs proves analysis properties randomized algorithms make definition normalized adjacency matrix d-regular normalized adjacency matrix defined aij braceleftbigg normalized adjacency matrix describes markov chain random walk aij state state column vector probability vertex probability vertex random step normalized adjacency matrix number properties proved basic linear algebra properties prove proposition real-symmetric eigenvalues real basis orthogonal eigenvectors turns eigenvalues normalized adjacency matrix expander closely connected expanders graph properties basic properties proofs omit proposition normalized adjacency matrix graph vertices eigenvalue satisfies eigenvalue eigenvector uniform distribution multiplicity eigenvalue greater iff disconnected eigenvalue iff bipartite uniform distribution eigenvector remaining eigenvector values turns largest eigenvalue absolute work definition max largest eigenvalue eigenvector orthogonal connected bipartite theorems proven notes spring proofs theorem -expanding function depends corollary expanders positive spectral gaps expander families spectral gaps bounded spectral gap graph theorem -expanding function depends light theorems defined expander families definition d-regular families positive spectral gaps expanders uniform distribution fixed point proposition tells larger spectral gap faster arbitrary probability distribution converges uniform distribution random walk lemma probability distribution vector bardblatp ubardbl bardblvbardblq qbracketrightbig q-norm proof atp nsummationdisplay nsummationdisplay probability distribution write summationtextiaiei form orthogonal eigen basis aei iei u-component bardblat bardbl bardblat summationdisplay aieibardbl bardbl summationdisplay tiaieibardbl tbardbl summationdisplay aieibardbl tbardblp ubardbl bardblp ubardbl bardblubardbl bardblpbardbl bardblpbardbl andbardblvbardbl bardblvbardbl vectors cauchy-schwartz inequality bardblat bardbl bardbl bardbl bardblat bardbl nbardblat bardbl braceleftbigg combining bardblat bardbl nbardblat bardbl tbardbl bardbl completing proof lemma prove random walk algorithm undirected path problem polynomially steps path bpl proof lemma exercise exercise connected bipartite constructions prove expanders exist argue randomly chosen d-regular graph high probability expander expanders reduce amount randomness needed random algorithms randomness construct expanders won explicit constructions vertex index compute ith neighbor time poly integer expander vertices edges relations graph degree proof construction works non-trivial notes partial proof harmonic analysis efficient constructions expanders aforementioned expander suffices notes spring constructions applications expanders purposes deterministic amplification randomized algorithm random bits reduce error arbitrary additional random bits requires running poly times randomness efficient amplification withrandr reduce error arbitrary log additional random bits running log times accomplish amplifications expander graph vertices oneto-one correspondence bit strings application runr vertex random bits run run neighbor random bits application starting perform random walk starting length log vertices run vertex random bits cases finish taking majority vote runs discuss applications prove correctness lecture time lecture prove correctness algorithms applications accomplish prove lemma expander mixing lemma d-regular expander graph radicalbig radicalbig set edges connecting notice number ways choose edge choices starting vertex degreed choices ending vertex probability randomly chosen vertices lies complexity theory lecture amplification instructor dieter van melkebeek scribe matthew anderson lecture introduced expander graphs combinatorial point view sparse 
graphs vertex constant degree non-trivially expanding algebraic point view expanders graphs constant degree recall largest absolute eigenvalue normalized adjacency eigenvector perpendicular vector today discuss applications expanders performing correctness amplification randomized algorithms application decreases error rate algorithm additional randomness application decreases error rate algorithm slightly randomness expander properties determines quickly random walks converge uniform distribution lecture showed probability distribution normalized matrix uniform distribution bardblatp ubardbl distance uniform distribution random walk arbitrary distribution decreases exponentially number steps lhs equation written definition -norm bardblatp ubardbl max atp bardblatp ubardbl distance uniform distribution random walk set vertices logv random bits select vertex random property vertex selected uniformly tlogd bits fixing start vertex performing random walk steps important algebraic property expanders called expander mixing lemma lemma expander mixing lemma radicalbig lemma bounds difference distributions picking vertices uniformly random term left picking vertex neighbor vertex random term left case logv random bits case logv logd random bits idea amount randomness reduced cost producing distribution uniform proof expander mixing lemma recall symmetric real implying full orthonormal eigenbasis number edges sets written terms relative characteristic vectors iff standard adjacency matrix real symmetric matrix full orthonormal eigenbasis rewritten terms components parallel perpendicular uniform vector recall eigenvector eigenvalue product bardbls equation rewritten bardbls bardblt bardblsda bardblt sda bardbls bardblt sda sda lines follow bardbl eigenvector causing term simplify cross terms vanish dividing moving terms taking absolute bardbl sbardbl bardbl tbardbl line reached applying cauchy-schwarz rhs fact decreases magnitude component applying pythagorean theorem simple algebra tobardbl sbardbl derive ofbardbl sbardbl bardbl sbardbl bardbl bardblsbardbl bardbl sbardbl bardbl sbardbl bardbl sbardbl bardbl sbardbl radicalbig substituting back forbardbl sbardbl andbardbl tbardbl pulling factor square root completes proof properties reduce error probability randomized algorithms extra random bits deterministic amplification expanders transform random algorithm takes random bits errs probability equivalent algorithm random bits errs probability calling poly times idea transformation explicit expander graphgwith vertices vertex random bit string pick vertex random random bits neighbors distance run neighbors return majority vote neighbors output intuitively expanding set neighbors distance spread graph close uniformly distributed analysis set bad random strings strings give wrong answer input set bad random strings strings majority neighbors distance give wrong answer incorrect answer majority give incorrect answer construction order required error fixing half neighbors incorrect applying expander mixing lemma radicalbig extra terms expression dropped equal rearranging terms bounding constant decrease error effect taking neighbors distance neighbors replace vertices edge vertices path length multiple edges vertices effect increasing degree decreasing eigenvalue prior analysis holds substituted result equation give selecting log error number neighbors distance log polynomial complexity determining neighbors polynomial explicit expander construction reduce error poly constant polynomial time randomness original algorithm randomness efficient amplification idea application reduce error additional randomness random algorithm random bits errs probability transformed equivalent algorithm log random bits error callingronlyo log times total notice construction acheive exponentially small error polynomial time slightly randomness transformation trivially rlog bits sampling log random strings achieve additive result suggested order improve trivial result perform variation approach previous application pick uniform random random walk lengthtstarting run majority vote idea job previous application randomness work neighbors distance visited neighbor distance visited analysis key lemma bound error approach lemma projection errs vector bardblpaxbardbl radicalbig bardblxbardbl proof representation xbardbl eigenbasis respect stated earlier triangle inequality bardblpaxbardbl bardblpaxbardblbardbl bardblpax bardbl facts bad set small projects bad set contracts bardblpaxbardblbardbl bardblpxbardblbardbl bardblxbardblbardbl bardblpax bardbl bardblax bardbl bardblx bardbl substituting back original equation bardblpaxbardbl bardblxbardblbardbl bardblx bardbl bardblxbardblbardbl bardblx bardbl radicalbig bardblxbardbl inequality cauchy-schwarz lemma bound error probability probability errs probability half steps random walk fell set errs errs fall set errs summationdisplay ith step lies bad set summationdisplay bardblmtamt aubardbl summationdisplay nbardblm aubardbl summationdisplay parenleftbigradicalbig parenrightbig bardblubardbl summationdisplay parenleftbigradicalbig parenrightbig parenleftbigradicalbig parenrightbigt radicalbig line upper bounds actual probability counting bad strings probability rewritten matrix line line repeated applications lemma constant number iterations decrease making maximize rhs deterministic amplification procedure acheive walking log steps give error procedure random bits pick starting vertex logd bits log steps random walk total log random bits results stronger result considers variance random walks expander chernoff bound states random walk fraction times walk lands bad set vary expected number indicator variable event ith step lies set probability walk varies expected number steps bad sets written tsummationdisplay universal constant probability walk varies expected constant decreases exponentially increases inequality reduces standard chernoff bound complete graph rank independent time lecture discuss pseudorandom generators space-bounded computation application expanders application leverages power pick vertex neighbor random picking vertices uniformly random apply procedure recursively construct pretty good pseudorandom generators pseudorandom number generation dual amplification pseudorandom number generation reduce amount randomness making error grow complexity theory lecture space-bounded derandomization instructor dieter van melkebeek scribe jake rosin time expanders reduce error probabilistic algorithms increasing randomness small amount today attempt opposite reducing amount randomness required bounded increase error lecture focuses derandomization space-bounded setting lecture derandomization time-bounds pseudorandom generators definition -prg class algorithms collection deterministic procedures number random bits denotes bits uniform distribution means finitely note decision algorithm equivalent bracketleftbig bracketrightbig important parameters definition error deviation original randomized algorithm original algorithm probability error probability error algorithm small suffices small amplification techniques discussed previous lectures seed length number random bits required inputto pseudorandom generator small complexity measured terms output length prgs low complexity generate random bits increase total cost running randomized algorithm prgs pseudorandom generators reduce amount randomness required run randomized algorithm side effect reduce complexity deterministic simulation randomized algorithm explicitly computing probability acceptance set prg seeds -prg bptime computable dtime bptime dtime cycling random seeds running algorithm output outputting majority answer seed random string generated taking time algorithm run additional steps enumerates seeds cumulative error majority vote correct answer similarly -prg bpspace computable dspace bpspace dspace prg computable polynomial time logarithmic seed length bpp similarly prg logarithmic seed length runs log space bpl pseudorandom generators exist approach attempt prove containments space-bounded derandomization construct log space computable prg logr seed length nontrivial constructions approaching goal present construction based expanders theorem exists -prg bpspace log log computable space corollary -prg bpl log computable space log bpl dspace 
log due bpl theorem shows prgs idea proof dividing space-bounded randomized computation phases phase random bits operation machine bounded space bits pass phase phase pairing blocks expander produce random bits reduce level randomness machine expander degree vertices produce pseudorandom bits choosing vertex expander random moving random neighbor equivalent selecting edge random endpoints requires seed length logd random bits block pair reduced amount randomness process diagrammed figure expander good output modified block pair differ greatly output original rely expander mixing lemma prove call distribution input output resp states block pair sin sout random inputs pair left distributions left alternative construction show bpl dspace log bound blocks logd logd logd block pairs figure dividing computation blocks bits passing block original computation shown shown random bits adjacent blocks coming picking adjacent vertices expander random original randomized input pseudo-random ulogd output expander note -th neighbor expander lemma bounds difference output distribution scenarios lemma distribution sin bits largest eigenvalue expander sout sin sout sin ulogd prove lemma finish description proof prg lemma bound difference output distribution running algorithm purely random bits versus running algorithm grouping pairs blocks producing random bits expander hybrid distributions wheredi distribution formed random distribution blocks switching pseudo-random distribution remainder thusd perfectly random pseudo-random difference distributions difference randomized algorithm pseudorandom version triangle inequality key lemma find summationdisplay bound error introduced step derandomization amount randomness reduced block pair logd savings roughly constant large savings note reduced original block chain easier instance problem blocks taking logd random bits computational blocks paired logd random bits generated expander pairing blocks recursively shown figure results prg parameters bound found summing previous errors logd reduction requires additional logd random bits space complexity compute output bit prg compute neighbor relations series expanders computed linear space amount space topmost level dominates total space prg defined related important terms parameters prg constant degree expander constant eventually overshadowed resulting grow begin constant-degree constantexpander raise t-th power allowing multi-edges graph results simple expression degree spectral gap error prg satisfy logd logd logd logd logd logd blocks figure recursively pairing blocks applying expander expansions cover entire computation rearrange derive plug degree determine seed length log log logd blocks construction block random bit seed length defined log term grows descends remarked setting terms equal solving result minimal constant factors log seed length log log finishing proof theorem remains prove lemma notice construction block treated black box connection blocks bits representing state machine algorithm relies bits transmitted blocks places limit computations performed block individually prg works algorithm divided blocks limited communication block block block unbounded space proof lemma expander mixing lemma proof involves finding sets apply lemma proof notice prove lemma point distributions point distributions place probability single point distribution sin convex combination point distributions randomized process quantity sin bardblz sin sin ulogd bardbl triangle inequality -norm sin point distribution sin defined sin sout distributions inputs outputs pair blocks definesmid distribution states control passes block pair distribution represent probability moving input state sin output state sout perfectly random bits sin sout summationdisplay smid sin smid sout summationdisplay smid left defined ssin smid left sin smid tsmid sout smid sout terms notation expander mixing lemma equation written summationtextsmid left chosen independently random pseudorandom distribution probability picking edge replaced expander mixing lemma vextendsingle left sin sout left sin sout vextendsingle vextendsingle summationdisplay smid summationdisplay smid vextendsingle summationdisplay smid radicalbig inequality represents probability generating single fixedsout find difference probability sout sum sout sin random sout sin pseudo summationdisplay sout summationdisplay smid radicalbig cauchy-schwartz bound summation summationdisplay sout summationdisplay smid radicalbig sout summationdisplay smid sout summationdisplay smid definition provided clear summationtextsmid similarly order summations term reversed summationtextsout demonstrated sout sin random sout sin pseudo alternate proof theorem usinguniversal hashfunctions exists shows bpspace dtisp proof general discussed due sole requirement computation divided discrete blocks limited communication alternate proof shows bpspace dspace exploiting properties construction inclusion improved bpspace dspace randomness conjectured provide constant factor improvement space complexity overhead lecture lecture time-bounded derandomization time-bounded setting non-trivial derandomizations surprising bpp exp perform non-trivial derandomizations reasonable assumptions exists problem linear exponential time requires circuits linear exponential size bpp words non-uniformity doesn speed computations randomness complexity theory lecture time-bounded derandomization instructor dieter van melkebeek scribe tom watson lecture introduced notion pseudorandom generator prg showed prgs derandomization developed construction prg fools spacebounded computations developed prg seed length log fools bpl computations time-bounded setting nontrivial unconditional prg constructions constructions work reasonable complexitytheoretic hypotheses lecture present construction due nisan wigderson ciently strong reasonable hypothesis prg show bpp pseudorandom generators time-bounded computations distinguishability recall prg takes random seed length produces pseudorandom string length prg ciently computable deterministic machine prg called quick computed time time linear exponential seed length show exists language large average-case circuit complexity exists quick prg short seed length fools time-bounded randomized computations formalize notion average-case complexity section lecture error-correcting codes relax hypothesis existence average-case hard language existence worst-case hard language notion quickness cient cryptographic setting prgs typically required computable time polynomial seed length cient goal reduce amount randomness needed computation present focus full derandomization achieved seeds explicitly computing probability algorithm accepts pseudorandom distribution setting time seeds factor overhead computing prg output polynomial overhead time guage quality prg construction measures powerful computations fool allowed fool computations measures formalized parameters nition definition -prg circuits size family functions circuits inputs size vextendsinglepr bracketleftbigc bracketrightbig rbracketleftbigc bracketrightbig vextendsingle chosen uniformly random intuitively nition means circuit size trouble distinguishing input sampled uniform distribution pseudorandom distribution questions nition naturally present require prg fool circuits interested fooling uniform computations bptime computations mimicked circuits size polynomial prg fool uniform computations prg succeed fooling computations nitely inputs easily captured nonuniform setting constructing erent circuit input input hard-wired random bits left inputs circuit turns arguments critically nonuniformity circuits results start uniform hardness assumption results aren strong require prg fool circuits linear size parameter size circuit number inputs arguments cleaner harm allowing circuit random bits mimicking uniform computation circuit yield circuit larger number random bits computation won ected allowing prg provide random bits recall lecture prg full derandomization seeds explicity computing probability acceptance algorithm pseudorandom distribution running time 
time run prg seed time run simulation algorithm times seeds quick prg logr seed length full derandomization runs polynomial time implying bpp ultimate goal show ciently hard function exists prg exists predictability provided random seed prg produces output distribution seed length ideally smaller output length pseudorandom distribution mass strings length sense uniform distribution issue pseudorandom distribution computationally indistinguishable uniform distribution circuits nition viewed statistical tests require pseudorandom distribution pass tests computable small circuits rst step show restrict class statistical tests interested circuits attempt predict ith bit pseudorandom string rst bits predictor exists uniform distribution circuits succeed predicting bit sample probability principle advantage predicting bit gained fact input sampled pseudorandom distribution intuitively lot computation required prediction leave exercise show circuit succeeds probability predicting ith bit rst bits sample pseudorandom distribution yields circuit essentially size distinguish pseudorandom distribution uniform distribution amount sense nition indistinguishable distribution unpredictable conceivable distinguishing easier task predicting show unpredictable distributions indistinguishable uniform distribution sense focus orts constructing prg unpredictable output distribution theorem exists circuit size vextendsinglepr bracketleftbigc bracketrightbig rbracketleftbigc bracketrightbig vextendsingle exists circuit size parenrightbig ibracketrightbig proof distinguisher construct predictor rst task determine bit position predicted hybrid distributions consists samples rst bits chosen output distribution remaining bits chosen uniformly random uniform distribution strings length output distribution intuitively circuit behaves distributions give idea good predicting ith bit rst bits pseudorandom sample distributions similar ering ith component argue formally shorthand prdi probability outputs sample distribution vextendsingleprdr prd vextendsingle vextendsingle rsummationdisplay parenleftbigpr prdi rsummationdisplay vextendsingleprdi prdi vextendsingle prdi prdi choose index predictor rparenrightbig bracketrightbig ers rparenrightbig bracketrightbig probabilities chosen uniformly random circuit appears good job detecting ith bit input pseudorandom distribution predictor takes input bits predictor rst bits sample averaging argument setting tildewide tildewide inputs tildewide tildewide rparenrightbig bracketrightbig ers tildewide tildewide rparenrightbig bracketrightbig probabilities chosen uniformly random hard-wire inputs ecting circuit size note critically fact dealing nonuniform circuits handle separately bit circuit output provided rst bits sample pseudorandom distribution provided rst bits random bit suggests construct randomized predictor rst bits sample pseudorandom distribution coin determine evaluate tildewide tildewide evaluates assume guess correct output output formally tildewide tildewide proof claim left exercise claim prbracketleftbigp parenleftbig iparenrightbig ibracketrightbig probability behavior predictor undesirable feature ips coin advantage fact nonuniform setting hard-wire tildewide circuit retains advantage predicting ith bit yields predictor tildewide tildewide tildewide tildewide expressed circuit size possibly additional gate assume doesn increase size circuit predictor satis parenrightbig ibracketrightbig desired nisan-wigderson construction average-case circuit complexity construct -prg circuits size argued circuit size distinguishes pseudorandom distribution uniform distribution amount exists index circuit size succeeds predicting ith bit sample rst bits advantage trivial bound task reduced constructing prg small circuit gain signi advantage predicting bit sample previous bits intuitively suggests prg generate bit output applying hard function argue small predictor circuit index construct circuit evaluating function generate ith bit formalize precise notion hardness definition language average-case hardness input length denoted largest circuit size compute correctly fraction inputs length note computing correctly fraction inputs length trivial constant constant job average-case hard function hard compute hard compute correctly noticeably half inputs nition refer size circuits consideration degree hardness main reason number parameters small analysis works cleanly measuring hardness nonuniform circuits good reason arguments crucially nonuniformity gain intuition nition mentioned previous lecture predicate bits computed circuit size smaller condition nition easier satisfy circuits consideration computationally restricted required compute inputs serves measure average-case hardness input length prg construction suppose language circuit size circuit size compute probability inputs length chosen uniformly random suggests approach constructing prg chosen independently uniformly random apply viewed function producing bit yielding output string lengthr intuitively bit output distribution prg predictable samples chosen independently predictor advantage computing output distribution prg unpredictable theorem indistinguishable uniform distribution desired proceed formalize vague idea awed issue naturally arises computing output function require computing assumed hard compute length computing ideally output length complexity computing prohibitive critical problem construction takes seed length outputs bits seed length smaller larger trivial build prg seed length large output length output bits seed yielding uniform output distribution reason construction requires long seed chosen independently show sacri cing independence drastically reduce seed length quality output distribution deteriorating accomplish taking seed length selecting subsets bit positions seed letting bits seed indexed seed illustrated desired subset construction formalized nition definition -design size sequence subsets inegationslash prg output length large time pairwise intersections small independent possble goals odds lemma shows fact exist designs large subsets ciently computed lemma logr exists efficiently computable logr -design size proof assume prime power round power ect constant factor identify ith univariate polynomial degree logr obvious logr fact polynomials degree logr represent distinct functions logr leave exercise pair fewer logr points common number subsets provided mlogr subset computed simple arithmetic ciently purposes give detailed analysis ciency condition logr problem constraint logr position fully prg set obtain logr -design lemma prg straightforward verify computable linear exponential time prg quick remains show construction fools circuits size ciently hard theorem construction -prg circuits size proof prove theorem contradiction suppose circuit size vextendsinglepr bracketleftbigc bracketrightbig rbracketleftbigc bracketrightbig vextendsingle show exhibiting circuit size solves length fraction inputs contradicting assumed hardness theorem exists circuit size parenrightbig ibracketrightbig construct small circuit approximate length intuitively approximating input fact averaging argument setting bits indexed predictor maintains advantage critically fact working nonuniform circuits renaming letting tildewide denote bits lls positions indexed rest positions xed tildewide tildewide parenrightbig bracketrightbig probability chosen uniformly random sort behavior construct circuit takes input takes rst bits output attach circuit computing computing involves computing critical observation entire argument input depends logr bits logr jnegationslash computed circuit size logr limited pairwise intersections subsets design key avoiding inherent complexity computing allowing contradiction jth input attach circuit size computing tildewide tildewide illustrated obtained circuit size succeeds computing probability choice conclude contradiction theorem proved summarize proof assumed prg output distribution distinguishable uniform distribution small circuit theorem obtain small predictor circuit bit pseudorandom distribution connected additional small circuitry predictor convert small circuit approximated showing hard eliminate parameter setting obtain clean corollary corollary exists quick r-prg circuits size seed length remark languages satisfy hardness condition arbitrary circuits 
interesting values lecture exist languages requiring large circuits worst case conjectured true average-case hard languages exist extensions constant-depth circuits previous lecture average-case hardness results parity constant-depth circuits hardness results nisan-wigderson construction yields unconditional prgs constant depth circuits supposing distinguisher prg output distribution obtain predictor theorem increasing depth nal circuit approximating parity obtained adding depthcircuits computing rst bits prg output dnf cnf prg succeeds fooling constant-depth circuits polylogarithmic seed length involves computing parity short strings space-bounded derandomization similar construction discussed today yields prgs branching programs space-bounded derandomization exists language dspace average-case hard linear exponential size branching programs construction yields conditional prg space-bounded computations worst-case average-case reductions lecture error-correcting codes relax hardness requirement average-case hardness worst-case hardness show encoding characteristic sequence worst-case hard function good error-correcting code yield average-case hard function circuit approximates encoded function combined cient decoder compute original function input combining technique results today lecture obtain prg fools polynomial-size circuits logarithmic seed length leading result theorem exists language requiring linear exponential size circuits bpp nisan wigderson hardness randomness journal computer system sciences complexity theory lecture error-correcting codes instructor dieter van melkebeek scribe matt elder lecture constructed family quick pseudo-random generators based assumption exists language high average-case hardness lecture extend results show worst-case hardness length substituted average-case hardness length lecture prove fact error-correcting codes codes construct language average-case hardness close worst-case hardness language pseudo-random generators yield derandomization time found generate efficient pseudo-random generators precisely suppose function logr design construct function key property -prg circuits size demonstrated efficient design quick time linear-exponential hard language exists construct pseudo-random generator bpp algorithm problem deterministic algorithm solve problem construct prg takes random seed length outputs pseudo-random string length seed run replacing random bits accept accepts seeds reject complexity small prg fool deterministic algorithm problem solves results exists language build takes input bits bpp subexp exists language build takes logr input bits bpp dtime logn exists language build takes logr input bits bpp implication clogr logr design logr show build takes logr input bits assert design exists omit construction implication implies corollary corollary bpp zppnp proof definition language bpp poly-time bounded-error randomized algorithm shown algorithms derandomized functionf hardness characteristic string function length counting argument characteristic strings functions bits hardness bpp algorithm algorithm zppnp pick random function logr oracle exists circuit size computes function logr bits predicate small circuit halt return construct pseudo-random generator built hard function run derandomized version accept accepts reject rejects candidates forf hard languages algorithm halts fails low probability cases outputs correct answer zppnp algorithm language solved algorithm bpp solved zppnp bpp zppnp discuss converse implications showing hard languages imply prgs show prgs imply hard languages pseudo-random generators yield circuit lower bounds theorem exists -prg computable fools circuits size exists language circuit complexity greater proof idea proof prgg construct language differentiates distribution generates uniform distribution prg language high circuit complexity note length output larger length input existence trivial output bits assume takes bits bits language braceleftbig bracerightbig suppose circuit decides language line holds definition line holds maps inputs distinct outputs statements show differentiates distribution generated uniform distribution undifferentiable circuit size circuit size greater true circuit decides language circuit complexity greater determine naive algorithm compute seeds output assume cycle seeds computation takes time showing implication ways exist quick prgs fool circuits size iff exist functions circuit complexity greater error-correcting codes informally error-correcting code function set information words set codewords codeword not-too-large fraction bits flipped information word retrieved error-correcting codes encode information manner robust amount error error-correcting codes relate language high average-case circuit complexity language high worst-case circuit complexity suppose characteristic sequence inputs length ith bit iff ith m-bit word language language characteristic sequence inputs bits codeword information word error-correcting code relate complexities languages error-correcting code properties ecc handle error rates high small ecc employs local decoding single bit information word derived examining small portion codeword ecc encode polynomial time implies positive constant usefully discuss properties formally define error-correcting codes definition error-correcting code ecc alphabet function distinct hamming distance greater suppose process word ecc producing suppose uncontrolled conditions flip bits code word random producing received word perturb destroying memory fewer bit flips occurred legal codeword detect bits changed fewer bit flips occurred terms hamming distance closer legal codeword corrected parameters ecc optimize relative distance make large rate make small hamming distance binary strings equal length number bits differ complexity encoding decoding low rate relative distance sense opposed small rate restricts minimum hamming distance codewords leaves extra space codes interested belong general class eccs called linear errorcorrecting codes intuitively codeword bit linear function message bits define formally definition ecc linear range linear subspace rank prime power designate linear ecc square brackets linear ecc nice properties generator matrix discuss give examples linear eccs hadamard code hadamard code takes information word codeword concatenation dot products binary words length code relative distance good rate bad decode received word encoded mangled piece received word position suppose bit values differ bit pick uniformly random bit bit uniformly random aiei correct correct probability decode single bit examining greater long error rate transmission slightly correct errors relative distance ecc error-correction rate algorithm yields arbitrarily close rate reed-solomon code thereed-solomon codetransforms theinformation worda thecodeword polynomial degree coefficients digits code relies fact polynomials degree points intersection meaning distance distinct codewords parameters reed-solomon code reed-solomon code yields adjustable trade-off rate relative distance fairly easy encode decode heavily communications data-retrieval applications reed-solomon code unsuitable purposes decoding methods nonlocal retrieve single bit codeword requires examining entire received word reed-m uller code reed-solomon code univariate polynomials reed-m uller code variate polynomials information word composed elements transformed codeword elements reed-m uller code achieves relative distance encoding naive encode consisting coefficients needed m-variate polynomial variable degree output polynomial m-tuples inputs interpretation message prove decoding encode information word produce m-variate polynomial record outputs produce denote ith invertible map integers subcube size define compute cousin polynomial defined m-variable constant vector inside thesm-subcube andqc values inside sm-subcube construct mproductdisplay productdisplay jnegationslash normalization constant values xnegationslash sm-subcube index xinegationslash construction multiplicand form note degree compose desired polynomial polynomials compose vector orthogonal basis explicitly smsummationdisplay aiq 
degree degree constructed information word produce codeword concatenating values codeword copy indices correspond sm-subcube interpolated decoding present method decoding reed-m uller code assumption error rate transmission greater artificially low didactic purposes method nice local decoding decoding algorithm reed-m uller code corrects higher errors page suppose received word denote position denote analogous position correct codeword retrieve ith digit message determine determine pick random point select distinct values tnegationslash examine polynomial degree assume thatp values chosen determine polynomialp evaluate point query uniform probability negationslash query assumption probability negationslash selected values selected process correct decoding probability repeat process random values majority vote make decoding algorithm work probability small parameters previously mentioned smmm kmm polynomial size property constructions satisfy requirement arbitrary setting logk loglogk logk small madhu sudan luca trevisian salil vadhan pseudorandom generators xor lemma computer system sciences preliminary version proc acm stoc accessed http berkeley eluca pubs complexity theory lecture worst-case average-case reductions instructor dieter van melkebeek scribe tom watson lecture discussed applications nisan-wigderson pseudorandom generator showing language ciently average-case hard nonuniform circuits bpp ciently simulated deterministically ciency simulation depends hardness introduced idea error correcting codes relax hypothesis existence average-case hard language existence worst-case hard language local decoding procedure reed-muller codes today discuss paradigm list decoding describe local list decoding algorithm hadamard code show local list decoding algorithms obtain strong worst-case average-case hardness reductions finally introduce notion randomness extraction worst-case average-case reductions error correcting codes local list decoding suppose language family small circuits compute goal show exists language family small circuits compute family small circuits succeed computing noticeably half inputs strategy characteristic sequence input length string length encode good binary error correcting code ecc obtain string length larger interpret encoding characteristic sequence language input length intuition solved noticeably half inputs small circuit characteristic sequence function computed circuit viewed corrupted version original information word obtained cient decoding procedure allowing solve inputs ecc properties argue ciently hard construct small circuit computing circuit string length required compute bit string received word exponentially longer problem traditional decoding algorithms entire received word compute single bit information word local decoding algorithm index case bit information word computes bit making randomized queries received word lecture local decoding algorithms hadamard reed-muller codes hard solve half inputs decode fraction errors large small problematic correct fraction errors relative minimum distance ecc greater imply ecc minimum distance close problem argue distance hope case binary codes list decoding algorithm received word computes information words encodings distance dealing circuits nonuniformly select information word correct naturally fraction closer half number codewords distance grows show number grow large describe list decoding algorithm hadamard code today finally require cient encoding procedure ecc show shown combining exponential-time algorithm cient encoding procedure ecc fact constant factor larger show average-case hardness comparable worst-case hardness ultimate goal show linear exponential worst-case circuit complexity linear exponential average-case circuit complexity previously existence obtain quick pseudorandom generator logarithmic seed length conclude bpp properties ecc cient local list decoding algorithm give full details construction desired properties realized concatenation hadamard code reed-muller code local list decoder reed-muller code obtained local decoding approach discussed lecture combined list decoder reed-solomon code decoder involves technical procedure factoring bivariate polynomials today describe local list decoding procedure hadamard code local list decoders codes easily combined form local list decoder concatenation section show leads desired worst-case average-case reduction error correcting code constructions recall hadamard code code encodes information word codeword takes product bit string length outputs list results minimum distance code case binary codes distance hope asymptotically good minimum distance hadamard code horrible rate practical complexity theory code handle fraction errors require unique decoding good achieve strong hardness results show contenting list decoding handle fraction errors half reed-solomon code ecc minimum distance close locally decodable query positions received word order reconstruct position information word reed-solomon code requires eld size large codeword length undesirable interested codes handle concatenating binary code hadamard code reed-muller code good local decoding algorithm recall reed-solomon encoding achieved interpreting information word low-degree univariate polynomial evaluating points eld reed-muller encoding achieved interpreting information word low-degree polynomial variables evaluating -tuples eld elements intuitively packing information -dimensional cube locally decode picking random line point cube evaluate original polynomial querying received word points line reed-solomon decoder reconstruct univariate polynomial original polynomial restricted line similar approach list decoder reed-solomon code local list decoder reed-muller code obtained explore result finally concatenating reed-muller code hadamard code yields code satis desired properties concatenating hadamard code binary code exponential blow-up hadamard code compensated fact eld size required reed-muller code doesn grow fast locally decodability property key worst-case average-case reduction list decodability property key overcoming upper bound distance code order acheive strong worst-case average-case reductions local list decoding hadamard code develop local list decoding algorithm hadamard code worry local decoding aspect natural feature algorithm received word error bound list information words encodings hamming distance minimum distance code list information word larger list naturally larger show large speci cally handle fraction errors randomized time poly received word length random access theorem randomized algorithm random access received word runs time poly outputs list information words high probability prx kbracketleftbig bracketrightbig outputs list information words hadamard encodings relative distance proof focus obtaining satisfying prx running procedure times concatenating lists list high probability information words desired level agreement recall lecture local unique decoder hadamard code idea retrieve ith bit picking random querying string ith position assuming encoding ered fraction positions conclude union bound probability positions correct case picking independently taking majority vote values obtain correct high probability present settting wrong fraction positions conclude probability positions correct obtaining idea require samples describe elaborate approach power list decoding reduce number samples needed focus retrieving component information word idea select uniformly random small determined obtain strings adding combinations empty combination formally nonzero values string tsummationdisplay cjxj note bit string length sum locations nonzero uniformly distributed proof claim event consideration holds index position agrees encoding claim nonzero knew values pick arbitrary query add result conclude con dence rst attempt words circumventing inherent unreliability two-query approach assuming correct answer queries show handle hypothesis power list decoding issue handle naturally 
boost con dence making queries choices majority vote values choices means make queries turns chosen small isn problem important issue alarmed fact strings nitely fully independent generated bits randomness pairwise independent note negationslash index nonzero equality prbracketleftbig bracketrightbig conditioning values turns pairwise independence good claim majinegationslash maji majority cnegationslash proof indicator random variable event guess correct order majinegationslash happen case summationdisplay cnegationslash claim cnegationslash linearity expectation majinegationslash summationdisplay cnegationslash bracketleftbig summationdisplay cnegationslash vextendsingle bracketrightbigg pairwise independent apply chebyshev inequality fact indicator random variable variance conclude majinegationslash parenleftbig summationtext cnegationslash parenrightbig summationtext cnegationslash union bound probability exists maji negationslash made choosing parenleftbig log parenrightbig summarize algorithm point rst choose uniformly random recover bit separately local decoding forming queries erent query guessing equals taking majority vote guesses argued succeed recovering information word correctly probability choice recovering position involves poly queries entire procedure runs time poly desired critical issue resolve entire procedure assumed knew values ridiculous list decoding algorithm sequence values cnegationslash possibilities sequence run algorithm possibility output list information words obtained probability appears list appears correct values sequence cnegationslash problem erent leading possibilities making running time exponential easily remedied recalling product linear tsummationdisplay cjxj tsummationdisplay values uniquely determined values reduce list size poly values sequence running time remains poly explains didn choose strings independently chose strings looked combinations approach list long order entries approach list size expense samples pairwise independent argued big problem local decoding algorithm discussed lecture basic idea proof recover querying random location received word querying location index ith bit ipped xoring results present setting errors received word reliable key idea drastically increase reliability queries uncorrupted unique decoding required possibilities correct values queries key idea list size small choosing small number query locations deterministically generating rest query locations adding combinations chebyshev inequality conclude reliability doesn deteriorate corollary result note received words number information words hadamard encodings agree fraction positions bounded poly running time algorithm finally note list output decoding algorithm information words encodings agreement received word weed randomly querying ensure high probability agrees encoding fraction locations small worst-case average-case reductions hadamard decoder previous section local list decoder reed-muller code obtain local list decoder concatenation codes precise result stated proof theorem exists error correcting code properties polynomial-time encoder mapping information words length codewords length poly codeword length assumed power randomized algorithm runs time poly outputs list randomized oracle turing machines input position information word oracle access received word run time poly logk machines property received words information words agrees encoding fraction positions exists mri computes show theorem worst-case average-case reductions theorem exists language proof language applying ecc theorem yields string length string solve taking input length computing length explicitly writing encoding extracting bit input writing takes positions computed time encoding takes time ecc theorem polynomial-time encodable solving incurs exponential factor blowup running time doesn prevent technique worst-case average-case reductions smaller classes show theorem follow fact fact exponential changing input length constant factor makes change polynomial factor set determined suppose exists circuit size input length computes bit fraction inputs machine mri theorem takes input length outputs position high probability solves provided string length agrees fraction positions probability ampli choice randomness mri solves inputs length hard-wiring choice randomness obtain oracle circuit size solving input length oracle gates queries replaced hypothesized circuit size theorem circuit size computes provided oracle subcircuit solves fraction inputs hypothesis conclude parenleftbigm parenrightbig constant ciently large circuit size succeeds computing length fraction inputs implies min parenleftbig parenrightbig term nitely dictates minimum choosing desired result corollary exists language exists language exists quick prg subpolynomial seed length implying bpp subexp corollary exists language exists language exists quick prg polylogarithmic seed length implying bpp dtime nlogo corollary exists language exists language exists quick prg logarithmic seed length implying bpp randomness extraction evidence randomness powerful terms reducing complexity solving decision problems unconditional pseudorandom generator fools space-bounded computations conditional pseudorandom generator fools time-bounded computations hypothesis exists language requiring linear exponential size circuits conjectured randomness lead polynomial factor savings time constant factor savings space randomness useless practice contrary quadratic speedup achieved randomness attractive practice additionally randomized algorithms simpler easier implement deterministic algorithms problems turn erent question randomized algorithm assume access perfect source unbiased importantly uncorellated random bits run algorithms access imperfect random source goal randomness extraction samples weak random source samples uniformly distributed generate samples close uniformly distributed weak random sources models physical sources randomness keystrokes delays networks extractor cient procedure taking sample imperfect source extracting randomness producing output string shorter closer uniformly distributed procedure run randomized algorithms weak random sources fact output distribution extractor close uniform small ect output distribution randomized algorithm embark task constructing extractor formalize amount randomness contained weak random source closeness uniform output distribution obtained applying extractor weak random source standard measure statistical distance idea measure entropy physics definition entropy discrete random variable bracketleftbig log bracketrightbig summationdisplay log sum range measure randomness work setting suppose range nonzero rest probability concentrated entropy measure fair amount randomness useless simulating bpp algorithm bad set input probability error input greater half require large amount randomness case string weight suggests measure definition min entropy discrete random variable mini log equivalently largest outcomes probability source bits randomness goal construct extractors source min entropy output distribution extractor statistically close uniform distribution strings length close good extractor obtained viewing input sample characteristic string function function nisan-wigderson pseudorandom generator construction details construction lecture complexity theory lecture randomness extraction instructor dieter van melkebeek scribe jeff kinne lecture briefly introduced paradigm randomness extractors recall analysis correctness randomized algorithms assumed source random bits perfectly uniform independent general access sources real world access weak random sources randomness source randomness extractors procedures applied weak random source extract bits close uniform independent run randomized algorithm output extractor confidence answer access perfect random sources today formally define randomness extractors explore applications give constructions weak random sources defining extractors quantify source amount randomness definition random variable min-entropy denote min-entropy show lecture source withh polynomial time source run polynomial time randomized algorithms addition shown source randomness extraction define formally definition close source min-entropy exercise min-entropy correct notion randomness goal call 
source weak random source number sources high min-entropy simple descriptions bit fixing sources sources number bits fixed adversarially remaining bits perfectly random source weak random source unpredictable sources sources bit unpredictable previous bits constant weak random source flat sources sources correspond uniform distribution subset range log source weak random source exercise shows fact flat sources base case sources high min-entropy handle flat sources handle random sources high min-entropy exercise random source convex combination flat sources subset size randomness extractor source randomness high min-entropy output distribution statistically close uniform ideally convert weak randomness perfect randomness additional perfect randomness shows proposition function taking input weak random source weak random source constant function proof setting outputs single bit output probability suppose define flat distribution min-entropy meaning output distribution constant taking weak random source input attempting output bits close uniform proposition shows weakest setting augment additional input perfect random source definition extractor extractor bardble umbardbl uniform variable bits uniform bits note equivalent event additional true randomness define extractor setting logn meaning amount true randomness needed small fact extractors section eliminate true randomness cycling strings number parameters definition optimize bounds proven extractor logn log log bounds intuitively perfect random bits index weak random source extract random bits contained combination weak source perfect random source shown picking function random logn log log high probability satisfies definition application interested act picking extractor random requires large amount perfect randomness application develop extractors computable deterministic polynomial time exercise show combination random source function satisfying source close source min-entropy fact justifies choice notion weak randomness applications give applications extractors achieve original goal simulating randomized algorithms weak random sources give alternate proof bpp application eliminate perfect randomness extractor logn cycling seeds areas feasible cryptographic settings luxury exist extractors called seedless extractors settings extractor takes input independent weak random sources outputs distribution close uniform discuss seedless extractors mention existence simulating randomized algorithms extractor input perfect random source simulating randomized algorithm extractor trivial describe simulation section removes perfect random source giving simulation correct high probability suppose randomized algorithm random bits extractor input simulate set count sample random source foreach count count count output output probability simulation errors bad set algorithm negationslash majr bad set simulation pry claim extractor proof suppose flat source notice min-entropy set difference probability assigned extractor uniform contradicting extractor claim compute probability simulation errors assuming extractor simulation errors source bit probability suffices efficiency simulation hopethat simulation incursonly poly factor overhead time simulating polynomial time algorithm takes polynomial time time complete simulation product time compute time original algorithm poly computable extractor term poly poly term poly logm equivalently logn poly recall condition precisely stated earlier requirement weak random source choice weak random sources corresponds precisely random sources analysis yields correct simulation polynomial time remark extractors parameters stated exist demonstrate lecture alternate proof bpp application assume existence extractore computable polynomial time logn existence extractor proven section bpp machine requiring random bits input give formula equivalent acceptance start simulation previous section usinge perfectly random source withh view samplexfrom source components equal length number simulation fails sample claim counting argument choice simulation results correct answer stated formally input pry logn assuming inside predicate computable polynomial time show implies negation rhs goal mind switch roles note simulation outputs probability pry pry line implies implies pry pry constructions give constructions polynomial time computable extractors construction based construction pseudorandom generators secure circuits functions high circuit complexity construction logn sources note parameters good applications previous section dependence number output bits entropy input distribution optimal construction based random walk expander graph constant construction extractor sources entropy logn construction constant factors optimal works sources high min-entropy final construction based polynomials finite field construction building block parameters achieved construction works give today give lecture hardness based extractor basic idea weak random source view truth table function functions high circuit complexity hard function pseudorandom generator based hard functions perfect random seed seed generator elaborate ideas derive extractor recall pseudorandom generator gave previous lecture secure circuits functionf logr non-uniform circuit complexitycf construct generator logr circuits size examination proof reveals proof relativizes function circuit complexity caf circuits oracle output indistinguishable circuits oracle access output generator hard function indistinguishable oracle circuit queries oracle caf similar condition extractor makes short random seed works fixed weak random source pick function random view sample weak random source truth table function logr bits bits claim fixed oracle functions logr caf prove claim quantify means ready define extractor view truth table function logr bits bit view seed pseudorandom generator note oracle circuit size query oracle charged part size circuit large queries oracle count gate making constant sized circuits powerful difference probability assigned set extractor uniform distribution fact weak random source min-entropy split difference probability assigned based high circuit complexity prx caf large prx caf small caf small term caf small quantified intuitively bounded number small circuits caf number circuits size number small circuit complexity bounded means ensure probability constant showing extractor expander based extractor construction view sample weak random source describing random walk d-regular expander graph sample source view portion indicating initial vertex expander remaining part specifies path follow graph vertex perfect random seed specifies vertex path output bits tlogd path length starting index vertex path logt summarize yth point random walk proving extractor relationship parameters definition tlogd previously construction work pick set pick tlogd setting nlogd log logn show pick satisfied chernoff bound random walks expanders bound difference probability assigned recall chernoff bound random walks states ith vertex visited random walk expander largest eigenvalue tsummationdisplay bracehtipupleft bracehtipupright exp bracehtipupleft bracehtipupright splitting difference probability assigned based holds assuming weak random source min-entropy prx contribution good breaking satisfying finish bound satisfying satisfying constant depending pick sufficiently smaller extractor polynomial based extractor construction lecture complexity theory lecture counting instructor dieter van melkebeek scribe chi man liu time introduced extractors discussed methods construct part lecture present explicit construction extractors based finite fields construction extractors parameters constructions discussed time part lecture introduce class counting problems problems class decision problems output single bit contrary counting problems require integers form binary strings output properties relations complexity 
classes extractor condenser overview recall previous lecture presented constructions polynomial time computable extractors construction based pseudorandom generators secure circuits construction logn sources construction based expander graphs constant construction extracts bits logn perfect random bits section give construction based finite fields construction construction building block achieves parameters works restate definition extractor definition extractor -extractor function source bardble umbardbl recall construction requires weak random source apply procedure converts random source suitable applying construction arbitrary source bits min-entropy condense randomness source make ratio close intuitive notion formalized definition definition condenser -condenser function source exists distribution bardblc ybardbl condensers natural generalization extractors require near-uniform output extractor require output condenser close source amount randomness note definition condenser set back extractor give construction condenser good parameters output distribution weak random source construction lecture theorem constants exists poly log time computable -condenser logn proving theorem combination expander based extractor source bits applying condenser produces output bits close distribution min-entropy seed length logn notice close distribution high min-entropy expander based extractor applying extractor produces distribution bits close uniform additional seed length logk seed logn composing constructions takes poly time condenser prove theorem find condenser outputs distribution close high min-entropy input source guaranteed amount randomness arbitrary function output distribution elements large weights hindrance achieving high min-entropy lemma shows set inputs generating heavy elements small output distribution close distribution high min-entropy lemma source function define set -heavy elements prx set bad inputs bad pry bad exists distribution bardblc ybardbl proof element weight min-entropy bad bad prx note weight element redistribute weights elements resulting distributiony element weight greater weight needed redistribute difference probability set sobardblc ybardbl function bad sources min-entropy -condenser note depends source satisfies show bad inputs respect satisfying conclude -condenser lemma lemma subset define bad set respect badh pry badh -condenser prove main theorem proof theorem view sample weak random source polynomial finite field extractor evaluates powers polynomial point perfect random input outputs condition lemma show construction condenser small set range construct non-zero polynomial samples weak random source evaluates samples hit small set high probability keeping degree polynomial small show samples hit small set range high probability formalize intuition size perfect random seed length sample weak random source length output view view irreducible polynomial degree view elements setup define condenser xsm parameter set formula interpreted outputs -vector i-th element computed treating element raising -th power evaluating resulting polynomial make assumptions move end proof choose values make assumptions hold assume subset exists nonzero formal variate polynomial vanishes points degree variable evaluating polynomial point homogeneous linear equation polynomial coefficients unknowns equations number coefficients unknowns assumption homogeneous system nontrivial solution coefficients badh treat element formal univariate polynomialr xsm functions degree degree definitions definition badh vanishes points assumption zeroes degree identically point switch viewing -variate polynomial xsm univariate polynomial badh imply polynomial element individual degrees ofqwere thans nonzero polynomial distinct monomials inqmap distinct monomials ins degree ofs zeroes badh assumption badh lemma conclude -condenser pick values parameters satisfy assumptions achieve claimed parameters condenser statement theorem setup condenser show chooses ensure assumptions valid turn assumption note assumption equivalent rearranging equivalent choose satisfy assumption assumption substituting rearranged parenleftbig parenrightbig notice setting parenleftbig parenrightbig satisfies assumption assumption fact rearranging log set log works values finally efficiency construction finding irreducible polynomial degree arithmetic operations time poly poly log construction polynomial-time computable counting class problems studied decision problems problems require answers section introduce class problems require multiple-bit outputs problems form instance number solutions witnesses leads exploring class counting problems examples definitions give precise definition complexity class sat boolean formula find number assignments satisfying problem counting problem recall decision problem sat asks exists satisfying assignment construct ntm input guesses assignment accepts satisfies note number accepting computation paths number satisfying assignments leads defining terms ntms definition exists polynomial-time ntm input equals number accepting computation paths give examples problems sat discussion problem asks number perfect matchings bipartite graph note decision problem existence perfect matchings bipartite graphs solved polynomial time polynomial-time decidable graph property connectivity acyclicity counting number graphs size satisfy property problem matrix coefficients note define permanent perm summationdisplay nproductdisplay set permutations note permanent matrix similar determinant factor sign multiplied permutation determinant sign denotes sign permutation problem computing permanent matrixais obvious sight fact construct ntmm generates computation paths entries input guesses permutation entry captured creates computation paths reject immediately computation paths expanding entries processed total number computation paths generated product entries captured summing permutations permanent number perfect matchings bipartite graph equal permanent adjacency matrix restricted attention matrices non-negative entries relaxed constraint matrices negative entries computing permanents problem simply permanents negative fact complexity class captures problem gapp show unrestricted permanent problem lies gapp constructing ntm accepts permutations giving positive products ntm accepts permutations giving negative products properties complexity class exhibits algebraic properties adjacency matrix usual adjacency matrices rows represent vertices partition columns represent vertices closed addition functions sum lies show holds ntms inducing ntm input immediately creates computation paths paths runs computation runs computation easy total number accepting computation paths closed multiplication running ntm end accepting computation path ntm complexity class gapp properties closed subtraction property possess complexity classes complexity classes encountered classes decision problems order compare make oracle denote class decision problems solvable polynomial-time dtm access oracle class decision problems solvable polynomial-time dtm makes query oracle proposition relations hold bpp pspace proof problem polynomial-time ntm solving oracle reduction simply function induced completes part part proved similarly polynomial-time probabilistic machinep construct ntm guesses random bit string polynomial length simulates computation oracle reduction oracle machine accepts number accepting computation paths total number computation paths part fact entire computation tree ntm traversed deterministically polynomial space remark set containments pspace conjectured proper containments introduce counting-related complexity class definition exists polynomial-time ntm number accepting computation paths odd obvious proposition shows interesting property classes bpp proof left exercise reader proposition p-complete problems section present p-complete problems theorem sat p-complete proof sketch lecture proved sat np-complete proof polynomial-time ntm constructed boolean formula capturing computation input verified number assignments satisfying number accepting computation paths input remark reduction proof parsimonious reduction polynomial-time reduction preserving number solutions theorem computing permanent integer 
matrix p-hard proof idea shown boolean formula occurrences literals construct polynomial time matrix perm denotes number assignments satisfying construction single oracle call needed determine theorem p-complete theorem surprising disappointing result decision problem reduction sat simple theorem case sat formula reduce graph determine perfect matching apply equation conclude satisfiability steps polynomial-time reductions counting decision problems clear decision problem reduced counting problem single oracle query interesting question counting problem reduced decision problem oracle reduction answer positive p-complete problem sat imply pnp ppnp theorem lecture result collapse level problems give positive answer question graph isomorphism problem shown np-complete recall graphs isomorphic exists bijection write isomorphic define graphs counting problem asks numberof bijections satisfying edge-preserving condition easy verify related counting problem graph automorphism counting problem graph asks number automorphisms edge-preserving permutations theorem proof show showing left exercise reader graph automorphisms forms group aut pick vertex set automorphisms fixing aut set vertices mapped automorphism aut associate automorphism automorphism aut uniquely decomposed elementary group theory aut compute make oracle decide making query oracle graph obtained attaching large clique graph obtained attaching clique clique map clique map exists automorphism mapping conversely automorphism extended isomorphism computing fact instance attach large clique count number automorphisms graph vertex adjacent clique automorphisms graph fix note multiply count suitable fraction due clique vertices note graph larger original graph fact easier instance vertices fixed solving instance fix vertex negationslash clique compute attaching larger clique recursively steps step clique size added graph final graph size polynomial step takes polynomial time reduction polynomial-time computable corollary complete parsimonious reduction proof suppose complete parsimonious reduction show reduce sat sat oracle reduction cnf satisfying assignments assumption exists parsimonious reduction sat obtain graphs polynomial time equal number isomorphisms sat theorem np-completeness sat sat sat collapses level mentioned beginning section time lecture discuss relations polynomial hierarchy prove happen shown counting problems approximated level guruswami umans vadhan extractors condensers univariate polynomials electronic colloquium computational complexity report october complexity theory lecture alternation counting instructor dieter van melkebeek scribe jeff kinne introduced counting complexity classes previous lecture gave basic properties including relation counting decision classes lecture give results relating counting polynomial hierarchy result shows function approximated level polynomial hierarchy giving evidence approximate counting difficult deciding result evidence exact counting difficult showing entire polynomial hierarchy decided single query function proofs results make families universal hash functions small function families behave respects random allowing efficient random sampling introduce universal hash functions prove main results universal families hash functions universal family hash functions collection functions set functions small size behaving similarly set functions pick member random made choosing notion behaving similarly definition universal family hash functions holds negationslash chosen uniformly random functions notice probability pickedhfrom functions fix pick hat random random variables independent universal hash functions giving ability produce uniform pairwise independent samples definition generalized define k-universal hash functions produce k-wise independent samples make consequences definition negationslash prh prh efficiently sample family small number ways achieve give leth wheret ntoeplitz matrix vector toeplitz matrix entries diagonal takes bits element ofh specification random function functions requires bits truth table correctness randomized algorithm relies pairwise independence universal family hash functions logn length seed pseudorandom generator derandomize algorithm leave exercise prove thathsatisfies definition set affine functions finite field leave exercise prove mod mod universal family hash functions applications delving main results lecture give intuition universal families hash functions intuitively expect pick randomly chosen hash function bits bits map collisions high probability application determine size witness set make intuition derive predicate approximately determine size application randomness reduce satisfiable formula uniquely satisfiable satisfiable assignment intuition show choosing appropriately picking random high probability unique satisfying assignment hashes approximate counting section prove function approximated polynomial factor oracle level polynomial hierarchy theorem function computable polynomial time oracle access language proof adapted show computable randomized machine oracle access language estimate smaller true notice goal proving theorem similar goal showing bpp needed approximate function counting number accepting random strings constant factor approximate function polynomial factor proof underlying ntm run time view polynomial-time verifier ntm takes certificate length input determine size set certificates causing ntm accept applying randomly chosen hash function set certificates large compared expect covers small portion range small compared expect cover large portion range small collection hash functions collectively cover provided roughly size construct predicate queried determine small set hash functions covers range querying language increasing values negative answer estimate bound probability fixed hit randomly chosen upper bound prh summationtexty fact choosing random results pairwise independent samples chebyshev inequality bound probability compute expected sum linearity expectation properties universal hash functions summationdisplay summationdisplay summationdisplay denote chebyshev inequality pairwise independence prh summationtexty prh summationtexty probability fixed hit randomly chosen choosing number points small number hash functions fromhindependently random probability hash functions fail cover independence union bound prz notsubseteqluniontext case tuniondisplay polynomial beginning predicate case small show prz uniontext small notice hash function cover elements hash functions cover suppose constant meaning hash functions covers small portion case prz uniontextti close quantifiers wrong order union bound fact elements ofh tuniondisplay set parameters achieve goals settingk min suitable constant super-logarithmic prz uniontextni prz uniontextni assume logarithmic function probabilities work restrictive poly compute oracle leave exercise moment oracle predicate approximate show realized predicate leave exercise verify portion inside probability predicate remove probability quantifier proof bpp setting probability quantifier removed adding additional levels quantifiers remove probability quantifier adding front left predicate predicate oracle equivalent predicate oracle language approximate mentioned earlier query predicate determine answer predicate negative log predicate answered positively log loglog predicate answered negatively log log loglog rewritten log log approximation fixed polynomial factor computable polynomial factor constant obtain applying procedure modified predicate original function approximate apply algorithm function fnd constant choose leave exercise show function approximation log taking power rearranging log approximation relative error logn taylor expansion lognnd set large error exact counting main result show theorem language polynomial hierarchy decided polynomial time single oracle query function prove theorem parts show rpunique-sat unique-sat promise problem defined formulae satisfying assignments positive instance uniquely satisfiable formulas unique-sat oracle guaranteed give correct answer formulae act arbitrarily fact algorithm correct oracle inconsistent answers 
queries promise stated logn compute oracle size assume larger fix polynomial start logn part show bpp finish proof showing bpp solving randomness unique-sat oracle hash functions theorem ntm sat running time set assignments formula input applying hash function idea choose range hash function size achieve show randomly chosen hash function high probability maps unique satisfying assignment potential unique-sat query oracle bound probability randomly chosen hash function maps unique satisfying assignment set satisfying assignments lethm universal family hash functions probability thathmaps unique satisfying assignment summationdisplay summationdisplay summationdisplay term summationdisplay parenleftbigg parenrightbigg terms inclusion-exclusion principle expansion probability pairwise independence hash functions term summationdisplay parenleftbigg parenrightbigg union bound pairwise independence putting fact thatparenleftbig parenrightbig summationdisplay parenleftbigg parenrightbigg equal achieves maximum increases choice causing probability range providing negationslash probability randomly chosen hash function maps unique satisfying assignment analysis rpunique-sat algorithm sat input formula foreach pick random query unique-sat oracle query assignment satisfies oracle self-reducibility verify output output choosing hfrom universal family hash functions choosing hash function polynomial time rest algorithm runs polynomial time suppose satisfiable choice probability line corresponds uniquely satisfiable formula notice formula remains uniquely satisfiable self-reducibility case algorithm correctly outputs satisfiable algorithm outputs probability success satisfiable formulas amplified repeating algorithm rpunique-sat randomized reduction fact rpunique-sat unique-sat cares formulas satisfying assignments sat solves unique-sat formulas promise previous section shows bpp fact problem homework relativizes bpp bpp relativizes bpp bpp show hypothesis notice bpp relativizes giving bpp notice bpp machine previous section access oracle bpp bpp achieved bpp conclude bpp point proof result simpler original proof demonstration power relativization deterministic reduction bpp language bpp determine making single query function show separate randomized portion counting portion performing reduction definition complexity class define operator give complexity class languages pry pry notice bpp reasonable definition operator alternative characterization bpp claim bpp proof show complexity classc bppc result asc fact bpp machine queries language changing computation machine guess random bits beginning computation proceeding left predicate language bppc machine computing language simply generates random bits input machine simulates machine language hope solve definition mod mod create function sums detect gap probability claim main ingredient make happen claim function mod mod mod mod power proving claim complete construction notice mod bits mod bits sum results spill past bits sum pick ensure spill notice summationtext mod summationtext mod fact picking ensure single bit sum check distinguish cases summationtext function query determine notice fact function machine branch compute branch remains proof claim proof claim base construction function nice property mod mod mod mod property result applying times claimed property property running time consists logm applications application increases running time constant factor polynomial factor slower remains prove claimed property suppose mod integer expansion ofh remove terms factor higher power geth mod argument generalizes show mod mod desired property mod time lecture concludes part focused traditional setting complexity theory efficiently computing relations computational models focus remainder alternative goals complexity theory lectures area complexity theory studied entire lectures surveys area fact lecture interested efficiency computing relations lecture discuss power quantum computing alternate proof approximate counting alternate proof theorem notion isolation proof underlying ntm run time view polynomial-time verifier ntm takes certificate length input determine size set certificates causing ntm accept applying randomly chosen hash function set certificates small compared expect collisions members large compared expect collisions determine relative number collisions estimate ideas formalized concept isolation universal family hash functions isolated equal negationslash small compared large portion intuitively isolated randomly chosen case small number hash functions required guarantee isolated hand large compared show small set hash functions isolate quantify ideas bound probability fixed isolated random isolated logicalordisplay negationslash summationdisplay negationslash summationdisplay negationslash definition isolation union bound chosen random universal family hash functions summing negationslash probability random choice hash functions isolated events isolated fixed independent independently chosen isolated parenleftbigg isolated parenrightbiggt parenleftbiggs parenrightbiggt probability isolated union bound isolated summationdisplay isolated parenleftbigg parenrightbiggt meaning probability method testing roughly large large choice isolating method testing roughly large notice isolate elements isolate isolating lett mfor simplicity discussion allm log loglog set hash functionsh isolating log log exist isolating method estimate size test predicate isolates determine predicate evaluates true claim predicate finish analysis claim prove claim discussion log loglog log rewritten log log approximation fixed polynomial factor computable method section make approximation ratio polynomial remains verify point fact choosing universal family hash functions random choosing fromh initial existential guesses polynomial size claim remaining predicate isolates conp predicate realized predicate negationslash testing polynomial time evaluating ntm certificate existential phase pushed inside polynomial size predicate shown approximate deterministically oracle fact randomized algorithm oracle pick hash functions random large values hash functions satisfy inside conp predicate small values set hash functions satisfy predicate derived randomly selecting hash functions querying inside conp predicate high probability satisfies notice estimate derived errors direction choice random functions satisfy inside conp predicate small values complexity theory lecture quantum effects instructor dieter van melkebeek scribe seeun william umboh today quick quantum computing model define quantum model computing variant probabilistic model computing present common technique design quantum algorithms give upper bounds power quantum computation motivation quantum computation presents challenge strong church-turing thesis physically realizable computing device efficiently simulated turing machine model presented lecture clear point problems solvable polynomial time quantum computers solved polynomial time deterministic turing machines randomized machines reason factor efficiently quantum machines classical machines consensus community quantum computers solve np-complete problems efficient classical factoring algorithm caveat uncertain quantum computers physically realizable idea exploit quantum effects solve computational problems efficiently terms time key idea search problems quantum interference good solutions interfere constructively bad solutions interfere destructively end good solutions remain turing machine models probabilistic relate quantum model probabilistic model viewing probabilistic model perspective markov chains give alternate definition probabilistic model define quantum model definition state represent state probabilistic machine probability distribution configurations ket notation summationdisplay summationtextcpc probability configuration column vector zeros position representing configuration runs configurations definition computation computation probabilistic machine consists phases sequence local acting bits tapehead state linear transformations transform probability distribution probability distribution stochastic matrices induced transition function final observation part configuration answer summationdisplay runs configurations giving 
answer markov chain view point time state machine superposition configurations represented column vector summationtextcpc note set singleconfiguration vectors forms basis linear space overr state vectors end computation observe output bit probability observing probability machine configuration giving output rephrasing probabilistic model presented earlier lecture move quantum model quantum definition state state quantum machine defined linear superposition configurations summationdisplay summationtextc definition computation computation quantum machine consists phases sequence local acting bits tapehead state linear transformations transform vector bardblvbardbl vector bardblv bardbl unitary matrices induced transition function final observation part configuration answer summationdisplay runs configurations giving answer transformation depend configuration distribution require transition probabilities efficiently approximable rationals avoid dealing machines halting sequence transition probability view state quantum machine wave function coefficients called amplitudes vectors imaginary plane length fact amplitudes negative allowing destructive interference underlies lot power quantum computing note probability configuration square absolute amplitude issue condition matrices induced stochastic unitary imposes restrictions set allowable transition functions probabilistic setting transition function stochastic fixed configuration sum probabilities configurations move step show setting transition probability quantum setting natural thing unitary sense turns satisfy orthogonality conditions conditions unnatural quantum machines turing machines algorithm design prefer terms circuits circuit models define circuit models probabilistic quantum computations order satisfy conditions gates act finite number bits sufficient act bits induce stochastic unitary matrices end define notions register analogous notion turing machine configuration circuit model contents register reflect results computation retain notation denote contents register state register represented probability distribution linear superposition contents register note set vectors form basis linear space reals complex numbers state vectors operation gon anm-bit register linear stochastic unitary transformation acting distinct bits indices leaving unmodified everyx applyinggon yjykyl xjxkxl computation consists sequence operations final observation register note operations represented stochastic unitary matrices models defined satisfy condition uniformity simply require single turing machine compute operation step addition -time bounded versions models require turing machine time compute operation step probabilistic probabilistic model sufficient classical gates simulate deterministic computation coin flip gate access fair coin deterministic gates operations defined transformations xyz xyz matrix remember input bits unaffected gate multiply denotes probability register contents started configuration kth bit coin flip gate coin flip gate acts bit output equiprobably bracketleftbigg bracketrightbigg quantum deterministic gates quantum setting simply matrices gates preserve -norm note -norm preserving condition matrix equivalent satisfying iff gate matrices invertible gates invertible input map deterministic gates reversible induce permutation matrices determinism requires matrix column entry reversibility requires matrix row entry introducing additional ancilla bits boolean function transform reversible version defined apply transformation gates deterministic classical circuit obtain circuit usable quantum machine circuit computing resulting function transforming gates defined garbage number ancilla bits order number gates themancilla bits set interference patterns garbage ancilla bits computation paths complex conjugate interfere simply resetting bits irreversible operation applyingf reverse extra bit preserve result computed figure schematic reversible simulation complexity reversible simulation denoted constant factor greater complexity apply transformation gate run transformed circuit note bqp bqp class decision problems solvable polynomial quantum turing machines output quantum turing machine random variable decides language probability deciding correctly membership hadamard gate quantum analog classical coin flip gate called hadamard gate matrix gate bracketleftbigg bracketrightbigg exercise verify hadamard matrix unitary orthogonal effect applying gate single bit observe bit applying hadamard gate equiprobably fair coin flip applying hadamard gate consecutively sequence give original bit result coin flip gate terms interference computation paths simulate randomized computation applying hadamard gate observing bits afterward proceed deterministically bits random bits bpp bqp illustration quantum power widely believed community interference solve npcomplete problems managed interference efficiently solve problems efficient classical algorithms factoring simon problem problem unnatural technique solving underlies quantum algorithms factoring definition simon problem poly-time length-preserving maps strings length strings length function promise negationslash addition defined bitwise xor find input words strings length function -toand strings map string differ shift find note promise problem problem second-level polynomial hierarchy guess shift verify pairs ofn-length strings thatf poly-time function easily bitwise-xor verification efficiently classical machines exponential time randomness algorithm guess collision easily determine expected number trials collision exponential quantum machines problem solvable polynomial time start state firstn bits encode inputs achieve applying hadamard gate thenbits denote operation ash state summationtext apply bits input bits bits output bits state summationtextx finally apply bits leave exercise verify end summationtext summationtext denotes product rewrite summationtext linear superposition contents registers probability observing register summationtextz range range maps strings linear algebra n-fold tensor product hadamard gate matrix common factor sum n-length strings count probability observed summationtextx mod mod output computation chosen uniformly random mod observe mod linear combination components coefficients components linear equation variables run routine order times collect output run equations form homogeneous system rank elementary linear algebra unique non-trivial solution argued efficiency components routine solve homogeneous linear systems equations efficiently lastly leave fact average runs routine exercise exercise verify high probability runs suffice hidden subgroup generalization definition hidden subgroup problem group poly-time promise exists subgroup iff belong coset find generators familiar instances problem simon problem group simon problem denotes bit-wise xor defined definition subgroup interested sincexandy belong coset ofh iffx orx critical factoring algorithm discuss factoring algorithm finding order mod prime find order mod interested group denoting multiplication mod poly-time function mod iff solved similar simon problem general fast fourier transform hadamard gate fourier transform discrete log leave exercise reader graph isomorphism connected graphs vertices order cast hidden subgroup problem symmetric group elements function result applying permutation vertices disjoint union graphs aut automorphism applying automorphism applying result applying note graphs isomorphic generator swaps decompose automorphisms automorphisms swap find generators easily determine graphs isomorphic main technique algorithms examples fourier sampling set linear superposition inputs register store output register apply fourier transform measure system technique works group abelian case factoring simon problem discrete logarithm case graph isomorphism symmetric group abelian technique specifically probability distributions fourier sampling positive instances graph isomorphism negative instances indistinguishable upper bounds power quantum computers upper bound quantum computers note outcome quantum computation depends possibly negative amplitudes paths probability distribution gapp function bqp bqp class define future lecture biggest open problem quantum computation complexity theory bqp contained 
polynomial hierarchy probabilistic setting approximate counting good show containment hierarchy quantum setting possibility interference makes harder rely approximate counting fact conjectured exact counting required physics side build reliable scalable quantum computers models proposed spin single electron trapped silicon lattice scales implement bits silicon abundant implement bits model optical lattice model electron trapped optical lattice lasers managed implement limited quantum computers model scaling problem bottleneck laser power lecture today lecture completed part models computation compare time space resources lecture start section goal metrics time space 
complexity theory lecture introduction instructor dieter van melkebeek scribe jeff kinne today begin review basic complexity theory material typically covered undergraduate theory computing lecture introduce define model computation formalize intuitive notion computer explore issues arise computational model overview graduate-level introduction computational complexity theory study power limitations efficient computation part focus standard setting realize mapping inputs outputs timeand space-efficient develop models computation represent capabilities digital computing devices including parallelism randomness quantum effects non-uniformity introduce models based notions nondeterminism alternation counting precisely capture power needed efficiently compute important types mappings meat part consists intricate relationships models separation results inthe secondpartwe studyother computational processesthat arise indiverse areas computer science relevant efficiency measures specific topics include proof complexity interactive proofs probabilistically checkable proofs motivated verification pseudorandomness zero-knowledge motivated cryptography security computational learning theory motivated artificial intelligence communication complexity motivated distributed computing query complexity motivated databases topics grown substantial research areas cover main concepts key results standard setting machine model deterministic turing machine model computation capture intuitive notion computer turing machine depicted figure finite control finite number states time read write memory tapes based current state contents tapes finite control state alters contents tapes input tape work tape finite control work tape work tape woutput tape figure illustration deterministic turing machine finite control read-only access input tape write-only access one-way output tape read-write access constant work tapes definition sequential access turing machine sequential access deterministic turing machine defined tuple qhalt finite set states finite control finite input output alphabet finite work-tape alphabet qstart start state qhalt halt state finite control transition function transition function form qhalt input represents current state current symbol scanned input tape current symbol scanned work tape output represents state finite control symbol write output tape possibly empty symbols write work tape direction move head input work tapes typically binary alphabet tapes turing machine consisting steps machine initialized place input input tape tape head symbol input work tapes empty tape heads left-most cell tape output tape empty finite control set qstart machine allowed run step time repeatedly applying transition function machine halts entering qhalt computation finished read output output tape denote output input computation halts sight definition turing machine restrictive correspond intuitive notion computing turing machine shown powerful roughly efficient traditional computers discuss lecture model turing machine modification definition definition bit restrictive indirect memory addressing real computers rely definition random access turing machine random access turing machine turing machine functions definition output sequential access work tapes input tape fixed number work tapes random access tapes sequential access tapes random access tape sequential access index work tape tape head random access tape moved special jump operation moves tape head location index tape tape head position random access tape altered transition function contents memory cell read written transition function notice tape sequential tape random access tape sequential access tapes performing operations performed registers modern computers arithmetic random access tapes storage choose random access turing machine basic model computation closely models modern computers sequential access turing machines computing relation main setting part turing machine ability compute relations definition relation turing machine computes holds inputs input halts outputs exists exists indicating accomplished encoding scheme output halt states relation shortest path problem relation compute shortest path vertices graph input description graph source destination vertices output description path graph notice function special case relation xthere factoring input integer output unique prime factorization listing prime factors smallest largest interested kind relation called decision problem definition decision problem decision problem relation output case output input property input property refer set inputs output language problem determining string palindrome define language palindromes set strings read front back back front relation assigns palindrome non-palindrome case complexity computing relation captured complexity computing related decision problem turn factoring problem decision problem compute ith bit output input compute ith bit description prime factorization time space complexity turing machine originally defined theory computability recursion theory setting goal determine relations computable famous early result halting problem computable turing machine surprising uncomputable relations closer inspection makes fact obvious countably turing machines uncountably relations contrast setting computability complexity theory concerned efficiency relation computable end amount resources turing machine computation standard resources time space definition turing machine input number steps halts input max sum work tapes maximum cell touched halts max corresponds time input corresponds amount memory alternative definition count number work-tape cells touched definition counts cells left work-tape cell touched counts unused cells left cell definition natural perspective run algorithm computer memory algorithm space alternative definition run machine ram modification definition notice configuration machine positions tapes contents work tapes internal state log space true alternative definition purposes choice definition effect power efficiency model interested worst-case complexity turing machine defined worst-case measures correspond worst performance input length notice definition count input tape output tape memory cells choice definition reason distinguished types tapes place turing machines compute non-trivial relations sub-linear space definition including input tape usage preclude non-trivial sub-linear space algorithms entire input read algorithms logarithmic space amount required index input time usage linear smallest read entire input goal complexity theory main goal complexity theory characterize amount time space required compute relation words find machine minimal machines solve relation number issues arise question hard wiring solution finite subset inputs hard-wired transition function turing machine lookup table finite subset inputs solved fast low space usage issue focus asymptotic run-time space usage constant factor speedups turing machine amount space binary alphabet changing alphabet machine store information original tape cells tape cells finite control machine modified work properly setting reducing space usage machine roughly factor space usage decreased constant factor increasing size tape alphabet suitably large constant notice alternative definition space usage counts memory cells touched computation argument work random access machines algorithms high amount memory locality similar argument made time usage argument bit complicated finite control read current cell immediately adjacent cells properly mimic original turing machine random access operations destroy time speedup argument potential problem makes fact indexing operations sped algorithm making random access operations spend large amount time indexing operations constant factor speedups ignore constant factors running time space usage incomparable behavior 
modulo issues fundamental problem remains attempting determine optimal time space usage compute relation case machines input lengths smaller input lengths smaller case machine created simulate machines achieve optimal run-time inputs hard-wiring issue discussed finite set inputs turing machine decides instances correctly fast small space usage machines optimal set inputs general create machine combining optimal performance infinitely machines general single single turing machine minimal run-time space-usage input lengths dual problem originally stated find minimal relation determine relations computed time space bound definition define dtime decision problems solvable time random access turing machine dspace decision problems solvable space random access turing machine main goal complexity theory restated time space boundt relations computed turing machine amount time space goal number issues remain model dependence results independent choices made defining turing machine recall church-turing thesis relation computable physically realizable computing device computed turing machine belief underscores turing machine computability theory computing device studied note church-turing thesis violated models computation setting complexity theory strong church-turing thesis relation computable physically realizable computing device computed model turing machine polynomial overhead time constant overhead space machine time compute relation turing machine poly time machine space turing machine logn space notice strong church-turing thesis bolder statement church-turing thesis widely believed violated quantum machines debatable physically realizable violated randomized machines believed case language palindromes single tape sequential turing machine shown trivial algorithm scanning back input string running time similar result shows multitape sequential access turing machine product space time usage solve palindromes palindromes decided simultaneous quasi-linear time logarithmic space random access machines notice result implies single-tape turing machine incur roughly quadratic overhead time attempts simulate model random access multi-tape turing machine physically realizable models computation differ polynomial factor time solve relation constant factor space needed strong church-turing thesis stated strengthened notice quadratic lower bound palindromes sequential access turing machines model dependent true models chosen model random access turing machine avoid model dependent results results present model independent input representation input representation clear palindromes language relations choice made shortest path problem input problem includes graph represented input tape standard methods representing graph include adjacency matrix adjacency list note linear factor difference size effects running time space usage functions size input input made artificially large padding unnecessary running time space usage artificially decreased functions size input reason assume reasonable encoding input leave notion qualitative quantified long choose reasonable encoding input running time space usage depend input encoding issues define complexity classes robust respect model input representation complexity class remains model reasonable input encoding definition definitions standard complexity classes dtime exp dtime dtime dspace logn pspace dspace notice robust respect model strong church-turing thesis classes robust respect input representation restricting space usage logarithmic case complexity class great graph problems logarithmic space remember constant number vertices graph turns interesting problems solved recent result showed problem determining connectivity undirected graph achieved logarithmic space deterministic machines universality turing machine called universal turing machine simulate turing machines turing machines inputs key property leads number results exist universal turing machines incur small overhead time space theorem universal turing machines udtime udspace turing machines inputs tudtime log sudspace log denotes length description fact show single machine udtime udspace proof sketch main difficulty designing udtime udspace fixed number work tapes simulating machines number work tapes udspace suppose work tapes contents single tape udspace call tape storage tape storing cell tapes cells udspace storage tape storing cell tapes cells recall single step reads contents work tape locations tape head udspace tape heads udspace stores information additional work tape call tape lookup tape udspace index tape order perform tape head jumps leave exercise verify udspace simulate tapes storage lookup index simulation efficient claimed time required run simulation step execution udspace read contents sequential access work tapes remember contents current cell random access work tapes sequential access tapes access locations mosttm address sequential access tape head takes logtm space leave exercise verify transition function step ofm takes logtm steps udspace simulate fact udspace performs tape head jump operations constant time conclude udtime udspace efficient respect time claimed notice analysis takes account udtime random access input tape sequential access input tape simulating sequential access input tape udtime incurs log factor overhead time simulate sequential access input tape key component analysis time efficiency proof work tape sequential access random access single work tape allowed sequential random access analysis fail counterexample case machine jumps location performs local operations address runs time simulation time situation universal machine udtime similar overhead time constructed ensuring simulation udtime accesses tape cells small addresses logtm achieved keeping track random access tape operations tape cell address tape cell contents pairs storing efficient data structure balanced binary tree trick keeping track random access tape operations data structure convert machine time machine computes relation space defined space complexity notice transformation trivial machine space exponential writing large address accessing location random access tape existence universal machine key component number important results hierarchy theorems completeness results hierarchy theorem states turing machine slightly resources time space compute relations computed slightly resources problem complete complexity class class difficult problems class universal machines prove time space hierarchy theorems existence complete problems formalize notions give proofs lecture show relationships complexity classes pspace exp open containments proper complexity theory lecture determinism nondeterminism instructor dieter van melkebeek scribe matt elder lecture discuss applications efficient deterministic universal turing machines deterministic time spaces hierarchy theorems completeness results introduce nondeterministic turing machine model nondeterministic computation hierarchy results hierarchy result theorem imposes strict-subset relation complexity classes classes problemscandc hierarchy result yield thatc subsetnoteqlc classc computationally powerful classc show function sufficiently smaller function dtime subsetnoteql dtime prove technique diagonalization originated cantor proof uncountable theorem cantor interval uncountably infinite proof prove theorem contradiction enumeration numbers show numbers constructing number assume countable interval countable individual elements enumerated suppose enumerate numbers infinite binary representation ith number enumeration jth bit figure constructed complement diagonal elements prove theorem diagonal elements bold elements figure build diagonal elements set bit complement ith bit differs theith bit ofri thatr negationslash alli represents numberxthat enumerated isn true rational number infinite binary representations terminating terminating ways avoid 
issue representations base set digit equals set equals ensure end infinite sequence zeroes construction complicated provided care issue construction contradicts fact enumeration element initial assumption false countable proof deterministic time space hierarchies emulate cantor diagonalization proof theorem requires condition time bounds time-constructibility describe appears proof theorem iftandt functions nto tis time-constructible andt logt dtime subsetnoteql dtime proof universal turing machine construct contrary machine build turing machine running time output differs output input contrary machine accept language machine accept time ensure runs time function mapping inputs descriptions turing machines properties computable linear time machine appears infinitely image leave reader verify constructed computable enumeration deterministic turing machines denote ith input code read input compute pass universal turing machine run simulation long total time universal turing machine halts rejects accept reject simulation track time usage wishes time total place time-constructibility define notion proof property require time write zeroes work tape zeroes clock erasing step execution halting erased time-constructible discussion shows track time usage ensure entire execution logt efficiency universal turing machine proved previous lecture time perform simulation machine running time finitely inputs turing machine appears infinitely image input time complete simulation complement behavior long runs time dtime dtime dtime subsetnoteql dtime condition required time bound theorem stated formally definition shown functions dealing polynomials exponentials logarithms linear time-constructible logarithmic space-constructible definition function time-constructible function maps string string computed time similarly function spaceconstructible function maps computed space identical proof derive hierarchy theorem amount space deterministic machines giving theorem due fact overhead space universal turing machine smaller overhead time space hierarchy tighter time hierarchy theorem space-constructable dspace subsetnoteql dspace notice separation space bounds tight hope discussed constant-multiple differences functions change computational power corollary theorems subsetnoteqle subsetnoteqlexp lsubsetnoteqlpspace reductions completeness problem reducibility central study complexity reductions determine relative complexity problems knowing absolute complexity problems problems denotes reduces efficiently solved efficiently solved implies complexity greater complexity modulo complexity reduction notation context types reductions mapping oracle reductions mapping reductions restrictive definition mapping reduction called many-one reduction karp reduction function maps instances problem instances preserving outcome specifically decision problems exists function problem instances language iff language capture intended meaning reduction function efficient efficiency requirement varies context describe common settings moment definition oracle reduction called turing reduction cook reduction algorithm solve problem solver problem instantaneous subroutine b-oracle hypothetical machine solve instance problem return answer step oracle turing machine otm turing machine special oracle tape specific query state machine reaches query state invokes oracle current content oracle tape state oracle input erased oracle output oracle tape oracle tape head leftmost position otm machine oracle oracle-reduces denoted exists efficient otm solves mapping reduction give oracle-reduction otm input compute write oracle tape query oracle return output mapping reduction reduced oracle reduction oracle reductions powerful mapping reductions denote time space constraints efficiency reduction superscripts symbol polynomial-time reducibility denoted log-space reducibility denoted log log-space oracle reductions slightly complicated specification differ author context purposes impose restriction read write oracle tape left oracle tape procedural memory count size oracle tape space efficiency proposition log true reducibility transitive log definition reduction relation complexity class hard problem complete hard choice reduction depends context equal case log-space reductions reason problem complete log connection complete problems complexity class collapses variety complete problems make start construct complete languages efficient universal turing machines proposition language tuples angbracketleftbigm tangbracketrightbig halts accepts input steps complete logm proof language udtime runs polynomial time overhead suppose language demonstrate function demonstrating logm turing machine computes polynomial time define mapping takes angbracketleftbign cangbracketrightbig iff hard-code output log space hard-coded log-space mapping reduction nondeterminism note nondeterministic model computation intuitive good reason nondeterminism physically realizable model computation utility model lies modeling actual computation capturing complexity important class problems model standard model nondeterministic computation nondeterministic turing machine ntm ntm definition similar normal deterministic turing machine transition function relation ntm combination internal state read-head state provide multiple next-state instructions language ntm set strings exists valid computation input halts accepts accepts computation path accepts fruitful interpretations ntms view ntm machine allowed make guesses guesses controlled force machine accept input permissible series guesses lead machine accepting state machine make guesses accept series guesses machine accept forced reject ntm massively parallel computer time makes choice spawns copy branch choice copies continue processing child machine accepts input machine accepts input time space ntm efficiency stated terms worst-case behavior runs time means branch execution halts steps similarly runs space means branch execution cells nondeterministic complexity classes ntime nspace precisely analogous deterministic counterparts dtime dspace problem ntime exists ntmm solves problem runs timeo inputs sizen problem nspace exists ntm solves problem runs space inputs size complexity classes analogous deterministic counterparts ntime ntime nexp ntime nspace log npspace nspace won talk npspace turns pspace npspace result prove universal machines constructed universal deterministic turing machines construct universal nondeterministic turing machines notice deterministic universal machine construction lecture single universal nondeterministic machine logarithmic overhead time constant overhead space task simulating nondeterministic machines time-efficiently deterministic setting input running time machine simulate demonstrate machine simulates machine constant factor overhead time theorem exists ntm untime tuntime angbracketleftbigm tangbracketrightbig poly untime angbracketleftbigm tangbracketrightbig proof untime assumes runs time begins guessing computation record writing work tape time step computation record includes guess motion tape heads cell contents tape heads internal state length computation record poly writing guessed computation record untime verifies guessed computation record corresponds valid computation transition function computation ends accepting state achieved checking validity computation work tapes turn important point accepting computation path length untime guessed computation records accept leave reader verify time efficiency simulation critical proof untime takes input amount time simulate construction modified information run construction passing maximum time accepting computation found construction repeated double amount maximum time passed continued accepting computation found note construction correct runs time poly accepting computation path construction halts deterministic machines universal machines nondeterministic machines define complete language proof similar proof proposition proposition language tuples angbracketleftbigm tangbracketrightbig ntm accepts input time complete logm hierarchy results nondeterministic model difficult achieve deterministic model complementation difficult perform diagonalization ntms dtms simple accept input simulated machine rejects input vice versa ntm accepts computation branches 
accept rejects computation branches reject asymmetry make complementation inefficient complementation ntms efficiently computed unknown conp problem hierarchy results show lecture lecture time start discussing relationship class deterministic verification complexity theory lecture np-completeness instructor dieter van melkebeek scribe baris aydinlioglu time introduced model ntm mentioned realistic model computation captures complexity important classes problems started turn attention complexity class brie mentioned complexity class characterizes languages exists cient veri cation mechanism lecture continue discussion connection cient veri ability present striking relationship complexity problems formalize results tools developed previous class reducibility completeness efficient verification definition language efficient verifier exist refers verification procedure runs polynomial time refers short proof certificate witness membership turns problems practical interest property cient veri ability giving examples establish connection class problems class alluded earlier theorem iff efficient verifier proof call veri call describe ntm runs polytime nition constant string length accepted simply guesses string polynomial overhead simulates call ntm nition string accepts steps computation path constant description accepting paths certi cate formally sequence nondeterministic choices makes accepting branch computation simulates simulating nondeterministic transitions accordance accepts accepts give examples problems ciently veri boolean formula conjunctive normal form cnf conjunction disjunctions literals literal boolean variable negation rst ciently veri language sat boolean formulas cnf assignment satisfies satis certi cate membership sat satisfying assignment polynomial fact linear size length recall capture efficiency time-bounded setting class fundamental problem stripped version natural form search-sat commonly occurring problem elds arti cial intelligence search-sat asks satisfying assignment exists rst sight sat simple compared search-sat closer reveals equally cult sense solution problem ciently compute solution sat captures inherent complexity search-sat problem argue notion polynomial time oracle reductions sat search-sat show search-sat sat providing procedure sat-oracle compute solution search-sat query oracle answer negative satis pick variable set true query sat-oracle true substituted satis set false proceed remaining variables gradually build satisfying assignment total number oracle-queries linear number variables sat search-sat search-sat sat abbreviated sat search-sat convenient work erent version satis ability formulas structure purpose language sat satis boolean formula -cnf form formula -cnf form cnf form clause literals vertex cover graph subset vertices edge incident vertex subset language vertex cover size ciently veri certi cate membership purported vertex cover similar relationship sat search-sat decision-version naturally occurring form search-vc problem asks vertex cover minimal size show search-vc helpful rst intermediate problem optimization problem asks size minimal vertex cover leave exercise procedure solves problem making logarithmic number queries vc-oracle reader verify search-vc harder optimization problem subset-sum summationtexti question problems examples literally thousands problems encountered everyday science engineering equivalent sense polytime turing reductions decision-versions cient solution referred question deterministic ntm important problems contemporary mathematics due philosophical practical signi cance philosophical interpretation question ciently verify proofs implies ability ciently proofs stated answer obvious question remains open practical side positive answer question utopic consequences science engineering bring demise public-key cryptography semester co-np question complexity class co-c co-np question relates question nondeterministic computations easily complemented recall lecture asymmetry nondeterministic computation yields answer yields answer input ntm rejects computation path rejects input equivalently co-nondeterministic computation accepts input computation path accepts co-np question asks cient ntm language implies existence cient ntm complement language similar question answer intuitively negative doesn question membership np-language ciently translate question membership co-np language vice versa problem open co-np question relates topic proof complexity summed question tautologies short witnesses similar satis ability problem captures complexity class discuss problem formula tautology captures complexity class co-np cover proof complexity lecture notice passing implies co-np necessarily np-completeness turns problems cient veri cation procedure don cient solution erent manifestations problem inherent complexity tightly connected ciently solved rest theorem states connection language sat entire class polynomial time mapping reductions didactic reasons show result simpli model computation single-tape sequential access result extends random access model simulate random access machine sequential machine quadratic blowup running time theorem sat complete bit mapping reduction computable logarithmic space polylogarithmic time proof sketch showed sat show problem polynomial time mapping reduces sat language ntm decides runs time input length constant rest proof discuss string question membership question utility solve problem time historical evidence suggests problem pulled class quickly trimmed friendlier exponents ime osition figure computation tableau input ciently translated question satis ability cnf formula construct cnf formula polytime sat computation tableau input computation tableau input depicts contents tape successive steps computation tape positions time steps comprises variables clauses rst describe variables time step variables describe con guration time step boolean variable state true state time step computing addition tapehead true tape head located pth position tape time step computing tapehead true tape symbol pth position tape time step computing describe clauses clauses basically force variables intended meaning set-up clauses satis setting variables describes valid accepting computation input achieve clauses capture initial con guration clauses express valid transitions valid tape head movements valid evolution tape contents time step accordance transition relation iii clauses express nal accepting con guration time step details involved setting clauses brie touch leave rest reader row tableau corresponds initial con guration unit clauses state state demand initial state rst step computation initial con guration unit clauses tapehead logicalandtext tapehead tape head position addition logicalandtextp contents logicalandtextp anegationslash contents require tape blanks input denoting ith symbol logicalandtextp contents logicalandtext anegationslash contents input contents cell change tape head cell step clause tapehead logicalandtexta contents contents don write cnf form readability cell tape head positioned time row multiple possibilities position tape head contents cell depending transition relation clauses tapehead state contents tapehead state contents tapehead state contents tapehead state contents left reader end formula variables constructible time polynomial length freedom setting variables corresponds freedom making nondeterministic choices computing satis valid computation path accepts resulting formula simple structure due structure reader verify individual bit formula computed ciently time polynomial length position address bit computed equivalently time polylogarithmic size input establishes mapping reduction proof complete completeness nqlin present theorem shows tighter result complexity reductions connect problems sat problem sat complete problems solved quasi-linear time quasi-linear time mapping reductions proving hardness part theorem make simplifying assumptions model computation previous theorem start ning complexity classes related quasi-linear time 
obvious qlin dtime logc nqlin ntime logc theorem sat complete nqlin qlinm bit mapping reduction computable logarithmic space polylogarithmic time proof theorem rst show sat nqlin discuss language nqlin reduced quasi-linear time sat observe sat computed quasi-linear time nondeterministic random access machine rst guesses linear time satisfying assignment evaluates formula guessed assignment quasi-linear time show sat nqlin-hard begin making key observation principle quasi-linear-time nondeterministic machine access locations non-index tapes addresses quasi-linear length claim loss generality assume addresses logarithmic length reason construct ntm simulates constant factor overhead time satis restriction non-index tape additional non-index tape stores list address pairs cells accesses address logarithmic length simulation store contents cells small addresses remaining cells accessed track address pairs tape cient data structure sorted doubly linked lists pairs addresses length address lengths note list address pairs quasi-linear size index values logarithmic retrieve pair insert perform updates constant factor overhead time exploiting power nondeterminism guess tape locations simulates constant factor overhead time accesses cells tapes addresses logarithmic length similar proof theorem step computation associate block boolean variables block represents information beginning time step internal state machine con guration contents tape head position index tapes iii tape head positions non-index tapes contents cell tape head transition machine step notice information needed advance execution step block logn variables capture intended information represented constant number variables light earlier observation iii logn variables blocks variables set clauses clauses satis blocks represent valid accepting computation input achieve checking initial block corresponds valid transition initial con guration pairs successive computation steps consistent terms internal state contents index tapes tape head positions tapes indexed iii accesses indexed non-input tapes consistent accesses input tape consistent input nal step leads acceptance proof theorem conditions linear number constituent conditions expressed clauses polylogarithmic size variables additional auxiliary variables bit clauses computed polylogarithmic time logarithmic space remains show conditions iii check consistency accesses indexed non-input tapes tape separately tape ine cient perform consistency check pairs blocks verifying accessed cell block accessed cell contents cell block dictated transition encoded rst block approach captures essence formulation isn adequate due quadratic overhead introduces construction made cient rst sorting blocks non-index tape stable tape head location block perform deterministic simulation incur logarithmic overhead time fine purposes require involved data structure balanced search tree stable sort exchanges order elements comparator inputs outputs figure simple diagram sorting network consistency check tape pairs consecutive blocks verifying accessed cell contents cell block dictated transition encoded rst block accessed erent cells contents cell block blank conditions expressed note stable sort order maintain order accesses tape cell construct boolean clauses mimic deterministic sorting procedure avoiding quadratic overheads focus nlogn sorting procedure point hit block order ciently formulate quasi-linear computation ciently formulate quasi-linear computation stuck computation speci type lends quasi-linear formulations formulate sorting procedure making sorting networks sorting networks speci type circuit inputs outputs input values length logn outputs inputs stable-sorted order circuit consists single type element called comparator element basically stable-sorting box elements figure detail fact exist easily computable sorting networks size nlog number constructions yield result batcher networks worth mentioning due simplicity built merge-sort divide-and-conquer strategy so-called odd-even merger network constructed level divide-and-conquer refer reader algorithms book clrs sorting networks associate block boolean variables connection network include clauses enforce correct operation comparator elements network conditions expressed similar condition size constructibility properties network guarantee resulting boolean formula quasilinear size bit computed polylogarithmic time logarithmic space consistency input tape accesses actual input checked similar condition iii erence running stable sorting input tape prepend dummy blocks ith input tape head set location approach handling condition iii enforces input accesses consistent values encoded dummy blocks explicitly variable encodes ith input bit dummy blocks include simple clauses force variable agree ith bit established quasi-linear mapping reduction problem nqlin sat problem proof complete strikingly turns naturally occurring np-complete problems nqlin-complete problems connected tight sense ignoring polylogarithmic factors solved amount nondeterministic time shown sat nqlin-complete qlin reductions transitive proving nqlin-completeness subsequent languages easier task show nqlincomplete show sat qlinm fact time problem proved nqlin-complete tool proving subsequent problems nqlincomplete give avor reductions prove nqlin-completeness additional problems sat theorem sat complete nqlin qlinm proof give quasi-linear time reduction sat sat formula cnf form output equivalent formula -cnf form clauses literals transferred modi cation clause literals converted clause literals repeating literals contained clause clause literals clause converted equivalent -cnf formula introducing variables formula satis original clause satis general clause form converted formula leave reader verify reduction takes quasi-linear time reduction sat sat simple problems closely related proof reduction typical required proof npcompleteness theorem complete nqlin qlinm proof prove nqlin-complete reducing sat cnf formula show convert graph integer satis minimum size vertex cover clauses variables reductions sat sat basic idea create set gadgets clause set gadgets variable connect fashion gadget clause complete graph vertices literals vertex represents figure graph generated reduction sat formula assignment true false true satis induced vertex cover highlighted graph literal clause gadget variable vertex complete graph vertex represents represents gadgets connected vertex representing variable clause edge inserted graph connecting gadget appears positively connection made portion gadget representing made portion representing construction figure minimum size vertex cover gadgets representing variables vertices chosen gadget representing clause vertices chosen vertex cover graph size summationtextmj fact vertex cover size satis reduction outputs graph summationtextmj target vertex cover size demonstrate reverse implication leave direction exercise satisfying assignment rst vertex variable gadgets assignment assignment satis clause choice variables covers edge clause gadget choosing vertices clause gadget completes vertex cover leave exercise verify graph generated adjacency list form quasi-linear time lecture fact naturally occurring np-complete problems nqlin-complete brings questions complete problems nqlin ciently strong hierarchy nondeterministic time recall due asymmetry involved obtaining hierarchy results nondeterministic computation cult address issue time obtain results assuming pnegationslash problems np-complete np-intermediate problems exist np-intermediate problems natural fact general belief current natural problems cient solution show np-complete graph isomorphism factoring np-complete ciently solvable haven clever complexity theory lecture time-bounded nondeterminism instructor dieter van melkebeek scribe baris aydinlioglu time presented strong connection problems proof sat problem np-complete polynomial time mapping reductions strengthened result showing cient 
reduction runs quasi-linear time establishing nqlin-completeness sat mentioned natural problems polynomial-time algorithm unknown eventually shown np-complete nqlin-complete nished lecture questions ers complete problems nqlin problems np-complete rst part today lecture tackle questions order answer rst question obtaining hierarchy results non-deterministic polynomial time explicitly constructing np-intermediate language remainder lecture discuss concept relativization explain question orts researchers decades nondeterministic time hierarchy start showing nondeterministic setting similar deterministic case time strictly theorem time bounds timeconstructible ntime subsetnoteql ntime proof recall directly apply diagonalization technique separating deterministic time proof deterministic time hierarchy polynomially time hands universal dtm simulate computation dtm lower time bound result deterministic computations lower time bound nondeterministic setting hand ciently simulate ntm negate output ntm exponential time hierarchy result exponential jumps time interesting erent technique modi version diagonalization technique proof deterministic time hierarchy named delayed diagonalization based idea deterministic setting diagonalize machines running lower time bound ensuring disagree machine input ensure disagree interval inputs don care input disagree fact won simulate machine interval inputs contrast deterministic case mapped input machine map intervals inputs machine specifically problem lies case simulated machine accepts branches rejects iim iim figure delayed diagonalization interval element interval nondeterministically simulates element interval element interval deterministically simulates rst element interval ips result interval attempts diagonalize machine time allowed ned function case deterministic time hierarchy case nite number intervals allocated machine ensures asymptotic behavior guarantee time complete construction intervals achieved skip details present discussion detailed mapping book arora barak diagonalization interval elements shortly denote kth element intervals set element interval larger size previous element integer simulates notice intervals time simulate time steps universal nondeterministic simulation constant factor overhead time behavior element interval erent dictates deterministically simulates negates result notice order brute force deterministic simulation exponentially time long takes halt size interval large figure claim disagrees element interval suppose contradiction constructed repeated application argument constructed reached contradiction shown ntime proof complete theorem tells strictly quadratic time quasi-linear time brings answer rst question raised proof leave exercise corollary exist languages np-complete nqlin-complete existence np-intermediate problems obtain answer question theorem pnegationslash np-intermediate problems proof notice statement theorem give restrictions type reductions involved proof show result strongest interpretation polynomial time oracle reductions display existence language hard main idea proof similar delayed diagonalization technique employed theorem construct language ers languages polytime dtm languages making disagree polytime dtm input make np-hard ensuring language sat disagrees input dotm oracle rst thing enumerate polytime dtm polytime dotm access l-oracle set strings member interpret parse erent ways pair dtm clocked time brevity call interpretation pair mlj mlj dotm access l-oracle clocked time call interpretation clear reasonable interpretation give enumeration desired construct conditions met fails serve reduction language sat decides language erent converse true trivial string parse half description half time bound meeting condition ensure np-hard np-hard polynomial time oracle reduction reduces sat meeting condition explicitly rules reductions similarly condition realize reasons clear condition condition order satisfy conditions construct interpolates language language sat interpolate intervals inputs agrees language agrees sat interval agrees language make interval large string dotm interval disagrees sat satis condition interval agrees sat make interval large string dtm interval disagrees sat satis condition doesn matter language pick empty set rst present construction makes meet conditions modify construction ends empty string construct phases phase realize conditions foreach phase polytime dotm equipped l-oracle nitely inputs disagrees sat case lexicographically smallest string disagrees sat sat words make agree sat starting strings length larger notice polytime dtm nitely inputs ers case lexicographically smallest string disagrees sat words make agree starting strings size larger notice mentioned close order decide membership string culty ciently nding sat agrees found rest np-computation case agrees computation trivial constrained time sat agrees running procedure hit problem lies steps long time exponential suitable string form case step step disagrees sat problem employing kind delayed diagonalization recall idea delayed diagonalization spread interval end interval elements larger beginning brute-force check hard-to-compute condition earlier elements speci cally modify construction steps waiting long easy detect disagreement sat words interval begun verify condition present interval satis smaller input modi construction presented procedure cond takes length input string returns index condition realizes length returned odd realizes condition agrees realizes condition agrees sat cond odd reject return sat procedure cond return compute cond check rst strings lex order witness ccond clock check steps decide time bound conclude witness found witness found return cond return cond procedure cond recursively calls decreasing values step compute sat rst strings lex order verify agrees sat strings length logn brute force search polynomial time fact reader verify cond runs polynomial time desired satisfying condition relativization definition relativizing complexity theoretic statement respect language means giving machine involved statement access a-oracle statement theorem proof holds relative holds relativized respect statement relativizes holds respect language statement ntime subsetnoteql ntime theorem types machines involved statement run time run time relativize statement respect oracle language giving machines access a-oracle express modi cation writing ntime ntimea ntime ntimea holds relative ntimea subsetnoteql ntimea relativizes holds language claim relativizes notice proof theorem applies verbatim modi cation needed simulation a-oracle writing query tape transitioning query state reading query output simulator a-oracle state succinctly proof theorem relativizes statement recall lecture language tuples angbracketleftbigm tangbracketrightbig ntm accepts input steps shown complete logm language kan angbracketleftbigm tangbracketrightbig halts accepts steps previous proof np-completeness relativizes language kan complete npa logm conclusion draw language notm kan observe relativizations proof completeness respect language language proofs erence oracles reach stronger result exists fixed notm kan fact essentially cient universal ntm remark key ingredient proof theorem limits simulation technique question fact turns revealing results complexity theory relativize kinds techniques diagonalization lazy diagonalization relativize core techniques lies simulation equip simulator simulated oracle statements proofs oracle carry yield proofs oracle techniques semester relativize fact techniques relativize infrequent reader assume verify statement relativizes told makes important result exist oracles relative ers exist oracles relative equals words statements subsetnoteql relativizes prove note signi cance implication corollary techniques general relativize solve question settle problem idea theorem exist oracles npa negationslash npb proof half start construction oracle language relative equals usual proof 
fact pspace-complete language oracle give alternate proof illustrates techniques oracle constructions mention alternate proof lecture construct build dotm runs polytime decides npa-complete language giving rst half theorem npa-complete problem solves kan key idea call notm kan make powerful achieve making compensate lack nondeterministic power speci cally construct results computations strategy pitfall avoided point construction store computation result language careful ect computations prior point construction order address issue make key observation input length longest oracle query make length recall works simulates notm encoded rst part input number steps equal length input simulated machine steps execute longest query make oracle length step perform query observation clears construction similar proof theorem build phases end phase assigned membership strings length procedure foreach phase foreach accepts elaborate procedure works intended fully constructed stand point phase construction phase set string length string add phase subsequent phases length longer light observation length oracle queries makes respect input size means addition string ect computations inputs length fact avoid pitfall mentioned earlier parenthetical remark observe follow order constructed trivial input simply queries oracle returns result query argue kan containment left suppose constructed implies constructed implies accepted construction implies accepts containment left suppose accepts construction accepts completes proof rst half theorem half prove half constructing language exploiting power nondeterminism language language npb notm guess string length construct enumeration polynomial dotm dotm clocked running times form case previous proofs assume machine appears enumeration nitely loss generality running time build phases phase realize condition negationslash nbi phase oracle strings longer considered previous phase ensures computation results dotm nbj previous phase remain una ected procedure constructing foreach phase pick integer nbi rejects pick string length queried deciding track maximum length string queried construction line pick large strings length set query strings length run accepts put string length realizing condition case rejects put k-length string queried realizing polynomial time dotm decides completes proof half theorem lecture lecture move current time-bounded setting space-bounded investigate power computation limits amount space results suggest space-bounded setting understood nondeterministic space closed complementation complexity theory lecture space-bounded nondeterminism instructor dieter van melkebeek scribe matthew anderson lecture discussed time-bounded nondeterminism discussed hierarchy results showed time solve strictly larger subset problems proved existence np-intermediate problems assumption negationslash finally explored relativization showing exists oracle npa oracle negationslash npb implies techniques relativize sufficient resolving versus question overview today continue discussion nondeterminism space-bounded nondeterminism prove stronger results space-bounded case time-bounded case prove main results relating space-bounded nondeterminism complexity classes theorem nspace dtime theorem nspace dspace theorem conspace nspace proof results assume space computable function logn restriction space computable proofs theorems discuss remove restriction require logn space bounds lower logarithmic strange behavior make difficult machine act interesting manner linear input theorem npspace exp theorem quadratically space perform nondeterministic computation deterministically similar result time-bounded computation result made fact space reused time result theorem fact easier compute complement language space-bounded computation iterate witnesses check valid prove conspace nspace complementing equality theorem implies tight space hierarchy nondeterministic machines diagonalization theorems results determine containment number complexity classes pspace npspace exp nexp containments follow definition classes containments npspace exp follow directly theorem pspace npspace theorem pspace simple proof pspace machine iterate witnesses checking verify membership inclusions strict open problem separations hierarchy results discussed previous lectures subsetnoteql pspace subsetnoteql corollary space constructable nspace subsetnoteql nspace proof corollary diagonalization strategy complementation easier space domain constant factor sufficient accomplish strictly recall lecture definition space usage machine index highest indexed cell accesses machine runs space machine state tape heads tape state computation state bits proof nspace dtime proof ntmm running space fix inputx configuration graph input vertex represents configuration space constants depend inequality amount space number positions input tape head inequality fact logn edge iff valid transition configurations note input tape change state information contained configuration configuration vertices independent values input tape edges dependent path start configuration accepting configuration accepted input simulation make accept state unique requiring thatm clear work tapes reset tape heads starting position moving accepting state transforms problem accepting problem graph reachability unique start configuration unique accepting configuration solve reachability problem time polynomial size graph standard algorithms graph size case result nspace dtime proof works nicely space constructable case run procedure times increasing fixed space-bound computation space complete precisely iterate space bounds computation reaches accepting state accept computation accept exceed space bound repeat procedure larger space bound computation path exceed space bound accept path accepting state reject corollary directed path problem dpp logm -complete figure illustration configuration tableau proof theorem tableau width describe configuration step runs time bounded proof dpp store location vertex visiting guess vertex visit continue procedure reach destination traveled steps dpp hard apply configuration graphs machine corollary implies dpp dpp stconnectivity problem stcon dpp undirected version problem proof nspace dspace proof ntm running nspace fix input computation tableau original discussion computation tableau applied techniques one-tape turing machine random access model configuration bits label starting configuration label unique accepting configuration resetting idea principle computation time infinite exists accepting computation exists accepting computation repeat states fact assume computation takes time forcing accepting state repeat diagram tableau shown figure determine sequence states time space naive approach exponential space achieve quadratic space blow divide conquer strategy directly guess intermediate state verify independently benefit reuse space part computation part highest level computation thisreduces original probleminto subproblemsof half size apply procedure recursively reusing space computation part problem halving size problem level logt recursions reach base case verify state transitions step phrase full quantified boolean formula cxt index part equation dependent previous choices variables predicate checks configurations guessed immediately cxt valid step transitions cxt space required evaluate boolean formula existential quantifier requires space describe configuration universal quantifier requires bit information store logt pairs quantifiers total amount space required logt implicitly assuming space constructable apply technique remove requirement tqbf boolean formula introduced previous proof called quantified boolean formula types formulas part interesting language called true quantified boolean formulas definition true quantified boolean formula tqbf language quantified boolean formulas number quantifier alternations free variables true negationslash tqbf tqbf corollary tqbf complete pspace proof proof theorem polynomial mapping reduction 
general pspace problem transforming tqbf polynomial time making tqbf hard pspace tqbf pspace pspace machine iterate possibilities note pspace ptqbf corollary ptqbf pspace queries oracle constructed polynomial time closure polynomial composition ptqbf pspace taking idea containment ptqbf pspace nptqbf pspacetqbf pspace equality model dependent matters count cells oracle tape oracle tape counted pspacetqbf machine abuse oracle tape compute unassisted pspace machine oracle time natural npa note techniques relativize sole means solve versus question proof conspace nspace proof ntm space fixed input graph vertices reachability guessed reachability log space theorem shows complement computed log space showing path exist key idea proof vertices reachable start vertex verified destination vertex vertices vertices guessing verifying reachable order count number reachable vertices procedure call inductive counting suppose subroutine behaves subroutine takes input graph start vertex destination vertex number steps allowed number vertices steps subroutine return values answer means reach steps answer means reach steps return means procedure unable determine answer return subroutine made bad internal guesses bad input case output trusted computation path compromised subroutine run correct answers computation path returns passed correct subroutine return describe subroutine specifically subroutine solve original problem start compute set run subroutine subroutine add continue subroutine continue subroutine halt reject final looping possiblev number vertices reachable step iterate procedure compute current values stored point computation finally run subroutine time parameters answer accept answer reject entire computation accepts exists computation path correctly tracks counts reachable step path step computation inconsistent bails rejecting writing subroutine idea subroutine simple cycle vertices guess reachable subroutines guess reachable verify reachable vertex reachable subrountine modifies count reachable vertices checks reachable additional step count match count passed parameter verify reached subroutine input graph starting vertex number steps number vertices steps destination vertex output reachable steps reachable steps computation determine correct computation path return correct answer foreach guess reachable steps guessed verify guess nondeterministically guessing path steps successfully verified reached step return return return return main point technique number positive instances reachable vertices guessing verifying positive instances verify count correct count check instance question member positive set time lecture discuss alternation generalization hypothetical model nondeterministic computation alternation captures languages fixed number quantifier alternations tqbf complexity theory lecture alternation instructor dieter van melkebeek scribe piramanayagam arumuga nainar past lectures studied depth non-deterministic model computation lecture extend general model alternation derive results classes problems solved alternation discuss characterizations model alternating turing machine generalization non-deterministic turing machines motivation non-determinism hypothetical model important captures complexity interesting problems class problems solved non-deterministic polynomial time languages membership verified efficiently polynomial time state formally language iff exists non-determinism restrictive efficiently solve interesting problems minimizing cnf formula equivalent decision problem testing cnf formula minimum size define min-cnf cnf minimum size state membership min-cnf min-cnf size negationslash cnf smaller expressed string size polynomial case assignment values variables checking polynomial time takes sat verifications test equality stmt rewritten resemble formulation min-cnf logical formulas describe membership language stmt min-cnf stmt notice significant differences quantifiers universal quantifier generalization make alternating model quantifier formulas expressing membership constraints languages alternating universal existential quantifiers adjacent quantifiers type combined leaving quantified variable polynomial size input alternating model define general complexity class qpk set languages membership constraints expressed formulas alternate existential universal quantifiers quantified variable size polynomial length input initial quantifier existential universal notational description definition membership expressed formula form qyk constant definition membership expressed formula form qyk constant notes quantifier odd dual true super-script denotes poly-time verifiability small notational inconsistency denote class problems denote input alphabet intended usage clear context facts quantified variables verifier decide membership input words algorithm absence quantifiers real distinction existential universal quantification definition earlier state prove general result conp finally description min-cnf matches min-cnf class hierarchy results proposition simple result state classes introduced solve equal number problems greater number quantifier alternations trivial add unused variable quantify appropriately leave unchanged proposition transformthe membershipconstraint byaddingan universally quantified variable end adding universally quantified variable beginning similar argument applies result holds proposition proof language iff verify string negates membership constraint defn quantifiers switched leaving predicate verification task efficiently similar argument holds conp figure pictorial illustration polynomial hierarchy propositions illustrated figure kth line sloping upwards bounds languages kth line sloping bounds lines lines previous levels lines collapse cop corollary conp derived question inclusion proposition strict simplest version question words pnegationslash turned hard result prove based definition polynomial hierarchy definition class problems polynomial time hierarchy fixed number alternations allowed uniontextk note include previous definition consequence proposition theorem words polynomial time hierarchy collapses level proof language string iff condition true qyk qyk qyk qyk predicate input equivalent predicate input existential quantification equation merged initial existential quantifier leaving predicate input words language expressed predicate combining proposition multiple alternate applications operations converting predicates merging quantifiers prove note condition theorem required quantifier make premise non-trivial corollary proof proved conp theorem polynomial hierarchy collapses corollary state collapse negationslash stronger statement pnegationslash polynomial hierarchy collapse class general conjecture community collapse fact results start assumption derive collapses order disprove likeliness assumption completeness problem complete definition set true fully quantified formulas predicate cnf odd dnf similarly define set true fully quantified formulas claim pm-complete pm-complete proof language verifier suppose odd quantifier quantifier statement np-completeness sat converted polynomial time statement cnf formula instance true suppose quantifier quantifier conp statement conp-completeness tautologies converted polynomial time statement dnf formula instance created reduction accomplished polynomial time hard construction complete similar argument proves pk-complete alternate characterizations oracle machines claim words set languages level polynomial hierarchy set languages recognized non-deterministic machines access oracles kth level proof statement npp npp trivial simply choose oracle npp time complexity oracle worst case increase degree polynomial time complexity statement non-trivial suppose language construct non-deterministic guesses solve formula solved oracle general language solved oracle complement suppose express decidable express computation path base machine formula guessing queries made machine results queries express constraints positive query responses valid predicate express constraints negative query responses valid predicate universal quantifier required step ensure non-existence witness query existence predicate expresses decidability hand side written npnp arguments similar boolean circuits claim language expressed exponential size boolean circuit alternating levels gates unbounded 
fan-in level polynomial bounded fan-in bit circuit description computed polynomial time vice-versa proof language verifier construct enormous boolean circuit exponential number polynomial circuits evaluating membership inv combinations specific make polynomial circuits levels expressing function cnf dnf outputs circuits combined hierarchically levels leave single output top-most level output decision ith level array gates universally quantified array gates existentially quantified number gates ith level equal number choices inputs appropriately choosing cnf dnf verifier merge gates kth level top gates normal form chosen verified bit poly-time computable boolean circuit gate top-most level construct formula compute language decided circuit determine bits guess quantifiers top-most gate output exists gate lower level output express output gate level gate gate produce output gates level produce output stmt output gate gate output connected input chosen circuit exponential circuit represent gates circuit polynomial size indices repeatedly apply steps predicate final verification task evaluating output gate level bit circuit description computable polynomial time choices indices level identify gate evaluated bits input gate evaluate predicate formula poly-time language circuit similarly construct language circuit gate top-most level alternating turing machines section extend non-deterministic turing machine model alternation alternating non-deterministic non-halting state additional property existential universal configuration machine accepting halting configuration machine accepting state current state existential transition state leads accepting configuration current state universal configurations state leads accepting configuration machine accepts input initial configuration accepting final characterization claim accepted alternating existential start state runs polynomial time quantifier alternations accepted alternating universal start state runs polynomial time quantifier alternations proof language construct stage alternating ith stage guessing match quantifier states ith stage existential odd universal verifier require non-determinism states simulate made existential universal depending recognizes existential start state performs alternations similarly construct alternating recognizes language satisfies constraints alternating performs alternations construct equivalent language halts polynomial time time spends stage alternation polynomial model choices made ith step polynomial length string existential universal stage quantified existentially universally verifier verify choices made valid input machine final state halting accepting polynomial time resulting formula formula initial state existential formula time space definition time space required turing machine define complexity classes k-time k-space derive hierarchy results technique earlier delayed diagonalization results simplified unlimited number alternations define atime set problems solved time alternating number quantifier alternations aspace set problems solved space alternating number quantifier alternations results time space theorem nspace atime proof proof nspace dspace lecture remember constructed formula similar formula divide-and-conquer formulation proof existential quantifier guessed intermediate configuration long turing machine universal quantifier independent reachability conditions bit wereo quantifiers final predicate verifies transition configuration valid takes time configuration long guessing stages machine time verification end takes time total running time theorem atime dspace proof alternating machine running time separate execution existential universal stages long begin simulating long remains stage stage simulate choices stage separate choices cycle space stage simulate choices stages takes space cycle total stages cycle guesses space guesses existential stage ensure guesses results accepting computation guesses universal stage ensure guesses result accepting computation sequence guesses simulatem guesses space-efficient universal turing machine lecture convert equivalent machine space total space usage corollary pspace proof thm pspace pspace npspace thm pspace theorem aspace uniontextc dtime words time exponential space requirement deterministically simulate alternating proving theorem homework problem corollary corollary apspace exp lecture time alternation prove non-existence sat-solvers time space efficient main topic class non-uniformity algorithms inputs lengths complexity theory lecture nonuniformity instructor dieter van melkebeek scribe chi man liu lecture studied alternations related polynomial-time hierarchy gave characterizations alternation model introduced alternating time space complexity classes part lecture make alternations prove time-space lower bound results sat part lecture introduce notion nonuniform computation nonuniform models discuss include boolean circuits branching programs uniform machines advice conclude lecture connections uniform nonuniform models time-space lower bounds sat sat solved polynomial time remains open question question resolved sat solved linear time results ruled seemingly ridiculous possibility strikingly sat put time space consideration prove nontrivial lower bounds sat definition functions class dtisp defined consist languages accepted dtm steps space note dtisp dtime dspace general theorem algorithm sat timeand space-efficient theorem proved nondeterministic linear time prove lemma sat essentially captures power nondeterministic linear time lemma sat dtisp ntime dtisp poly-log poly-log proof recall lecture proved sat complete nqlin qlinm bit reduction computed polylogarithmic time logarithmic space language ntime nqlin input length compute reduction sat reduction length npoly-log reduction solve deterministic poly-log time deterministic algorithm sat hypothesis computed reduction straightforward manner space npoly-log space storing reduction note dmay modify sat algorithm run directly inputs algorithm requires bit reduction bit computed original input computation single bit polylogarithmic time logarithmic space incurs polylogarithmic blow-up time space requirement poly-log lognfactor computing reduction on-the-fly absorbed theorem sat dtisp constants proof lemma suffices show ntime notsubseteql dtisp ncpoly-log poly-log prove contradiction proof assume ntime dtisp show leads violation nondeterministic time hierarchy theorem polylogarithmic factors add term exponent time space usage reach contradiction include factors proof involves alternations discussed previous lecture split proof parts speed deterministic computations introducing alternations dtisp -time eliminate alternations -time ntime hypothesis part letlbe language dtisp fix input stringx computation tableau rows columns row describes configuration turing machine point time call initial configuration unique accepting configuration reached steps proof nspace dspace lecture guessed intermediate state verified independently technique time splitting tableau parts split parts determined guess configurations verify steps computation stated note fact computation analyze time computation guessing existential part takes time length guessing universal part takes time logb verification part takes time easily simulate step deterministic computation constant time combining running time achieve speedup minimize setting appropriately setting achieves constant factor minimum radicalbigt running time dtisp time part letl language -time somea computation forlcan written deterministic linear time computable predicate note co-ntime fixed length ntime dtisp co-ntime dtisp closed complement dtime ntime ntime nac time ntime nac combining parts dtisp -time ntime final step showing ntime dtisp ntime ntime contradicting nondeterministic time hierarchy theorem inclusion hypothesis technique called padding notice included polylogarithmic factors end addition term final running time reach conclusion ntime ntime remains contradictory nondeterministic time hierarchy padding language ntime claim ntime ntm accepting runs quadratic time construct 
ntm accepting input checks member counting number leading zeroes extracts removing artificially padded prefix simulates computation radicalbig computation takes time ntime dtisp dtisp algorithm decide dtisp instance pad decide dtisp equivalent solved dtisp corollary suppose sat dtisp constants statement corollary algorithm sat space-efficient logarithmic space runs super-linear time statement algorithm sat time-efficient linear time polynomial space logarithmic space sufficient theabove theorem andits corollary show inefficiency time space asingle algorithm sat exists linear-time linear-space algorithm logspace quadratic-time algorithm sat lower bound result rules possibility theorem sat co-ntime proof exercise corollary sat dtime nonuniformity motivation computational models turing machines random access machines work inputs lengths call uniform models computation section introduce nonuniform models computation short nonuniform model computational model machine generally computing device input length machine inputs length machine inputs length machine length machines form infinite family machines nonuniformity bit odd sight uniformity natural form computation resembles algorithms finite procedures inputs interested nonuniform models fact close relationships uniform nonuniform models studying nonuniform models derive lower bound hardness results uniform models relationships section nonuniform models computation introduce forms nonuniform computation nonuniform models boolean circuits branching programs solve instances specific problem fixed input length simplicity assume languages defined binary alphabet boolean circuits analyzing uniform time complexity problems branching programs space complexity model fact uniform model nonuniform ingredient advice advices similar certificates additional information speed computation difference certificates advices certificates vary input input inputs length share advice words advice input depends length briefly discuss models section relate nonuniform models uniform models boolean circuits define boolean circuits similarly real-world electronic circuits boolean circuit directed acyclic graph node logic gate input input node incoming edges gate nodes designated output node outgoing edges label input nodes input string boolean circuit computes output single bit bits copied input nodes topological order logic gate receives bits incoming edges performs boolean operation bits sends output bit outgoing edges output circuit bit output output node output depth figure boolean circuit function boolean circuit realizes output matches input circuits gates bounded fan-in define circuit size function size smallest terms number nodes circuit realizing boolean circuits accept language circuit inputs uniform computation circuit inputs lengths formally family circuits accepts language realizes characteristic function restricted inputs length define circuit complexity circuit complexity language good measure uniform time complexity reason boolean circuit simulate computation uniform machine linear time likewise turing machine runs time encode transition function boolean circuit size quadratic measure depth circuit equals length longest path input output node circuit depth comparable uniform time complexity circuit size specific language input length convert membership cnf dnf build constant-depth circuit fan-in circuit converted equivalent linear-depth circuit bounded fan-in note language circuit complexity considerably smaller uniform time complexity due algorithm inputs restriction imposed uniform computation branching programs branching program directed acyclic graph node labeled accept reject node labeled accept reject outgoing edges marked nodes designated start node computation input starting start node label follow edge node input string repeat reaches accept node reject node note similar boolean circuit branching program works inputs specific length function define branching program complexity size smallest branching program accepts start accept reject figure branching program family branching programs accept language branching program complexity bpl language defined bpl subsection boolean circuits branching program complexity language good measure uniform space complexity suppose branching program nodes simulate computation turing machine logv space space store index current node suppose turing machine space runs time construct layered branching program branching program nodes partitioned layers edge layer layer layers nodes layer node represents machine configuration layer single node representing initial configuration node start node node subsequent layers labeled variable current input tape head position configuration edges valid transitions successive configurations node accept resp reject node represents accepting resp rejecting configuration size branching program simulations roughly logarithmic relationship size branching program space usage turing machine candidate measurement width layered branching program equals maximum number nodes layer note language branching program complexity bpl considerably smaller uniform space complexity uniform models advice models discussed machine input length resulting infinite family machines model similar uniform models single machine input lengths give extra power nonuniformity uniform machine allowing access advice piece additional information improve efficiency computation definition function class languages define class exists sequence definition called advice sequence upper bound length advice note advice machine depends length input differs certificates input certificate restriction certificates inputs equal length advice powerful length bounded bit fact exist uncomputable languages computed one-bit advice halting problem halt encodes dtm halts input halt uncomputable turing machine language lexicographic rank halt clear halt uncomputable advice sequence characteristic function halt computed machine simply outputs advice bit input connections uniform nonuniform models section present results relating nonuniform models uniform complexity classes poly class languages computed polynomial time usingpolynomiallength advice similarly poly class languages computable logarithmic space polynomial-length advice theorems show relationships nonuniform models complexity classes theorem poly polynomially bounded proof sketch construct polynomial-size circuits accepting language poly hardwiring polynomial-length advice strings additional inputs polynomialsize circuits descriptions circuits advices proof theorem similar left exercise theorem poly bpl polynomially bounded uniform boolean circuits family circuits uniform exists uniform machine outputs description time polynomial uniform branching programs defined similarly notion uniformity standardized differ context theorems uniform circuits branching programs uniform theorem uniform polynomial-size circuits proof sketch dtm accepting construct circuit inputs length hardwiring valid transitions constraints computation tableau runs polynomial time computation tableau polynomial size resulting circuit polynomial size computed polynomial time inputx uniform machine computes polynomial time simulates computation polynomial time theorem uniform polynomial-size branching programs time class poly problems solvable polynomial time advice polynomial length np-complete problems happened computed advice strings polynomial-time algorithms making solve np-complete problems efficiently lecture show case prove poly polynomial-time hierarchy collapses level move talk constant-depth boolean circuits complexity theory lecture constant-depth circuits instructor dieter van melkebeek scribe seeun william umboh draft lecture applied alternations prove time-space lower bound results sat introduced notion nonuniform computation nonuniform models boolean circuits branching programs uniform machines advice today begin theorem suggests sat small circuits investigate constant-depth circuits small circuits collapses theorem poly note show simulate computation computation proof language predicate decided deterministically time 
linear combined input predicate input reduce sat instance hypothesis exists circuit csat size polynomial running time decide size polynomial size letting denote reduction replace predicate csat rephrase formula roughly exist circuit solving sat strings circuit accepts transform right-hand side csat input size csat size csat recursive predicate variable thencsat csat csat csat true unset variable slight detail circuit csat takes inputs fixed input size varying size simply pad equivalent instance required size essentially guess circuit csat combined predicate checks csat accepts csat valid circuit solving sat evaluating polynomial size circuits evaluatentimes takes polynomial time check universal quantifier merged single polynomial time verifiable predicate formula note hypothesis crucial polynomial size circuits fail polynomial-time hierarchy collapses evidence suggesting polynomial-size circuits proofs similar leave exercises exercise pspace poly pspace exercise exp poly exp nonuniform lower bounds previous lecture stated application nonuniform models computation attempts prove lower bounds computing functions np-complete problems fact beenlittle progress proving lower boundsfor np-complete problems survey results section nontrivial lower bounds proven restricted models computation discussed section boolean circuits facts area theorem boolean function naive encoding truth table dnf -size circuit analysis bound theorem boolean functions pick uniformly random set boolean functions variables probability converges grows proof denote number binary gates gates pick variable gate input gate inputs number circuits size mostsis wherecis constant takes care possibility input negated map circuits boolean functions maximum number boolean functions computable gates number boolean functions variables slogs setting sufficiently small constant slogs nlogd logn claim shows boolean functions require circuits maximum circuit size constant factor expect complicated functions capture np-complete problems prove non-trivial lower bounds case lower bound proposition branching programs branching programs show functions case boolean circuits lower bound roughly quadratic lower bound case boolean circuits trivial result recall previous lecture turing machine logv space size branching program hope prove lower bound branching program size restricting attention layered branching programs constant width powerful sight prove substantially lower bounds arbitrary branching programs constant-depth circuits unable prove lower bounds np-complete problems general setting focus attention restricted model constant-depth circuits give basic facts constant-depth circuits prove require exponential size compute parity function definition constant-depth circuit constant-depth circuit boolean circuit unbounded fan-in depth bounded constant model restricted mentioned function computed depth cnf dnf circuit general exponential size parity function size required exponential encountered constant-depth circuits lecture alternation showed simulate alternation constant-depth circuits exponential fan-in today circuits polynomial size family classes definition ack ack logk polynomial logk denotes complexity circuits unbounded fan-in depth logkn deciding restriction length interested class languages decidable constant-depth circuits polynomial size examples languages proposition decision variant binary addition proof proof strings indexed determine ith bit sum ith bits summands determine carry bits position introduce notation label column depending generates carry bit transmits carry bit stops carry bit input bits column column labeled bit labeled bits column labeled carry column point columns words determine carry ith position job reduced detecting string form guess length number lengths linear input size length determine symbol string xors ensure symbols big xors level ands ands xors xors implemented constant depth ands ors nots circuit constant depth discuss problems computed ack future lecture sketch proof parity requires exponential size computed constant-depth circuits definition parity odd number denote parity variables circleplustextn theorem parity proving result shown parity computed polynomial size circuits bounded fan-in log-depth theorem divideand-conquer strategy fact proof outline today shows circleplustextn parity computed circuits size exact characterization size constantdepth circuits required compute parity proof present today tool definition random restrictions p-random restriction variables random function independently leave variable set result note apply random restriction parity function parity function complement bits set proof sketch theorem start circuitc wlog assume level ands ors circuit alternates assume inputs circuit variables negations allowing ignore gates part main ingredients proof proposition circleplustextn proof depth easily prove exponential lower bound assumption circuit dnf cnf assume dnf terms check setting variables circleplustextn variables flip variable detect difference n-variable terms dnf formula half half check circleplustextn size bound stated lemma switching lemma cnf small bottom fan-in apply random restriction set variables high probability resulting function written dnf small bottom fan-in note statement trivial restriction set variables setting variables important qualifications small quantified appropriately statement hold exposition approach qualitative level proof idea ors size notice random restriction set literals involved set happen small nontrivial probability cases large number pairwise disjoint ors case independent events set gate pairwise disjoint ors set events nontrivial probability odds random restriction set gate case trivially written dnf small bottom fan-in large number pairwise disjoint ors minimal set variables queries variable lot overlap ors small query variables essentially reduced problem simpler type transformation cnf bottom fan-in ors literal repeat case distinction simpler problem depending setting variables branch process eventually end case steps step involves querying small number variables end decision tree small depth represents cnf random restriction high probability decision tree small depth turned dnf small bottom fan-in writing paths decision tree lead acceptance conditions define path note switch dnf cnf negation circuit switching lemma reduce depth circuit time left circuit depth suppose bottom gates ands apply switching lemma ensure gates bottom circuit small fan-in ensure insert dummy gates gates input gate replace apply switching lemma ors created high probability application successful creating ands small bottom fan-in setting variables bottom-most bottom-most levels ors merged reduces depth circuit back added level initially circuit small bottom fan-in apply switching lemma repeat process circuit depth point computed circleplustextn computescircleplustextm somem-subset variables unset random restrictions point proposition derive lower bound size remaining circuit original circuit large exponential lower bound size original circuit positive probability application switching lemma successful lecture give alternate proof parity requires exponential size constant-depth circuits proof low-degree polynomial approximations random restrictions bound circleplustextn tight previous result advantage applies circuits gates complexity theory lecture polynomial approximations instructor dieter van melkebeek scribe piramanayagam arumuga nainar time proved constant depth circuit evaluate parity function random restrictions obtain bound complexity circuit evaluating parity inputs lecture complete give alternative proof slightly weaker bound random restriction method showed thatcd tight bound property parity function sensitive bit input derive similar 
bound modm function defined modm braceleftbigg mod number non-zero bits input parity special case modm function prove majority function returns bit bit occurs maximum number times input proved parity function black box left exercise lecture low degree polynomial approximations show weaker bound technique interesting result applies mod gates circuit finally prove constant depth circuits approximately evaluate parity polynomial approximation method theorem nnegationslash specifically proof outline prove steps show constant depth circuit approximated low degree multi-variate polynomial field free ability mimic mod gates general prime number handle modp gates show parity function approximated multi-variate polynomial sufficiently low degree field proof step circuit made mod gates represented multi-variate polynomial degree size input goal represent polynomial lower degree allowing errors required literal directly passed input gate represented polynomial base case construction assume polynomial ith input gate types mod goal construct polynomial represents output gate note number inputs gate polynomial representing input gate represents output gate notice representation gate increase degree polynomial mod gate output gate msummationdisplay summation output note field model gate polynomial msummationdisplay accurately models gate degree degree inputs gate output gate words output represented mproductdisplay formulation accurate degree times degree largest degree higher trivial bound gates levels circuit tackle model linear combination coefficient modm square linear combination boolean leaves msummationdisplay makes degree degree inputs accurate description gate suppose pick coefficients random evaluate probability boolean expression irrespective values picked coefficients output correct msummationdisplay summationdisplay wrong cases random assignment coefficients introduce errors representation probability randomized algorithm repeat calculation independent trials output trials note output correct output wrong leads final formulation application eqn inputs kth trial formulation eqn shorthand formulation produces wrong output trials produce wrong output probability degree increases factor factor -formulation factor -formulation handle gate similar resulting approximation factor blow-up degree giving imprecise probability depth circuit degree polynomialp representing entire circuit wrong output gates wrong probability note tight upper bound proof averaging expected number inputs give wrong inputs length exists choice random coefficients wrong expected number derived formally lemma exists choice exists set relative size polynomial degree constructed relative size respect set inputs equal construction generalized work field prime allowing mod gates property mod anegationslash mod squaring polynomial ensures boolean values work raise polynomials power mod negationslash mod degree resulting polynomial step step polynomial degree approximates subset inputs establish upper bound function inputs polynomial approximating equating number functions number polynomials degrees greater established upper bound derive lower bound depth circuit step transform inputs slightly convenient domain proposition suppose exists polynomial degree computes set exists polynomial degree set nproductdisplay reason parity boolean inputs equivalent multiplication lemma suppose exists polynomial degree represents multiplication set function multi-variate polynomial degree represents proof function multi-variate polynomial degree trivial hardwire input monomials degree start polynomial monomial form productdisplay subset input bits concerned inputs rewrite productdisplay productdisplay productdisplay productdisplay nproductdisplay productdisplay productdisplay eqn holds input bits eqn holds inputs set lhs degree rhs degree degrees smaller equal make degree monomial exceed lemmas ready combine prove theorem suppose exists circuit depth computing lemma exists polynomial degree computes parity set relative size lemma functions represented multivariate polynomial degree total number polynomials number functions number multivariate polynomials degree number monomials degree monomials degree summationdisplay parenleftbiggn parenrightbigg number monomials degree half monomials remaining terms summation lower parenleftbignn parenrightbig maximum number degree stirling approximation show parenleftbiggn parenrightbigg parenleftbigg parenrightbigg parenleftbig parenrightbig parenleftbig parenleftbig number functions form values assigned element number functions form number polynomials degree words bound size parenleftbigg parenrightbigg lemma parenleftbigg parenrightbigg bracketleftbigg parenleftbigg setting tight rhs equation part analysis working result holds lower bound boolean circuits mod gates prime fact argument proof generalized give lower bound circuits mod gates compute mod recall parity special case achieved viewing step harmonic analysis generalizing harmonic analysis generalization takes bit work prove leave lower bound parity proved viewing parity multiplication lower bound multiplication corollary decision variant binary multiplication proof give lower bound circuits approximate parity corollary depth unbounded fan-in circuit agrees parity fraction size proof suppose circuit correct inputs similar theorem prove exists polynomial degree correct set step proof parenleftbigg parenrightbigg parenleftbigg parenrightbigg bracketleftbigg parenleftbigg note term ensure lower bound positive set optimize rhs corollary proves inapproximability parity function constant depth circuits result proved random restrictions theorem depth unbounded fan-in circuit agrees parity fraction size interesting trivial functions guess parity correctly half inputs slightly weaker bound derived lecture disproves approximability computability parity function results inapproximability discuss pseudo-randomness lecture lecture discuss parallelism distribute computational task multiple processors reduce time complexity complexity theory lecture parallelism instructor dieter van melkebeek scribe matt elder goal parallelism speed computation dividing processors lecture discuss models parallelism complexity classes capture efficiently parallel-computable problems conceptual model model parallelism roughly power large collections turing machines acting means communication ourmodel capture means communication form interconnections processors model blithely assume connections free realistic real parallel computers interconnection network confusing pieces network configurations butterfly nets hypercubes grow reasonable rates yield communication processors logp time number processors model impose limits number processors model diverge physically realizable computers constant number processors give constant speedup standard turing machine problem number processors grow input size entail issues uniformity ourcriteria forefficiency change whenwe move fromstandard turingmachines vastly parallel computers aim polylog time polynomial time achieve permit number processors polynomial size input concrete model model parallel computation uniform nc-circuits class similar defined definition nck set languages recognizable circuits bounded fanin polynomial size logkn depth union classes nck nck circuit uniform circuit computed size input logarithmic space uniformity condition considered standard typically means uniform thesis efficient parallel algorithm iff uniform leave reader verify complexity class uniform nck closed composition log space mapping reductions complexity place class classes nck hierarchy theorem uniform uniform proof show uniform suppose uniform family -circuits decides language input simulate logarithmic space compute circuitc precisely compute bit description ofc needed space store entire description circuit compute part logarithmic space uniform output node compute values gate recursively memoization painfully slow optimize space depth log computation logarithmic space output accept reject fact uniform left exercise relate class hierarchy classes closely related hierarchy theorem nck ack nck proof nck restriction ack inclusion clear inclusion implied 
fact polynomially-bounded fanin simulated simple logarithmic-depth circuit bounded fanin languages nck give feel hierarchy efficiently basic tasks accomplished parallel class definition languages decidable constant-depth constantfanin circuits implies things problems decidable checking constant number bits input theorem class binary addition class iterated addition theorem iterated addition carries mod figure finding numbers sum numbers proof binary numbers output numbers sumusing constant depth circuit triple input bits produce binary number additions modulo binary number carries figure operation constant-depth circuits group inputs groups apply operation repeat remain inputs operation reduces number remaining numbers add logarithmic number layers circuits reduces problem binary addition iterated addition binary multiplication perform matrix multiplication element-wise multiply binary multiplication layer follow layer iterated addition subproblems concatenation symmetric function function change input bits permuted dependent size number input determined iterated addition symmetric functions computable necessarily uniform iterated multiplication uniform computable proof complex divide-and-conquer algorithm circuits show iterated matrix multiplication implies matrix inversion linear systems rest linear algebra computable upper bounds classes nck upper bounds computation power weak truth statements open questions uniform uniform uniform cvp circuit problem circuit input return output cvp p-complete log-space mapping reductions uniform iff cvp nc-computable connection theorem states circuits bounded-width branching programs polynomial size equally powerful proof formulas restricted version circuits definition formula circuit gates maximum fanout gate formula maximum fanout number gates formula matches notion size boolean expression standard circuit shape directed acyclic graph formula rooted tree inputs circuit smaller equivalent formula reducing duplication sharing outputs theorem equivalent power circuits polynomial size formulas log depth formulas bounded-width branching programs polynomial size proof show theorem elements simulate predecessor theorem poly-size formulas capture circuits log depth formulas capture poly-size formulas proposition circuits simulated poly-size formulas proof circuit forms rooted directed acyclic graph root topmost operator circuit transform formula recursively replacing subgraphs node fanout replace node child subgraph copies node child subgraph node fanout node child parents black node figure transformed figure step recursive transformation circuit poly size formula circuit root output suppose repeat procedure node root circuit maximum fanin depth number nodes depth times number nodes depth nodes layer size bottom layer dominates size formula process yields formula size circuits depth logn size formula logn polynomial step function computed generated circuit remains process creates poly-size formula equivalent circuit proposition polynomial size formulas simulated log depth formulas proof formula binary fanin find edge formula subformulas side edge size formula sub-formula low side cut edge sub-formula high side cut edge constant literal figure illustrates trees figure step transformation polynomial size formulas log-depth formulas cut well-chosen edge formula yields sub-formulas create formula function original decreased depth formula shown figure formula computes function original inputs original function likewise inputs original function function combines cases figure step transformation polynomial size formulas log-depth formulas combine sub-formulas recurse procedure sub-trees continue recursing constant-size formulas size original formula notice size applying step sub-formulas considered reduced factor notice level recursion places depth circuit top sub-formula worked depth final formula generated satisfies inequality words logs proposition bounded-width branching programs polynomial size simulated circuits proof suppose branching program width polynomial number layers construct circuit simulate divide conquer strategy place gate fanin ensure gate true input induces path start state layer accepting state layer layer ith input gate place gate fanin outputs true input induces path start state layer ith state layer accepting state layer input true iff sub-path layer layer induced input true iff sub-path layer layer induced recurse inputs ands reaching base case checking adjacent layers pis polynomial divide conquer strategy recurses onlyo log times giving constructed circuit logarithmic depth analyze size circuit rely fact generating circuit formula sub-problem computed circuit compute needed roughly intervals considered subproblems subproblems form state layer reached state layer asked interval number individual questions circuit computes polynomial size input circuit constructed polynomial number gates logarithmic depth circuit proposition log-depth formulas simulated bounded width branching programs polynomial size proof construct properties width label node depends layer oblivious levels branches distinct end states branches distinct end states width constant makes permutation effect identity permutation input rejected single cycle input accepted accepting claims corollaries give components construct recursively building structures equivalent pieces log depth formula claim exists accepting size cyclic exists accepting size cycle negationslash proof cyclic permutation conjugate exists permutation construct acceptor acceptor permute machine top-layer nodes bottom-layer nodes corollary decide language acceptor size decide language acceptor size proof build acceptor decides apply nodes acceptor decides claim exists acceptor size decides language exists acceptor size decides language negationslash exists acceptor size decides proof suppose acceptor deciding language acceptor deciding language machine formed concatenating order start-to-finish acceptor deciding analogous previous claim shows build fate input fed undergoes permutation net permutation undergoes perform identity permutation net permutation experienced rejected case similar case clearer machine accepts precisely language size machine exist permutations negationslash combine branching programs simulate gates complement branching programs simulate gates morgan law encode individual input variables trivial model branches form permutation branches form permutation label node layer relevant variable standard post-order formula traversal constructions suggest level branching program increase factor formula depth branching program construct size logn size branching program polynomial proved computational models question transformed chain transformations machine models transformed equivalent machine models models equivalent power complexity theory lecture randomness instructor dieter van melkebeek scribe jake rosin time discussed parallelism extension existing model computation today introduce randomness extend turing machine model make show qualitative usefulness randomness cient probabilistic algorithms cult problems quantify power comparison existing computational classes motivation randomness appears great computational tool simpli problems large number settings essential dining philosophers problem solved deterministic solution randomness essential cryptography deterministic method hide secret means deterministically found adversary randomness cryptographic setting covered upcoming lectures deal randomness standard setting realizing mapping inputs outputs decision problems intuitively randomness hindrance setting problems solved ciently randomness deterministic algorithm randomness additional computing power concept make randomness coins base decisions outcome ips con guration machine time random variable based coin ips outcome dictated nal con guration machine random variable context decision problems introduces possibility incorrect result probability error made negligible results easily generated machine errs probability nontrivially running machine repeatedly taking 
majority vote outcomes machine produces erroneous result probability results independent runs majority vote wrong ksummationdisplay parenleftbiggk parenrightbigg shows produce exponentially small probability error majority vote polynomial number runs original probability error close erent ways error randomized computation type error allowed ect class languages computed -sided error error membership non-membership sides -sided error error side typically membership side invalid input rejected valid input rejected small probability -sided error incorrect answer answer unknown small probability randomized quick sort -sided algorithm quick sort guaranteed produce correct result answer unknown behavior quick sort ected randomness time space aspects program behavior random variables randomized algorithms goal randomness introduced obtain solutions cient algorithms deterministically ciency measured time space sequential time efficiency polynomial identity testing problem cient randomized algorithm cient deterministic algorithm arithmetic formula composed addition subtraction multiplication brackets variables problem determine solving problem deterministically appears cult method involves expanding terms comparing monomials number monomials exponential length formula fact deterministic algorithms run exponential time randomized solution formed choosing values variables random evaluating formula resultnegationslash formula rejected formula probability bound probability error determined values variable chosen uniformly random set degree negationslash degree formula bounded length interval chosen ciently small polynomial ensuring small speci logn bits evaluating formula worst raises variables power meaning resulting numbers logn bits arithmetic operations involved performed polynomial time bit length numbers forms -sided randomized algorithm polynomial identity testing errs nonmembers small probability producing false positives arithmetic circuit testing bene approach relevant decision problem arithmetic circuit inputs evaluate degree polynomial exponential depth circuit exact calculation polyn bits prevents evaluation polynomial time solution perform calculations modulo random number polyn bits evaluation polynomial time introduces source error dealt polynomially prime numbers produce incorrectly numbers prime factors true result reduce probability error pick prime numbers set picking prime number set small probability achieve pick prime number random poly large polynomial work guarantee randomly chosen poly nontrivial number primes interval prime number theorem assurance prime counting function number primes equal xlnx result -sided algorithm correct poly errs nonmembers running algorithm multiple times increase con dence result case polynomial identity testing deterministic algorithm arithmetic circuit testing runs exponential time parallel time efficiency existence perfect matching bipartite graphs problem deterministic parallel algorithm inherently sequential polynomial time algorithm exists nding parallel algorithm greatly improve ciency problem solved algorithm generated randomness graph represented adjacency matrix replace graph random variable unique location claim perfect matching iff det proof term determinant exists permutation permutations -tocorrespondence perfect matchings determinant term perfect matching coe cient term matching graph erent perfect matchings lead erent monomials non-zero coe cient valid graph determinant multi-variate polynomial degree checking perfect matching performed checking polynomial accomplished randomized algorithm parallel algorithm computing determinant linear algebra problem lecture fact device algorithm replace adjacency matrix random suitable interval poly compute determinant parallel result non-zero perfect matching exists algorithm repeated ciently con dent result space efficiency undirected path problem recently ciently solved randomized algorithm cient deterministic suppressl solution problem included well-known note related directed path problem nl-complete undirected graph vertices problem determine path exists randomized algorithm random walk beginning walk ends number steps immediately reached performing polynomial number steps reduces small probability chance reaching connected demonstrated upcoming lecture algorithm performed logarithmic space storing current location destination steps polynomially large representable logarithmic bits model model randomness equipping standard turing machine random bit tape nite control one-way read access assume tape lled bits perfectly uniform distribution computation begins machine one-way read-only access random bit tape counted space reuse random stored work tape random takes single computational step read entry random bit tape time space complexity classes bptime bpspace analogous deterministic counterparts represent classes problems solvable randomized machine time space bound requirement error speci cally refer classes bpp bounded-error probabilistic polynomial time bpl log space complexity classes exist -sided -sided machines rtime rspace speci classes refer problems solvable randomized machines meet criteria error error zptime zpspace speci cally classes zpp zpl refer problems solvable -sided randomized machines machines meet criteria error unknown claim class zpp equivalent class problems solvable randomized machines chance error run expected polynomial time call class zpp proof zpp machine run repeatedly outputs nite answer nition zpp run halts polynomial time outputs answer probability running time zpp algorithm expected running time modi algorithm run time summationdisplay summationdisplay machine expected running time polynomial satis nition zpp similarly zpp machine run clock run time terminated output unknown modi algorithm outputs unknown probability markov inequality ensure probability outputting unknown set algorithm satis error criterion zpp runs polynomial time zpp algorithm language claim zpp corp proof claim left exercise space complications deterministic setting log-space algorithm terminates polynomial time terminates due polynomial bound number machine con gurations repeated con guration signi loop occurs machine halt things complicated randomness involved discussing space bounds setting assume machines halt deterministic setting requires machine repeats con guration introduce non-halting loop restriction nice property randomized log-space machine runs polynomial time general space machine runs time note machines type distinct halt probability separate class zpl type machine addition power model stated claim leave exercise claim zpl nitional issues ect power randomness log-space setting survey relation deterministic classes relating randomized classes deterministic classes measure computational power zpp bpp exp inclusion nition bpp exp fact exponential time cient compute probability acceptance randomized machine exhaustively generating coin results suppressl zpl bpl uniformnc dspace log uniform dspace log proof similar suppressl lecture bpl uniform takes bit work claim bpl uniform proof bpl computation viewed markov chain machine con gurations log-space machine size set con gurations polynomial markov chain represented matrix entry mij representing probability transitioning state state multiplying matrix times probability matrix state transitions taking steps determine probability reaching accepting con guration pmm iterated matrix multiplication discussed time uniform fact tighter bound class bpl claim bpl dspace log proof claim presented future lecture evidence conjectures bpp bpl complexity classes ignore constant-factor increases facts proving nal problem homework proposition bppbpp bpp bpp bpp bpp results relate randomized complexity classes deterministic nondeterministic complexity classes result relates randomized class bpp non-uniform class poly showing general randomness replaced non-uniformity theorem bpp poly bpl poly proof bpp 
algorithm rst make probability error smaller number inputs length error recall section running bpp algorithm error times taking majority vote results bpp algorithm computing language error assume original error pick large large ces meaning resulting bpp algorithm runs polynomial time reduced error distinct setting random bit tape probability exists input length machine makes error exists coin sequence machine correct result inputs length sequence coin ips advice amount randomness polynomial polynomial amount advice stated conjectured bpp unable prove fact prove bpp shown bpp lies polynomial hierarchy theorem bpp proof theorem presented lecture lecture lecture expanders tool error reduction fewer random bits reducing number coin ips improve ciency trivial derandomization evaluating series ips expanders analogous pseudorandom number generators short random input deterministically produce series pseudorandom bits randomized functions random address issue model relies series bits randomness unbiased uncorrelated functionally impossible achieve real world expanders transformation series bits randomness essentially perfect randomness michael saks randomization derandomization space-bounded computation annual conference structure complexity theory complexity theory lecture expanders instructor dieter van melkebeek scribe nathan collins lecture introduced randomized computation terms machines access source random bits return correct answers time showed bpp polynomial-size circuits conjecture community bpp today introduce expanders type graph improving amplifying randomized algorithms additional random bit overhead prove theorem relating bpp polynomial time hierarchy hierarchy results bpp generally introduce computational model hierarchy results class problems solve model question depend resources allowed hierarchy results computable enumeration machines type question shown exercise exist computable enumeration randomized machines error probability bounded typical hierarchy arguments fail randomized machines typical hierarchy arguments tailored prove hierarchy theorem modified model randomized computation called promise-bpp hierarchy result bpp bpp poly time hierarchy don bpp bpp bpp theorem bpp proof fix randomized polytime machine accepts bpp number random bits running inputx size show bpp bpp cobpp bpp completing proof remove randomness computation input space r-bit strings partitioned pieces acc set random strings accepts rej set strings rejects error rate small acc larger rej acc smaller rej xnegationslash figure random computation small error rate correct random bit strings turn idea shifts acc cover space r-bit random sequences shifts acc fail cover space xnegationslash shift shifting invertible symbol denotes xor equivalently addition acc rej rej acc figure error rate small acc larger rej acc smaller rej xnegationslash shifts give -predicate intuition discussed tuniondisplay acc poly pick poly -predicate provided verify membership uniontextti acc time poly membership check problem equivalently check acc polytime corresponds running random bit string poly-many show pick suitable poly make true showing choose randomly high rate success cases fixed tuniondisplay acc rej rej probability rejects accept larger union bound negationslash tuniondisplay acc choice work choice bit string makes reject tuniondisplay acc tsummationdisplay acc acc xnegationslash choose works provided definition bpp majority vote trick introduced lecture runs reduce error runs random bits suffices choose poly large fact logr works examination shows time complexity logt original run-time expanders proof theorem majority vote trick exponential increase accuracy linear increase random bit usage expander graphs introduced lead amplification technique exponential accuracy improvement constant increase random bit usage versus expanders mention lecture lectures definition -expanding graph -expanding implies neighborhood notice graph trivially -expanding definition expander family expander family infinite sequence graphs fixed numbers degree -expanding number vertices intuitively expander graphs connected number vertices reachable subset vertices proportional size subset subsets aren large make impossible graph theoretic properties assume graphs d-regular describe d-regular graph normalized adjacency matrix view expander graphs proves analysis properties randomized algorithms make definition normalized adjacency matrix d-regular normalized adjacency matrix defined aij braceleftbigg normalized adjacency matrix describes markov chain random walk aij state state column vector probability vertex probability vertex random step normalized adjacency matrix number properties proved basic linear algebra properties prove proposition real-symmetric eigenvalues real basis orthogonal eigenvectors turns eigenvalues normalized adjacency matrix expander closely connected expanders graph properties basic properties proofs omit proposition normalized adjacency matrix graph vertices eigenvalue satisfies eigenvalue eigenvector uniform distribution multiplicity eigenvalue greater iff disconnected eigenvalue iff bipartite uniform distribution eigenvector remaining eigenvector values turns largest eigenvalue absolute work definition max largest eigenvalue eigenvector orthogonal connected bipartite theorems proven notes spring proofs theorem -expanding function depends corollary expanders positive spectral gaps expander families spectral gaps bounded spectral gap graph theorem -expanding function depends light theorems defined expander families definition d-regular families positive spectral gaps expanders uniform distribution fixed point proposition tells larger spectral gap faster arbitrary probability distribution converges uniform distribution random walk lemma probability distribution vector bardblatp ubardbl bardblvbardblq qbracketrightbig q-norm proof atp nsummationdisplay nsummationdisplay probability distribution write summationtextiaiei form orthogonal eigen basis aei iei u-component bardblat bardbl bardblat summationdisplay aieibardbl bardbl summationdisplay tiaieibardbl tbardbl summationdisplay aieibardbl tbardblp ubardbl bardblp ubardbl bardblubardbl bardblpbardbl bardblpbardbl andbardblvbardbl bardblvbardbl vectors cauchy-schwartz inequality bardblat bardbl bardbl bardbl bardblat bardbl nbardblat bardbl braceleftbigg combining bardblat bardbl nbardblat bardbl tbardbl bardbl completing proof lemma prove random walk algorithm undirected path problem polynomially steps path bpl proof lemma exercise exercise connected bipartite constructions prove expanders exist argue randomly chosen d-regular graph high probability expander expanders reduce amount randomness needed random algorithms randomness construct expanders won explicit constructions vertex index compute ith neighbor time poly integer expander vertices edges relations graph degree proof construction works non-trivial notes partial proof harmonic analysis efficient constructions expanders aforementioned expander suffices notes spring constructions applications expanders purposes deterministic amplification randomized algorithm random bits reduce error arbitrary additional random bits requires running poly times randomness efficient amplification withrandr reduce error arbitrary log additional random bits running log times accomplish amplifications expander graph vertices oneto-one correspondence bit strings application runr vertex random bits run run neighbor random bits application starting perform random walk starting length log vertices run vertex random bits cases finish taking majority vote runs discuss applications prove correctness lecture time lecture prove correctness algorithms applications accomplish prove lemma expander mixing lemma d-regular expander graph radicalbig radicalbig set edges connecting notice number ways choose edge choices starting vertex degreed choices ending vertex probability randomly chosen vertices lies complexity theory lecture amplification instructor dieter van melkebeek scribe matthew anderson lecture introduced expander graphs combinatorial point view sparse 
graphs vertex constant degree non-trivially expanding algebraic point view expanders graphs constant degree recall largest absolute eigenvalue normalized adjacency eigenvector perpendicular vector today discuss applications expanders performing correctness amplification randomized algorithms application decreases error rate algorithm additional randomness application decreases error rate algorithm slightly randomness expander properties determines quickly random walks converge uniform distribution lecture showed probability distribution normalized matrix uniform distribution bardblatp ubardbl distance uniform distribution random walk arbitrary distribution decreases exponentially number steps lhs equation written definition -norm bardblatp ubardbl max atp bardblatp ubardbl distance uniform distribution random walk set vertices logv random bits select vertex random property vertex selected uniformly tlogd bits fixing start vertex performing random walk steps important algebraic property expanders called expander mixing lemma lemma expander mixing lemma radicalbig lemma bounds difference distributions picking vertices uniformly random term left picking vertex neighbor vertex random term left case logv random bits case logv logd random bits idea amount randomness reduced cost producing distribution uniform proof expander mixing lemma recall symmetric real implying full orthonormal eigenbasis number edges sets written terms relative characteristic vectors iff standard adjacency matrix real symmetric matrix full orthonormal eigenbasis rewritten terms components parallel perpendicular uniform vector recall eigenvector eigenvalue product bardbls equation rewritten bardbls bardblt bardblsda bardblt sda bardbls bardblt sda sda lines follow bardbl eigenvector causing term simplify cross terms vanish dividing moving terms taking absolute bardbl sbardbl bardbl tbardbl line reached applying cauchy-schwarz rhs fact decreases magnitude component applying pythagorean theorem simple algebra tobardbl sbardbl derive ofbardbl sbardbl bardbl sbardbl bardbl bardblsbardbl bardbl sbardbl bardbl sbardbl bardbl sbardbl bardbl sbardbl radicalbig substituting back forbardbl sbardbl andbardbl tbardbl pulling factor square root completes proof properties reduce error probability randomized algorithms extra random bits deterministic amplification expanders transform random algorithm takes random bits errs probability equivalent algorithm random bits errs probability calling poly times idea transformation explicit expander graphgwith vertices vertex random bit string pick vertex random random bits neighbors distance run neighbors return majority vote neighbors output intuitively expanding set neighbors distance spread graph close uniformly distributed analysis set bad random strings strings give wrong answer input set bad random strings strings majority neighbors distance give wrong answer incorrect answer majority give incorrect answer construction order required error fixing half neighbors incorrect applying expander mixing lemma radicalbig extra terms expression dropped equal rearranging terms bounding constant decrease error effect taking neighbors distance neighbors replace vertices edge vertices path length multiple edges vertices effect increasing degree decreasing eigenvalue prior analysis holds substituted result equation give selecting log error number neighbors distance log polynomial complexity determining neighbors polynomial explicit expander construction reduce error poly constant polynomial time randomness original algorithm randomness efficient amplification idea application reduce error additional randomness random algorithm random bits errs probability transformed equivalent algorithm log random bits error callingronlyo log times total notice construction acheive exponentially small error polynomial time slightly randomness transformation trivially rlog bits sampling log random strings achieve additive result suggested order improve trivial result perform variation approach previous application pick uniform random random walk lengthtstarting run majority vote idea job previous application randomness work neighbors distance visited neighbor distance visited analysis key lemma bound error approach lemma projection errs vector bardblpaxbardbl radicalbig bardblxbardbl proof representation xbardbl eigenbasis respect stated earlier triangle inequality bardblpaxbardbl bardblpaxbardblbardbl bardblpax bardbl facts bad set small projects bad set contracts bardblpaxbardblbardbl bardblpxbardblbardbl bardblxbardblbardbl bardblpax bardbl bardblax bardbl bardblx bardbl substituting back original equation bardblpaxbardbl bardblxbardblbardbl bardblx bardbl bardblxbardblbardbl bardblx bardbl radicalbig bardblxbardbl inequality cauchy-schwarz lemma bound error probability probability errs probability half steps random walk fell set errs errs fall set errs summationdisplay ith step lies bad set summationdisplay bardblmtamt aubardbl summationdisplay nbardblm aubardbl summationdisplay parenleftbigradicalbig parenrightbig bardblubardbl summationdisplay parenleftbigradicalbig parenrightbig parenleftbigradicalbig parenrightbigt radicalbig line upper bounds actual probability counting bad strings probability rewritten matrix line line repeated applications lemma constant number iterations decrease making maximize rhs deterministic amplification procedure acheive walking log steps give error procedure random bits pick starting vertex logd bits log steps random walk total log random bits results stronger result considers variance random walks expander chernoff bound states random walk fraction times walk lands bad set vary expected number indicator variable event ith step lies set probability walk varies expected number steps bad sets written tsummationdisplay universal constant probability walk varies expected constant decreases exponentially increases inequality reduces standard chernoff bound complete graph rank independent time lecture discuss pseudorandom generators space-bounded computation application expanders application leverages power pick vertex neighbor random picking vertices uniformly random apply procedure recursively construct pretty good pseudorandom generators pseudorandom number generation dual amplification pseudorandom number generation reduce amount randomness making error grow complexity theory lecture space-bounded derandomization instructor dieter van melkebeek scribe jake rosin time expanders reduce error probabilistic algorithms increasing randomness small amount today attempt opposite reducing amount randomness required bounded increase error lecture focuses derandomization space-bounded setting lecture derandomization time-bounds pseudorandom generators definition -prg class algorithms collection deterministic procedures number random bits denotes bits uniform distribution means finitely note decision algorithm equivalent bracketleftbig bracketrightbig important parameters definition error deviation original randomized algorithm original algorithm probability error probability error algorithm small suffices small amplification techniques discussed previous lectures seed length number random bits required inputto pseudorandom generator small complexity measured terms output length prgs low complexity generate random bits increase total cost running randomized algorithm prgs pseudorandom generators reduce amount randomness required run randomized algorithm side effect reduce complexity deterministic simulation randomized algorithm explicitly computing probability acceptance set prg seeds -prg bptime computable dtime bptime dtime cycling random seeds running algorithm output outputting majority answer seed random string generated taking time algorithm run additional steps enumerates seeds cumulative error majority vote correct answer similarly -prg bpspace computable dspace bpspace dspace prg computable polynomial time logarithmic seed length bpp similarly prg logarithmic seed length runs log space bpl pseudorandom generators exist approach attempt prove containments space-bounded derandomization construct log space computable prg logr seed length nontrivial constructions approaching goal present construction based expanders theorem exists -prg bpspace log log computable space corollary -prg bpl log computable space log bpl dspace 
log due bpl theorem shows prgs idea proof dividing space-bounded randomized computation phases phase random bits operation machine bounded space bits pass phase phase pairing blocks expander produce random bits reduce level randomness machine expander degree vertices produce pseudorandom bits choosing vertex expander random moving random neighbor equivalent selecting edge random endpoints requires seed length logd random bits block pair reduced amount randomness process diagrammed figure expander good output modified block pair differ greatly output original rely expander mixing lemma prove call distribution input output resp states block pair sin sout random inputs pair left distributions left alternative construction show bpl dspace log bound blocks logd logd logd block pairs figure dividing computation blocks bits passing block original computation shown shown random bits adjacent blocks coming picking adjacent vertices expander random original randomized input pseudo-random ulogd output expander note -th neighbor expander lemma bounds difference output distribution scenarios lemma distribution sin bits largest eigenvalue expander sout sin sout sin ulogd prove lemma finish description proof prg lemma bound difference output distribution running algorithm purely random bits versus running algorithm grouping pairs blocks producing random bits expander hybrid distributions wheredi distribution formed random distribution blocks switching pseudo-random distribution remainder thusd perfectly random pseudo-random difference distributions difference randomized algorithm pseudorandom version triangle inequality key lemma find summationdisplay bound error introduced step derandomization amount randomness reduced block pair logd savings roughly constant large savings note reduced original block chain easier instance problem blocks taking logd random bits computational blocks paired logd random bits generated expander pairing blocks recursively shown figure results prg parameters bound found summing previous errors logd reduction requires additional logd random bits space complexity compute output bit prg compute neighbor relations series expanders computed linear space amount space topmost level dominates total space prg defined related important terms parameters prg constant degree expander constant eventually overshadowed resulting grow begin constant-degree constantexpander raise t-th power allowing multi-edges graph results simple expression degree spectral gap error prg satisfy logd logd logd logd logd logd blocks figure recursively pairing blocks applying expander expansions cover entire computation rearrange derive plug degree determine seed length log log logd blocks construction block random bit seed length defined log term grows descends remarked setting terms equal solving result minimal constant factors log seed length log log finishing proof theorem remains prove lemma notice construction block treated black box connection blocks bits representing state machine algorithm relies bits transmitted blocks places limit computations performed block individually prg works algorithm divided blocks limited communication block block block unbounded space proof lemma expander mixing lemma proof involves finding sets apply lemma proof notice prove lemma point distributions point distributions place probability single point distribution sin convex combination point distributions randomized process quantity sin bardblz sin sin ulogd bardbl triangle inequality -norm sin point distribution sin defined sin sout distributions inputs outputs pair blocks definesmid distribution states control passes block pair distribution represent probability moving input state sin output state sout perfectly random bits sin sout summationdisplay smid sin smid sout summationdisplay smid left defined ssin smid left sin smid tsmid sout smid sout terms notation expander mixing lemma equation written summationtextsmid left chosen independently random pseudorandom distribution probability picking edge replaced expander mixing lemma vextendsingle left sin sout left sin sout vextendsingle vextendsingle summationdisplay smid summationdisplay smid vextendsingle summationdisplay smid radicalbig inequality represents probability generating single fixedsout find difference probability sout sum sout sin random sout sin pseudo summationdisplay sout summationdisplay smid radicalbig cauchy-schwartz bound summation summationdisplay sout summationdisplay smid radicalbig sout summationdisplay smid sout summationdisplay smid definition provided clear summationtextsmid similarly order summations term reversed summationtextsout demonstrated sout sin random sout sin pseudo alternate proof theorem usinguniversal hashfunctions exists shows bpspace dtisp proof general discussed due sole requirement computation divided discrete blocks limited communication alternate proof shows bpspace dspace exploiting properties construction inclusion improved bpspace dspace randomness conjectured provide constant factor improvement space complexity overhead lecture lecture time-bounded derandomization time-bounded setting non-trivial derandomizations surprising bpp exp perform non-trivial derandomizations reasonable assumptions exists problem linear exponential time requires circuits linear exponential size bpp words non-uniformity doesn speed computations randomness complexity theory lecture time-bounded derandomization instructor dieter van melkebeek scribe tom watson lecture introduced notion pseudorandom generator prg showed prgs derandomization developed construction prg fools spacebounded computations developed prg seed length log fools bpl computations time-bounded setting nontrivial unconditional prg constructions constructions work reasonable complexitytheoretic hypotheses lecture present construction due nisan wigderson ciently strong reasonable hypothesis prg show bpp pseudorandom generators time-bounded computations distinguishability recall prg takes random seed length produces pseudorandom string length prg ciently computable deterministic machine prg called quick computed time time linear exponential seed length show exists language large average-case circuit complexity exists quick prg short seed length fools time-bounded randomized computations formalize notion average-case complexity section lecture error-correcting codes relax hypothesis existence average-case hard language existence worst-case hard language notion quickness cient cryptographic setting prgs typically required computable time polynomial seed length cient goal reduce amount randomness needed computation present focus full derandomization achieved seeds explicitly computing probability algorithm accepts pseudorandom distribution setting time seeds factor overhead computing prg output polynomial overhead time guage quality prg construction measures powerful computations fool allowed fool computations measures formalized parameters nition definition -prg circuits size family functions circuits inputs size vextendsinglepr bracketleftbigc bracketrightbig rbracketleftbigc bracketrightbig vextendsingle chosen uniformly random intuitively nition means circuit size trouble distinguishing input sampled uniform distribution pseudorandom distribution questions nition naturally present require prg fool circuits interested fooling uniform computations bptime computations mimicked circuits size polynomial prg fool uniform computations prg succeed fooling computations nitely inputs easily captured nonuniform setting constructing erent circuit input input hard-wired random bits left inputs circuit turns arguments critically nonuniformity circuits results start uniform hardness assumption results aren strong require prg fool circuits linear size parameter size circuit number inputs arguments cleaner harm allowing circuit random bits mimicking uniform computation circuit yield circuit larger number random bits computation won ected allowing prg provide random bits recall lecture prg full derandomization seeds explicity computing probability acceptance algorithm pseudorandom distribution running time 
time run prg seed time run simulation algorithm times seeds quick prg logr seed length full derandomization runs polynomial time implying bpp ultimate goal show ciently hard function exists prg exists predictability provided random seed prg produces output distribution seed length ideally smaller output length pseudorandom distribution mass strings length sense uniform distribution issue pseudorandom distribution computationally indistinguishable uniform distribution circuits nition viewed statistical tests require pseudorandom distribution pass tests computable small circuits rst step show restrict class statistical tests interested circuits attempt predict ith bit pseudorandom string rst bits predictor exists uniform distribution circuits succeed predicting bit sample probability principle advantage predicting bit gained fact input sampled pseudorandom distribution intuitively lot computation required prediction leave exercise show circuit succeeds probability predicting ith bit rst bits sample pseudorandom distribution yields circuit essentially size distinguish pseudorandom distribution uniform distribution amount sense nition indistinguishable distribution unpredictable conceivable distinguishing easier task predicting show unpredictable distributions indistinguishable uniform distribution sense focus orts constructing prg unpredictable output distribution theorem exists circuit size vextendsinglepr bracketleftbigc bracketrightbig rbracketleftbigc bracketrightbig vextendsingle exists circuit size parenrightbig ibracketrightbig proof distinguisher construct predictor rst task determine bit position predicted hybrid distributions consists samples rst bits chosen output distribution remaining bits chosen uniformly random uniform distribution strings length output distribution intuitively circuit behaves distributions give idea good predicting ith bit rst bits pseudorandom sample distributions similar ering ith component argue formally shorthand prdi probability outputs sample distribution vextendsingleprdr prd vextendsingle vextendsingle rsummationdisplay parenleftbigpr prdi rsummationdisplay vextendsingleprdi prdi vextendsingle prdi prdi choose index predictor rparenrightbig bracketrightbig ers rparenrightbig bracketrightbig probabilities chosen uniformly random circuit appears good job detecting ith bit input pseudorandom distribution predictor takes input bits predictor rst bits sample averaging argument setting tildewide tildewide inputs tildewide tildewide rparenrightbig bracketrightbig ers tildewide tildewide rparenrightbig bracketrightbig probabilities chosen uniformly random hard-wire inputs ecting circuit size note critically fact dealing nonuniform circuits handle separately bit circuit output provided rst bits sample pseudorandom distribution provided rst bits random bit suggests construct randomized predictor rst bits sample pseudorandom distribution coin determine evaluate tildewide tildewide evaluates assume guess correct output output formally tildewide tildewide proof claim left exercise claim prbracketleftbigp parenleftbig iparenrightbig ibracketrightbig probability behavior predictor undesirable feature ips coin advantage fact nonuniform setting hard-wire tildewide circuit retains advantage predicting ith bit yields predictor tildewide tildewide tildewide tildewide expressed circuit size possibly additional gate assume doesn increase size circuit predictor satis parenrightbig ibracketrightbig desired nisan-wigderson construction average-case circuit complexity construct -prg circuits size argued circuit size distinguishes pseudorandom distribution uniform distribution amount exists index circuit size succeeds predicting ith bit sample rst bits advantage trivial bound task reduced constructing prg small circuit gain signi advantage predicting bit sample previous bits intuitively suggests prg generate bit output applying hard function argue small predictor circuit index construct circuit evaluating function generate ith bit formalize precise notion hardness definition language average-case hardness input length denoted largest circuit size compute correctly fraction inputs length note computing correctly fraction inputs length trivial constant constant job average-case hard function hard compute hard compute correctly noticeably half inputs nition refer size circuits consideration degree hardness main reason number parameters small analysis works cleanly measuring hardness nonuniform circuits good reason arguments crucially nonuniformity gain intuition nition mentioned previous lecture predicate bits computed circuit size smaller condition nition easier satisfy circuits consideration computationally restricted required compute inputs serves measure average-case hardness input length prg construction suppose language circuit size circuit size compute probability inputs length chosen uniformly random suggests approach constructing prg chosen independently uniformly random apply viewed function producing bit yielding output string lengthr intuitively bit output distribution prg predictable samples chosen independently predictor advantage computing output distribution prg unpredictable theorem indistinguishable uniform distribution desired proceed formalize vague idea awed issue naturally arises computing output function require computing assumed hard compute length computing ideally output length complexity computing prohibitive critical problem construction takes seed length outputs bits seed length smaller larger trivial build prg seed length large output length output bits seed yielding uniform output distribution reason construction requires long seed chosen independently show sacri cing independence drastically reduce seed length quality output distribution deteriorating accomplish taking seed length selecting subsets bit positions seed letting bits seed indexed seed illustrated desired subset construction formalized nition definition -design size sequence subsets inegationslash prg output length large time pairwise intersections small independent possble goals odds lemma shows fact exist designs large subsets ciently computed lemma logr exists efficiently computable logr -design size proof assume prime power round power ect constant factor identify ith univariate polynomial degree logr obvious logr fact polynomials degree logr represent distinct functions logr leave exercise pair fewer logr points common number subsets provided mlogr subset computed simple arithmetic ciently purposes give detailed analysis ciency condition logr problem constraint logr position fully prg set obtain logr -design lemma prg straightforward verify computable linear exponential time prg quick remains show construction fools circuits size ciently hard theorem construction -prg circuits size proof prove theorem contradiction suppose circuit size vextendsinglepr bracketleftbigc bracketrightbig rbracketleftbigc bracketrightbig vextendsingle show exhibiting circuit size solves length fraction inputs contradicting assumed hardness theorem exists circuit size parenrightbig ibracketrightbig construct small circuit approximate length intuitively approximating input fact averaging argument setting bits indexed predictor maintains advantage critically fact working nonuniform circuits renaming letting tildewide denote bits lls positions indexed rest positions xed tildewide tildewide parenrightbig bracketrightbig probability chosen uniformly random sort behavior construct circuit takes input takes rst bits output attach circuit computing computing involves computing critical observation entire argument input depends logr bits logr jnegationslash computed circuit size logr limited pairwise intersections subsets design key avoiding inherent complexity computing allowing contradiction jth input attach circuit size computing tildewide tildewide illustrated obtained circuit size succeeds computing probability choice conclude contradiction theorem proved summarize proof assumed prg output distribution distinguishable uniform distribution small circuit theorem obtain small predictor circuit bit pseudorandom distribution connected additional small circuitry predictor convert small circuit approximated showing hard eliminate parameter setting obtain clean corollary corollary exists quick r-prg circuits size seed length remark languages satisfy hardness condition arbitrary circuits 
interesting values lecture exist languages requiring large circuits worst case conjectured true average-case hard languages exist extensions constant-depth circuits previous lecture average-case hardness results parity constant-depth circuits hardness results nisan-wigderson construction yields unconditional prgs constant depth circuits supposing distinguisher prg output distribution obtain predictor theorem increasing depth nal circuit approximating parity obtained adding depthcircuits computing rst bits prg output dnf cnf prg succeeds fooling constant-depth circuits polylogarithmic seed length involves computing parity short strings space-bounded derandomization similar construction discussed today yields prgs branching programs space-bounded derandomization exists language dspace average-case hard linear exponential size branching programs construction yields conditional prg space-bounded computations worst-case average-case reductions lecture error-correcting codes relax hardness requirement average-case hardness worst-case hardness show encoding characteristic sequence worst-case hard function good error-correcting code yield average-case hard function circuit approximates encoded function combined cient decoder compute original function input combining technique results today lecture obtain prg fools polynomial-size circuits logarithmic seed length leading result theorem exists language requiring linear exponential size circuits bpp nisan wigderson hardness randomness journal computer system sciences complexity theory lecture error-correcting codes instructor dieter van melkebeek scribe matt elder lecture constructed family quick pseudo-random generators based assumption exists language high average-case hardness lecture extend results show worst-case hardness length substituted average-case hardness length lecture prove fact error-correcting codes codes construct language average-case hardness close worst-case hardness language pseudo-random generators yield derandomization time found generate efficient pseudo-random generators precisely suppose function logr design construct function key property -prg circuits size demonstrated efficient design quick time linear-exponential hard language exists construct pseudo-random generator bpp algorithm problem deterministic algorithm solve problem construct prg takes random seed length outputs pseudo-random string length seed run replacing random bits accept accepts seeds reject complexity small prg fool deterministic algorithm problem solves results exists language build takes input bits bpp subexp exists language build takes logr input bits bpp dtime logn exists language build takes logr input bits bpp implication clogr logr design logr show build takes logr input bits assert design exists omit construction implication implies corollary corollary bpp zppnp proof definition language bpp poly-time bounded-error randomized algorithm shown algorithms derandomized functionf hardness characteristic string function length counting argument characteristic strings functions bits hardness bpp algorithm algorithm zppnp pick random function logr oracle exists circuit size computes function logr bits predicate small circuit halt return construct pseudo-random generator built hard function run derandomized version accept accepts reject rejects candidates forf hard languages algorithm halts fails low probability cases outputs correct answer zppnp algorithm language solved algorithm bpp solved zppnp bpp zppnp discuss converse implications showing hard languages imply prgs show prgs imply hard languages pseudo-random generators yield circuit lower bounds theorem exists -prg computable fools circuits size exists language circuit complexity greater proof idea proof prgg construct language differentiates distribution generates uniform distribution prg language high circuit complexity note length output larger length input existence trivial output bits assume takes bits bits language braceleftbig bracerightbig suppose circuit decides language line holds definition line holds maps inputs distinct outputs statements show differentiates distribution generated uniform distribution undifferentiable circuit size circuit size greater true circuit decides language circuit complexity greater determine naive algorithm compute seeds output assume cycle seeds computation takes time showing implication ways exist quick prgs fool circuits size iff exist functions circuit complexity greater error-correcting codes informally error-correcting code function set information words set codewords codeword not-too-large fraction bits flipped information word retrieved error-correcting codes encode information manner robust amount error error-correcting codes relate language high average-case circuit complexity language high worst-case circuit complexity suppose characteristic sequence inputs length ith bit iff ith m-bit word language language characteristic sequence inputs bits codeword information word error-correcting code relate complexities languages error-correcting code properties ecc handle error rates high small ecc employs local decoding single bit information word derived examining small portion codeword ecc encode polynomial time implies positive constant usefully discuss properties formally define error-correcting codes definition error-correcting code ecc alphabet function distinct hamming distance greater suppose process word ecc producing suppose uncontrolled conditions flip bits code word random producing received word perturb destroying memory fewer bit flips occurred legal codeword detect bits changed fewer bit flips occurred terms hamming distance closer legal codeword corrected parameters ecc optimize relative distance make large rate make small hamming distance binary strings equal length number bits differ complexity encoding decoding low rate relative distance sense opposed small rate restricts minimum hamming distance codewords leaves extra space codes interested belong general class eccs called linear errorcorrecting codes intuitively codeword bit linear function message bits define formally definition ecc linear range linear subspace rank prime power designate linear ecc square brackets linear ecc nice properties generator matrix discuss give examples linear eccs hadamard code hadamard code takes information word codeword concatenation dot products binary words length code relative distance good rate bad decode received word encoded mangled piece received word position suppose bit values differ bit pick uniformly random bit bit uniformly random aiei correct correct probability decode single bit examining greater long error rate transmission slightly correct errors relative distance ecc error-correction rate algorithm yields arbitrarily close rate reed-solomon code thereed-solomon codetransforms theinformation worda thecodeword polynomial degree coefficients digits code relies fact polynomials degree points intersection meaning distance distinct codewords parameters reed-solomon code reed-solomon code yields adjustable trade-off rate relative distance fairly easy encode decode heavily communications data-retrieval applications reed-solomon code unsuitable purposes decoding methods nonlocal retrieve single bit codeword requires examining entire received word reed-m uller code reed-solomon code univariate polynomials reed-m uller code variate polynomials information word composed elements transformed codeword elements reed-m uller code achieves relative distance encoding naive encode consisting coefficients needed m-variate polynomial variable degree output polynomial m-tuples inputs interpretation message prove decoding encode information word produce m-variate polynomial record outputs produce denote ith invertible map integers subcube size define compute cousin polynomial defined m-variable constant vector inside thesm-subcube andqc values inside sm-subcube construct mproductdisplay productdisplay jnegationslash normalization constant values xnegationslash sm-subcube index xinegationslash construction multiplicand form note degree compose desired polynomial polynomials compose vector orthogonal basis explicitly smsummationdisplay aiq 
degree degree constructed information word produce codeword concatenating values codeword copy indices correspond sm-subcube interpolated decoding present method decoding reed-m uller code assumption error rate transmission greater artificially low didactic purposes method nice local decoding decoding algorithm reed-m uller code corrects higher errors page suppose received word denote position denote analogous position correct codeword retrieve ith digit message determine determine pick random point select distinct values tnegationslash examine polynomial degree assume thatp values chosen determine polynomialp evaluate point query uniform probability negationslash query assumption probability negationslash selected values selected process correct decoding probability repeat process random values majority vote make decoding algorithm work probability small parameters previously mentioned smmm kmm polynomial size property constructions satisfy requirement arbitrary setting logk loglogk logk small madhu sudan luca trevisian salil vadhan pseudorandom generators xor lemma computer system sciences preliminary version proc acm stoc accessed http berkeley eluca pubs complexity theory lecture worst-case average-case reductions instructor dieter van melkebeek scribe tom watson lecture discussed applications nisan-wigderson pseudorandom generator showing language ciently average-case hard nonuniform circuits bpp ciently simulated deterministically ciency simulation depends hardness introduced idea error correcting codes relax hypothesis existence average-case hard language existence worst-case hard language local decoding procedure reed-muller codes today discuss paradigm list decoding describe local list decoding algorithm hadamard code show local list decoding algorithms obtain strong worst-case average-case hardness reductions finally introduce notion randomness extraction worst-case average-case reductions error correcting codes local list decoding suppose language family small circuits compute goal show exists language family small circuits compute family small circuits succeed computing noticeably half inputs strategy characteristic sequence input length string length encode good binary error correcting code ecc obtain string length larger interpret encoding characteristic sequence language input length intuition solved noticeably half inputs small circuit characteristic sequence function computed circuit viewed corrupted version original information word obtained cient decoding procedure allowing solve inputs ecc properties argue ciently hard construct small circuit computing circuit string length required compute bit string received word exponentially longer problem traditional decoding algorithms entire received word compute single bit information word local decoding algorithm index case bit information word computes bit making randomized queries received word lecture local decoding algorithms hadamard reed-muller codes hard solve half inputs decode fraction errors large small problematic correct fraction errors relative minimum distance ecc greater imply ecc minimum distance close problem argue distance hope case binary codes list decoding algorithm received word computes information words encodings distance dealing circuits nonuniformly select information word correct naturally fraction closer half number codewords distance grows show number grow large describe list decoding algorithm hadamard code today finally require cient encoding procedure ecc show shown combining exponential-time algorithm cient encoding procedure ecc fact constant factor larger show average-case hardness comparable worst-case hardness ultimate goal show linear exponential worst-case circuit complexity linear exponential average-case circuit complexity previously existence obtain quick pseudorandom generator logarithmic seed length conclude bpp properties ecc cient local list decoding algorithm give full details construction desired properties realized concatenation hadamard code reed-muller code local list decoder reed-muller code obtained local decoding approach discussed lecture combined list decoder reed-solomon code decoder involves technical procedure factoring bivariate polynomials today describe local list decoding procedure hadamard code local list decoders codes easily combined form local list decoder concatenation section show leads desired worst-case average-case reduction error correcting code constructions recall hadamard code code encodes information word codeword takes product bit string length outputs list results minimum distance code case binary codes distance hope asymptotically good minimum distance hadamard code horrible rate practical complexity theory code handle fraction errors require unique decoding good achieve strong hardness results show contenting list decoding handle fraction errors half reed-solomon code ecc minimum distance close locally decodable query positions received word order reconstruct position information word reed-solomon code requires eld size large codeword length undesirable interested codes handle concatenating binary code hadamard code reed-muller code good local decoding algorithm recall reed-solomon encoding achieved interpreting information word low-degree univariate polynomial evaluating points eld reed-muller encoding achieved interpreting information word low-degree polynomial variables evaluating -tuples eld elements intuitively packing information -dimensional cube locally decode picking random line point cube evaluate original polynomial querying received word points line reed-solomon decoder reconstruct univariate polynomial original polynomial restricted line similar approach list decoder reed-solomon code local list decoder reed-muller code obtained explore result finally concatenating reed-muller code hadamard code yields code satis desired properties concatenating hadamard code binary code exponential blow-up hadamard code compensated fact eld size required reed-muller code doesn grow fast locally decodability property key worst-case average-case reduction list decodability property key overcoming upper bound distance code order acheive strong worst-case average-case reductions local list decoding hadamard code develop local list decoding algorithm hadamard code worry local decoding aspect natural feature algorithm received word error bound list information words encodings hamming distance minimum distance code list information word larger list naturally larger show large speci cally handle fraction errors randomized time poly received word length random access theorem randomized algorithm random access received word runs time poly outputs list information words high probability prx kbracketleftbig bracketrightbig outputs list information words hadamard encodings relative distance proof focus obtaining satisfying prx running procedure times concatenating lists list high probability information words desired level agreement recall lecture local unique decoder hadamard code idea retrieve ith bit picking random querying string ith position assuming encoding ered fraction positions conclude union bound probability positions correct case picking independently taking majority vote values obtain correct high probability present settting wrong fraction positions conclude probability positions correct obtaining idea require samples describe elaborate approach power list decoding reduce number samples needed focus retrieving component information word idea select uniformly random small determined obtain strings adding combinations empty combination formally nonzero values string tsummationdisplay cjxj note bit string length sum locations nonzero uniformly distributed proof claim event consideration holds index position agrees encoding claim nonzero knew values pick arbitrary query add result conclude con dence rst attempt words circumventing inherent unreliability two-query approach assuming correct answer queries show handle hypothesis power list decoding issue handle naturally 
boost con dence making queries choices majority vote values choices means make queries turns chosen small isn problem important issue alarmed fact strings nitely fully independent generated bits randomness pairwise independent note negationslash index nonzero equality prbracketleftbig bracketrightbig conditioning values turns pairwise independence good claim majinegationslash maji majority cnegationslash proof indicator random variable event guess correct order majinegationslash happen case summationdisplay cnegationslash claim cnegationslash linearity expectation majinegationslash summationdisplay cnegationslash bracketleftbig summationdisplay cnegationslash vextendsingle bracketrightbigg pairwise independent apply chebyshev inequality fact indicator random variable variance conclude majinegationslash parenleftbig summationtext cnegationslash parenrightbig summationtext cnegationslash union bound probability exists maji negationslash made choosing parenleftbig log parenrightbig summarize algorithm point rst choose uniformly random recover bit separately local decoding forming queries erent query guessing equals taking majority vote guesses argued succeed recovering information word correctly probability choice recovering position involves poly queries entire procedure runs time poly desired critical issue resolve entire procedure assumed knew values ridiculous list decoding algorithm sequence values cnegationslash possibilities sequence run algorithm possibility output list information words obtained probability appears list appears correct values sequence cnegationslash problem erent leading possibilities making running time exponential easily remedied recalling product linear tsummationdisplay cjxj tsummationdisplay values uniquely determined values reduce list size poly values sequence running time remains poly explains didn choose strings independently chose strings looked combinations approach list long order entries approach list size expense samples pairwise independent argued big problem local decoding algorithm discussed lecture basic idea proof recover querying random location received word querying location index ith bit ipped xoring results present setting errors received word reliable key idea drastically increase reliability queries uncorrupted unique decoding required possibilities correct values queries key idea list size small choosing small number query locations deterministically generating rest query locations adding combinations chebyshev inequality conclude reliability doesn deteriorate corollary result note received words number information words hadamard encodings agree fraction positions bounded poly running time algorithm finally note list output decoding algorithm information words encodings agreement received word weed randomly querying ensure high probability agrees encoding fraction locations small worst-case average-case reductions hadamard decoder previous section local list decoder reed-muller code obtain local list decoder concatenation codes precise result stated proof theorem exists error correcting code properties polynomial-time encoder mapping information words length codewords length poly codeword length assumed power randomized algorithm runs time poly outputs list randomized oracle turing machines input position information word oracle access received word run time poly logk machines property received words information words agrees encoding fraction positions exists mri computes show theorem worst-case average-case reductions theorem exists language proof language applying ecc theorem yields string length string solve taking input length computing length explicitly writing encoding extracting bit input writing takes positions computed time encoding takes time ecc theorem polynomial-time encodable solving incurs exponential factor blowup running time doesn prevent technique worst-case average-case reductions smaller classes show theorem follow fact fact exponential changing input length constant factor makes change polynomial factor set determined suppose exists circuit size input length computes bit fraction inputs machine mri theorem takes input length outputs position high probability solves provided string length agrees fraction positions probability ampli choice randomness mri solves inputs length hard-wiring choice randomness obtain oracle circuit size solving input length oracle gates queries replaced hypothesized circuit size theorem circuit size computes provided oracle subcircuit solves fraction inputs hypothesis conclude parenleftbigm parenrightbig constant ciently large circuit size succeeds computing length fraction inputs implies min parenleftbig parenrightbig term nitely dictates minimum choosing desired result corollary exists language exists language exists quick prg subpolynomial seed length implying bpp subexp corollary exists language exists language exists quick prg polylogarithmic seed length implying bpp dtime nlogo corollary exists language exists language exists quick prg logarithmic seed length implying bpp randomness extraction evidence randomness powerful terms reducing complexity solving decision problems unconditional pseudorandom generator fools space-bounded computations conditional pseudorandom generator fools time-bounded computations hypothesis exists language requiring linear exponential size circuits conjectured randomness lead polynomial factor savings time constant factor savings space randomness useless practice contrary quadratic speedup achieved randomness attractive practice additionally randomized algorithms simpler easier implement deterministic algorithms problems turn erent question randomized algorithm assume access perfect source unbiased importantly uncorellated random bits run algorithms access imperfect random source goal randomness extraction samples weak random source samples uniformly distributed generate samples close uniformly distributed weak random sources models physical sources randomness keystrokes delays networks extractor cient procedure taking sample imperfect source extracting randomness producing output string shorter closer uniformly distributed procedure run randomized algorithms weak random sources fact output distribution extractor close uniform small ect output distribution randomized algorithm embark task constructing extractor formalize amount randomness contained weak random source closeness uniform output distribution obtained applying extractor weak random source standard measure statistical distance idea measure entropy physics definition entropy discrete random variable bracketleftbig log bracketrightbig summationdisplay log sum range measure randomness work setting suppose range nonzero rest probability concentrated entropy measure fair amount randomness useless simulating bpp algorithm bad set input probability error input greater half require large amount randomness case string weight suggests measure definition min entropy discrete random variable mini log equivalently largest outcomes probability source bits randomness goal construct extractors source min entropy output distribution extractor statistically close uniform distribution strings length close good extractor obtained viewing input sample characteristic string function function nisan-wigderson pseudorandom generator construction details construction lecture complexity theory lecture randomness extraction instructor dieter van melkebeek scribe jeff kinne lecture briefly introduced paradigm randomness extractors recall analysis correctness randomized algorithms assumed source random bits perfectly uniform independent general access sources real world access weak random sources randomness source randomness extractors procedures applied weak random source extract bits close uniform independent run randomized algorithm output extractor confidence answer access perfect random sources today formally define randomness extractors explore applications give constructions weak random sources defining extractors quantify source amount randomness definition random variable min-entropy denote min-entropy show lecture source withh polynomial time source run polynomial time randomized algorithms addition shown source randomness extraction define formally definition close source min-entropy exercise min-entropy correct notion randomness goal call 
source weak random source number sources high min-entropy simple descriptions bit fixing sources sources number bits fixed adversarially remaining bits perfectly random source weak random source unpredictable sources sources bit unpredictable previous bits constant weak random source flat sources sources correspond uniform distribution subset range log source weak random source exercise shows fact flat sources base case sources high min-entropy handle flat sources handle random sources high min-entropy exercise random source convex combination flat sources subset size randomness extractor source randomness high min-entropy output distribution statistically close uniform ideally convert weak randomness perfect randomness additional perfect randomness shows proposition function taking input weak random source weak random source constant function proof setting outputs single bit output probability suppose define flat distribution min-entropy meaning output distribution constant taking weak random source input attempting output bits close uniform proposition shows weakest setting augment additional input perfect random source definition extractor extractor bardble umbardbl uniform variable bits uniform bits note equivalent event additional true randomness define extractor setting logn meaning amount true randomness needed small fact extractors section eliminate true randomness cycling strings number parameters definition optimize bounds proven extractor logn log log bounds intuitively perfect random bits index weak random source extract random bits contained combination weak source perfect random source shown picking function random logn log log high probability satisfies definition application interested act picking extractor random requires large amount perfect randomness application develop extractors computable deterministic polynomial time exercise show combination random source function satisfying source close source min-entropy fact justifies choice notion weak randomness applications give applications extractors achieve original goal simulating randomized algorithms weak random sources give alternate proof bpp application eliminate perfect randomness extractor logn cycling seeds areas feasible cryptographic settings luxury exist extractors called seedless extractors settings extractor takes input independent weak random sources outputs distribution close uniform discuss seedless extractors mention existence simulating randomized algorithms extractor input perfect random source simulating randomized algorithm extractor trivial describe simulation section removes perfect random source giving simulation correct high probability suppose randomized algorithm random bits extractor input simulate set count sample random source foreach count count count output output probability simulation errors bad set algorithm negationslash majr bad set simulation pry claim extractor proof suppose flat source notice min-entropy set difference probability assigned extractor uniform contradicting extractor claim compute probability simulation errors assuming extractor simulation errors source bit probability suffices efficiency simulation hopethat simulation incursonly poly factor overhead time simulating polynomial time algorithm takes polynomial time time complete simulation product time compute time original algorithm poly computable extractor term poly poly term poly logm equivalently logn poly recall condition precisely stated earlier requirement weak random source choice weak random sources corresponds precisely random sources analysis yields correct simulation polynomial time remark extractors parameters stated exist demonstrate lecture alternate proof bpp application assume existence extractore computable polynomial time logn existence extractor proven section bpp machine requiring random bits input give formula equivalent acceptance start simulation previous section usinge perfectly random source withh view samplexfrom source components equal length number simulation fails sample claim counting argument choice simulation results correct answer stated formally input pry logn assuming inside predicate computable polynomial time show implies negation rhs goal mind switch roles note simulation outputs probability pry pry line implies implies pry pry constructions give constructions polynomial time computable extractors construction based construction pseudorandom generators secure circuits functions high circuit complexity construction logn sources note parameters good applications previous section dependence number output bits entropy input distribution optimal construction based random walk expander graph constant construction extractor sources entropy logn construction constant factors optimal works sources high min-entropy final construction based polynomials finite field construction building block parameters achieved construction works give today give lecture hardness based extractor basic idea weak random source view truth table function functions high circuit complexity hard function pseudorandom generator based hard functions perfect random seed seed generator elaborate ideas derive extractor recall pseudorandom generator gave previous lecture secure circuits functionf logr non-uniform circuit complexitycf construct generator logr circuits size examination proof reveals proof relativizes function circuit complexity caf circuits oracle output indistinguishable circuits oracle access output generator hard function indistinguishable oracle circuit queries oracle caf similar condition extractor makes short random seed works fixed weak random source pick function random view sample weak random source truth table function logr bits bits claim fixed oracle functions logr caf prove claim quantify means ready define extractor view truth table function logr bits bit view seed pseudorandom generator note oracle circuit size query oracle charged part size circuit large queries oracle count gate making constant sized circuits powerful difference probability assigned set extractor uniform distribution fact weak random source min-entropy split difference probability assigned based high circuit complexity prx caf large prx caf small caf small term caf small quantified intuitively bounded number small circuits caf number circuits size number small circuit complexity bounded means ensure probability constant showing extractor expander based extractor construction view sample weak random source describing random walk d-regular expander graph sample source view portion indicating initial vertex expander remaining part specifies path follow graph vertex perfect random seed specifies vertex path output bits tlogd path length starting index vertex path logt summarize yth point random walk proving extractor relationship parameters definition tlogd previously construction work pick set pick tlogd setting nlogd log logn show pick satisfied chernoff bound random walks expanders bound difference probability assigned recall chernoff bound random walks states ith vertex visited random walk expander largest eigenvalue tsummationdisplay bracehtipupleft bracehtipupright exp bracehtipupleft bracehtipupright splitting difference probability assigned based holds assuming weak random source min-entropy prx contribution good breaking satisfying finish bound satisfying satisfying constant depending pick sufficiently smaller extractor polynomial based extractor construction lecture complexity theory lecture counting instructor dieter van melkebeek scribe chi man liu time introduced extractors discussed methods construct part lecture present explicit construction extractors based finite fields construction extractors parameters constructions discussed time part lecture introduce class counting problems problems class decision problems output single bit contrary counting problems require integers form binary strings output properties relations complexity 
classes extractor condenser overview recall previous lecture presented constructions polynomial time computable extractors construction based pseudorandom generators secure circuits construction logn sources construction based expander graphs constant construction extracts bits logn perfect random bits section give construction based finite fields construction construction building block achieves parameters works restate definition extractor definition extractor -extractor function source bardble umbardbl recall construction requires weak random source apply procedure converts random source suitable applying construction arbitrary source bits min-entropy condense randomness source make ratio close intuitive notion formalized definition definition condenser -condenser function source exists distribution bardblc ybardbl condensers natural generalization extractors require near-uniform output extractor require output condenser close source amount randomness note definition condenser set back extractor give construction condenser good parameters output distribution weak random source construction lecture theorem constants exists poly log time computable -condenser logn proving theorem combination expander based extractor source bits applying condenser produces output bits close distribution min-entropy seed length logn notice close distribution high min-entropy expander based extractor applying extractor produces distribution bits close uniform additional seed length logk seed logn composing constructions takes poly time condenser prove theorem find condenser outputs distribution close high min-entropy input source guaranteed amount randomness arbitrary function output distribution elements large weights hindrance achieving high min-entropy lemma shows set inputs generating heavy elements small output distribution close distribution high min-entropy lemma source function define set -heavy elements prx set bad inputs bad pry bad exists distribution bardblc ybardbl proof element weight min-entropy bad bad prx note weight element redistribute weights elements resulting distributiony element weight greater weight needed redistribute difference probability set sobardblc ybardbl function bad sources min-entropy -condenser note depends source satisfies show bad inputs respect satisfying conclude -condenser lemma lemma subset define bad set respect badh pry badh -condenser prove main theorem proof theorem view sample weak random source polynomial finite field extractor evaluates powers polynomial point perfect random input outputs condition lemma show construction condenser small set range construct non-zero polynomial samples weak random source evaluates samples hit small set high probability keeping degree polynomial small show samples hit small set range high probability formalize intuition size perfect random seed length sample weak random source length output view view irreducible polynomial degree view elements setup define condenser xsm parameter set formula interpreted outputs -vector i-th element computed treating element raising -th power evaluating resulting polynomial make assumptions move end proof choose values make assumptions hold assume subset exists nonzero formal variate polynomial vanishes points degree variable evaluating polynomial point homogeneous linear equation polynomial coefficients unknowns equations number coefficients unknowns assumption homogeneous system nontrivial solution coefficients badh treat element formal univariate polynomialr xsm functions degree degree definitions definition badh vanishes points assumption zeroes degree identically point switch viewing -variate polynomial xsm univariate polynomial badh imply polynomial element individual degrees ofqwere thans nonzero polynomial distinct monomials inqmap distinct monomials ins degree ofs zeroes badh assumption badh lemma conclude -condenser pick values parameters satisfy assumptions achieve claimed parameters condenser statement theorem setup condenser show chooses ensure assumptions valid turn assumption note assumption equivalent rearranging equivalent choose satisfy assumption assumption substituting rearranged parenleftbig parenrightbig notice setting parenleftbig parenrightbig satisfies assumption assumption fact rearranging log set log works values finally efficiency construction finding irreducible polynomial degree arithmetic operations time poly poly log construction polynomial-time computable counting class problems studied decision problems problems require answers section introduce class problems require multiple-bit outputs problems form instance number solutions witnesses leads exploring class counting problems examples definitions give precise definition complexity class sat boolean formula find number assignments satisfying problem counting problem recall decision problem sat asks exists satisfying assignment construct ntm input guesses assignment accepts satisfies note number accepting computation paths number satisfying assignments leads defining terms ntms definition exists polynomial-time ntm input equals number accepting computation paths give examples problems sat discussion problem asks number perfect matchings bipartite graph note decision problem existence perfect matchings bipartite graphs solved polynomial time polynomial-time decidable graph property connectivity acyclicity counting number graphs size satisfy property problem matrix coefficients note define permanent perm summationdisplay nproductdisplay set permutations note permanent matrix similar determinant factor sign multiplied permutation determinant sign denotes sign permutation problem computing permanent matrixais obvious sight fact construct ntmm generates computation paths entries input guesses permutation entry captured creates computation paths reject immediately computation paths expanding entries processed total number computation paths generated product entries captured summing permutations permanent number perfect matchings bipartite graph equal permanent adjacency matrix restricted attention matrices non-negative entries relaxed constraint matrices negative entries computing permanents problem simply permanents negative fact complexity class captures problem gapp show unrestricted permanent problem lies gapp constructing ntm accepts permutations giving positive products ntm accepts permutations giving negative products properties complexity class exhibits algebraic properties adjacency matrix usual adjacency matrices rows represent vertices partition columns represent vertices closed addition functions sum lies show holds ntms inducing ntm input immediately creates computation paths paths runs computation runs computation easy total number accepting computation paths closed multiplication running ntm end accepting computation path ntm complexity class gapp properties closed subtraction property possess complexity classes complexity classes encountered classes decision problems order compare make oracle denote class decision problems solvable polynomial-time dtm access oracle class decision problems solvable polynomial-time dtm makes query oracle proposition relations hold bpp pspace proof problem polynomial-time ntm solving oracle reduction simply function induced completes part part proved similarly polynomial-time probabilistic machinep construct ntm guesses random bit string polynomial length simulates computation oracle reduction oracle machine accepts number accepting computation paths total number computation paths part fact entire computation tree ntm traversed deterministically polynomial space remark set containments pspace conjectured proper containments introduce counting-related complexity class definition exists polynomial-time ntm number accepting computation paths odd obvious proposition shows interesting property classes bpp proof left exercise reader proposition p-complete problems section present p-complete problems theorem sat p-complete proof sketch lecture proved sat np-complete proof polynomial-time ntm constructed boolean formula capturing computation input verified number assignments satisfying number accepting computation paths input remark reduction proof parsimonious reduction polynomial-time reduction preserving number solutions theorem computing permanent integer 
matrix p-hard proof idea shown boolean formula occurrences literals construct polynomial time matrix perm denotes number assignments satisfying construction single oracle call needed determine theorem p-complete theorem surprising disappointing result decision problem reduction sat simple theorem case sat formula reduce graph determine perfect matching apply equation conclude satisfiability steps polynomial-time reductions counting decision problems clear decision problem reduced counting problem single oracle query interesting question counting problem reduced decision problem oracle reduction answer positive p-complete problem sat imply pnp ppnp theorem lecture result collapse level problems give positive answer question graph isomorphism problem shown np-complete recall graphs isomorphic exists bijection write isomorphic define graphs counting problem asks numberof bijections satisfying edge-preserving condition easy verify related counting problem graph automorphism counting problem graph asks number automorphisms edge-preserving permutations theorem proof show showing left exercise reader graph automorphisms forms group aut pick vertex set automorphisms fixing aut set vertices mapped automorphism aut associate automorphism automorphism aut uniquely decomposed elementary group theory aut compute make oracle decide making query oracle graph obtained attaching large clique graph obtained attaching clique clique map clique map exists automorphism mapping conversely automorphism extended isomorphism computing fact instance attach large clique count number automorphisms graph vertex adjacent clique automorphisms graph fix note multiply count suitable fraction due clique vertices note graph larger original graph fact easier instance vertices fixed solving instance fix vertex negationslash clique compute attaching larger clique recursively steps step clique size added graph final graph size polynomial step takes polynomial time reduction polynomial-time computable corollary complete parsimonious reduction proof suppose complete parsimonious reduction show reduce sat sat oracle reduction cnf satisfying assignments assumption exists parsimonious reduction sat obtain graphs polynomial time equal number isomorphisms sat theorem np-completeness sat sat sat collapses level mentioned beginning section time lecture discuss relations polynomial hierarchy prove happen shown counting problems approximated level guruswami umans vadhan extractors condensers univariate polynomials electronic colloquium computational complexity report october complexity theory lecture alternation counting instructor dieter van melkebeek scribe jeff kinne introduced counting complexity classes previous lecture gave basic properties including relation counting decision classes lecture give results relating counting polynomial hierarchy result shows function approximated level polynomial hierarchy giving evidence approximate counting difficult deciding result evidence exact counting difficult showing entire polynomial hierarchy decided single query function proofs results make families universal hash functions small function families behave respects random allowing efficient random sampling introduce universal hash functions prove main results universal families hash functions universal family hash functions collection functions set functions small size behaving similarly set functions pick member random made choosing notion behaving similarly definition universal family hash functions holds negationslash chosen uniformly random functions notice probability pickedhfrom functions fix pick hat random random variables independent universal hash functions giving ability produce uniform pairwise independent samples definition generalized define k-universal hash functions produce k-wise independent samples make consequences definition negationslash prh prh efficiently sample family small number ways achieve give leth wheret ntoeplitz matrix vector toeplitz matrix entries diagonal takes bits element ofh specification random function functions requires bits truth table correctness randomized algorithm relies pairwise independence universal family hash functions logn length seed pseudorandom generator derandomize algorithm leave exercise prove thathsatisfies definition set affine functions finite field leave exercise prove mod mod universal family hash functions applications delving main results lecture give intuition universal families hash functions intuitively expect pick randomly chosen hash function bits bits map collisions high probability application determine size witness set make intuition derive predicate approximately determine size application randomness reduce satisfiable formula uniquely satisfiable satisfiable assignment intuition show choosing appropriately picking random high probability unique satisfying assignment hashes approximate counting section prove function approximated polynomial factor oracle level polynomial hierarchy theorem function computable polynomial time oracle access language proof adapted show computable randomized machine oracle access language estimate smaller true notice goal proving theorem similar goal showing bpp needed approximate function counting number accepting random strings constant factor approximate function polynomial factor proof underlying ntm run time view polynomial-time verifier ntm takes certificate length input determine size set certificates causing ntm accept applying randomly chosen hash function set certificates large compared expect covers small portion range small compared expect cover large portion range small collection hash functions collectively cover provided roughly size construct predicate queried determine small set hash functions covers range querying language increasing values negative answer estimate bound probability fixed hit randomly chosen upper bound prh summationtexty fact choosing random results pairwise independent samples chebyshev inequality bound probability compute expected sum linearity expectation properties universal hash functions summationdisplay summationdisplay summationdisplay denote chebyshev inequality pairwise independence prh summationtexty prh summationtexty probability fixed hit randomly chosen choosing number points small number hash functions fromhindependently random probability hash functions fail cover independence union bound prz notsubseteqluniontext case tuniondisplay polynomial beginning predicate case small show prz uniontext small notice hash function cover elements hash functions cover suppose constant meaning hash functions covers small portion case prz uniontextti close quantifiers wrong order union bound fact elements ofh tuniondisplay set parameters achieve goals settingk min suitable constant super-logarithmic prz uniontextni prz uniontextni assume logarithmic function probabilities work restrictive poly compute oracle leave exercise moment oracle predicate approximate show realized predicate leave exercise verify portion inside probability predicate remove probability quantifier proof bpp setting probability quantifier removed adding additional levels quantifiers remove probability quantifier adding front left predicate predicate oracle equivalent predicate oracle language approximate mentioned earlier query predicate determine answer predicate negative log predicate answered positively log loglog predicate answered negatively log log loglog rewritten log log approximation fixed polynomial factor computable polynomial factor constant obtain applying procedure modified predicate original function approximate apply algorithm function fnd constant choose leave exercise show function approximation log taking power rearranging log approximation relative error logn taylor expansion lognnd set large error exact counting main result show theorem language polynomial hierarchy decided polynomial time single oracle query function prove theorem parts show rpunique-sat unique-sat promise problem defined formulae satisfying assignments positive instance uniquely satisfiable formulas unique-sat oracle guaranteed give correct answer formulae act arbitrarily fact algorithm correct oracle inconsistent answers 
queries promise stated logn compute oracle size assume larger fix polynomial start logn part show bpp finish proof showing bpp solving randomness unique-sat oracle hash functions theorem ntm sat running time set assignments formula input applying hash function idea choose range hash function size achieve show randomly chosen hash function high probability maps unique satisfying assignment potential unique-sat query oracle bound probability randomly chosen hash function maps unique satisfying assignment set satisfying assignments lethm universal family hash functions probability thathmaps unique satisfying assignment summationdisplay summationdisplay summationdisplay term summationdisplay parenleftbigg parenrightbigg terms inclusion-exclusion principle expansion probability pairwise independence hash functions term summationdisplay parenleftbigg parenrightbigg union bound pairwise independence putting fact thatparenleftbig parenrightbig summationdisplay parenleftbigg parenrightbigg equal achieves maximum increases choice causing probability range providing negationslash probability randomly chosen hash function maps unique satisfying assignment analysis rpunique-sat algorithm sat input formula foreach pick random query unique-sat oracle query assignment satisfies oracle self-reducibility verify output output choosing hfrom universal family hash functions choosing hash function polynomial time rest algorithm runs polynomial time suppose satisfiable choice probability line corresponds uniquely satisfiable formula notice formula remains uniquely satisfiable self-reducibility case algorithm correctly outputs satisfiable algorithm outputs probability success satisfiable formulas amplified repeating algorithm rpunique-sat randomized reduction fact rpunique-sat unique-sat cares formulas satisfying assignments sat solves unique-sat formulas promise previous section shows bpp fact problem homework relativizes bpp bpp relativizes bpp bpp show hypothesis notice bpp relativizes giving bpp notice bpp machine previous section access oracle bpp bpp achieved bpp conclude bpp point proof result simpler original proof demonstration power relativization deterministic reduction bpp language bpp determine making single query function show separate randomized portion counting portion performing reduction definition complexity class define operator give complexity class languages pry pry notice bpp reasonable definition operator alternative characterization bpp claim bpp proof show complexity classc bppc result asc fact bpp machine queries language changing computation machine guess random bits beginning computation proceeding left predicate language bppc machine computing language simply generates random bits input machine simulates machine language hope solve definition mod mod create function sums detect gap probability claim main ingredient make happen claim function mod mod mod mod power proving claim complete construction notice mod bits mod bits sum results spill past bits sum pick ensure spill notice summationtext mod summationtext mod fact picking ensure single bit sum check distinguish cases summationtext function query determine notice fact function machine branch compute branch remains proof claim proof claim base construction function nice property mod mod mod mod property result applying times claimed property property running time consists logm applications application increases running time constant factor polynomial factor slower remains prove claimed property suppose mod integer expansion ofh remove terms factor higher power geth mod argument generalizes show mod mod desired property mod time lecture concludes part focused traditional setting complexity theory efficiently computing relations computational models focus remainder alternative goals complexity theory lectures area complexity theory studied entire lectures surveys area fact lecture interested efficiency computing relations lecture discuss power quantum computing alternate proof approximate counting alternate proof theorem notion isolation proof underlying ntm run time view polynomial-time verifier ntm takes certificate length input determine size set certificates causing ntm accept applying randomly chosen hash function set certificates small compared expect collisions members large compared expect collisions determine relative number collisions estimate ideas formalized concept isolation universal family hash functions isolated equal negationslash small compared large portion intuitively isolated randomly chosen case small number hash functions required guarantee isolated hand large compared show small set hash functions isolate quantify ideas bound probability fixed isolated random isolated logicalordisplay negationslash summationdisplay negationslash summationdisplay negationslash definition isolation union bound chosen random universal family hash functions summing negationslash probability random choice hash functions isolated events isolated fixed independent independently chosen isolated parenleftbigg isolated parenrightbiggt parenleftbiggs parenrightbiggt probability isolated union bound isolated summationdisplay isolated parenleftbigg parenrightbiggt meaning probability method testing roughly large large choice isolating method testing roughly large notice isolate elements isolate isolating lett mfor simplicity discussion allm log loglog set hash functionsh isolating log log exist isolating method estimate size test predicate isolates determine predicate evaluates true claim predicate finish analysis claim prove claim discussion log loglog log rewritten log log approximation fixed polynomial factor computable method section make approximation ratio polynomial remains verify point fact choosing universal family hash functions random choosing fromh initial existential guesses polynomial size claim remaining predicate isolates conp predicate realized predicate negationslash testing polynomial time evaluating ntm certificate existential phase pushed inside polynomial size predicate shown approximate deterministically oracle fact randomized algorithm oracle pick hash functions random large values hash functions satisfy inside conp predicate small values set hash functions satisfy predicate derived randomly selecting hash functions querying inside conp predicate high probability satisfies notice estimate derived errors direction choice random functions satisfy inside conp predicate small values complexity theory lecture quantum effects instructor dieter van melkebeek scribe seeun william umboh today quick quantum computing model define quantum model computing variant probabilistic model computing present common technique design quantum algorithms give upper bounds power quantum computation motivation quantum computation presents challenge strong church-turing thesis physically realizable computing device efficiently simulated turing machine model presented lecture clear point problems solvable polynomial time quantum computers solved polynomial time deterministic turing machines randomized machines reason factor efficiently quantum machines classical machines consensus community quantum computers solve np-complete problems efficient classical factoring algorithm caveat uncertain quantum computers physically realizable idea exploit quantum effects solve computational problems efficiently terms time key idea search problems quantum interference good solutions interfere constructively bad solutions interfere destructively end good solutions remain turing machine models probabilistic relate quantum model probabilistic model viewing probabilistic model perspective markov chains give alternate definition probabilistic model define quantum model definition state represent state probabilistic machine probability distribution configurations ket notation summationdisplay summationtextcpc probability configuration column vector zeros position representing configuration runs configurations definition computation computation probabilistic machine consists phases sequence local acting bits tapehead state linear transformations transform probability distribution probability distribution stochastic matrices induced transition function final observation part configuration answer summationdisplay runs configurations giving 
answer markov chain view point time state machine superposition configurations represented column vector summationtextcpc note set singleconfiguration vectors forms basis linear space overr state vectors end computation observe output bit probability observing probability machine configuration giving output rephrasing probabilistic model presented earlier lecture move quantum model quantum definition state state quantum machine defined linear superposition configurations summationdisplay summationtextc definition computation computation quantum machine consists phases sequence local acting bits tapehead state linear transformations transform vector bardblvbardbl vector bardblv bardbl unitary matrices induced transition function final observation part configuration answer summationdisplay runs configurations giving answer transformation depend configuration distribution require transition probabilities efficiently approximable rationals avoid dealing machines halting sequence transition probability view state quantum machine wave function coefficients called amplitudes vectors imaginary plane length fact amplitudes negative allowing destructive interference underlies lot power quantum computing note probability configuration square absolute amplitude issue condition matrices induced stochastic unitary imposes restrictions set allowable transition functions probabilistic setting transition function stochastic fixed configuration sum probabilities configurations move step show setting transition probability quantum setting natural thing unitary sense turns satisfy orthogonality conditions conditions unnatural quantum machines turing machines algorithm design prefer terms circuits circuit models define circuit models probabilistic quantum computations order satisfy conditions gates act finite number bits sufficient act bits induce stochastic unitary matrices end define notions register analogous notion turing machine configuration circuit model contents register reflect results computation retain notation denote contents register state register represented probability distribution linear superposition contents register note set vectors form basis linear space reals complex numbers state vectors operation gon anm-bit register linear stochastic unitary transformation acting distinct bits indices leaving unmodified everyx applyinggon yjykyl xjxkxl computation consists sequence operations final observation register note operations represented stochastic unitary matrices models defined satisfy condition uniformity simply require single turing machine compute operation step addition -time bounded versions models require turing machine time compute operation step probabilistic probabilistic model sufficient classical gates simulate deterministic computation coin flip gate access fair coin deterministic gates operations defined transformations xyz xyz matrix remember input bits unaffected gate multiply denotes probability register contents started configuration kth bit coin flip gate coin flip gate acts bit output equiprobably bracketleftbigg bracketrightbigg quantum deterministic gates quantum setting simply matrices gates preserve -norm note -norm preserving condition matrix equivalent satisfying iff gate matrices invertible gates invertible input map deterministic gates reversible induce permutation matrices determinism requires matrix column entry reversibility requires matrix row entry introducing additional ancilla bits boolean function transform reversible version defined apply transformation gates deterministic classical circuit obtain circuit usable quantum machine circuit computing resulting function transforming gates defined garbage number ancilla bits order number gates themancilla bits set interference patterns garbage ancilla bits computation paths complex conjugate interfere simply resetting bits irreversible operation applyingf reverse extra bit preserve result computed figure schematic reversible simulation complexity reversible simulation denoted constant factor greater complexity apply transformation gate run transformed circuit note bqp bqp class decision problems solvable polynomial quantum turing machines output quantum turing machine random variable decides language probability deciding correctly membership hadamard gate quantum analog classical coin flip gate called hadamard gate matrix gate bracketleftbigg bracketrightbigg exercise verify hadamard matrix unitary orthogonal effect applying gate single bit observe bit applying hadamard gate equiprobably fair coin flip applying hadamard gate consecutively sequence give original bit result coin flip gate terms interference computation paths simulate randomized computation applying hadamard gate observing bits afterward proceed deterministically bits random bits bpp bqp illustration quantum power widely believed community interference solve npcomplete problems managed interference efficiently solve problems efficient classical algorithms factoring simon problem problem unnatural technique solving underlies quantum algorithms factoring definition simon problem poly-time length-preserving maps strings length strings length function promise negationslash addition defined bitwise xor find input words strings length function -toand strings map string differ shift find note promise problem problem second-level polynomial hierarchy guess shift verify pairs ofn-length strings thatf poly-time function easily bitwise-xor verification efficiently classical machines exponential time randomness algorithm guess collision easily determine expected number trials collision exponential quantum machines problem solvable polynomial time start state firstn bits encode inputs achieve applying hadamard gate thenbits denote operation ash state summationtext apply bits input bits bits output bits state summationtextx finally apply bits leave exercise verify end summationtext summationtext denotes product rewrite summationtext linear superposition contents registers probability observing register summationtextz range range maps strings linear algebra n-fold tensor product hadamard gate matrix common factor sum n-length strings count probability observed summationtextx mod mod output computation chosen uniformly random mod observe mod linear combination components coefficients components linear equation variables run routine order times collect output run equations form homogeneous system rank elementary linear algebra unique non-trivial solution argued efficiency components routine solve homogeneous linear systems equations efficiently lastly leave fact average runs routine exercise exercise verify high probability runs suffice hidden subgroup generalization definition hidden subgroup problem group poly-time promise exists subgroup iff belong coset find generators familiar instances problem simon problem group simon problem denotes bit-wise xor defined definition subgroup interested sincexandy belong coset ofh iffx orx critical factoring algorithm discuss factoring algorithm finding order mod prime find order mod interested group denoting multiplication mod poly-time function mod iff solved similar simon problem general fast fourier transform hadamard gate fourier transform discrete log leave exercise reader graph isomorphism connected graphs vertices order cast hidden subgroup problem symmetric group elements function result applying permutation vertices disjoint union graphs aut automorphism applying automorphism applying result applying note graphs isomorphic generator swaps decompose automorphisms automorphisms swap find generators easily determine graphs isomorphic main technique algorithms examples fourier sampling set linear superposition inputs register store output register apply fourier transform measure system technique works group abelian case factoring simon problem discrete logarithm case graph isomorphism symmetric group abelian technique specifically probability distributions fourier sampling positive instances graph isomorphism negative instances indistinguishable upper bounds power quantum computers upper bound quantum computers note outcome quantum computation depends possibly negative amplitudes paths probability distribution gapp function bqp bqp class define future lecture biggest open problem quantum computation complexity theory bqp contained 
polynomial hierarchy probabilistic setting approximate counting good show containment hierarchy quantum setting possibility interference makes harder rely approximate counting fact conjectured exact counting required physics side build reliable scalable quantum computers models proposed spin single electron trapped silicon lattice scales implement bits silicon abundant implement bits model optical lattice model electron trapped optical lattice lasers managed implement limited quantum computers model scaling problem bottleneck laser power lecture today lecture completed part models computation compare time space resources lecture start section goal metrics time space 
